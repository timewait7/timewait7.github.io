<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"timewait7.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":true,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="深入理解数据类型及适用场景、持久化机制（RDB&#x2F;AOF）、内存淘汰策略、集群模式（主从、哨兵、Cluster）、分布式锁实现（Redlock 争议及替代方案）、缓存穿透&#x2F;击穿&#x2F;雪崩解决方案、与数据库一致性策略。了解底层数据结构（SDS, 跳跃表, 字典, 压缩列表等）。 基础Redis 有哪些数据类型，分别用于哪些场景  String（字符串）  描述：最基本的数据类">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="http://timewait7.github.io/post/bae4ff13.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="深入理解数据类型及适用场景、持久化机制（RDB&#x2F;AOF）、内存淘汰策略、集群模式（主从、哨兵、Cluster）、分布式锁实现（Redlock 争议及替代方案）、缓存穿透&#x2F;击穿&#x2F;雪崩解决方案、与数据库一致性策略。了解底层数据结构（SDS, 跳跃表, 字典, 压缩列表等）。 基础Redis 有哪些数据类型，分别用于哪些场景  String（字符串）  描述：最基本的数据类">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://timewait7.github.io/post/bae4ff13/image-20251103210359642.png">
<meta property="og:image" content="http://timewait7.github.io/post/bae4ff13/why-redis-so-fast-TbWX24ja.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20240918114125.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-b7b24e25-d2dc-4457-994f-95bdb3674b8e.png">
<meta property="article:published_time" content="2025-09-21T08:00:24.000Z">
<meta property="article:modified_time" content="2025-12-08T14:52:51.339Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://timewait7.github.io/post/bae4ff13/image-20251103210359642.png">


<link rel="canonical" href="http://timewait7.github.io/post/bae4ff13.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://timewait7.github.io/post/bae4ff13.html","path":"post/bae4ff13.html","title":"Redis"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Redis | Hexo</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-archives"><a href="/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="Searching..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%88%86%E5%88%AB%E7%94%A8%E4%BA%8E%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF"><span class="nav-number">1.1.</span> <span class="nav-text">Redis 有哪些数据类型，分别用于哪些场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%BA%95%E5%B1%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.</span> <span class="nav-text">Redis数据类型底层的数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB"><span class="nav-number">1.3.</span> <span class="nav-text">Redis为什么快</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86IO%E8%AF%B7%E6%B1%82%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88"><span class="nav-number">1.4.</span> <span class="nav-text">Redis单线程处理IO请求性能瓶颈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E5%92%8CMySQL%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.5.</span> <span class="nav-text">Redis和MySQL的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E5%92%8Cmemchahed%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.6.</span> <span class="nav-text">Redis和memchahed的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">2.1.</span> <span class="nav-text">Redis IO多路复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-6-0-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.2.</span> <span class="nav-text">Redis 6.0 多线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98"><span class="nav-number">3.</span> <span class="nav-text">缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-%E9%9B%AA%E5%B4%A9-%E5%87%BB%E7%A9%BF%EF%BC%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">3.1.</span> <span class="nav-text">什么是缓存穿透&#x2F;雪崩&#x2F;击穿，对应的解决方案是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">3.2.</span> <span class="nav-text">布隆过滤器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="nav-number">3.3.</span> <span class="nav-text">缓存淘汰策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="nav-number">3.4.</span> <span class="nav-text">缓存与数据的更新策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">4.</span> <span class="nav-text">持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB%E5%92%8CAOF%E6%8C%81%E4%B9%85%E5%8C%96%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8A%A3%E5%AF%B9%E6%AF%94"><span class="nav-number">4.1.</span> <span class="nav-text">RDB和AOF持久化原理及优劣对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5%E5%92%8C%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.</span> <span class="nav-text">全量同步和增量同步的区别</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/">
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="Back to top">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://timewait7.github.io/post/bae4ff13.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Redis | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-09-21 16:00:24" itemprop="dateCreated datePublished" datetime="2025-09-21T16:00:24+08:00">2025-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>4.9k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>18 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>深入理解数据类型及适用场景、持久化机制（RDB&#x2F;AOF）、内存淘汰策略、集群模式（主从、哨兵、Cluster）、分布式锁实现（Redlock 争议及替代方案）、缓存穿透&#x2F;击穿&#x2F;雪崩解决方案、与数据库一致性策略。了解底层数据结构（SDS, 跳跃表, 字典, 压缩列表等）。</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="Redis-有哪些数据类型，分别用于哪些场景"><a href="#Redis-有哪些数据类型，分别用于哪些场景" class="headerlink" title="Redis 有哪些数据类型，分别用于哪些场景"></a>Redis 有哪些数据类型，分别用于哪些场景</h3><img src="/post/bae4ff13/image-20251103210359642.png" class="" title="image-20251103210359642">

<p><strong>String（字符串）</strong></p>
<ul>
<li><strong>描述</strong>：最基本的数据类型，可存储文本、二进制数据（如图片）、数字（整数或浮点数）。</li>
<li><strong>典型场景</strong>：<ul>
<li><strong>缓存</strong>：存储用户会话信息（Session）、HTML片段、API响应等。</li>
<li><strong>计数器</strong>：网站访问量、点赞数、库存数量（利用 <code>INCR/DECR</code>）。</li>
<li><strong>分布式锁</strong>：通过 <code>SET key value NX EX</code> 实现简单锁。</li>
<li><strong>位操作（Bitmaps）</strong>：利用 <code>SETBIT</code>, <code>GETBIT</code>, <code>BITCOUNT</code> 等命令实现用户在线状态、签到记录、布隆过滤器等（本质上是操作字符串的位）。</li>
</ul>
</li>
</ul>
<p><strong>List（列表）</strong></p>
<ul>
<li><strong>描述</strong>：有序的字符串集合，元素可重复。按照插入顺序排序，可在头部(<code>LPUSH</code>)或尾部(<code>RPUSH</code>)插入元素。</li>
<li><strong>典型场景</strong>：<ul>
<li><strong>消息队列（简单版）</strong>：生产者 <code>LPUSH</code> 消息，消费者 <code>RPOP</code>&#x2F;<code>BRPOP</code> 消息（FIFO）。也可实现栈（LIFO）。</li>
<li><strong>最新消息&#x2F;动态流（Timeline）</strong>：<code>LPUSH</code> 最新内容，<code>LRANGE</code> 获取最近 N 条。</li>
<li><strong>记录操作日志</strong>。</li>
</ul>
</li>
</ul>
<p><strong>Set（集合）</strong></p>
<ul>
<li><strong>描述</strong>：无序的字符串集合，元素<strong>不可重复</strong>，支持集合运算（交集、并集、差集）。</li>
<li><strong>典型场景</strong>：<ul>
<li><strong>标签（Tagging）</strong>：存储文章、商品的标签（自动去重）。</li>
<li><strong>共同关注&#x2F;好友（社交关系）</strong>：利用 <code>SINTER</code> 求交集。</li>
</ul>
</li>
</ul>
<p><strong>Hash（哈希 &#x2F; 字典）</strong></p>
<ul>
<li><strong>描述</strong>：键值对集合，用于存储对象（如用户信息）。<code>field-value</code> 映射表。</li>
<li><strong>典型场景</strong>：<ul>
<li><strong>存储对象</strong>：用户信息（<code>user:1000 &#123;name: &quot;Alice&quot;, age: 30, email: ...&#125;</code>）、商品详情、配置项。</li>
<li><strong>频繁修改部分属性的对象</strong>：如只更新用户积分，避免读取整个字符串再写回。</li>
</ul>
</li>
</ul>
<p><strong>Sorted Set（有序集合 &#x2F; ZSet）</strong></p>
<ul>
<li><strong>描述</strong>：Set 的升级版，元素<strong>唯一</strong>，但每个元素关联一个 <code>score</code>（分数）。元素<strong>按 <code>score</code> 排序</strong>（从小到大）。<code>score</code> 可相同，此时按元素字典序排序。</li>
<li><strong>典型场景</strong>：<ul>
<li><strong>排行榜</strong>：游戏积分榜（<code>score</code> 为积分）、热搜榜（<code>score</code> 为热度值）。<code>ZREVRANGE</code> 获取 Top N。</li>
</ul>
</li>
</ul>
<p><strong>Bitmaps</strong></p>
<ul>
<li><strong>本质</strong>：String 类型的位操作扩展。</li>
<li><strong>场景</strong>：极省空间的布尔值统计（用户在线状态、每日签到、活跃用户统计、布隆过滤器）。</li>
</ul>
<p><strong>HyperLogLog（HLL）</strong></p>
<ul>
<li><strong>本质</strong>：特殊的 String 类型。</li>
<li><strong>场景</strong>：海量数据的去重计数（网站 UV、独立 IP 访问数、搜索词去重统计），不需要精确结果时。</li>
</ul>
<p><strong>Geospatial（地理空间）</strong></p>
<ul>
<li><strong>本质</strong>：基于 Sorted Set（ZSet）实现，<code>member</code> 是位置标识符，<code>score</code> 是经度+纬度编码成的 52 位整数（GeoHash）。</li>
<li><strong>场景</strong>：附近的人&#x2F;地点（如滴滴打车）、基于位置的服务（LBS）、地理围栏。</li>
</ul>
<p><strong>Streams</strong></p>
<ul>
<li><strong>描述</strong>：Redis 5.0 引入。为<strong>消息队列</strong>设计的功能更完善的数据类型。类似 Kafka 或 RabbitMQ 的 topic。</li>
<li><strong>场景</strong>：<strong>可靠的消息队列</strong>、事件溯源（Event Sourcing）、实时数据管道。</li>
</ul>
<h3 id="Redis数据类型底层的数据结构"><a href="#Redis数据类型底层的数据结构" class="headerlink" title="Redis数据类型底层的数据结构"></a>Redis数据类型底层的数据结构</h3><table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">底层数据结构（历史&#x2F;其他实现）</th>
<th align="left">底层数据结构（最新趋势）</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>String（字符串）</strong></td>
<td align="left">int, embstr, raw</td>
<td align="left">(通常不变)</td>
</tr>
<tr>
<td align="left"><strong>List（列表）</strong></td>
<td align="left">QuickList (由LinkedList和Ziplist组成)</td>
<td align="left">QuickList (节点内部使用Listpack)</td>
</tr>
<tr>
<td align="left"><strong>Hash（哈希）</strong></td>
<td align="left">ZipList, HashTable</td>
<td align="left"><strong>Listpack</strong>, HashTable</td>
</tr>
<tr>
<td align="left"><strong>Set（集合）</strong></td>
<td align="left">IntSet, HashTable</td>
<td align="left">(通常不变)</td>
</tr>
<tr>
<td align="left"><strong>ZSet（有序集合）</strong></td>
<td align="left">ZipList, SkipList + HashTable</td>
<td align="left"><strong>Listpack</strong>, SkipList + HashTable</td>
</tr>
<tr>
<td align="left"><strong>Stream（流）</strong></td>
<td align="left">Rax (基数树) + Listpack</td>
<td align="left">(使用Listpack存储消息内容)</td>
</tr>
</tbody></table>
<p>Listpack 被设计用来替代 <strong>Ziplist（压缩列表）</strong>，主要为了解决Ziplist的<strong>连锁更新问题</strong>。</p>
<ul>
<li><strong>Ziplist的缺陷</strong>：Ziplist中每个元素都记录了<strong>前一个元素的长度</strong>。当在一个元素前插入一个新元素，导致该元素的”前一个元素长度”字段需要扩容时，它自己本身的大小也会改变。这可能会引发链式反应，导致后续多个元素都需要被更新，在最坏情况下，一次插入操作可能需要重新分配整个Ziplist的内存，性能损耗很大。</li>
<li><strong>Listpack的解决方案</strong>：Listpack移除了对前一个元素长度的依赖。每个元素只记录<strong>自身的编码、实际数据和当前元素的总长度</strong>，并且这个总长度信息被放在了元素的<strong>尾部</strong>。这个巧妙的设计使得任何元素的修改都只影响自身，完全<strong>避免了连锁更新</strong>。</li>
</ul>
<h3 id="Redis为什么快"><a href="#Redis为什么快" class="headerlink" title="Redis为什么快"></a>Redis为什么快</h3><p>对于Redis的高性能设计，我的理解主要得益于以下几点：</p>
<ul>
<li><p><strong>内存操作</strong>：Redis数据存储在内存，相比于磁盘数据库，减少了IO开销</p>
</li>
<li><p><strong>高效的数据结构</strong>：Redis针对不同场景设计了不同的数据结构，优化了空间和访问效率</p>
</li>
<li><p><strong>单线程</strong>：Redis使用单线程处理命令，避免了多线程之间的竞争和上下文切换的开销</p>
</li>
<li><p><strong>IO多路复用</strong>：Redis基于epoll&#x2F;kqueue实现了非阻塞的网络模型，通过事件机制循环处理请求</p>
</li>
</ul>
<img src="/post/bae4ff13/why-redis-so-fast-TbWX24ja.png" class="">

<h3 id="Redis单线程处理IO请求性能瓶颈"><a href="#Redis单线程处理IO请求性能瓶颈" class="headerlink" title="Redis单线程处理IO请求性能瓶颈"></a>Redis单线程处理IO请求性能瓶颈</h3><p>主要包括2个方面：</p>
<p> 1、任意一个请求在server中一旦发生耗时，都会影响整个server的性能，也就是说后面的请求都要等前面这个耗时请求处理完成，自己才能被处理到。耗时的操作包括以下几种： </p>
<ul>
<li><p>操作bigkey：写入一个bigkey在分配内存时需要消耗更多的时间，同样，删除bigkey释放内存同样会产生耗时；</p>
</li>
<li><p>使用复杂度过高的命令：例如SORT&#x2F;SUNION&#x2F;ZUNIONSTORE，或者O(N)命令，但是N很大，例如lrange key 0 -1一次查询全量数据；</p>
</li>
<li><p>大量key集中过期：Redis的过期机制也是在主线程中执行的，大量key集中过期会导致处理一个请求时，耗时都在删除过期key，耗时变长；</p>
</li>
<li><p>淘汰策略：淘汰策略也是在主线程执行的，当内存超过Redis内存上限后，每次写入都需要淘汰一些key，也会造成耗时变长； </p>
</li>
<li><p>AOF刷盘开启always机制：每次写入都需要把这个操作刷到磁盘，写磁盘的速度远比写内存慢，会拖慢Redis的性能； </p>
</li>
<li><p>主从全量同步生成RDB：虽然采用fork子进程生成数据快照，但fork这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久；</p>
</li>
</ul>
<p>2、并发量非常大时，单线程读写客户端IO数据存在性能瓶颈，虽然采用IO多路复用机制，但是读写客户端数据依旧是同步IO，只能单线程依次读取客户端的数据，无法利用到CPU多核。 </p>
<p>针对问题1，一方面需要业务人员去规避，一方面Redis在4.0推出了lazy-free机制，把bigkey释放内存的耗时操作放在了异步线程中执行，降低对主线程的影响。 </p>
<p>针对问题2，Redis在6.0推出了多线程，可以在高并发场景下利用CPU多核多线程读写客户端数据，进一步提升server性能，当然，只是针对客户端的读写是并行的，每个命令的真正操作依旧是单线程的。</p>
<h3 id="Redis和MySQL的区别"><a href="#Redis和MySQL的区别" class="headerlink" title="Redis和MySQL的区别"></a>Redis和MySQL的区别</h3><table>
<thead>
<tr>
<th></th>
<th>Redis</th>
<th>MySQL</th>
</tr>
</thead>
<tbody><tr>
<td>数据结构</td>
<td>非结构化</td>
<td>结构化</td>
</tr>
<tr>
<td>持久化</td>
<td>可选持久化</td>
<td>默认持久化</td>
</tr>
<tr>
<td>事务支持</td>
<td>简单支持</td>
<td>支持完整的ACID</td>
</tr>
<tr>
<td>扩展性</td>
<td>通过分片水平扩展</td>
<td>复杂，需分库分表或中间件</td>
</tr>
<tr>
<td>数据一致性</td>
<td>最终一致性</td>
<td>强一致性</td>
</tr>
</tbody></table>
<p>总结：</p>
<ul>
<li>当需要复杂查询和事务支持，对数据一致性要求较高，需要长期持久化存储的场景，选择MySQL</li>
<li>当需要超高性能和灵活数据类型，对数据的一致性要求不那么高，且容忍一定的数据丢失的情况下，选择Redis</li>
</ul>
<h3 id="Redis和memchahed的区别"><a href="#Redis和memchahed的区别" class="headerlink" title="Redis和memchahed的区别"></a>Redis和memchahed的区别</h3><table>
<thead>
<tr>
<th></th>
<th>Redis</th>
<th>Memcached</th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>丰富的数据类型：string、hash、list等</td>
<td>只支持string</td>
</tr>
<tr>
<td>持久化</td>
<td>支持（RDB、AOF）</td>
<td>不支持</td>
</tr>
<tr>
<td>事务</td>
<td>简单支持（MULTI&#x2F;EXEC）</td>
<td>不支持</td>
</tr>
<tr>
<td>分布式</td>
<td>支持，集群自动分片</td>
<td>依赖客户端一致性哈希或第三方工具实现分布式</td>
</tr>
<tr>
<td>命令</td>
<td>支持丰富的命令</td>
<td>仅支持SET、GET、ADD、DELTE等基础操作</td>
</tr>
<tr>
<td>内存占用</td>
<td>复杂数据结构可能导致内存消耗较高</td>
<td>内存利用率高，但灵活性较低</td>
</tr>
</tbody></table>
<p>总结：</p>
<ul>
<li>需要复杂数据结构、持久化、事务支持和高可用性的场景，选择Redis</li>
<li>追求极致的性能和简单性，数据结构简单且无需持久化的场景，可以选择Memcached</li>
</ul>
<h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><h3 id="Redis-IO多路复用"><a href="#Redis-IO多路复用" class="headerlink" title="Redis IO多路复用"></a>Redis IO多路复用</h3><p>常见的 I&#x2F;O 多路复用机制包括 select、poll 和 epoll 等。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>select</code></th>
<th><code>poll</code></th>
<th><code>epoll</code></th>
</tr>
</thead>
<tbody><tr>
<td>文件描述符限制</td>
<td>受 <code>FD_SETSIZE</code> 限制</td>
<td>无限制</td>
<td>无限制</td>
</tr>
<tr>
<td>时间复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>数据复制</td>
<td>需要</td>
<td>需要</td>
<td>不需要</td>
</tr>
<tr>
<td>工作方式</td>
<td>线性扫描</td>
<td>线性扫描</td>
<td>事件通知</td>
</tr>
<tr>
<td>内核支持</td>
<td>所有 UNIX 系统</td>
<td>所有 UNIX 系统</td>
<td>Linux 2.6 及以上版本</td>
</tr>
<tr>
<td>适用场景</td>
<td>少量连接</td>
<td>中等连接</td>
<td>大量并发连接</td>
</tr>
</tbody></table>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/redis-20240918114125.png" alt="有盐先生：IO 多路复用"></p>
<h3 id="Redis-6-0-多线程"><a href="#Redis-6-0-多线程" class="headerlink" title="Redis 6.0 多线程"></a>Redis 6.0 多线程</h3><p>在 Redis 6.0 中，多线程主要用来处理网络 IO 操作，命令解析和执行仍然是单线程完成，这样既可以发挥多核 CPU 的优势，又能避免锁和上下文切换带来的性能损耗。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-b7b24e25-d2dc-4457-994f-95bdb3674b8e.png" alt="三分恶面渣逆袭：Redis6.0多线程"></p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="什么是缓存穿透-雪崩-击穿，对应的解决方案是什么"><a href="#什么是缓存穿透-雪崩-击穿，对应的解决方案是什么" class="headerlink" title="什么是缓存穿透&#x2F;雪崩&#x2F;击穿，对应的解决方案是什么"></a>什么是缓存穿透&#x2F;雪崩&#x2F;击穿，对应的解决方案是什么</h3><p><strong>缓存穿透</strong>是指查询数据库中不存在的数据，导致请求每次都穿过缓存查询数据库。</p>
<p>解决方案：</p>
<ul>
<li><strong>布隆过滤器（Bloom Filter）</strong></li>
</ul>
<p>服务启动时加载全量有效key，标记数据是否存在；新增数据时同步更新过滤器</p>
<p>缺点：存在一定的误判率</p>
<ul>
<li><strong>缓存空值</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getData</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> redis.get(key);</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> NullValue) &#123; <span class="comment">// 空值标记</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    value = db.query(key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        redis.setex(key, <span class="number">300</span>, <span class="keyword">new</span> <span class="title class_">NullValue</span>()); <span class="comment">// 缓存空值5分钟</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redis.setex(key, <span class="number">3600</span>, value); <span class="comment">// 正常缓存1小时</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>增强请求参数的复杂度，避免被猜测，同时做好数据的基础格式校验</li>
</ul>
<p><strong>缓存雪崩</strong>是指<strong>大量key</strong>同时失效，导致大量请求都去查询数据库，造成数据库压力骤增。</p>
<p>解决方案：</p>
<ul>
<li><strong>差异化过期时间</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基础过期时间，1小时</span></span><br><span class="line"><span class="type">int</span> <span class="variable">baseExpire</span> <span class="operator">=</span> <span class="number">3600</span>;</span><br><span class="line"><span class="comment">// 随机0-5分钟</span></span><br><span class="line"><span class="type">int</span> <span class="variable">randomExpire</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">300</span>);</span><br><span class="line">redis.setex(key, baseExpire + randomExpire, value);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>永不过期+异步更新</strong></li>
<li><strong>添加降级限流策略</strong></li>
<li><strong>添加多级缓存</strong></li>
</ul>
<p><strong>缓存击穿</strong>是指某个<strong>热点key</strong>失效的瞬间，有大量请求同时访问这个key，导致所有请求都去查询数据库。</p>
<p>解决方案：</p>
<ul>
<li><strong>互斥锁</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> Redission.getLock(<span class="string">&quot;PREFIX:&quot;</span> + key);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lock.tryLock(<span class="number">3</span>, <span class="number">30</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">        <span class="comment">// 查库并重建缓存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>逻辑过期</strong></li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;真实数据&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;expire_ts&quot;</span><span class="punctuation">:</span> <span class="number">1672502400</span> <span class="comment">// 逻辑过期时间戳</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>处理流程：</p>
<ol>
<li>判断逻辑过期时间<ol>
<li>未过期，直接返回数据</li>
<li>已过期，创建子线程，异步重建缓存</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th>解决方案</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>互斥锁</td>
<td>实现简单；保证一致性；无需消耗额外内存</td>
<td>线程需等待，影响性能</td>
</tr>
<tr>
<td>逻辑过期</td>
<td>线程无需等待，性能较好</td>
<td>存在不一致性；消耗额外内存；实现复杂</td>
</tr>
</tbody></table>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>布隆过滤器（Bloom Filter）是一种空间高效、快速判断某个元素是否存在于集合中的数据结构。它由布隆于1970年提出，主要用于大规模数据集合的快速查找和去重。</p>
<p>布隆过滤器的基本思想是使用多个独立的哈希函数将元素映射到一个位数组（或称为布隆过滤器的位向量）中，并将这些位数组初始化为0。当要插入一个元素时，通过这些哈希函数计算得到的多个哈希值对应的位都被设置为1。当要查询一个元素是否存在时，同样通过这些哈希函数计算得到的多个哈希值对应的位都被检查，如果其中有任意一个位为0，则表示元素一定不存在；如果所有位都为1，则表示元素可能存在，但并不一定存在，可能会存在一定的误判率。</p>
<p>布隆过滤器的优点是占用空间小，插入和查询操作的时间复杂度都是O(k)，其中k是哈希函数的数量。此外，布隆过滤器可以处理非常大的数据集合，而且对于插入和查询操作的响应速度非常快。然而，布隆过滤器的缺点是存在一定的误判率，即在查询时可能会出现”误判为存在”的情况，因此在使用时需要注意选择合适的哈希函数数量和位数组大小，以及合理设置误判率的阈值。</p>
<p>布隆过滤器在实际应用中有很多用途，例如在数据库、缓存、网络路由器、爬虫等领域中都有广泛的应用，特别是在处理大规模数据集合时，可以显著减少存储和查询的开销。但需要注意的是，布隆过滤器并不适用于所有情况，因为它存在一定的误判率，并且无法删除已插入的元素，因此在选择使用时需要根据具体应用场景进行评估。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.BitSet;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BloomFilter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BitSet bitArray;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> m; <span class="comment">// 位数组的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> k; <span class="comment">// 哈希函数的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BloomFilter</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.m = m;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        <span class="built_in">this</span>.bitArray = <span class="keyword">new</span> <span class="title class_">BitSet</span>(m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] hash(String data) &#123;</span><br><span class="line">        <span class="type">int</span>[] hashValues = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">MessageDigest</span> <span class="variable">md</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;SHA-256&quot;</span>);</span><br><span class="line">            <span class="type">byte</span>[] hashBytes = md.digest(data.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">                hashValues[i] = Math.abs((<span class="type">int</span>) (hashBytes[(i * <span class="number">4</span>) % hashBytes.length]) % m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hashValues;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] hashValues = hash(data);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> hashValue : hashValues) &#123;</span><br><span class="line">            bitArray.set(hashValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">query</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] hashValues = hash(data);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> hashValue : hashValues) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!bitArray.get(hashValue)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建布隆过滤器，位数组大小为100，哈希函数数量为3</span></span><br><span class="line">        <span class="type">BloomFilter</span> <span class="variable">bloomFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BloomFilter</span>(<span class="number">100</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入元素</span></span><br><span class="line">        bloomFilter.insert(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        bloomFilter.insert(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        bloomFilter.insert(<span class="string">&quot;cherry&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询元素是否存在</span></span><br><span class="line">        System.out.println(bloomFilter.query(<span class="string">&quot;apple&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(bloomFilter.query(<span class="string">&quot;grape&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存淘汰策略"><a href="#缓存淘汰策略" class="headerlink" title="缓存淘汰策略"></a>缓存淘汰策略</h3><table>
<thead>
<tr>
<th align="left"><strong>数据范围</strong></th>
<th align="left"><strong>策略</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>所有Key</strong></td>
<td align="left"><code>allkeys-lru</code></td>
<td align="left">从所有Key中淘汰最近最少使用的</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>allkeys-lfu</code></td>
<td align="left">从所有Key中淘汰最不经常使用的（Redis 4.0+）</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>allkeys-random</code></td>
<td align="left">从所有Key中随机淘汰</td>
</tr>
<tr>
<td align="left"><strong>过期Key</strong></td>
<td align="left"><code>volatile-lru</code></td>
<td align="left">从设置了过期时间的Key中淘汰最近最少使用的</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>volatile-lfu</code></td>
<td align="left">从设置了过期时间的Key中淘汰最不经常使用的</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>volatile-random</code></td>
<td align="left">从设置了过期时间的Key中随机淘汰</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>volatile-ttl</code></td>
<td align="left">淘汰剩余存活时间（TTL）最短的Key</td>
</tr>
<tr>
<td align="left"><strong>不淘汰</strong></td>
<td align="left"><code>noeviction</code>（默认）</td>
<td align="left">内存不足时拒绝写入，返回错误</td>
</tr>
</tbody></table>
<h3 id="缓存与数据的更新策略"><a href="#缓存与数据的更新策略" class="headerlink" title="缓存与数据的更新策略"></a>缓存与数据的更新策略</h3><p><strong>方案一：先删缓存 → 更新数据库 → 重建缓存</strong></p>
<p><strong>问题风险</strong>：</p>
<ol>
<li><strong>并发脏读（严重问题）</strong><ul>
<li>线程A删除缓存后，尚未更新数据库</li>
<li>线程B读取缓存未命中，<strong>从数据库读到旧值</strong>并重建缓存</li>
<li>线程A更新数据库后，缓存中遗留<strong>旧数据</strong>（直到下次更新&#x2F;过期）<br><em>👉 缓存与数据库长期不一致</em></li>
</ul>
</li>
<li><strong>缓存击穿压力</strong><ul>
<li>删除缓存后，大量请求瞬间穿透到数据库（尤其热点数据）</li>
<li>若重建缓存慢，可能导致数据库雪崩</li>
</ul>
</li>
</ol>
<p><strong>方案二：先更新数据库 → 删除缓存（推荐方案）</strong></p>
<p><strong>问题风险：</strong></p>
<ol>
<li><strong>极小概率的旧数据残留</strong><ul>
<li>线程A读缓存<strong>命中旧值</strong>（此时缓存未失效）</li>
<li>线程B更新数据库并<strong>删除缓存</strong></li>
<li>线程A仍使用旧数据（短暂不一致，通常毫秒级）<br><em>👉 概率低，且旧数据很快被淘汰</em></li>
</ul>
</li>
<li><strong>缓存删除失败</strong><ul>
<li>数据库更新成功，但缓存删除失败 → <strong>永久不一致</strong><br><em>👉 需引入重试或补偿机制</em></li>
</ul>
</li>
</ol>
<p><strong>业界通用方案：Cache-Aside + 延迟双删</strong></p>
<p>结合可靠性设计，核心流程：</p>


<p><strong>关键优化措施</strong>：</p>
<ol>
<li><strong>延迟双删 (Double Delete)</strong><ul>
<li>更新数据库后<strong>立即删除缓存</strong></li>
<li><strong>额外启动异步任务</strong>（如延迟500ms）<strong>再次删除缓存</strong><br><em>👉 解决并发导致的旧数据重建问题</em></li>
</ul>
</li>
<li><strong>缓存操作失败重试</strong><ul>
<li>将删除操作发到<strong>消息队列</strong>（如Kafka&#x2F;RabbitMQ）</li>
<li>消费失败自动重试，直至成功<br><em>👉 确保最终一致性</em></li>
</ul>
</li>
<li><strong>短过期时间兜底</strong><ul>
<li>所有缓存设置 <strong>TTL（如1-5秒）</strong><br><em>👉 即使双删失败，旧数据也会快速过期</em></li>
</ul>
</li>
</ol>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="RDB和AOF持久化原理及优劣对比"><a href="#RDB和AOF持久化原理及优劣对比" class="headerlink" title="RDB和AOF持久化原理及优劣对比"></a>RDB和AOF持久化原理及优劣对比</h3><p>RDB，存储某一时刻内存中所有的数据，触发命令<code>save</code>、<code>bgsave</code>，主进程<code>fork</code>子进程，阻塞。</p>
<p>触发条件：</p>
<ol>
<li>客户端发送<code>shutdown</code></li>
<li>从节点要进行全量复制</li>
<li>达到<code>redis.conf</code>文件中配置的条件</li>
<li>客户端执行<code>flushall</code>（生成空的<code>dump.rdb</code>，慎用）</li>
</ol>
<p>不能频繁生成 RBD 快照，原因：</p>
<ul>
<li>多次 RDB 会竞争磁盘带宽</li>
<li><code>fork</code> 子进程会阻塞主进程</li>
</ul>
<p>写时复制<code>copy-on-write</code>：</p>
<ul>
<li><strong>共享内存初始化</strong>：子进程刚创建时，<strong>与父进程共享全部内存页</strong>，此时内存占用几乎无额外开销。</li>
<li><strong>写操作触发复制</strong>：若父进程收到写请求（修改数据），操作系统会<strong>将被修改的内存页复制一份</strong>，父进程在副本上修改，子进程仍读取原始页。</li>
<li><strong>子进程视角固定</strong>：子进程看到的数据始终是 <code>fork()</code> 瞬间的状态，确保快照一致性。</li>
</ul>
<p>AOF，所有写命令追加到 <code>aof_buf</code>，刷盘策略由 <code>appendfsync</code> 决定。</p>
<p>如果有 AOF 文件，加载 AOF；否则，加载 RDB 文件。AOF 最多丢失 1s 数据。</p>
<p>AOF重写是直接为当前内存的数据生成对应命令，并不是读取旧AOF文件进行命令合并</p>
<ul>
<li>父子进程写同一个文件会产生竞争问题，影响父进程的性能。</li>
<li>如果AOF重写过程中失败了，相当于污染了原本的AOF文件，无法做恢复数据使用</li>
</ul>
<p>修复已损害的AOF文件：<code>redis-check-aof --fix appendonly.aof</code></p>
<table>
<thead>
<tr>
<th></th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody><tr>
<td>启动加载优先级</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>体积</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>恢复速度</td>
<td>慢</td>
<td>快</td>
</tr>
</tbody></table>
<p>总结：RDB适合用作数据备份，AOF适合用作数据恢复。</p>
<h3 id="全量同步和增量同步的区别"><a href="#全量同步和增量同步的区别" class="headerlink" title="全量同步和增量同步的区别"></a>全量同步和增量同步的区别</h3><p>全量同步：master生成当前内存中所有数据的RDB文件，将RDB发送给slave。在此过程中，master将新的命令记录在<code>repl_backlog</code>中，后续再发送给slave。</p>
<p>执行时机：</p>
<ol>
<li>slave第一次连接到master</li>
<li>slave宕机太久，导致它在<code>repl_backlog</code>中的<code>offset</code>已经被覆盖掉了</li>
</ol>
<p>增量同步：salve将自己的<code>offset</code>发送到master，master将<code>repl_backlog</code>中<code>offset</code>之后的命令发送给slave</p>
<p>执行时机：</p>
<ol>
<li>slave断开重连之后，<code>repl_backlog</code>中的<code>offset</code>尚未被覆盖</li>
</ol>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/7ad2e472.html" rel="prev" title="脚本库">
                  <i class="fa fa-angle-left"></i> 脚本库
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/d48132d3.html" rel="next" title="ElasticSearch">
                  ElasticSearch <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa-regular fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder"></span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Word count total">344k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">20:53</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>

  <script class="next-config" data-name="wavedrom" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/wavedrom.min.js","integrity":"sha256-INLAoJc6quTNfiMWkGZniYO2cxE8mHpddnLow1m6RFs="}}</script>
  <script class="next-config" data-name="wavedrom_skin" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/skins/default.js","integrity":"sha256-fduc/Zszk5ezWws2uInY/ALWVmIrmV6VTgXbsYSReFI="}}</script>
  <script src="/js/third-party/tags/wavedrom.js"></script>




  





</body>
</html>
