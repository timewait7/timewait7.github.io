<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"timewait7.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":true,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="深入理解数据类型及适用场景、持久化机制（RDB&#x2F;AOF）、内存淘汰策略、集群模式（主从、哨兵、Cluster）、分布式锁实现（Redlock 争议及替代方案）、缓存穿透&#x2F;击穿&#x2F;雪崩解决方案、与数据库一致性策略。了解底层数据结构（SDS, 跳跃表, 字典, 压缩列表等）。 数据结构Redis 有哪些数据类型，分别用于哪些场景String（字符串）  描述：最基本的数据类">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="http://timewait7.github.io/post/bae4ff13.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="深入理解数据类型及适用场景、持久化机制（RDB&#x2F;AOF）、内存淘汰策略、集群模式（主从、哨兵、Cluster）、分布式锁实现（Redlock 争议及替代方案）、缓存穿透&#x2F;击穿&#x2F;雪崩解决方案、与数据库一致性策略。了解底层数据结构（SDS, 跳跃表, 字典, 压缩列表等）。 数据结构Redis 有哪些数据类型，分别用于哪些场景String（字符串）  描述：最基本的数据类">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20240918114125.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-b7b24e25-d2dc-4457-994f-95bdb3674b8e.png">
<meta property="article:published_time" content="2025-09-21T08:00:24.000Z">
<meta property="article:modified_time" content="2025-09-21T08:03:17.900Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20240918114125.png">


<link rel="canonical" href="http://timewait7.github.io/post/bae4ff13.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://timewait7.github.io/post/bae4ff13.html","path":"post/bae4ff13.html","title":"Redis"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Redis | Hexo</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-archives"><a href="/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="Searching..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%88%86%E5%88%AB%E7%94%A8%E4%BA%8E%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF"><span class="nav-number">1.1.</span> <span class="nav-text">Redis 有哪些数据类型，分别用于哪些场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB%EF%BC%9F%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E9%AB%98%E5%B9%B6%E5%8F%91%EF%BC%9F"><span class="nav-number">1.2.</span> <span class="nav-text">Redis为什么快？单线程如何处理高并发？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E5%92%8CMySQL%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.</span> <span class="nav-text">Redis和MySQL的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E5%92%8Cmemchahed%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.</span> <span class="nav-text">Redis和memchahed的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">1.5.</span> <span class="nav-text">Redis IO多路复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-6-0-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.6.</span> <span class="nav-text">Redis 6.0 多线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">内存管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">IO模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98"><span class="nav-number">4.</span> <span class="nav-text">缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-%E9%9B%AA%E5%B4%A9-%E5%87%BB%E7%A9%BF%EF%BC%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">4.1.</span> <span class="nav-text">什么是缓存穿透&#x2F;雪崩&#x2F;击穿，对应的解决方案是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">4.2.</span> <span class="nav-text">布隆过滤器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="nav-number">4.3.</span> <span class="nav-text">缓存淘汰策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="nav-number">4.4.</span> <span class="nav-text">缓存与数据的更新策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">5.</span> <span class="nav-text">持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB%E5%92%8CAOF%E6%8C%81%E4%B9%85%E5%8C%96%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8A%A3%E5%AF%B9%E6%AF%94"><span class="nav-number">5.1.</span> <span class="nav-text">RDB和AOF持久化原理及优劣对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5%E5%92%8C%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.2.</span> <span class="nav-text">全量同步和增量同步的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">6.</span> <span class="nav-text">分布式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.1.</span> <span class="nav-text">Redis分布式锁实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%AF%AF%E9%87%8A%E6%94%BE%E9%94%81"><span class="nav-number">6.2.</span> <span class="nav-text">如何避免误释放锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%94%81%E7%BB%AD%E6%9C%9F"><span class="nav-number">6.3.</span> <span class="nav-text">如何实现锁续期</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4"><span class="nav-number">7.</span> <span class="nav-text">集群</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8-Redis-%E4%B8%AD%E7%BB%91%E5%AE%9A-CPU-%E6%A0%B8"><span class="nav-number">7.1.</span> <span class="nav-text">在 Redis 中绑定 CPU 核</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/">
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="Back to top">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://timewait7.github.io/post/bae4ff13.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Redis | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-09-21 16:00:24" itemprop="dateCreated datePublished" datetime="2025-09-21T16:00:24+08:00">2025-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>6.2k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>23 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>深入理解数据类型及适用场景、持久化机制（RDB&#x2F;AOF）、内存淘汰策略、集群模式（主从、哨兵、Cluster）、分布式锁实现（Redlock 争议及替代方案）、缓存穿透&#x2F;击穿&#x2F;雪崩解决方案、与数据库一致性策略。了解底层数据结构（SDS, 跳跃表, 字典, 压缩列表等）。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="Redis-有哪些数据类型，分别用于哪些场景"><a href="#Redis-有哪些数据类型，分别用于哪些场景" class="headerlink" title="Redis 有哪些数据类型，分别用于哪些场景"></a>Redis 有哪些数据类型，分别用于哪些场景</h3><p><strong>String（字符串）</strong></p>
<ul>
<li><strong>描述</strong>：最基本的数据类型，可存储文本、二进制数据（如图片）、数字（整数或浮点数）。</li>
<li><strong>典型场景</strong>：<ul>
<li><strong>缓存</strong>：存储用户会话信息（Session）、HTML片段、API响应等。</li>
<li><strong>计数器</strong>：网站访问量、点赞数、库存数量（利用 <code>INCR/DECR</code>）。</li>
<li><strong>分布式锁</strong>：通过 <code>SET key value NX EX</code> 实现简单锁。</li>
<li><strong>位操作（Bitmaps）</strong>：利用 <code>SETBIT</code>, <code>GETBIT</code>, <code>BITCOUNT</code> 等命令实现用户在线状态、签到记录、布隆过滤器等（本质上是操作字符串的位）。</li>
</ul>
</li>
</ul>
<p><strong>List（列表）</strong></p>
<ul>
<li><strong>描述</strong>：有序的字符串集合，元素可重复。按照插入顺序排序，可在头部(<code>LPUSH</code>)或尾部(<code>RPUSH</code>)插入元素。</li>
<li><strong>典型场景</strong>：<ul>
<li><strong>消息队列（简单版）</strong>：生产者 <code>LPUSH</code> 消息，消费者 <code>RPOP</code>&#x2F;<code>BRPOP</code> 消息（FIFO）。也可实现栈（LIFO）。</li>
<li><strong>最新消息&#x2F;动态流（Timeline）</strong>：<code>LPUSH</code> 最新内容，<code>LRANGE</code> 获取最近 N 条。</li>
<li><strong>记录操作日志</strong>。</li>
</ul>
</li>
</ul>
<p><strong>Set（集合）</strong></p>
<ul>
<li><strong>描述</strong>：无序的字符串集合，元素<strong>不可重复</strong>，支持集合运算（交集、并集、差集）。</li>
<li><strong>典型场景</strong>：<ul>
<li><strong>标签（Tagging）</strong>：存储文章、商品的标签（自动去重）。</li>
<li><strong>共同关注&#x2F;好友（社交关系）</strong>：利用 <code>SINTER</code> 求交集。</li>
</ul>
</li>
</ul>
<p><strong>Hash（哈希 &#x2F; 字典）</strong></p>
<ul>
<li><strong>描述</strong>：键值对集合，用于存储对象（如用户信息）。<code>field-value</code> 映射表。</li>
<li><strong>典型场景</strong>：<ul>
<li><strong>存储对象</strong>：用户信息（<code>user:1000 &#123;name: &quot;Alice&quot;, age: 30, email: ...&#125;</code>）、商品详情、配置项。</li>
<li><strong>频繁修改部分属性的对象</strong>：如只更新用户积分，避免读取整个字符串再写回。</li>
</ul>
</li>
</ul>
<p><strong>Sorted Set（有序集合 &#x2F; ZSet）</strong></p>
<ul>
<li><strong>描述</strong>：Set 的升级版，元素<strong>唯一</strong>，但每个元素关联一个 <code>score</code>（分数）。元素<strong>按 <code>score</code> 排序</strong>（从小到大）。<code>score</code> 可相同，此时按元素字典序排序。</li>
<li><strong>典型场景</strong>：<ul>
<li><strong>排行榜</strong>：游戏积分榜（<code>score</code> 为积分）、热搜榜（<code>score</code> 为热度值）。<code>ZREVRANGE</code> 获取 Top N。</li>
</ul>
</li>
</ul>
<p><strong>Bitmaps</strong></p>
<ul>
<li><strong>本质</strong>：String 类型的位操作扩展。</li>
<li><strong>场景</strong>：极省空间的布尔值统计（用户在线状态、每日签到、活跃用户统计、布隆过滤器）。</li>
</ul>
<p><strong>HyperLogLog（HLL）</strong></p>
<ul>
<li><strong>本质</strong>：特殊的 String 类型。</li>
<li><strong>场景</strong>：海量数据的去重计数（网站 UV、独立 IP 访问数、搜索词去重统计），不需要精确结果时。</li>
</ul>
<p><strong>Geospatial（地理空间）</strong></p>
<ul>
<li><strong>本质</strong>：基于 Sorted Set（ZSet）实现，<code>member</code> 是位置标识符，<code>score</code> 是经度+纬度编码成的 52 位整数（GeoHash）。</li>
<li><strong>场景</strong>：附近的人&#x2F;地点（如滴滴打车）、基于位置的服务（LBS）、地理围栏。</li>
</ul>
<p><strong>Streams</strong></p>
<ul>
<li><strong>描述</strong>：Redis 5.0 引入。为<strong>消息队列</strong>设计的功能更完善的数据类型。类似 Kafka 或 RabbitMQ 的 topic。</li>
<li><strong>场景</strong>：<strong>可靠的消息队列</strong>、事件溯源（Event Sourcing）、实时数据管道。</li>
</ul>
<h3 id="Redis为什么快？单线程如何处理高并发？"><a href="#Redis为什么快？单线程如何处理高并发？" class="headerlink" title="Redis为什么快？单线程如何处理高并发？"></a>Redis为什么快？单线程如何处理高并发？</h3><p>对于Redis的高性能设计，我的理解主要得益于以下几点：</p>
<ul>
<li><p>内存操作：Redis数据存储在内存，相比于磁盘数据库，减少了IO开销</p>
</li>
<li><p>高效的数据结构：Redis针对不同场景设计了不同的数据结构，优化了空间和访问效率</p>
</li>
<li><p>单线程：Redis使用单线程处理命令，避免了多线程之间的竞争和上下文切换的开销</p>
</li>
<li><p>IO多路复用：Redis基于epoll&#x2F;kqueue实现了非阻塞的网络模型，通过事件机制循环处理请求</p>
</li>
</ul>
<h3 id="Redis和MySQL的区别"><a href="#Redis和MySQL的区别" class="headerlink" title="Redis和MySQL的区别"></a>Redis和MySQL的区别</h3><table>
<thead>
<tr>
<th></th>
<th>Redis</th>
<th>MySQL</th>
</tr>
</thead>
<tbody><tr>
<td>数据结构</td>
<td>非结构化</td>
<td>结构化</td>
</tr>
<tr>
<td>持久化</td>
<td>可选持久化</td>
<td>默认持久化</td>
</tr>
<tr>
<td>事务支持</td>
<td>简单支持</td>
<td>支持完整的ACID</td>
</tr>
<tr>
<td>扩展性</td>
<td>通过分片水平扩展</td>
<td>复杂，需分库分表或中间件</td>
</tr>
<tr>
<td>数据一致性</td>
<td>最终一致性</td>
<td>强一致性</td>
</tr>
</tbody></table>
<p>总结：</p>
<ul>
<li>当需要复杂查询和事务支持，对数据一致性要求较高，需要长期持久化存储的场景，选择MySQL</li>
<li>当需要超高性能和灵活数据类型，对数据的一致性要求不那么高，且容忍一定的数据丢失的情况下，选择Redis</li>
</ul>
<h3 id="Redis和memchahed的区别"><a href="#Redis和memchahed的区别" class="headerlink" title="Redis和memchahed的区别"></a>Redis和memchahed的区别</h3><table>
<thead>
<tr>
<th></th>
<th>Redis</th>
<th>Memcached</th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>丰富的数据类型：string、hash、list等</td>
<td>只支持string</td>
</tr>
<tr>
<td>持久化</td>
<td>支持（RDB、AOF）</td>
<td>不支持</td>
</tr>
<tr>
<td>事务</td>
<td>简单支持（MULTI&#x2F;EXEC）</td>
<td>不支持</td>
</tr>
<tr>
<td>分布式</td>
<td>支持，集群自动分片</td>
<td>依赖客户端一致性哈希或第三方工具实现分布式</td>
</tr>
<tr>
<td>命令</td>
<td>支持丰富的命令</td>
<td>仅支持SET、GET、ADD、DELTE等基础操作</td>
</tr>
<tr>
<td>内存占用</td>
<td>复杂数据结构可能导致内存消耗较高</td>
<td>内存利用率高，但灵活性较低</td>
</tr>
</tbody></table>
<p>总结：</p>
<ul>
<li>需要复杂数据结构、持久化、事务支持和高可用性的场景，选择Redis</li>
<li>追求极致的性能和简单性，数据结构简单且无需持久化的场景，可以选择Memcached</li>
</ul>
<h3 id="Redis-IO多路复用"><a href="#Redis-IO多路复用" class="headerlink" title="Redis IO多路复用"></a>Redis IO多路复用</h3><p>常见的 I&#x2F;O 多路复用机制包括 select、poll 和 epoll 等。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>select</code></th>
<th><code>poll</code></th>
<th><code>epoll</code></th>
</tr>
</thead>
<tbody><tr>
<td>文件描述符限制</td>
<td>受 <code>FD_SETSIZE</code> 限制</td>
<td>无限制</td>
<td>无限制</td>
</tr>
<tr>
<td>时间复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>数据复制</td>
<td>需要</td>
<td>需要</td>
<td>不需要</td>
</tr>
<tr>
<td>工作方式</td>
<td>线性扫描</td>
<td>线性扫描</td>
<td>事件通知</td>
</tr>
<tr>
<td>内核支持</td>
<td>所有 UNIX 系统</td>
<td>所有 UNIX 系统</td>
<td>Linux 2.6 及以上版本</td>
</tr>
<tr>
<td>适用场景</td>
<td>少量连接</td>
<td>中等连接</td>
<td>大量并发连接</td>
</tr>
</tbody></table>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/redis-20240918114125.png" alt="有盐先生：IO 多路复用"></p>
<h3 id="Redis-6-0-多线程"><a href="#Redis-6-0-多线程" class="headerlink" title="Redis 6.0 多线程"></a>Redis 6.0 多线程</h3><p>在 Redis 6.0 中，多线程主要用来处理网络 IO 操作，命令解析和执行仍然是单线程完成，这样既可以发挥多核 CPU 的优势，又能避免锁和上下文切换带来的性能损耗。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-b7b24e25-d2dc-4457-994f-95bdb3674b8e.png" alt="三分恶面渣逆袭：Redis6.0多线程"></p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">Redis核心知识脑图</span><br><span class="line">├── 数据结构篇</span><br><span class="line">│   ├── 基础数据结构</span><br><span class="line">│   │   ├── String</span><br><span class="line">│   │   │   ├── 二进制安全</span><br><span class="line">│   │   │   ├── 应用场景：缓存、计数器</span><br><span class="line">│   │   ├── List</span><br><span class="line">│   │   │   ├── 双向链表/ziplist</span><br><span class="line">│   │   │   ├── 应用场景：队列、栈</span><br><span class="line">│   │   ├── Hash</span><br><span class="line">│   │   │   ├── field-value结构</span><br><span class="line">│   │   │   ├── 应用场景：对象存储</span><br><span class="line">│   │   ├── Set</span><br><span class="line">│   │   │   ├── 无序唯一集合</span><br><span class="line">│   │   │   ├── 应用场景：标签系统</span><br><span class="line">│   │   └── Sorted Set</span><br><span class="line">│   │       ├── 带权重的Set</span><br><span class="line">│   │       └── 应用场景：排行榜</span><br><span class="line">│   └── 高级数据结构</span><br><span class="line">│       ├── HyperLogLog</span><br><span class="line">│       │   └── 基数统计（误差0.81%）</span><br><span class="line">│       ├── Bitmap</span><br><span class="line">│       │   └── 位操作（日活统计）</span><br><span class="line">│       ├── Geospatial</span><br><span class="line">│       │   └── 地理位置计算</span><br><span class="line">│       └── Streams</span><br><span class="line">│           └── 消息队列（类似Kafka）</span><br><span class="line">│</span><br><span class="line">└── 内存管理篇</span><br><span class="line">    ├── 内存分配</span><br><span class="line">    │   ├── 使用jemalloc库</span><br><span class="line">    │   └── 预分配策略</span><br><span class="line">    ├── 内存回收</span><br><span class="line">    │   ├── 惰性删除（访问时检查过期）</span><br><span class="line">    │   └── 定期删除（随机抽查）</span><br><span class="line">    ├── 内存优化</span><br><span class="line">    │   ├── 编码优化</span><br><span class="line">    │   │   ├── ziplist（小数据量）</span><br><span class="line">    │   │   ├── intset（整数集合）</span><br><span class="line">    │   ├── 共享对象（0-9999整数池）</span><br><span class="line">    │   └── 内存碎片处理</span><br><span class="line">    │       ├── info memory查看碎片率</span><br><span class="line">    │       └── 重启消除碎片</span><br><span class="line">    ├── 淘汰策略</span><br><span class="line">    │   ├── volatile-lru</span><br><span class="line">    │   ├── allkeys-lru</span><br><span class="line">    │   ├── volatile-lfu（4.0+）</span><br><span class="line">    │   ├── allkeys-random</span><br><span class="line">    │   └── noeviction（默认）</span><br><span class="line">    └── 内存监控</span><br><span class="line">        ├── info memory命令</span><br><span class="line">        ├── used_memory_human</span><br><span class="line">        └── CONFIG SET调整参数</span><br></pre></td></tr></table></figure>

<h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="什么是缓存穿透-雪崩-击穿，对应的解决方案是什么"><a href="#什么是缓存穿透-雪崩-击穿，对应的解决方案是什么" class="headerlink" title="什么是缓存穿透&#x2F;雪崩&#x2F;击穿，对应的解决方案是什么"></a>什么是缓存穿透&#x2F;雪崩&#x2F;击穿，对应的解决方案是什么</h3><p><strong>缓存穿透</strong>是指查询数据库中不存在的数据，导致请求每次都穿过缓存查询数据库。</p>
<p>解决方案：</p>
<ul>
<li><strong>布隆过滤器（Bloom Filter）</strong></li>
</ul>
<p>服务启动时加载全量有效key，标记数据是否存在；新增数据时同步更新过滤器</p>
<p>缺点：存在一定的误判率</p>
<ul>
<li><strong>缓存空值</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getData</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> redis.get(key);</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> NullValue) &#123; <span class="comment">// 空值标记</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    value = db.query(key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        redis.setex(key, <span class="number">300</span>, <span class="keyword">new</span> <span class="title class_">NullValue</span>()); <span class="comment">// 缓存空值5分钟</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redis.setex(key, <span class="number">3600</span>, value); <span class="comment">// 正常缓存1小时</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>增强请求参数的复杂度，避免被猜测，同时做好数据的基础格式校验</li>
</ul>
<p><strong>缓存雪崩</strong>是指<strong>大量key</strong>同时失效，导致大量请求都去查询数据库，造成数据库压力骤增。</p>
<p>解决方案：</p>
<ul>
<li><strong>差异化过期时间</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基础过期时间，1小时</span></span><br><span class="line"><span class="type">int</span> <span class="variable">baseExpire</span> <span class="operator">=</span> <span class="number">3600</span>;</span><br><span class="line"><span class="comment">// 随机0-5分钟</span></span><br><span class="line"><span class="type">int</span> <span class="variable">randomExpire</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">300</span>);</span><br><span class="line">redis.setex(key, baseExpire + randomExpire, value);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>永不过期+异步更新</strong></li>
<li><strong>添加降级限流策略</strong></li>
<li><strong>添加多级缓存</strong></li>
</ul>
<p><strong>缓存击穿</strong>是指某个<strong>热点key</strong>失效的瞬间，有大量请求同时访问这个key，导致所有请求都去查询数据库。</p>
<p>解决方案：</p>
<ul>
<li><strong>互斥锁</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> Redission.getLock(<span class="string">&quot;PREFIX:&quot;</span> + key);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lock.tryLock(<span class="number">3</span>, <span class="number">30</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">        <span class="comment">// 查库并重建缓存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>逻辑过期</strong></li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;真实数据&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;expire_ts&quot;</span><span class="punctuation">:</span> <span class="number">1672502400</span> <span class="comment">// 逻辑过期时间戳</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>处理流程：</p>
<ol>
<li>判断逻辑过期时间<ol>
<li>未过期，直接返回数据</li>
<li>已过期，创建子线程，异步重建缓存</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th>解决方案</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>互斥锁</td>
<td>实现简单；保证一致性；无需消耗额外内存</td>
<td>线程需等待，影响性能</td>
</tr>
<tr>
<td>逻辑过期</td>
<td>线程无需等待，性能较好</td>
<td>存在不一致性；消耗额外内存；实现复杂</td>
</tr>
</tbody></table>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>布隆过滤器（Bloom Filter）是一种空间高效、快速判断某个元素是否存在于集合中的数据结构。它由布隆于1970年提出，主要用于大规模数据集合的快速查找和去重。</p>
<p>布隆过滤器的基本思想是使用多个独立的哈希函数将元素映射到一个位数组（或称为布隆过滤器的位向量）中，并将这些位数组初始化为0。当要插入一个元素时，通过这些哈希函数计算得到的多个哈希值对应的位都被设置为1。当要查询一个元素是否存在时，同样通过这些哈希函数计算得到的多个哈希值对应的位都被检查，如果其中有任意一个位为0，则表示元素一定不存在；如果所有位都为1，则表示元素可能存在，但并不一定存在，可能会存在一定的误判率。</p>
<p>布隆过滤器的优点是占用空间小，插入和查询操作的时间复杂度都是O(k)，其中k是哈希函数的数量。此外，布隆过滤器可以处理非常大的数据集合，而且对于插入和查询操作的响应速度非常快。然而，布隆过滤器的缺点是存在一定的误判率，即在查询时可能会出现”误判为存在”的情况，因此在使用时需要注意选择合适的哈希函数数量和位数组大小，以及合理设置误判率的阈值。</p>
<p>布隆过滤器在实际应用中有很多用途，例如在数据库、缓存、网络路由器、爬虫等领域中都有广泛的应用，特别是在处理大规模数据集合时，可以显著减少存储和查询的开销。但需要注意的是，布隆过滤器并不适用于所有情况，因为它存在一定的误判率，并且无法删除已插入的元素，因此在选择使用时需要根据具体应用场景进行评估。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.BitSet;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BloomFilter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BitSet bitArray;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> m; <span class="comment">// 位数组的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> k; <span class="comment">// 哈希函数的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BloomFilter</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.m = m;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        <span class="built_in">this</span>.bitArray = <span class="keyword">new</span> <span class="title class_">BitSet</span>(m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] hash(String data) &#123;</span><br><span class="line">        <span class="type">int</span>[] hashValues = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">MessageDigest</span> <span class="variable">md</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;SHA-256&quot;</span>);</span><br><span class="line">            <span class="type">byte</span>[] hashBytes = md.digest(data.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">                hashValues[i] = Math.abs((<span class="type">int</span>) (hashBytes[(i * <span class="number">4</span>) % hashBytes.length]) % m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hashValues;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] hashValues = hash(data);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> hashValue : hashValues) &#123;</span><br><span class="line">            bitArray.set(hashValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">query</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] hashValues = hash(data);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> hashValue : hashValues) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!bitArray.get(hashValue)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建布隆过滤器，位数组大小为100，哈希函数数量为3</span></span><br><span class="line">        <span class="type">BloomFilter</span> <span class="variable">bloomFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BloomFilter</span>(<span class="number">100</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入元素</span></span><br><span class="line">        bloomFilter.insert(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        bloomFilter.insert(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        bloomFilter.insert(<span class="string">&quot;cherry&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询元素是否存在</span></span><br><span class="line">        System.out.println(bloomFilter.query(<span class="string">&quot;apple&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(bloomFilter.query(<span class="string">&quot;grape&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存淘汰策略"><a href="#缓存淘汰策略" class="headerlink" title="缓存淘汰策略"></a>缓存淘汰策略</h3><table>
<thead>
<tr>
<th align="left"><strong>数据范围</strong></th>
<th align="left"><strong>策略</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>所有Key</strong></td>
<td align="left"><code>allkeys-lru</code></td>
<td align="left">从所有Key中淘汰最近最少使用的</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>allkeys-lfu</code></td>
<td align="left">从所有Key中淘汰最不经常使用的（Redis 4.0+）</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>allkeys-random</code></td>
<td align="left">从所有Key中随机淘汰</td>
</tr>
<tr>
<td align="left"><strong>过期Key</strong></td>
<td align="left"><code>volatile-lru</code></td>
<td align="left">从设置了过期时间的Key中淘汰最近最少使用的</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>volatile-lfu</code></td>
<td align="left">从设置了过期时间的Key中淘汰最不经常使用的</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>volatile-random</code></td>
<td align="left">从设置了过期时间的Key中随机淘汰</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>volatile-ttl</code></td>
<td align="left">淘汰剩余存活时间（TTL）最短的Key</td>
</tr>
<tr>
<td align="left"><strong>不淘汰</strong></td>
<td align="left"><code>noeviction</code>（默认）</td>
<td align="left">内存不足时拒绝写入，返回错误</td>
</tr>
</tbody></table>
<h3 id="缓存与数据的更新策略"><a href="#缓存与数据的更新策略" class="headerlink" title="缓存与数据的更新策略"></a>缓存与数据的更新策略</h3><p><strong>方案一：先删缓存 → 更新数据库 → 重建缓存</strong></p>
<p><strong>问题风险</strong>：</p>
<ol>
<li><strong>并发脏读（严重问题）</strong><ul>
<li>线程A删除缓存后，尚未更新数据库</li>
<li>线程B读取缓存未命中，<strong>从数据库读到旧值</strong>并重建缓存</li>
<li>线程A更新数据库后，缓存中遗留<strong>旧数据</strong>（直到下次更新&#x2F;过期）<br><em>👉 缓存与数据库长期不一致</em></li>
</ul>
</li>
<li><strong>缓存击穿压力</strong><ul>
<li>删除缓存后，大量请求瞬间穿透到数据库（尤其热点数据）</li>
<li>若重建缓存慢，可能导致数据库雪崩</li>
</ul>
</li>
</ol>
<p><strong>方案二：先更新数据库 → 删除缓存（推荐方案）</strong></p>
<p><strong>问题风险：</strong></p>
<ol>
<li><strong>极小概率的旧数据残留</strong><ul>
<li>线程A读缓存<strong>命中旧值</strong>（此时缓存未失效）</li>
<li>线程B更新数据库并<strong>删除缓存</strong></li>
<li>线程A仍使用旧数据（短暂不一致，通常毫秒级）<br><em>👉 概率低，且旧数据很快被淘汰</em></li>
</ul>
</li>
<li><strong>缓存删除失败</strong><ul>
<li>数据库更新成功，但缓存删除失败 → <strong>永久不一致</strong><br><em>👉 需引入重试或补偿机制</em></li>
</ul>
</li>
</ol>
<p><strong>业界通用方案：Cache-Aside + 延迟双删</strong></p>
<p>结合可靠性设计，核心流程：</p>


<p><strong>关键优化措施</strong>：</p>
<ol>
<li><strong>延迟双删 (Double Delete)</strong><ul>
<li>更新数据库后<strong>立即删除缓存</strong></li>
<li><strong>额外启动异步任务</strong>（如延迟500ms）<strong>再次删除缓存</strong><br><em>👉 解决并发导致的旧数据重建问题</em></li>
</ul>
</li>
<li><strong>缓存操作失败重试</strong><ul>
<li>将删除操作发到<strong>消息队列</strong>（如Kafka&#x2F;RabbitMQ）</li>
<li>消费失败自动重试，直至成功<br><em>👉 确保最终一致性</em></li>
</ul>
</li>
<li><strong>短过期时间兜底</strong><ul>
<li>所有缓存设置 <strong>TTL（如1-5秒）</strong><br><em>👉 即使双删失败，旧数据也会快速过期</em></li>
</ul>
</li>
</ol>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="RDB和AOF持久化原理及优劣对比"><a href="#RDB和AOF持久化原理及优劣对比" class="headerlink" title="RDB和AOF持久化原理及优劣对比"></a>RDB和AOF持久化原理及优劣对比</h3><p>RDB，存储某一时刻内存中所有的数据，触发命令<code>save</code>、<code>bgsave</code>，主进程<code>fork</code>子进程，阻塞。</p>
<p>触发条件：</p>
<ol>
<li>客户端发送<code>shutdown</code></li>
<li>从节点要进行全量复制</li>
<li>达到<code>redis.conf</code>文件中配置的条件</li>
<li>客户端执行<code>flushall</code>（生成空的<code>dump.rdb</code>，慎用）</li>
</ol>
<p>不能频繁生成 RBD 快照，原因：</p>
<ul>
<li>多次 RDB 会竞争磁盘带宽</li>
<li><code>fork</code> 子进程会阻塞主进程</li>
</ul>
<p>写时复制<code>copy-on-write</code>：</p>
<ul>
<li><strong>共享内存初始化</strong>：子进程刚创建时，<strong>与父进程共享全部内存页</strong>，此时内存占用几乎无额外开销。</li>
<li><strong>写操作触发复制</strong>：若父进程收到写请求（修改数据），操作系统会<strong>将被修改的内存页复制一份</strong>，父进程在副本上修改，子进程仍读取原始页。</li>
<li><strong>子进程视角固定</strong>：子进程看到的数据始终是 <code>fork()</code> 瞬间的状态，确保快照一致性。</li>
</ul>
<p>AOF，所有写命令追加到 <code>aof_buf</code>，刷盘策略由 <code>appendfsync</code> 决定。</p>
<p>如果有 AOF 文件，加载 AOF；否则，加载 RDB 文件。AOF 最多丢失 1s 数据。</p>
<p>AOF重写是直接为当前内存的数据生成对应命令，并不是读取旧AOF文件进行命令合并</p>
<ul>
<li>父子进程写同一个文件会产生竞争问题，影响父进程的性能。</li>
<li>如果AOF重写过程中失败了，相当于污染了原本的AOF文件，无法做恢复数据使用</li>
</ul>
<p>修复已损害的AOF文件：<code>redis-check-aof --fix appendonly.aof</code></p>
<table>
<thead>
<tr>
<th></th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody><tr>
<td>启动加载优先级</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>体积</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>恢复速度</td>
<td>慢</td>
<td>快</td>
</tr>
</tbody></table>
<p>总结：RDB适合用作数据备份，AOF适合用作数据恢复。</p>
<h3 id="全量同步和增量同步的区别"><a href="#全量同步和增量同步的区别" class="headerlink" title="全量同步和增量同步的区别"></a>全量同步和增量同步的区别</h3><p>全量同步：master生成当前内存中所有数据的RDB文件，将RDB发送给slave。在此过程中，master将新的命令记录在<code>repl_backlog</code>中，后续再发送给slave。</p>
<p>执行时机：</p>
<ol>
<li>slave第一次连接到master</li>
<li>slave宕机太久，导致它在<code>repl_backlog</code>中的<code>offset</code>已经被覆盖掉了</li>
</ol>
<p>增量同步：salve将自己的<code>offset</code>发送到master，master将<code>repl_backlog</code>中<code>offset</code>之后的命令发送给slave</p>
<p>执行时机：</p>
<ol>
<li>slave断开重连之后，<code>repl_backlog</code>中的<code>offset</code>尚未被覆盖</li>
</ol>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="Redis分布式锁实现"><a href="#Redis分布式锁实现" class="headerlink" title="Redis分布式锁实现"></a>Redis分布式锁实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.ValueOperations;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisDistributedLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_KEY</span> <span class="operator">=</span> <span class="string">&quot;myLock&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LOCK_EXPIRE_TIME</span> <span class="operator">=</span> <span class="number">5000</span>; <span class="comment">// 锁过期时间，单位毫秒</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisDistributedLock</span><span class="params">(RedisTemplate&lt;String, String&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">acquireLock</span><span class="params">()</span> &#123;</span><br><span class="line">        ValueOperations&lt;String, String&gt; valueOperations = redisTemplate.opsForValue();</span><br><span class="line">        <span class="comment">// 尝试获取分布式锁</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">result</span> <span class="operator">=</span> valueOperations.setIfAbsent(LOCK_KEY, <span class="string">&quot;locked&quot;</span>); <span class="comment">// RedisTemplate 的 setIfAbsent 方法，如果键不存在则设置键值对并返回 true，否则返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span> &amp;&amp; result) &#123;</span><br><span class="line">            <span class="comment">// 成功获取到锁，设置锁的过期时间</span></span><br><span class="line">            redisTemplate.expire(LOCK_KEY, LOCK_EXPIRE_TIME, TimeUnit.MILLISECONDS); <span class="comment">// 设置键的过期时间，单位毫秒</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">releaseLock</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.delete(LOCK_KEY); <span class="comment">// 删除键</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用分布式锁的业务逻辑</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBusinessWithLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acquireLock()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获得分布式锁后执行业务逻辑</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Acquired lock, do business logic...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>); <span class="comment">// 模拟业务处理时间</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                releaseLock(); <span class="comment">// 业务处理完成后释放锁</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Released lock.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 未获得分布式锁，执行其他逻辑</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Failed to acquire lock, do other logic...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 RedisTemplate 实例并设置连接信息</span></span><br><span class="line">        RedisTemplate&lt;String, String&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置 Redis 连接工厂、序列化方式等</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="type">RedisDistributedLock</span> <span class="variable">distributedLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisDistributedLock</span>(redisTemplate);</span><br><span class="line">        distributedLock.doBusinessWithLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>竞争条件（Race Condition）：在多个客户端同时尝试获取锁时，可能会出现竞争条件，导致多个客户端都成功获得锁，从而引发并发访问资源的问题。</li>
<li>死锁（Deadlock）：如果某个持有锁的客户端在业务处理期间发生异常或崩溃，导致没有释放锁的操作，可能会出现死锁的情况，导致其他客户端无法获得锁。</li>
<li>锁过期（Lock Expiration）：为了避免死锁，通常会给锁设置过期时间，但如果业务处理时间较长，超过了锁的过期时间，可能会导致其他客户端误认为锁已经释放，从而引发并发访问资源的问题。</li>
<li>锁的重入性（Lock Reentrancy）：在某些场景下，同一个客户端可能需要多次获取同一个锁，例如嵌套的业务处理逻辑。如果分布式锁没有支持锁的重入性，可能会导致同一个客户端无法在业务处理期间重新获取锁，从而引发死锁或并发访问资源的问题。</li>
<li>性能开销（Performance Overhead）：使用分布式锁可能会增加系统的性能开销，例如频繁的锁获取和锁释放操作，以及锁的管理和维护。如果锁的使用不当，可能会影响系统的性能和响应时间。</li>
</ol>
<h3 id="如何避免误释放锁"><a href="#如何避免误释放锁" class="headerlink" title="如何避免误释放锁"></a>如何避免误释放锁</h3><p>为了防止误删其他锁，可以通过<code>key</code>对应的<code>value</code>来判断。为了保证操作的原子性（先比较<code>value</code>，再删除<code>key</code>），可以通过Lua脚本来执行。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 释放锁时，先比较锁对应的 value 值是否相等，避免锁的误释放</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="如何实现锁续期"><a href="#如何实现锁续期" class="headerlink" title="如何实现锁续期"></a>如何实现锁续期</h3><p>在 Redis 中实现分布式锁时，续期（即锁的自动延期）是一个常见的需求，尤其是在锁的持有时间可能超过最初设定的过期时间时。常见的解决方案是使用一个后台线程（或定时任务）定期检查锁是否仍然被持有，如果是，则延长锁的过期时间。这种机制通常被称为“<strong>看门狗</strong>”（Watchdog）机制。</p>
<p>基于 Redis 的分布式锁续期的基本思路：</p>
<ol>
<li><strong>获取锁时设置过期时间</strong>：在获取锁时，通常会设置一个过期时间（例如30秒），以防止客户端崩溃导致锁无法释放。</li>
<li><strong>启动一个续期线程</strong>：当成功获取锁后，启动一个后台线程，该线程定期（例如，每隔过期时间的1&#x2F;3时间）去检查锁是否还存在，如果存在，则延长锁的过期时间。</li>
<li><strong>续期操作</strong>：续期操作实际上就是重新设置锁的过期时间。在Redis中，可以使用<code>PEXPIRE</code>命令（以毫秒为单位）或<code>EXPIRE</code>命令（以秒为单位）来重新设置过期时间。</li>
<li><strong>释放锁时停止续期</strong>：当业务逻辑执行完毕，释放锁的时候，需要同时停止续期线程，以避免不必要的续期操作。</li>
</ol>
<p>需要注意的是，续期操作必须保证原子性，即在检查锁是否仍然由当前客户端持有之后，再执行续期。可以使用Lua脚本来保证原子性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">if</span> set lock_key my_random_value NX PX <span class="number">30000</span>:</span><br><span class="line">    <span class="comment">// 锁获取成功</span></span><br><span class="line">    <span class="comment">// 启动一个看门狗线程，每10秒执行一次续期</span></span><br><span class="line">    watchdog = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (lockIsHeld) &#123;</span><br><span class="line">            sleep(<span class="number">10000</span>); <span class="comment">// 10秒</span></span><br><span class="line">            <span class="comment">// 使用Lua脚本续期：如果锁的值还是my_random_value，则重新设置为30秒</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then &quot;</span> +</span><br><span class="line">                           <span class="string">&quot;return redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]) &quot;</span> +</span><br><span class="line">                           <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                           <span class="string">&quot;return 0 &quot;</span> +</span><br><span class="line">                           <span class="string">&quot;end&quot;</span>;</span><br><span class="line">            redis.eval(script, lock_key, my_random_value, <span class="number">30000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    watchdog.start();</span><br><span class="line">    <span class="comment">// 执行业务逻辑</span></span><br><span class="line">    doBusiness();</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="comment">// 先停止看门狗线程</span></span><br><span class="line">    lockIsHeld = <span class="literal">false</span>;</span><br><span class="line">    watchdog.join();</span><br><span class="line">    <span class="comment">// 然后释放锁，使用Lua脚本来保证原子性</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">releaseScript</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then &quot;</span> +</span><br><span class="line">                           <span class="string">&quot;return redis.call(&#x27;del&#x27;, KEYS[1]) &quot;</span> +</span><br><span class="line">                           <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                           <span class="string">&quot;return 0 &quot;</span> +</span><br><span class="line">                           <span class="string">&quot;end&quot;</span>;</span><br><span class="line">    redis.eval(releaseScript, lock_key, my_random_value);</span><br></pre></td></tr></table></figure>

<p>在实际应用中，可以使用一些成熟的库，例如Redisson，它已经内置了看门狗机制来自动续期。在Redisson中，获取锁后，它会启动一个定时任务来定期续期，直到锁被释放或持有锁的客户端宕机。</p>
<p>使用Redisson的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RedissonClient</span> <span class="variable">redisson</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redisson.getLock(<span class="string">&quot;myLock&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取锁，并设置尝试加锁时间和锁自动释放时间，但是Redisson的看门狗机制会在获取锁成功后自动续期</span></span><br><span class="line">    lock.lock(); <span class="comment">// 默认情况下，看门狗会每30/3=10秒续期一次，将锁的过期时间重置为30秒</span></span><br><span class="line">    <span class="comment">// 执行业务逻辑</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="在-Redis-中绑定-CPU-核"><a href="#在-Redis-中绑定-CPU-核" class="headerlink" title="在 Redis 中绑定 CPU 核"></a>在 Redis 中绑定 CPU 核</h3><p>在 Redis 中绑定 CPU 核（CPU 亲和性）可以通过以下方法实现，以优化性能并减少上下文切换。以下是详细步骤：</p>
<p><strong>方法 1：通过 Redis 配置文件绑定</strong></p>
<p>Redis 从 <strong>6.0 版本</strong>开始支持 <code>server_cpulist</code> 配置项，可直接在配置文件中指定 CPU 核。</p>
<ol>
<li><p><strong>修改 <code>redis.conf</code> 文件</strong>：</p>
<p>bash</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 绑定 Redis 到 CPU 核心 0 和 1（逗号分隔）</span><br><span class="line">server_cpulist 0-1</span><br></pre></td></tr></table></figure>

<ul>
<li>格式支持：<code>0</code>（单个核心）、<code>0-3</code>（范围）、<code>0,2,4</code>（逗号分隔列表）。</li>
</ul>
</li>
<li><p><strong>重启 Redis 生效</strong>：</p>
<p>bash</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /path/to/redis.conf</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>方法 2：使用 <code>taskset</code> 命令绑定</strong></p>
<p>通过 Linux 的 <code>taskset</code> 工具直接绑定 Redis 进程到指定 CPU 核。</p>
<ol>
<li><p><strong>启动 Redis 时绑定</strong>：</p>
<p>bash</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskset -c 0,1 ./redis-server /path/to/redis.conf</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-c 0,1</code> 表示绑定到核心 0 和 1。</li>
</ul>
</li>
<li><p><strong>对已运行的 Redis 进程绑定</strong>：</p>
<p>bash</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskset -cp 0,1 &lt;redis_pid&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>方法 3：通过 Systemd 服务绑定</strong></p>
<p>如果 Redis 以 Systemd 服务运行，可在服务文件中添加 <code>CPUAffinity</code> 配置。</p>
<ol>
<li><p><strong>编辑 Redis 的 systemd 服务文件</strong>：</p>
<p>bash</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl edit redis.service</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>添加 CPU 亲和性配置</strong>：</p>
<p>ini</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">CPUAffinity=0 1</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重启服务生效</strong>：</p>
<p>bash</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart redis</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>方法 4：使用 Cgroups (高级)</strong></p>
<p>通过 Linux 控制组 (<code>cgroups</code>) 精细化控制 CPU 资源。</p>
<ol>
<li><p><strong>创建 cgroup</strong>：</p>
<p>bash</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cgcreate -g cpuset:redis</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>分配 CPU 核心和内存节点</strong>：</p>
<p>bash</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 0-1 &gt; /sys/fs/cgroup/cpuset/redis/cpuset.cpus</span><br><span class="line">echo 0 &gt; /sys/fs/cgroup/cpuset/redis/cpuset.mems</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>启动 Redis 并加入 cgroup</strong>：</p>
<p>bash</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cgexec -g cpuset:redis ./redis-server /path/to/redis.conf</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>验证绑定是否生效</strong></p>
<p>bash</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看 Redis 进程 PID</span><br><span class="line">ps -ef | grep redis-server</span><br><span class="line"></span><br><span class="line"># 检查进程的 CPU 亲和性</span><br><span class="line">taskset -cp &lt;redis_pid&gt;</span><br><span class="line"></span><br><span class="line"># 或查看 /proc 文件系统</span><br><span class="line">cat /proc/&lt;redis_pid&gt;/status | grep Cpus_allowed</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<ol>
<li><p><strong>NUMA 架构</strong>：若服务器有多个 CPU 插槽，建议配合 <code>numactl</code> 工具绑定内存节点。</p>
<p>bash</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numactl --cpunodebind=0 --membind=0 ./redis-server</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>性能测试</strong>：绑定 CPU 可能提升缓存命中率，但需根据实际负载测试效果。</p>
</li>
<li><p><strong>超线程</strong>：物理核与逻辑核（如 <code>0</code> 和 <code>4</code> 可能是同一物理核的超线程）需区分，避免误绑。</p>
</li>
</ol>
<hr>
<p>通过上述方法，可有效将 Redis 实例绑定到指定 CPU 核，优化性能并减少资源争用。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/7ad2e472.html" rel="prev" title="脚本库">
                  <i class="fa fa-angle-left"></i> 脚本库
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/d48132d3.html" rel="next" title="ElasticSearch">
                  ElasticSearch <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa-regular fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder"></span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Word count total">101k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">6:07</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>

  <script class="next-config" data-name="wavedrom" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/wavedrom.min.js","integrity":"sha256-INLAoJc6quTNfiMWkGZniYO2cxE8mHpddnLow1m6RFs="}}</script>
  <script class="next-config" data-name="wavedrom_skin" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/skins/default.js","integrity":"sha256-fduc/Zszk5ezWws2uInY/ALWVmIrmV6VTgXbsYSReFI="}}</script>
  <script src="/js/third-party/tags/wavedrom.js"></script>




  





</body>
</html>
