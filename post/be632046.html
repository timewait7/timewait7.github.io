<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"timewait7.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":true,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="1. 高频面试题RedisRedis为什么快？单线程如何处理高并发？对于Redis的高性能设计，我的理解主要得益于以下几点：  内存操作：Redis数据存储在内存，相比于磁盘数据库，减少了IO开销 高效的数据结构：Redis针对不同场景设计了不同的数据结构，优化了空间和访问效率 单线程：Redis使用单线程处理命令，避免了多线程之间的竞争和上下文切换的开销 IO多路复用：Redis基于epoll&amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题清单">
<meta property="og:url" content="http://timewait7.github.io/post/be632046.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1. 高频面试题RedisRedis为什么快？单线程如何处理高并发？对于Redis的高性能设计，我的理解主要得益于以下几点：  内存操作：Redis数据存储在内存，相比于磁盘数据库，减少了IO开销 高效的数据结构：Redis针对不同场景设计了不同的数据结构，优化了空间和访问效率 单线程：Redis使用单线程处理命令，避免了多线程之间的竞争和上下文切换的开销 IO多路复用：Redis基于epoll&amp;">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/webp/22164601/1726212535664-4bb3f3ff-704a-4706-84c8-a046a8486657.webp?x-oss-process=image/resize,w_1080,limit_0/resize,w_1080,limit_0">
<meta property="og:image" content="http://timewait7.github.io/post/be632046/image-20250302111116621.png">
<meta property="og:image" content="http://timewait7.github.io/post/be632046/image-20250302111551681.png">
<meta property="og:image" content="http://timewait7.github.io/post/be632046/image-20250302112330725.png">
<meta property="article:published_time" content="2025-02-25T15:09:43.000Z">
<meta property="article:modified_time" content="2025-03-02T11:57:32.646Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2024/webp/22164601/1726212535664-4bb3f3ff-704a-4706-84c8-a046a8486657.webp?x-oss-process=image/resize,w_1080,limit_0/resize,w_1080,limit_0">


<link rel="canonical" href="http://timewait7.github.io/post/be632046.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://timewait7.github.io/post/be632046.html","path":"post/be632046.html","title":"面试题清单"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>面试题清单 | Hexo</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-archives"><a href="/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="Searching..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">1. 高频面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis"><span class="nav-number">1.1.</span> <span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB%EF%BC%9F%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E9%AB%98%E5%B9%B6%E5%8F%91%EF%BC%9F"><span class="nav-number">1.1.1.</span> <span class="nav-text">Redis为什么快？单线程如何处理高并发？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E5%88%86%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="nav-number">1.1.2.</span> <span class="nav-text">Redis有哪些数据结构，分别有哪些使用场景场景？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-%E9%9B%AA%E5%B4%A9-%E5%87%BB%E7%A9%BF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.1.3.</span> <span class="nav-text">缓存穿透&#x2F;雪崩&#x2F;击穿解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RDB%E5%92%8CAOF%E6%8C%81%E4%B9%85%E5%8C%96%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8A%A3%E5%AF%B9%E6%AF%94"><span class="nav-number">1.1.4.</span> <span class="nav-text">RDB和AOF持久化原理及优劣对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-Sentinel-Cluster%EF%BC%89"><span class="nav-number">1.1.5.</span> <span class="nav-text">Redis集群模式（主从复制&#x2F;Sentinel&#x2F;Cluster）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%83%ADKey%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88"><span class="nav-number">1.1.6.</span> <span class="nav-text">热Key问题处理方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E4%BA%8B%E5%8A%A1%E4%B8%8EMySQL%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.7.</span> <span class="nav-text">Redis事务与MySQL事务的核心区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E6%BC%94%E8%BF%9B%E8%BF%87%E7%A8%8B"><span class="nav-number">1.1.8.</span> <span class="nav-text">使用Redis实现分布式锁的演进过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5%E5%92%8C%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.9.</span> <span class="nav-text">全量同步和增量同步的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ZSet%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%88%E8%B7%B3%E8%A1%A8-%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89"><span class="nav-number">1.1.10.</span> <span class="nav-text">ZSet底层实现（跳表+哈希表）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E4%B8%8ELRU%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.1.11.</span> <span class="nav-text">内存淘汰策略与LRU实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Pipeline%E5%92%8CLua%E8%84%9A%E6%9C%AC%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.1.12.</span> <span class="nav-text">Pipeline和Lua脚本的使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%A7Key%E9%97%AE%E9%A2%98%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88"><span class="nav-number">1.1.13.</span> <span class="nav-text">大Key问题检测与处理方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis6%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.1.14.</span> <span class="nav-text">Redis6多线程模型实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E5%92%8CMySQL%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.15.</span> <span class="nav-text">Redis和MySQL的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E5%92%8Cmemchahed%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.16.</span> <span class="nav-text">Redis和memchahed的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL"><span class="nav-number">1.2.</span> <span class="nav-text">MySQL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.2.1.</span> <span class="nav-text">查询语句的执行顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#InnoDB%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.2.</span> <span class="nav-text">InnoDB索引结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88MongoDB%E4%BD%BF%E7%94%A8B%E6%A0%91%E8%80%8CMySQL%E7%94%A8B-%E6%A0%91"><span class="nav-number">1.2.3.</span> <span class="nav-text">为什么MongoDB使用B树而MySQL用B+树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E6%A0%91%E8%8A%82%E7%82%B9%E5%88%86%E8%A3%82%E7%9A%84%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B"><span class="nav-number">1.2.4.</span> <span class="nav-text">B+树节点分裂的具体过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EXPLAIN-%E5%AD%97%E6%AE%B5%E8%AF%B4%E6%98%8E"><span class="nav-number">1.2.5.</span> <span class="nav-text">EXPLAIN 字段说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B"><span class="nav-number">1.2.6.</span> <span class="nav-text">覆盖索引与最左前缀原则实战案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88InnoDB%E4%B8%8D%E4%BF%9D%E5%AD%98%E8%A1%A8%E7%9A%84%E6%80%BB%E8%A1%8C%E6%95%B0"><span class="nav-number">1.2.7.</span> <span class="nav-text">为什么InnoDB不保存表的总行数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7%E5%92%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">1.2.8.</span> <span class="nav-text">解释一下事务的基本特性和隔离级别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#InnoDB%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB"><span class="nav-number">1.2.9.</span> <span class="nav-text">InnoDB如何解决幻读</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#InnoDB%E5%92%8CMyISAM%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.10.</span> <span class="nav-text">InnoDB和MyISAM的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E7%B4%A2%E5%BC%95%E4%BC%9A%E5%A4%B1%E6%95%88%E6%88%96%E9%80%89%E9%94%99%E7%B4%A2%E5%BC%95"><span class="nav-number">1.2.11.</span> <span class="nav-text">为什么有时索引会失效或选错索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.2.12.</span> <span class="nav-text">如何优化查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E5%8F%AA%E6%9F%A5%E8%AF%A2%E4%B8%80%E8%A1%8C%E4%BD%86%E6%98%AF%E5%BE%88%E6%85%A2"><span class="nav-number">1.2.13.</span> <span class="nav-text">为什么有时只查询一行但是很慢</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM"><span class="nav-number">1.3.</span> <span class="nav-text">JVM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="nav-number">1.4.</span> <span class="nav-text">并发编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring"><span class="nav-number">1.5.</span> <span class="nav-text">Spring</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="nav-number">1.6.</span> <span class="nav-text">微服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.7.</span> <span class="nav-text">分布式系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">1.8.</span> <span class="nav-text">消息队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RPC"><span class="nav-number">1.9.</span> <span class="nav-text">RPC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E5%85%85"><span class="nav-number">1.10.</span> <span class="nav-text">补充</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%85%B3%E9%94%AE%E5%87%86%E5%A4%87%E5%BB%BA%E8%AE%AE"><span class="nav-number">2.</span> <span class="nav-text">2. 关键准备建议</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/">
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="Back to top">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://timewait7.github.io/post/be632046.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="面试题清单 | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试题清单
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-02-25 23:09:43" itemprop="dateCreated datePublished" datetime="2025-02-25T23:09:43+08:00">2025-02-25</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>6.5k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>24 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="1-高频面试题"><a href="#1-高频面试题" class="headerlink" title="1. 高频面试题"></a>1. 高频面试题</h2><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="Redis为什么快？单线程如何处理高并发？"><a href="#Redis为什么快？单线程如何处理高并发？" class="headerlink" title="Redis为什么快？单线程如何处理高并发？"></a>Redis为什么快？单线程如何处理高并发？</h4><p>对于Redis的高性能设计，我的理解主要得益于以下几点：</p>
<ul>
<li>内存操作：Redis数据存储在内存，相比于磁盘数据库，减少了IO开销</li>
<li>高效的数据结构：Redis针对不同场景设计了不同的数据结构，优化了空间和访问效率</li>
<li>单线程：Redis使用单线程处理命令，避免了多线程之间的竞争和上下文切换的开销</li>
<li>IO多路复用：Redis基于epoll&#x2F;kqueue实现了非阻塞的网络模型，通过事件机制循环处理请求</li>
</ul>
<p><strong>追问1：单线程如何利用多核CPU</strong></p>
<p>可以部署分片集群，每个Redis实例绑定一个CPU核（&#x3D;&#x3D;如何部署和绑定？&#x3D;&#x3D;）</p>
<p><strong>追问2：为什么选用单线程而不是多线程</strong></p>
<ul>
<li>避免锁竞争</li>
<li>避免上下文切换开销</li>
<li>多线程内存管理复杂</li>
</ul>
<p><strong>追问3： 什么场景下单线程会成为瓶颈</strong></p>
<ul>
<li>超大 Value 操作（如10MB的string）（&#x3D;&#x3D;什么操作，普通读写就会阻塞吗&#x3D;&#x3D;）</li>
<li>复杂 Lua 脚本执行（阻塞其他命令）</li>
</ul>
<hr>
<h4 id="Redis有哪些数据结构，分别有哪些使用场景场景？"><a href="#Redis有哪些数据结构，分别有哪些使用场景场景？" class="headerlink" title="Redis有哪些数据结构，分别有哪些使用场景场景？"></a>Redis有哪些数据结构，分别有哪些使用场景场景？</h4><p>Redis的基础数据结构包括string、hash、list、set、zset，高级数据结构包括hyperloglog、geo、bitmap、stream</p>
<hr>
<h4 id="缓存穿透-雪崩-击穿解决方案"><a href="#缓存穿透-雪崩-击穿解决方案" class="headerlink" title="缓存穿透&#x2F;雪崩&#x2F;击穿解决方案"></a>缓存穿透&#x2F;雪崩&#x2F;击穿解决方案</h4><p><strong>缓存穿透</strong>是指查询数据库中不存在的数据，导致请求每次都穿过缓存查询数据库。</p>
<p>解决方案：</p>
<ul>
<li><strong>布隆过滤器（Bloom Filter）</strong></li>
</ul>
<p>服务启动时加载全量有效key，标记数据是否存在；新增数据时同步更新过滤器</p>
<p>缺点：存在一定的误判率</p>
<ul>
<li><strong>缓存空值</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getData</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> redis.get(key);</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> NullValue) &#123; <span class="comment">// 空值标记</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    value = db.query(key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        redis.setex(key, <span class="number">300</span>, <span class="keyword">new</span> <span class="title class_">NullValue</span>()); <span class="comment">// 缓存空值5分钟</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redis.setex(key, <span class="number">3600</span>, value); <span class="comment">// 正常缓存1小时</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>缓存雪崩</strong>是指<strong>大量key</strong>同时失效，导致大量请求都去查询数据库，造成数据库压力骤增。</p>
<p>解决方案：</p>
<ul>
<li><strong>差异化过期时间</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基础过期时间，1小时</span></span><br><span class="line"><span class="type">int</span> <span class="variable">baseExpire</span> <span class="operator">=</span> <span class="number">3600</span>;</span><br><span class="line"><span class="comment">// 随机0-5分钟</span></span><br><span class="line"><span class="type">int</span> <span class="variable">randomExpire</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">300</span>);</span><br><span class="line">redis.setex(key, baseExpire + randomExpire, value);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>永不过期+异步更新</strong></li>
</ul>
<p><strong>缓存击穿</strong>是指某个<strong>热点key</strong>失效的瞬间，有大量请求同时访问这个key，导致所有请求都去查询数据库。</p>
<p>解决方案：</p>
<ul>
<li><strong>互斥锁</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> Redission.getLock(<span class="string">&quot;PREFIX:&quot;</span> + key);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lock.tryLock(<span class="number">3</span>, <span class="number">30</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">        <span class="comment">// 查库并重建缓存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>逻辑过期</strong></li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;真实数据&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;expire_ts&quot;</span><span class="punctuation">:</span> <span class="number">1672502400</span> <span class="comment">// 逻辑过期时间戳</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>处理流程：</p>
<ol>
<li>判断逻辑过期时间<ol>
<li>未过期，直接返回数据</li>
<li>已过期，创建子线程，异步重建缓存</li>
</ol>
</li>
</ol>
<hr>
<h4 id="RDB和AOF持久化原理及优劣对比"><a href="#RDB和AOF持久化原理及优劣对比" class="headerlink" title="RDB和AOF持久化原理及优劣对比"></a>RDB和AOF持久化原理及优劣对比</h4><h4 id="Redis集群模式（主从复制-Sentinel-Cluster）"><a href="#Redis集群模式（主从复制-Sentinel-Cluster）" class="headerlink" title="Redis集群模式（主从复制&#x2F;Sentinel&#x2F;Cluster）"></a>Redis集群模式（主从复制&#x2F;Sentinel&#x2F;Cluster）</h4><h4 id="热Key问题处理方案"><a href="#热Key问题处理方案" class="headerlink" title="热Key问题处理方案"></a>热Key问题处理方案</h4><h4 id="Redis事务与MySQL事务的核心区别"><a href="#Redis事务与MySQL事务的核心区别" class="headerlink" title="Redis事务与MySQL事务的核心区别"></a>Redis事务与MySQL事务的核心区别</h4><h4 id="使用Redis实现分布式锁的演进过程"><a href="#使用Redis实现分布式锁的演进过程" class="headerlink" title="使用Redis实现分布式锁的演进过程"></a>使用Redis实现分布式锁的演进过程</h4><h4 id="全量同步和增量同步的区别"><a href="#全量同步和增量同步的区别" class="headerlink" title="全量同步和增量同步的区别"></a>全量同步和增量同步的区别</h4><p>全量同步：master生成当前内存中所有数据的RDB文件，将RDB发送给slave。在此过程中，master将新的命令记录在<code>repl_backlog</code>中，后续再发送给slave。</p>
<p>执行时机：</p>
<ol>
<li>slave第一次连接到master</li>
<li>slave宕机太久，导致它在<code>repl_backlog</code>中的<code>offset</code>已经被覆盖掉了</li>
</ol>
<p>增量同步：salve将自己的<code>offset</code>发送到master，master将<code>repl_backlog</code>中<code>offset</code>之后的命令发送给slave</p>
<p>执行时机：</p>
<ol>
<li>slave断开重连之后，<code>repl_backlog</code>中的<code>offset</code>尚未被覆盖</li>
</ol>
<h4 id="ZSet底层实现（跳表-哈希表）"><a href="#ZSet底层实现（跳表-哈希表）" class="headerlink" title="ZSet底层实现（跳表+哈希表）"></a>ZSet底层实现（跳表+哈希表）</h4><h4 id="内存淘汰策略与LRU实现"><a href="#内存淘汰策略与LRU实现" class="headerlink" title="内存淘汰策略与LRU实现"></a>内存淘汰策略与LRU实现</h4><h4 id="Pipeline和Lua脚本的使用场景"><a href="#Pipeline和Lua脚本的使用场景" class="headerlink" title="Pipeline和Lua脚本的使用场景"></a>Pipeline和Lua脚本的使用场景</h4><h4 id="大Key问题检测与处理方案"><a href="#大Key问题检测与处理方案" class="headerlink" title="大Key问题检测与处理方案"></a>大Key问题检测与处理方案</h4><h4 id="Redis6多线程模型实现原理"><a href="#Redis6多线程模型实现原理" class="headerlink" title="Redis6多线程模型实现原理"></a>Redis6多线程模型实现原理</h4><h4 id="Redis和MySQL的区别"><a href="#Redis和MySQL的区别" class="headerlink" title="Redis和MySQL的区别"></a>Redis和MySQL的区别</h4><table>
<thead>
<tr>
<th></th>
<th>Redis</th>
<th>MySQL</th>
</tr>
</thead>
<tbody><tr>
<td>数据结构</td>
<td>非结构化</td>
<td>结构化</td>
</tr>
<tr>
<td>持久化</td>
<td>可选持久化</td>
<td>默认持久化</td>
</tr>
<tr>
<td>事务支持</td>
<td>简单支持</td>
<td>支持完整的ACID</td>
</tr>
<tr>
<td>扩展性</td>
<td>通过分片水平扩展</td>
<td>复杂，需分库分表或中间件</td>
</tr>
<tr>
<td>数据一致性</td>
<td>最终一致性</td>
<td>强一致性</td>
</tr>
</tbody></table>
<p>总结：</p>
<ul>
<li>当需要复杂查询和事务支持，对数据一致性要求较高，需要长期持久化存储的场景，选择MySQL</li>
<li>当需要超高性能和灵活数据类型，对数据的一致性要求不那么高，且容忍一定的数据丢失的情况下，选择Redis</li>
</ul>
<h4 id="Redis和memchahed的区别"><a href="#Redis和memchahed的区别" class="headerlink" title="Redis和memchahed的区别"></a>Redis和memchahed的区别</h4><table>
<thead>
<tr>
<th></th>
<th>Redis</th>
<th>Memcached</th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>丰富的数据类型：string、hash、list等</td>
<td>只支持string</td>
</tr>
<tr>
<td>持久化</td>
<td>支持（RDB、AOF）</td>
<td>不支持</td>
</tr>
<tr>
<td>事务</td>
<td>简单支持（MULTI&#x2F;EXEC）</td>
<td>不支持</td>
</tr>
<tr>
<td>分布式</td>
<td>支持，集群自动分片</td>
<td>依赖客户端一致性哈希或第三方工具实现分布式</td>
</tr>
<tr>
<td>命令</td>
<td>支持丰富的命令</td>
<td>仅支持SET、GET、ADD、DELTE等基础操作</td>
</tr>
<tr>
<td>内存占用</td>
<td>复杂数据结构可能导致内存消耗较高</td>
<td>内存利用率高，但灵活性较低</td>
</tr>
</tbody></table>
<p>总结：</p>
<ul>
<li>需要复杂数据结构、持久化、事务支持和高可用性的场景，选择Redis</li>
<li>追求极致的性能和简单性，数据结构简单且无需持久化的场景，可以选择Memcached</li>
</ul>
<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h4 id="查询语句的执行顺序"><a href="#查询语句的执行顺序" class="headerlink" title="查询语句的执行顺序"></a>查询语句的执行顺序</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/webp/22164601/1726212535664-4bb3f3ff-704a-4706-84c8-a046a8486657.webp?x-oss-process=image/resize,w_1080,limit_0/resize,w_1080,limit_0" alt="img"></p>
<hr>
<h4 id="InnoDB索引结构"><a href="#InnoDB索引结构" class="headerlink" title="InnoDB索引结构"></a>InnoDB索引结构</h4><p>B树结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">       [10 | 20]</span><br><span class="line">      /    |     \</span><br><span class="line">[5|8]  [12|15|18]  [25|30]</span><br></pre></td></tr></table></figure>

<p>特征：</p>
<ul>
<li>所有节点都存储完整数据</li>
<li>每个节点最多包涵 m-1 个键值和 m 个子节点</li>
</ul>
<p>B+树结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">               [15]</span><br><span class="line">              /    \</span><br><span class="line">     [10|15]          [20|25]</span><br><span class="line">     /     \          /     \ </span><br><span class="line">[10|...]→[15|...]→[20|...]→[25|...]（叶子节点链表）</span><br></pre></td></tr></table></figure>

<p>特征：</p>
<ul>
<li>只有叶子节点存储完整数据，内部节点只存储索引</li>
<li>叶子节点通过双向链表连接，支持高效范围查询</li>
<li>相同磁盘页可以存储更多索引，提高查询效率</li>
</ul>
<p><strong>InnoDB选择B+树的7大关键原因</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>对比维度</strong></th>
<th align="left"><strong>B树</strong></th>
<th align="left"><strong>B+树</strong></th>
<th align="left"><strong>InnoDB优势体现</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>数据存储位置</strong></td>
<td align="left">所有节点存储数据</td>
<td align="left">仅叶子节点存储数据</td>
<td align="left">减少磁盘IO次数</td>
</tr>
<tr>
<td align="left"><strong>树高度</strong></td>
<td align="left">较高（数据分散存储）</td>
<td align="left">较低（内部节点纯索引）</td>
<td align="left">3层B+树可支撑千万级数据</td>
</tr>
<tr>
<td align="left"><strong>范围查询</strong></td>
<td align="left">需要回溯父节点</td>
<td align="left">通过叶子链表顺序扫描</td>
<td align="left"><code>WHERE id &gt; 100</code> 效率提升10倍+</td>
</tr>
<tr>
<td align="left"><strong>全表扫描</strong></td>
<td align="left">需遍历整棵树</td>
<td align="left">直接顺序遍历叶子节点链表</td>
<td align="left">全表扫描速度接近顺序读</td>
</tr>
<tr>
<td align="left"><strong>磁盘利用率</strong></td>
<td align="left">节点包含数据导致存储键值数少</td>
<td align="left">单页可存储更多键值（高分支因子）</td>
<td align="left">相同数据量减少30%-50%树高度</td>
</tr>
<tr>
<td align="left"><strong>数据更新代价</strong></td>
<td align="left">可能引起复杂结构调整</td>
<td align="left">插入删除多数情况只需局部调整</td>
<td align="left">支持更高并发写入</td>
</tr>
<tr>
<td align="left"><strong>缓存命中率</strong></td>
<td align="left">热点数据分散在不同层级</td>
<td align="left">叶子节点集中存储所有数据</td>
<td align="left">Buffer Pool利用率提升40%+</td>
</tr>
</tbody></table>
<h4 id="为什么MongoDB使用B树而MySQL用B-树"><a href="#为什么MongoDB使用B树而MySQL用B-树" class="headerlink" title="为什么MongoDB使用B树而MySQL用B+树"></a>为什么MongoDB使用B树而MySQL用B+树</h4><p>MongoDB面向文档存储，需快速获取整个文档（B树的内部节点存储完整数据，可以减少寻址次数）</p>
<p>MySQL侧重范围查询和事务处理（B+树的顺序访问特性更优秀）</p>
<h4 id="B-树节点分裂的具体过程"><a href="#B-树节点分裂的具体过程" class="headerlink" title="B+树节点分裂的具体过程"></a>B+树节点分裂的具体过程</h4><p>InnoDB优化：预留1&#x2F;16页空间避免频繁分裂</p>
<p><strong>索引设计原则</strong></p>
<ul>
<li>前缀索引优化</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> <span class="keyword">ADD</span> INDEX (name(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>覆盖索引优化</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建包含所有查询字段的索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_cover <span class="keyword">ON</span> orders(user_id, status, create_time);</span><br></pre></td></tr></table></figure>



<p><strong>监控工具使用</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看索引使用情况</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.schema_index_statistics;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分析索引效率</span></span><br><span class="line">EXPLAIN ANALYZE <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> category_id<span class="operator">=</span><span class="number">5</span>;</span><br></pre></td></tr></table></figure>



<p><strong>维护策略</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 定期优化表（重建索引）</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 监控页分裂次数</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Innodb_page_splits%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="EXPLAIN-字段说明"><a href="#EXPLAIN-字段说明" class="headerlink" title="EXPLAIN 字段说明"></a><code>EXPLAIN</code> 字段说明</h4><p>通常<code>EXPALIN</code>查询语句的输出如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="comment">// 每个select语句对应一个唯一的id</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询类型：</span></span><br><span class="line"><span class="comment">     * SIMPLE：不包含UNION或子查询的select（连接查询的每个查询都是simple查询）</span></span><br><span class="line"><span class="comment">     * PRIMARY：最外层查询</span></span><br><span class="line"><span class="comment">     * UNION</span></span><br><span class="line"><span class="comment">     * ...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="attr">&quot;select_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SIMPLE&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;users&quot;</span><span class="punctuation">,</span> <span class="comment">// 要查询的表</span></span><br><span class="line">    <span class="attr">&quot;partitions&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span> <span class="comment">// 分区信息</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 针对单表的访问方法：</span></span><br><span class="line"><span class="comment">     * system：当表中只有一条记录，并且该表使用的存储引擎的统计数据是精确的，访问方法就是system</span></span><br><span class="line"><span class="comment">     * constant：根据主键或唯一索引列与常数进行等值匹配时，访问方法就是const</span></span><br><span class="line"><span class="comment">     * eq_ref：连接查询中对被驱动表的主键或不允许为NULL的唯一索引进行等值查询时，访问方法就是eq_ref</span></span><br><span class="line"><span class="comment">     * ref：通过普通二级索引列与常量进行等值匹配时，对该表的访问方法就是 ref</span></span><br><span class="line"><span class="comment">     * ref_or_null：select * from single_table where key1 = &#x27;abc&#x27; or key1 is NULL;</span></span><br><span class="line"><span class="comment">     * index_merge：使用多个索引进行等值匹配</span></span><br><span class="line"><span class="comment">     * unique_subquery：在子查询中使用主键或不允许存储NULL值的唯一二级索引进行等值匹配</span></span><br><span class="line"><span class="comment">     * index_subquery：在子查询中使用普通二级索引进行等值匹</span></span><br><span class="line"><span class="comment">     * range：利用索引进行范围查询</span></span><br><span class="line"><span class="comment">     * index：当可以使用索引覆盖，但需要扫描全部索引记录</span></span><br><span class="line"><span class="comment">     * all：全表扫描</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ref&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;possible_keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;idx_composite&quot;</span><span class="punctuation">,</span> <span class="comment">// 可能使用的索引</span></span><br><span class="line">    <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;idx_composite&quot;</span><span class="punctuation">,</span> <span class="comment">// 实际使用的索引</span></span><br><span class="line">    <span class="attr">&quot;key_len&quot;</span><span class="punctuation">:</span> <span class="string">&quot;208&quot;</span><span class="punctuation">,</span> <span class="comment">// 实际使用的索引长度</span></span><br><span class="line">    <span class="attr">&quot;ref&quot;</span><span class="punctuation">:</span> <span class="string">&quot;const&quot;</span><span class="punctuation">,</span> <span class="comment">// 使用索引列等值查询时，与索引列进行等值匹配的对象信息</span></span><br><span class="line">    <span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="comment">// 预估需要读取的记录行数</span></span><br><span class="line">    <span class="attr">&quot;filtered&quot;</span><span class="punctuation">:</span> <span class="number">100.0</span><span class="punctuation">,</span> <span class="comment">// 过滤后剩余记录行数百分比</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 额外信息：</span></span><br><span class="line"><span class="comment">     * Using index：使用覆盖索引</span></span><br><span class="line"><span class="comment">     * Using index condition：使用索引条件下推</span></span><br><span class="line"><span class="comment">     * Using where：需要在server层判断条件是否成立</span></span><br><span class="line"><span class="comment">     * Using join buffer：执行连接查询时，被驱动表不能有效利用索引加快访问速度时，会分配一块内存用来保存驱动表的查询结果，</span></span><br><span class="line"><span class="comment">     					  利用join buffer可以减少访问被驱动表的次数</span></span><br><span class="line"><span class="comment">     * Using filesort：</span></span><br><span class="line"><span class="comment">     * Using temporary</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="attr">&quot;Extra&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Using index&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="覆盖索引与最左前缀原则实战案例"><a href="#覆盖索引与最左前缀原则实战案例" class="headerlink" title="覆盖索引与最左前缀原则实战案例"></a>覆盖索引与最左前缀原则实战案例</h4><p><strong>回表</strong>：查询需要的字段没有全表包含在索引中，需要根据索引找到主键，再从主键索引中找到数据才能获取所需字段。</p>
<p><strong>覆盖索引</strong>：查询所需的字段都包含在索引中，无需回表操作。</p>
<p>优点：</p>
<ul>
<li>减少IO操作</li>
<li>避免回表（减少随机读）</li>
</ul>
<p><strong>最左前缀原则</strong>：复合索引 <code>(a, b, c)</code> 的查询条件必须从最左列开始，且不能跳过中间列才能命中索引。</p>
<p>具体规则：</p>
<ul>
<li>等值查询：<code>WHERE a = 1 and b = 2</code> → 命中索引</li>
<li>范围查询：<code>WHERE a &gt; 1 and b = 2</code> → 仅能命中 <code>a</code> 列</li>
<li>跳跃查询：<code>WHERE b = 2 and c = 3</code> → 不能能命中索引</li>
</ul>
<p>覆盖索引优化：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `users` (</span><br><span class="line">	`id` <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">	`name` <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">	`age` <span class="type">INT</span>,</span><br><span class="line">	`city` <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">	`created_at` DATETIME,</span><br><span class="line">	KEY `idx_composite` (`city`, `age`, `created_at`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>

<p>查询需求：统计北京25岁用户的数量</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> city<span class="operator">=</span><span class="string">&#x27;北京&#x27;</span> <span class="keyword">AND</span> age<span class="operator">=</span><span class="number">25</span>;</span><br></pre></td></tr></table></figure>

<img src="/post/be632046/image-20250302111116621.png" class="" title="image-20250302111116621">

<p>之前的版本<code>Extra</code>中应该是<code>Using where</code>，因为需要回表确认数据是否存在。</p>
<p>优化方案：添加覆盖索引覆盖统计需要的所有字段</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> users <span class="keyword">ADD</span> INDEX idx_covering(city, age, id);</span><br></pre></td></tr></table></figure>

<p>最左前缀索引优化</p>
<p>查询需求：查询北京地区年龄大于 30 岁的用户，并按注册时间排序</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> city<span class="operator">=</span><span class="string">&#x27;北京&#x27;</span> <span class="keyword">AND</span> age<span class="operator">&gt;</span> <span class="number">30</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> created_at LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<img src="/post/be632046/image-20250302111551681.png" class="" title="image-20250302111551681">

<p>从<code>EXPLAIN</code>结果可以看出，这条查询语句需要用到耗时的文件排序，这是因为查询条件中存在范围查询，导致不能完全利用上组合索引。</p>
<p>优化方案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> users <span class="keyword">ADD</span> INDEX idx_city_created_age(city, created_at, age);</span><br></pre></td></tr></table></figure>

<img src="/post/be632046/image-20250302112330725.png" class="" title="image-20250302112330725">



<p>索引设计规范：</p>
<ul>
<li>组合索引字段按区分度从高到低排序</li>
<li>索引列数≤5列，避免更新开销太大</li>
<li>禁止<code>SELECT *</code>，尽量查询索引能覆盖的字段</li>
</ul>
<p>慢查询优化流程：</p>
<ol>
<li>抓取慢日志：<code>long_query_time=1s</code></li>
<li><code>EXPLAIN</code> 分析执行计划</li>
<li>检查索引使用情况<ul>
<li>是否触发覆盖索引</li>
<li>是否违反最左前缀原则</li>
</ul>
</li>
<li>使用<code>force index</code>验证索引有效性</li>
<li>调整索引或SQL写法</li>
</ol>
<p>监控指标</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看索引使用频率</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.schema_index_statistics <span class="keyword">WHERE</span> table_name<span class="operator">=</span><span class="string">&#x27;users&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检查冗余索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.schema_redundant_indexes;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="为什么InnoDB不保存表的总行数"><a href="#为什么InnoDB不保存表的总行数" class="headerlink" title="为什么InnoDB不保存表的总行数"></a>为什么InnoDB不保存表的总行数</h4><p>与MyISAM保存表的总行数不同，InnoDB统计行数需要扫描全表，因为MVCC，同一时刻多个查询返回的行数可能不一致。</p>
<p>对于需要经常统计表的行数的解决办法：</p>
<ul>
<li>在缓存（如 Redis）中保存计数</li>
<li>在 MySQL 中保存计数</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>count(*)</code></td>
<td>对于满足条件的数据行按行累加</td>
</tr>
<tr>
<td><code>count(1)</code></td>
<td>对于满足条件的每一行，放一个 1 进去，按行累加</td>
</tr>
<tr>
<td><code>count(主键)</code></td>
<td>对于满足条件的每一行，取出主键，判断非 null，按行累加</td>
</tr>
<tr>
<td><code>count(字段)</code></td>
<td>对于满足条件的每一行，取出字段，判断非 null，按行累加</td>
</tr>
</tbody></table>
<p>性能：<code>count(字段)</code> &lt; <code>count(主键)</code> &lt; <code>count(1)</code> ≈ <code>count(*)</code></p>
<p><code>count(主键/字段)</code> 的效率更低的原因是需要解析数据行，并拷贝要返回的字段值。</p>
<hr>
<h4 id="解释一下事务的基本特性和隔离级别"><a href="#解释一下事务的基本特性和隔离级别" class="headerlink" title="解释一下事务的基本特性和隔离级别"></a>解释一下事务的基本特性和隔离级别</h4><p>事务保证一组操作要么全部成功，要么全部失败。在 MySQL 中，事务支持是在引擎层实现的。</p>
<table>
<thead>
<tr>
<th>基本特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>原子性（<code>atomicity</code>）</td>
<td>事务中的操作要么全都执行，要么都不执行</td>
</tr>
<tr>
<td>一致性（<code>consistency</code>）</td>
<td>事务的执行要保证数据的完整性和一致性</td>
</tr>
<tr>
<td>隔离性（<code>isolation</code>）</td>
<td>事务的执行互不干扰</td>
</tr>
<tr>
<td>持久性（<code>durability</code>）</td>
<td>事务一旦提交，对数据的修改就永久保存到数据库中，不可撤销</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>事务可能引发的问题</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>脏读</td>
<td>A 事务读取 B 事务尚未提交的修改</td>
</tr>
<tr>
<td>不可重复读</td>
<td>A 事务多次读取同一数据，结果前后不一致</td>
</tr>
<tr>
<td>幻读</td>
<td>A 事务多次读取，数据总量前后不一致</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>说明</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td><code>read uncommitted</code></td>
<td>一个事务执行过程中，能看到其他未提交事务做的变更</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td><code>read committed</code></td>
<td>一个事务执行过程中，能看到其他已提交事务做的变更（MySQL 会在每个 SQL 语句开始执行时创建一个视图）</td>
<td></td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td><code>repeatable read</code></td>
<td>一个事务执行过程中，其他事务的变更对它不可见（MySQL 会在事务启动时创建一个视图，整个事务执行期间都使用这个视图）</td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td><code>serializable</code></td>
<td>事务串行执行，隔离级别最高，不会出现上面所说的问题，但相应的效率也最低</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
<h4 id="InnoDB如何解决幻读"><a href="#InnoDB如何解决幻读" class="headerlink" title="InnoDB如何解决幻读"></a>InnoDB如何解决幻读</h4><p>InnoDB解决幻读主要靠以下三大核心机制：</p>
<ul>
<li>多版本并发控制（<code>MVCC</code>）</li>
<li>间隙锁（<code>Gap Lock</code>）</li>
<li>临键锁（<code>Next-Key Lock</code>）</li>
</ul>
<p><strong><code>MVCC</code>实现原理：</strong></p>
<ul>
<li><code>Undo log</code>：每条数据维护多个历史版本</li>
<li><code>ReadView</code>：快照</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ReadView结构：</span><br><span class="line">&#123;</span><br><span class="line">  creator_trx_id: 150,      -- 当前事务ID</span><br><span class="line">  m_ids: [100, 120, 140],   -- 活跃事务ID列表</span><br><span class="line">  min_trx_id: 100,          -- 最小活跃事务ID</span><br><span class="line">  max_trx_id: 150           -- 预分配最大事务ID</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可见性判断规则</strong>：</p>
<ol>
<li>数据版本<code>trx_id</code> &lt; <code>min_trx_id</code> → 可见</li>
<li><code>trx_id</code>在<code>m_ids</code>中 → 不可见</li>
<li><code>trx_id</code> &gt;&#x3D; <code>max_trx_id</code> → 不可见</li>
</ol>
<p>InnoDB默认会为每行数据生成两个隐藏列：</p>
<ul>
<li><code>DB_TRX_ID</code>：最后修改该行的事务ID</li>
<li><code>DB_ROLL_PTR</code>：指向<code>Undo Log</code>的回滚指针</li>
</ul>
<p>不同隔离级别下<code>ReadView</code>的生成时机：</p>
<ul>
<li><code>READ COMMITTED(RC)</code>：每次<code>SELECT</code>都会创建新的<code>ReadView</code></li>
<li><code>REPEATABLE READ(RR)</code>：事务中第一次<code>SELECT</code>时创建<code>ReadView</code></li>
</ul>
<p><strong>间隙锁（<code>Gap Lock</code>）</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 表数据：5, 10, 15</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">10</span> <span class="keyword">AND</span> id <span class="operator">&lt;</span> <span class="number">20</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>这条语句会锁定区间 <code>(10, 15)</code>、<code>(15, +∞)</code>，在事务执行期间，其他事务无法在这两个区间插入数据</p>
<p><strong>临键锁（<code>Next-Key Lock</code>）</strong></p>
<p><strong>Q1：RR隔离级别如何既使用MVCC又用锁？</strong></p>
<ul>
<li><strong>快照读</strong>（普通SELECT）：依赖MVCC保证一致性</li>
<li><strong>当前读</strong>（SELECT FOR UPDATE）：使用临键锁保证物理数据一致</li>
</ul>
<p><strong>Q2：Gap Lock是否会导致死锁？</strong></p>
<p>间隙锁是有可能导致死锁的，如：事务A锁(5,10)，事务B锁(10,15)，两者同时请求对方区间的插入</p>
<p>解决方案：设置<code>innodb_deadlock_detect=ON</code>（默认开启检测）</p>
<p><strong>Q3：Purge线程的作用是什么？</strong></p>
<p>清理不再被任何事务需要的<code>Undo Log</code>，回收版本链中的过期数据版本</p>
<hr>
<h4 id="InnoDB和MyISAM的区别"><a href="#InnoDB和MyISAM的区别" class="headerlink" title="InnoDB和MyISAM的区别"></a>InnoDB和MyISAM的区别</h4><ol>
<li>数据的存储方式：MyISAM使用表级锁，而InnoDB使用行级锁。这意味着，在并发访问的情况下，InnoDB的并发性能更好。</li>
<li>事务支持：MyISAM不支持事务，而InnoDB支持事务，可以保证数据的一致性和完整性。</li>
<li>索引结构：MyISAM使用B树索引，而InnoDB使用B+树索引。B+树索引相对于B树索引，可以支持更快的范围查询和排序。</li>
<li>外键约束：MyISAM不支持外键约束，而InnoDB支持外键约束。</li>
<li>全文检索：MyISAM支持全文检索，而InnoDB不支持。</li>
<li>表空间管理：MyISAM每张表保存为三个文件（.frm、.MYD、.MYI），而InnoDB每张表只保存为一个文件。</li>
<li>内存和CPU的使用：MyISAM更注重查询的速度，因此会使用更多的内存和CPU资源，而InnoDB更注重事务的处理，因此会使用更多的磁盘I&#x2F;O资源。</li>
</ol>
<p>总体来说，如果需要支持事务、外键约束和高并发访问，那么InnoDB是更好的选择。如果需要进行全文检索，那么MyISAM是更好的选择。但是需要注意的是，MySQL 5.5版本之后，InnoDB已经支持了全文检索。</p>
<p><font color="red">为什么InnoDB不保存表行数？</font></p>
<p>InnoDB有个多版本并发控制的概念，这会导致不同的事务查询表的行数会获得不同的结果，因此维护一个表的行数没有意义。</p>
<p>需要注意的是，在使用InnoDB存储引擎时，通过类似<code>SELECT COUNT(*) FROM table</code>这样的查询来获取表的行数并不是一个好的做法，这种方式会遍历整张表，造成性能问题。如果需要获取准确的表的行数，可以通过查询<code>SHOW TABLE STATUS</code>的结果来获取。</p>
<hr>
<h4 id="为什么有时索引会失效或选错索引"><a href="#为什么有时索引会失效或选错索引" class="headerlink" title="为什么有时索引会失效或选错索引"></a>为什么有时索引会失效或选错索引</h4><hr>
<h4 id="如何优化查询"><a href="#如何优化查询" class="headerlink" title="如何优化查询"></a>如何优化查询</h4><ol>
<li>编写高效的查询语句：合理编写查询语句是查询优化的基础。避免使用复杂的嵌套查询和子查询，尽量使用简单的查询语句；避免使用过多的通配符，尽量指定具体的查询条件；使用合适的连接方式，如INNER JOIN、LEFT JOIN、RIGHT JOIN等；避免使用不必要的排序和分组。</li>
<li>使用索引：合理使用索引可以显著提高查询性能。在查询条件中频繁使用的列上创建索引，避免在大表上进行全表扫描。</li>
<li>避免使用SELECT *：在查询时，避免使用SELECT *，而是只选择需要的列。这样可以减少数据库传输和处理的数据量，提高查询效率。</li>
<li>优化子查询和嵌套查询：子查询和嵌套查询可能导致查询性能下降，尽量避免在查询中多次嵌套子查询。可以考虑使用连接（JOIN）操作、临时表等替代子查询，从而优化查询性能。</li>
<li>使用合适的数据类型：在数据库设计和查询中，使用合适的数据类型可以避免数据类型转换和隐式转换，提高查询性能。例如，对于整数类型的列，使用整数类型的数据而不是字符类型的数据，可以提高查询效率。</li>
</ol>
<hr>
<h4 id="为什么有时只查询一行但是很慢"><a href="#为什么有时只查询一行但是很慢" class="headerlink" title="为什么有时只查询一行但是很慢"></a>为什么有时只查询一行但是很慢</h4><ol>
<li>数据库表中数据量增加：随着表中数据量的增加，查询一行的时间可能会变得更长。</li>
<li>索引失效：如果查询条件中使用的列没有索引，或者索引失效（例如索引统计信息过期或者索引损坏），数据库可能会执行全表扫描或者其他低效的查询方法，从而导致查询一行的性能下降。</li>
<li>查询复杂度增加：如果查询的复杂度增加，例如涉及到多个表的联接、子查询、聚合函数等，查询一行的性能可能会受到影响。</li>
<li>数据库服务器负载增加：如果数据库服务器负载增加，例如同时有大量的查询和写入操作，数据库的性能可能会下降，从而导致查询一行变得很慢。</li>
</ol>
<hr>
<ol>
<li>MVCC实现原理（ReadView机制）</li>
<li>慢SQL优化全流程（explain-&gt;索引优化-&gt;业务重构）</li>
<li>主从同步原理（binlog格式差异）</li>
<li>分库分表策略（基因法 vs 时间分片）</li>
<li>死锁产生条件与排查方法（show engine innodb status）</li>
<li>大数据量count优化方案</li>
<li>线上DDL操作风险与pt-osc原理</li>
<li>索引下推与MRR优化原理</li>
<li>连接池参数配置与监控要点</li>
<li>双写一致性保障方案（延迟双删）</li>
<li>大数据量导出导致OOM的解决方案</li>
<li>线上事故：误删数据如何快速恢复？</li>
</ol>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ol>
<li>对象内存布局（对象头对齐）</li>
<li>类加载过程（双亲委派破坏场景）</li>
<li>G1收集器Mixed GC过程解析</li>
<li>线上Full GC频繁的排查思路</li>
<li>内存泄漏定位（MAT使用技巧）</li>
<li>方法区演进（永久代-&gt;元空间）</li>
<li>四种引用类型与缓存设计应用</li>
<li>Arthas热更新代码原理</li>
<li>逃逸分析与栈上分配</li>
<li>ZGC颜色指针实现原理</li>
</ol>
<h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><ol>
<li>synchronized锁升级过程</li>
<li>AQS实现原理（以ReentrantLock为例）</li>
<li>ConcurrentHashMap分段锁演进</li>
<li>线程池参数动态调整方案</li>
<li>ThreadLocal内存泄漏问题</li>
<li>CompletableFuture编排异步任务</li>
<li>volatile内存屏障实现原理</li>
<li>如何设计百万级QPS的计数系统？</li>
<li>限制接口调用次数的5种方案</li>
<li>Happens-Before规则实战应用</li>
<li>异步编程的异常处理要点</li>
<li>无锁队列实现（CAS应用）</li>
</ol>
<h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><ol>
<li>循环依赖解决原理（三级缓存）</li>
<li>Spring事务失效的7种场景</li>
<li>Bean生命周期扩展点实战</li>
<li>动态代理选择策略（CGLib vs JDK）</li>
<li>SpringBoot自动配置原理</li>
<li>自定义Starter开发要点</li>
<li>如何设计可插拔的功能模块？</li>
<li>统一异常处理的最佳实践</li>
<li>配置加载优先级（命令行&gt;环境变量）</li>
<li>如何实现接口幂等性？</li>
</ol>
<h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><ol>
<li>服务注册发现AP与CP架构对比</li>
<li>熔断降级策略（滑动窗口实现）</li>
<li>分布式配置中心推拉模式对比</li>
<li>灰度发布实现方案</li>
<li>分布式链路追踪原理（Span树）</li>
<li>Seata AT模式实现原理</li>
<li>服务网格Sidecar设计理念</li>
<li>接口性能突增的限流策略</li>
<li>如何设计服务治理平台？</li>
<li>跨库事务解决方案</li>
</ol>
<h3 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h3><ol>
<li>分布式ID生成方案（雪花算法优化）</li>
<li>一致性Hash算法虚拟节点设计</li>
<li>分布式锁的三种实现方式对比</li>
<li>分布式Session解决方案</li>
<li>如何实现最终一致性（消息表+重试）</li>
<li>分库分表后分页查询方案</li>
<li>分布式事务最大努力通知型实现</li>
<li>数据同步方案（canal+MQ）</li>
<li>高并发下单系统设计（库存扣减）</li>
<li>分布式缓存更新策略（Cache Aside）</li>
<li>分布式系统时钟同步问题</li>
<li>脑裂问题解决方案</li>
</ol>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><ol>
<li>Kafka高吞吐量实现原理</li>
<li>消息丢失与重复消费解决方案</li>
<li>顺序消息实现方案</li>
<li>延迟消息实现原理</li>
<li>死信队列应用场景</li>
<li>消息堆积处理策略</li>
<li>RocketMQ事务消息流程</li>
<li>Pulsar分层存储架构优势</li>
<li>如何设计消息轨迹系统？</li>
<li>Broker选举机制对比（Kafka vs RocketMQ）</li>
</ol>
<h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><ol>
<li>动态代理在RPC中的应用</li>
<li>如何设计可扩展的序列化协议？</li>
<li>连接池管理策略（饿汉式 vs 懒汉式）</li>
<li>超时控制与重试策略设计</li>
<li>如何实现跨语言调用？</li>
<li>熔断限流在RPC层的实现</li>
<li>分布式跟踪上下文传递方案</li>
<li>服务端线程模型对比（Netty vs Tomcat）</li>
</ol>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ol>
<li>HTTPS握手过程优化策略</li>
<li>零拷贝技术实现原理</li>
<li>百万连接服务器架构设计</li>
<li>线上CPU飙高排查流程</li>
<li>设计一个短链系统</li>
<li>接口性能优化全链路方案</li>
<li>海量数据判重方案（布隆过滤器）</li>
<li>如何设计秒杀系统？</li>
<li>大型项目代码规范落地实践</li>
<li>线上问题排查工具箱（arthas+prometheus）</li>
<li>技术方案文档编写要点</li>
</ol>
<h2 id="2-关键准备建议"><a href="#2-关键准备建议" class="headerlink" title="2. 关键准备建议"></a>2. 关键准备建议</h2><ol>
<li><strong>深度优先原则</strong>：每个技术栈准备3-5个可深入讲解的案例</li>
<li><strong>STAR法则训练</strong>：将项目经历整理成冲突-行动-结果的故事模板</li>
<li><strong>白板编程练习</strong>：每天1道LeetCode中等难度题（重点：链表&#x2F;树&#x2F;DFS）</li>
<li><strong>架构图绘制</strong>：准备可手绘的微服务架构图&#x2F;数据库分片图</li>
<li><strong>压力面试模拟</strong>：找同伴进行”为什么选择这个方案”的连续追问训练</li>
</ol>
<p>建议每天拿出2小时进行专题突破+1小时模拟面试。如果需要某个方向的详细解析或答案模板，可以告诉我具体方向，我会提供更深入的材料。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/8eda3648.html" rel="prev" title="Redis笔记">
                  <i class="fa fa-angle-left"></i> Redis笔记
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa-regular fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder"></span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Word count total">71k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">4:18</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>

  <script class="next-config" data-name="wavedrom" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/wavedrom.min.js","integrity":"sha256-INLAoJc6quTNfiMWkGZniYO2cxE8mHpddnLow1m6RFs="}}</script>
  <script class="next-config" data-name="wavedrom_skin" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/skins/default.js","integrity":"sha256-fduc/Zszk5ezWws2uInY/ALWVmIrmV6VTgXbsYSReFI="}}</script>
  <script src="/js/third-party/tags/wavedrom.js"></script>




  





</body>
</html>
