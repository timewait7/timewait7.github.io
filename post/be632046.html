<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"timewait7.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":true,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="高频面试题逻辑题Q：小白鼠试毒药 Q：100个人按灯  有100盏灯,编号依次为1,2,3…100,电灯全部关着。现在来了100个人,第一个人把所有的灯开关按下；第二个人隔一个灯按下（2,4,6…）；第三个人每隔两个灯按下（3,6,9…）.第100个人隔99个灯按下（100）,最后还有几盏灯，那几盏灯亮着？  Q：100的阶乘有几个0 100的阶乘（100!）有多少个末尾的零，可以通过计算其因式分">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题清单">
<meta property="og:url" content="http://timewait7.github.io/post/be632046.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="高频面试题逻辑题Q：小白鼠试毒药 Q：100个人按灯  有100盏灯,编号依次为1,2,3…100,电灯全部关着。现在来了100个人,第一个人把所有的灯开关按下；第二个人隔一个灯按下（2,4,6…）；第三个人每隔两个灯按下（3,6,9…）.第100个人隔99个灯按下（100）,最后还有几盏灯，那几盏灯亮着？  Q：100的阶乘有几个0 100的阶乘（100!）有多少个末尾的零，可以通过计算其因式分">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://timewait7.github.io/post/be632046/1726212535664-4bb3f3ff-704a-4706-84c8-a046a8486657.webp">
<meta property="og:image" content="http://timewait7.github.io/post/be632046/image-20250302111116621.png">
<meta property="og:image" content="http://timewait7.github.io/post/be632046/image-20250302111551681.png">
<meta property="og:image" content="http://timewait7.github.io/post/be632046/image-20250302112330725.png">
<meta property="article:published_time" content="2025-02-25T15:09:43.000Z">
<meta property="article:modified_time" content="2025-04-01T15:11:15.398Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://timewait7.github.io/post/be632046/1726212535664-4bb3f3ff-704a-4706-84c8-a046a8486657.webp">


<link rel="canonical" href="http://timewait7.github.io/post/be632046.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://timewait7.github.io/post/be632046.html","path":"post/be632046.html","title":"面试题清单"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>面试题清单 | Hexo</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-archives"><a href="/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="Searching..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">高频面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E9%A2%98"><span class="nav-number">1.1.</span> <span class="nav-text">逻辑题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis"><span class="nav-number">1.2.</span> <span class="nav-text">Redis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL"><span class="nav-number">1.3.</span> <span class="nav-text">MySQL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="nav-number">1.4.</span> <span class="nav-text">Java基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM"><span class="nav-number">1.5.</span> <span class="nav-text">JVM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="nav-number">1.6.</span> <span class="nav-text">并发编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring"><span class="nav-number">1.7.</span> <span class="nav-text">Spring</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="nav-number">1.8.</span> <span class="nav-text">微服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.9.</span> <span class="nav-text">分布式系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">1.10.</span> <span class="nav-text">消息队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RPC"><span class="nav-number">1.11.</span> <span class="nav-text">RPC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.12.</span> <span class="nav-text">系统设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%91%E5%8E%9F%E7%94%9F%E4%B8%8E%E5%AE%B9%E5%99%A8%E5%8C%96"><span class="nav-number">1.13.</span> <span class="nav-text">云原生与容器化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.14.</span> <span class="nav-text">架构设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5%E4%B8%8E%E8%BD%AF%E6%8A%80%E8%83%BD"><span class="nav-number">1.15.</span> <span class="nav-text">工程实践与软技能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.16.</span> <span class="nav-text">操作系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="nav-number">1.17.</span> <span class="nav-text">计算机网络</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E5%85%85"><span class="nav-number">1.18.</span> <span class="nav-text">补充</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%87%86%E5%A4%87%E5%BB%BA%E8%AE%AE"><span class="nav-number">2.</span> <span class="nav-text">关键准备建议</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/">
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="Back to top">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://timewait7.github.io/post/be632046.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="面试题清单 | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试题清单
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-02-25 23:09:43" itemprop="dateCreated datePublished" datetime="2025-02-25T23:09:43+08:00">2025-02-25</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>44 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="高频面试题"><a href="#高频面试题" class="headerlink" title="高频面试题"></a>高频面试题</h2><h3 id="逻辑题"><a href="#逻辑题" class="headerlink" title="逻辑题"></a>逻辑题</h3><p><strong>Q：小白鼠试毒药</strong></p>
<p><strong>Q：100个人按灯</strong></p>
<blockquote>
<p>有100盏灯,编号依次为1,2,3…100,电灯全部关着。现在来了100个人,第一个人把所有的灯开关按下；第二个人隔一个灯按下（2,4,6…）；第三个人每隔两个灯按下（3,6,9…）.第100个人隔99个灯按下（100）,最后还有几盏灯，那几盏灯亮着？</p>
</blockquote>
<p><strong>Q：100的阶乘有几个0</strong></p>
<p>100的阶乘（100!）有多少个末尾的零，可以通过计算其因式分解中10的因子个数来确定，因为末尾的零是由2和5相乘得到的。</p>
<p>首先，我们将100!进行因式分解。100!表示从1乘到100的连续整数的乘积，可以写成：</p>
<p>100! &#x3D; 1 × 2 × 3 × 4 × … × 99 × 100</p>
<p>接下来，我们观察乘法中每一项的因子中2和5的个数。</p>
<p>在100!中，偶数的因子2的个数明显比5多，因为每隔一个数就会有一个偶数出现，而偶数都包含因子2。所以，我们只需要关注100!中5的因子个数。</p>
<p>在100!中，5、10、15、20、…、95、100这些数都包含因子5，共有20个数。而25、50、75、100这些数包含两个因子5，所以需要将其计算在内。</p>
<p>因此，100!中总共有20 + 4 &#x3D; 24个因子5。</p>
<p>综上所述，100!末尾共有24个零。</p>
<p><strong>Q：用天平找最轻&#x2F;重的球</strong></p>
<blockquote>
<p>8个球，一个轻，天平2次找出来</p>
</blockquote>
<p>第一次称重：将任意三个球放在天平的一边，再将另外三个球放在另一边，剩下的两个球不放在天平上。如果天平平衡，则轻的球在剩下的两个球中，可以直接通过目测或者手感来找出轻的球。如果天平不平衡，那么轻的球一定在轻的那一边。</p>
<p>第二次称重：将轻的那一边的三个球中的两个球放在天平的一边，将剩下的一个球放在另一边。如果天平平衡，则剩下的那个球就是轻的球；如果天平不平衡，那么轻的球就是轻的那一边的球。</p>
<p><strong>Q：2017的2017 次方的最后一位数</strong></p>
<p>计算2017的2017次方的最后一位数，可以使用数论中的数学性质来简化计算。根据数学性质，一个整数的末位数只和该整数的个位数有关，而与其他位数无关。</p>
<p>首先，我们观察2017的个位数是什么。2017除以10的余数是7，因此2017的个位数是7。</p>
<p>接下来，我们观察7的幂的个位数的规律。我们可以列举一些7的幂，看看个位数的变化：</p>
<p>7^1 &#x3D; 7 7^2 &#x3D; 49 7^3 &#x3D; 343 7^4 &#x3D; 2401 7^5 &#x3D; 16807 …</p>
<p>可以观察到，7的幂的个位数会在7、9、3、1这四个数字之间循环。具体地，7^1的个位数是7，7^2的个位数是9，7^3的个位数是3，7^4的个位数是1，7^5的个位数又是7，以此类推。</p>
<p>因此，我们可以利用这个规律来简化计算2017的2017次方的个位数。2017除以4的余数是1，所以2017的2017次方的个位数也是1。</p>
<p>综上所述，2017的2017次方的最后一位数是1。</p>
<p><strong>Q：25匹马，5个跑道，最少比多少次能比出前3名</strong></p>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p><strong>Q：Redis为什么快？单线程如何处理高并发？</strong></p>
<p>对于Redis的高性能设计，我的理解主要得益于以下几点：</p>
<ul>
<li>内存操作：Redis数据存储在内存，相比于磁盘数据库，减少了IO开销</li>
<li>高效的数据结构：Redis针对不同场景设计了不同的数据结构，优化了空间和访问效率</li>
<li>单线程：Redis使用单线程处理命令，避免了多线程之间的竞争和上下文切换的开销</li>
<li>IO多路复用：Redis基于epoll&#x2F;kqueue实现了非阻塞的网络模型，通过事件机制循环处理请求</li>
</ul>
<p><strong>追问1：单线程如何利用多核CPU</strong></p>
<p>可以部署分片集群，每个Redis实例绑定一个CPU核（&#x3D;&#x3D;如何部署和绑定？&#x3D;&#x3D;）</p>
<p><strong>追问2：为什么选用单线程而不是多线程</strong></p>
<ul>
<li>避免锁竞争</li>
<li>避免上下文切换开销</li>
<li>多线程内存管理复杂</li>
</ul>
<p><strong>追问3： 什么场景下单线程会成为瓶颈</strong></p>
<ul>
<li>超大 Value 操作（如10MB的string）（&#x3D;&#x3D;什么操作，普通读写就会阻塞吗&#x3D;&#x3D;）</li>
<li>复杂 Lua 脚本执行（阻塞其他命令）</li>
</ul>
<p><strong>Q：Redis有哪些数据结构，分别有哪些使用场景场景？</strong></p>
<p>Redis的基础数据结构包括string、hash、list、set、zset，高级数据结构包括hyperloglog、geo、bitmap、stream</p>
<p><strong>Q：缓存穿透&#x2F;雪崩&#x2F;击穿解决方案</strong></p>
<p><strong>缓存穿透</strong>是指查询数据库中不存在的数据，导致请求每次都穿过缓存查询数据库。</p>
<p>解决方案：</p>
<ul>
<li><strong>布隆过滤器（Bloom Filter）</strong></li>
</ul>
<p>服务启动时加载全量有效key，标记数据是否存在；新增数据时同步更新过滤器</p>
<p>缺点：存在一定的误判率</p>
<ul>
<li><strong>缓存空值</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getData</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> redis.get(key);</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> NullValue) &#123; <span class="comment">// 空值标记</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    value = db.query(key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        redis.setex(key, <span class="number">300</span>, <span class="keyword">new</span> <span class="title class_">NullValue</span>()); <span class="comment">// 缓存空值5分钟</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redis.setex(key, <span class="number">3600</span>, value); <span class="comment">// 正常缓存1小时</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>增强请求参数的复杂度，避免被猜测，同时做好数据的基础格式校验</li>
</ul>
<p><strong>缓存雪崩</strong>是指<strong>大量key</strong>同时失效，导致大量请求都去查询数据库，造成数据库压力骤增。</p>
<p>解决方案：</p>
<ul>
<li><strong>差异化过期时间</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基础过期时间，1小时</span></span><br><span class="line"><span class="type">int</span> <span class="variable">baseExpire</span> <span class="operator">=</span> <span class="number">3600</span>;</span><br><span class="line"><span class="comment">// 随机0-5分钟</span></span><br><span class="line"><span class="type">int</span> <span class="variable">randomExpire</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">300</span>);</span><br><span class="line">redis.setex(key, baseExpire + randomExpire, value);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>永不过期+异步更新</strong></li>
<li><strong>添加降级限流策略</strong></li>
<li><strong>添加多级缓存</strong></li>
</ul>
<p><strong>缓存击穿</strong>是指某个<strong>热点key</strong>失效的瞬间，有大量请求同时访问这个key，导致所有请求都去查询数据库。</p>
<p>解决方案：</p>
<ul>
<li><strong>互斥锁</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> Redission.getLock(<span class="string">&quot;PREFIX:&quot;</span> + key);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lock.tryLock(<span class="number">3</span>, <span class="number">30</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">        <span class="comment">// 查库并重建缓存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>逻辑过期</strong></li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;真实数据&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;expire_ts&quot;</span><span class="punctuation">:</span> <span class="number">1672502400</span> <span class="comment">// 逻辑过期时间戳</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>处理流程：</p>
<ol>
<li>判断逻辑过期时间<ol>
<li>未过期，直接返回数据</li>
<li>已过期，创建子线程，异步重建缓存</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th>解决方案</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>互斥锁</td>
<td>实现简单；保证一致性；无需消耗额外内存</td>
<td>线程需等待，影响性能</td>
</tr>
<tr>
<td>逻辑过期</td>
<td>线程无需等待，性能较好</td>
<td>存在不一致性；消耗额外内存；实现复杂</td>
</tr>
</tbody></table>
<p><strong>Q：RDB和AOF持久化原理及优劣对比</strong></p>
<p><strong>Q：Redis集群模式（主从复制&#x2F;Sentinel&#x2F;Cluster）</strong></p>
<p><strong>Q：热Key问题处理方案</strong></p>
<p><strong>Q：Redis事务与MySQL事务的核心区别</strong></p>
<p><strong>Q：使用Redis实现分布式锁的演进过程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.ValueOperations;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisDistributedLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_KEY</span> <span class="operator">=</span> <span class="string">&quot;myLock&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LOCK_EXPIRE_TIME</span> <span class="operator">=</span> <span class="number">5000</span>; <span class="comment">// 锁过期时间，单位毫秒</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisDistributedLock</span><span class="params">(RedisTemplate&lt;String, String&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">acquireLock</span><span class="params">()</span> &#123;</span><br><span class="line">        ValueOperations&lt;String, String&gt; valueOperations = redisTemplate.opsForValue();</span><br><span class="line">        <span class="comment">// 尝试获取分布式锁</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">result</span> <span class="operator">=</span> valueOperations.setIfAbsent(LOCK_KEY, <span class="string">&quot;locked&quot;</span>); <span class="comment">// RedisTemplate 的 setIfAbsent 方法，如果键不存在则设置键值对并返回 true，否则返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span> &amp;&amp; result) &#123;</span><br><span class="line">            <span class="comment">// 成功获取到锁，设置锁的过期时间</span></span><br><span class="line">            redisTemplate.expire(LOCK_KEY, LOCK_EXPIRE_TIME, TimeUnit.MILLISECONDS); <span class="comment">// 设置键的过期时间，单位毫秒</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">releaseLock</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.delete(LOCK_KEY); <span class="comment">// 删除键</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用分布式锁的业务逻辑</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBusinessWithLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acquireLock()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获得分布式锁后执行业务逻辑</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Acquired lock, do business logic...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>); <span class="comment">// 模拟业务处理时间</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                releaseLock(); <span class="comment">// 业务处理完成后释放锁</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Released lock.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 未获得分布式锁，执行其他逻辑</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Failed to acquire lock, do other logic...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 RedisTemplate 实例并设置连接信息</span></span><br><span class="line">        RedisTemplate&lt;String, String&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置 Redis 连接工厂、序列化方式等</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="type">RedisDistributedLock</span> <span class="variable">distributedLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisDistributedLock</span>(redisTemplate);</span><br><span class="line">        distributedLock.doBusinessWithLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>竞争条件（Race Condition）：在多个客户端同时尝试获取锁时，可能会出现竞争条件，导致多个客户端都成功获得锁，从而引发并发访问资源的问题。</li>
<li>死锁（Deadlock）：如果某个持有锁的客户端在业务处理期间发生异常或崩溃，导致没有释放锁的操作，可能会出现死锁的情况，导致其他客户端无法获得锁。</li>
<li>锁过期（Lock Expiration）：为了避免死锁，通常会给锁设置过期时间，但如果业务处理时间较长，超过了锁的过期时间，可能会导致其他客户端误认为锁已经释放，从而引发并发访问资源的问题。</li>
<li>锁的重入性（Lock Reentrancy）：在某些场景下，同一个客户端可能需要多次获取同一个锁，例如嵌套的业务处理逻辑。如果分布式锁没有支持锁的重入性，可能会导致同一个客户端无法在业务处理期间重新获取锁，从而引发死锁或并发访问资源的问题。</li>
<li>性能开销（Performance Overhead）：使用分布式锁可能会增加系统的性能开销，例如频繁的锁获取和锁释放操作，以及锁的管理和维护。如果锁的使用不当，可能会影响系统的性能和响应时间。</li>
</ol>
<p><strong>Q：全量同步和增量同步的区别</strong></p>
<p>全量同步：master生成当前内存中所有数据的RDB文件，将RDB发送给slave。在此过程中，master将新的命令记录在<code>repl_backlog</code>中，后续再发送给slave。</p>
<p>执行时机：</p>
<ol>
<li>slave第一次连接到master</li>
<li>slave宕机太久，导致它在<code>repl_backlog</code>中的<code>offset</code>已经被覆盖掉了</li>
</ol>
<p>增量同步：salve将自己的<code>offset</code>发送到master，master将<code>repl_backlog</code>中<code>offset</code>之后的命令发送给slave</p>
<p>执行时机：</p>
<ol>
<li>slave断开重连之后，<code>repl_backlog</code>中的<code>offset</code>尚未被覆盖</li>
</ol>
<p><strong>Q：ZSet底层实现（跳表+哈希表）</strong></p>
<p><strong>Q：内存淘汰策略与LRU实现</strong></p>
<p><strong>Q：Pipeline和Lua脚本的使用场景</strong></p>
<p><strong>Q：大Key问题检测与处理方案</strong></p>
<p><strong>Q：Redis6多线程模型实现原理</strong></p>
<p><strong>Q：Redis和MySQL的区别</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>Redis</th>
<th>MySQL</th>
</tr>
</thead>
<tbody><tr>
<td>数据结构</td>
<td>非结构化</td>
<td>结构化</td>
</tr>
<tr>
<td>持久化</td>
<td>可选持久化</td>
<td>默认持久化</td>
</tr>
<tr>
<td>事务支持</td>
<td>简单支持</td>
<td>支持完整的ACID</td>
</tr>
<tr>
<td>扩展性</td>
<td>通过分片水平扩展</td>
<td>复杂，需分库分表或中间件</td>
</tr>
<tr>
<td>数据一致性</td>
<td>最终一致性</td>
<td>强一致性</td>
</tr>
</tbody></table>
<p>总结：</p>
<ul>
<li>当需要复杂查询和事务支持，对数据一致性要求较高，需要长期持久化存储的场景，选择MySQL</li>
<li>当需要超高性能和灵活数据类型，对数据的一致性要求不那么高，且容忍一定的数据丢失的情况下，选择Redis</li>
</ul>
<p><strong>Q：Redis和memchahed的区别</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>Redis</th>
<th>Memcached</th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>丰富的数据类型：string、hash、list等</td>
<td>只支持string</td>
</tr>
<tr>
<td>持久化</td>
<td>支持（RDB、AOF）</td>
<td>不支持</td>
</tr>
<tr>
<td>事务</td>
<td>简单支持（MULTI&#x2F;EXEC）</td>
<td>不支持</td>
</tr>
<tr>
<td>分布式</td>
<td>支持，集群自动分片</td>
<td>依赖客户端一致性哈希或第三方工具实现分布式</td>
</tr>
<tr>
<td>命令</td>
<td>支持丰富的命令</td>
<td>仅支持SET、GET、ADD、DELTE等基础操作</td>
</tr>
<tr>
<td>内存占用</td>
<td>复杂数据结构可能导致内存消耗较高</td>
<td>内存利用率高，但灵活性较低</td>
</tr>
</tbody></table>
<p>总结：</p>
<ul>
<li>需要复杂数据结构、持久化、事务支持和高可用性的场景，选择Redis</li>
<li>追求极致的性能和简单性，数据结构简单且无需持久化的场景，可以选择Memcached</li>
</ul>
<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p><strong>Q：查询语句的执行顺序</strong></p>
<img src="/post/be632046/1726212535664-4bb3f3ff-704a-4706-84c8-a046a8486657.webp" class="" title="img">

<p><strong>Q：InnoDB索引结构</strong></p>
<p>B树结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">       [10 | 20]</span><br><span class="line">      /    |     \</span><br><span class="line">[5|8]  [12|15|18]  [25|30]</span><br></pre></td></tr></table></figure>

<p>特征：</p>
<ul>
<li>所有节点都存储完整数据</li>
<li>每个节点最多包涵 m-1 个键值和 m 个子节点</li>
</ul>
<p>B+树结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">               [15]</span><br><span class="line">              /    \</span><br><span class="line">     [10|15]          [20|25]</span><br><span class="line">     /     \          /     \ </span><br><span class="line">[10|...]→[15|...]→[20|...]→[25|...]（叶子节点链表）</span><br></pre></td></tr></table></figure>

<p>特征：</p>
<ul>
<li>只有叶子节点存储完整数据，内部节点只存储索引</li>
<li>叶子节点通过双向链表连接，支持高效范围查询</li>
<li>相同磁盘页可以存储更多索引，提高查询效率</li>
</ul>
<p><strong>InnoDB选择B+树的7大关键原因</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>对比维度</strong></th>
<th align="left"><strong>B树</strong></th>
<th align="left"><strong>B+树</strong></th>
<th align="left"><strong>InnoDB优势体现</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>数据存储位置</strong></td>
<td align="left">所有节点存储数据</td>
<td align="left">仅叶子节点存储数据</td>
<td align="left">减少磁盘IO次数</td>
</tr>
<tr>
<td align="left"><strong>树高度</strong></td>
<td align="left">较高（数据分散存储）</td>
<td align="left">较低（内部节点纯索引）</td>
<td align="left">3层B+树可支撑千万级数据</td>
</tr>
<tr>
<td align="left"><strong>范围查询</strong></td>
<td align="left">需要回溯父节点</td>
<td align="left">通过叶子链表顺序扫描</td>
<td align="left"><code>WHERE id &gt; 100</code> 效率提升10倍+</td>
</tr>
<tr>
<td align="left"><strong>全表扫描</strong></td>
<td align="left">需遍历整棵树</td>
<td align="left">直接顺序遍历叶子节点链表</td>
<td align="left">全表扫描速度接近顺序读</td>
</tr>
<tr>
<td align="left"><strong>磁盘利用率</strong></td>
<td align="left">节点包含数据导致存储键值数少</td>
<td align="left">单页可存储更多键值（高分支因子）</td>
<td align="left">相同数据量减少30%-50%树高度</td>
</tr>
<tr>
<td align="left"><strong>数据更新代价</strong></td>
<td align="left">可能引起复杂结构调整</td>
<td align="left">插入删除多数情况只需局部调整</td>
<td align="left">支持更高并发写入</td>
</tr>
<tr>
<td align="left"><strong>缓存命中率</strong></td>
<td align="left">热点数据分散在不同层级</td>
<td align="left">叶子节点集中存储所有数据</td>
<td align="left">Buffer Pool利用率提升40%+</td>
</tr>
</tbody></table>
<p><strong>Q：为什么MongoDB使用B树而MySQL用B+树</strong></p>
<p>MongoDB面向文档存储，需快速获取整个文档（B树的内部节点存储完整数据，可以减少寻址次数）</p>
<p>MySQL侧重范围查询和事务处理（B+树的顺序访问特性更优秀）</p>
<p><strong>Q：B+树节点分裂的具体过程</strong></p>
<p>InnoDB优化：预留1&#x2F;16页空间避免频繁分裂</p>
<p><strong>索引设计原则</strong></p>
<ul>
<li>前缀索引优化</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> <span class="keyword">ADD</span> INDEX (name(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>覆盖索引优化</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建包含所有查询字段的索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_cover <span class="keyword">ON</span> orders(user_id, status, create_time);</span><br></pre></td></tr></table></figure>



<p><strong>监控工具使用</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看索引使用情况</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.schema_index_statistics;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分析索引效率</span></span><br><span class="line">EXPLAIN ANALYZE <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> category_id<span class="operator">=</span><span class="number">5</span>;</span><br></pre></td></tr></table></figure>



<p><strong>维护策略</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 定期优化表（重建索引）</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 监控页分裂次数</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Innodb_page_splits%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>Q：<code>EXPLAIN</code> 字段说明</strong></p>
<p>通常<code>EXPALIN</code>查询语句的输出如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="comment">// 每个select语句对应一个唯一的id</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询类型：</span></span><br><span class="line"><span class="comment">     * SIMPLE：不包含UNION或子查询的select（连接查询的每个查询都是simple查询）</span></span><br><span class="line"><span class="comment">     * PRIMARY：最外层查询</span></span><br><span class="line"><span class="comment">     * UNION</span></span><br><span class="line"><span class="comment">     * ...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="attr">&quot;select_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SIMPLE&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;users&quot;</span><span class="punctuation">,</span> <span class="comment">// 要查询的表</span></span><br><span class="line">    <span class="attr">&quot;partitions&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span> <span class="comment">// 分区信息</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 针对单表的访问方法：</span></span><br><span class="line"><span class="comment">     * system：当表中只有一条记录，并且该表使用的存储引擎的统计数据是精确的，访问方法就是system</span></span><br><span class="line"><span class="comment">     * constant：根据主键或唯一索引列与常数进行等值匹配时，访问方法就是const</span></span><br><span class="line"><span class="comment">     * eq_ref：连接查询中对被驱动表的主键或不允许为NULL的唯一索引进行等值查询时，访问方法就是eq_ref</span></span><br><span class="line"><span class="comment">     * ref：通过普通二级索引列与常量进行等值匹配时，对该表的访问方法就是 ref</span></span><br><span class="line"><span class="comment">     * ref_or_null：select * from single_table where key1 = &#x27;abc&#x27; or key1 is NULL;</span></span><br><span class="line"><span class="comment">     * index_merge：使用多个索引进行等值匹配</span></span><br><span class="line"><span class="comment">     * unique_subquery：在子查询中使用主键或不允许存储NULL值的唯一二级索引进行等值匹配</span></span><br><span class="line"><span class="comment">     * index_subquery：在子查询中使用普通二级索引进行等值匹</span></span><br><span class="line"><span class="comment">     * range：利用索引进行范围查询</span></span><br><span class="line"><span class="comment">     * index：当可以使用索引覆盖，但需要扫描全部索引记录</span></span><br><span class="line"><span class="comment">     * all：全表扫描</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ref&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;possible_keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;idx_composite&quot;</span><span class="punctuation">,</span> <span class="comment">// 可能使用的索引</span></span><br><span class="line">    <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;idx_composite&quot;</span><span class="punctuation">,</span> <span class="comment">// 实际使用的索引</span></span><br><span class="line">    <span class="attr">&quot;key_len&quot;</span><span class="punctuation">:</span> <span class="string">&quot;208&quot;</span><span class="punctuation">,</span> <span class="comment">// 实际使用的索引长度</span></span><br><span class="line">    <span class="attr">&quot;ref&quot;</span><span class="punctuation">:</span> <span class="string">&quot;const&quot;</span><span class="punctuation">,</span> <span class="comment">// 使用索引列等值查询时，与索引列进行等值匹配的对象信息</span></span><br><span class="line">    <span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="comment">// 预估需要读取的记录行数</span></span><br><span class="line">    <span class="attr">&quot;filtered&quot;</span><span class="punctuation">:</span> <span class="number">100.0</span><span class="punctuation">,</span> <span class="comment">// 过滤后剩余记录行数百分比</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 额外信息：</span></span><br><span class="line"><span class="comment">     * Using index：使用覆盖索引</span></span><br><span class="line"><span class="comment">     * Using index condition：使用索引条件下推</span></span><br><span class="line"><span class="comment">     * Using where：需要在server层判断条件是否成立</span></span><br><span class="line"><span class="comment">     * Using join buffer：执行连接查询时，被驱动表不能有效利用索引加快访问速度时，会分配一块内存用来保存驱动表的查询结果，</span></span><br><span class="line"><span class="comment">     					  利用join buffer可以减少访问被驱动表的次数</span></span><br><span class="line"><span class="comment">     * Using filesort：</span></span><br><span class="line"><span class="comment">     * Using temporary</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="attr">&quot;Extra&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Using index&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>Q：覆盖索引与最左前缀原则实战案例</strong></p>
<p><strong>回表</strong>：查询需要的字段没有全表包含在索引中，需要根据索引找到主键，再从主键索引中找到数据才能获取所需字段。</p>
<p><strong>覆盖索引</strong>：查询所需的字段都包含在索引中，无需回表操作。</p>
<p>优点：</p>
<ul>
<li>减少IO操作</li>
<li>避免回表（减少随机读）</li>
</ul>
<p><strong>最左前缀原则</strong>：复合索引 <code>(a, b, c)</code> 的查询条件必须从最左列开始，且不能跳过中间列才能命中索引。</p>
<p>具体规则：</p>
<ul>
<li>等值查询：<code>WHERE a = 1 and b = 2</code> → 命中索引</li>
<li>范围查询：<code>WHERE a &gt; 1 and b = 2</code> → 仅能命中 <code>a</code> 列</li>
<li>跳跃查询：<code>WHERE b = 2 and c = 3</code> → 不能能命中索引</li>
</ul>
<p>覆盖索引优化：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `users` (</span><br><span class="line">	`id` <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">	`name` <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">	`age` <span class="type">INT</span>,</span><br><span class="line">	`city` <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">	`created_at` DATETIME,</span><br><span class="line">	KEY `idx_composite` (`city`, `age`, `created_at`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>

<p>查询需求：统计北京25岁用户的数量</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> city<span class="operator">=</span><span class="string">&#x27;北京&#x27;</span> <span class="keyword">AND</span> age<span class="operator">=</span><span class="number">25</span>;</span><br></pre></td></tr></table></figure>

<img src="/post/be632046/image-20250302111116621.png" class="" title="image-20250302111116621">

<p>之前的版本<code>Extra</code>中应该是<code>Using where</code>，因为需要回表确认数据是否存在。</p>
<p>优化方案：添加覆盖索引覆盖统计需要的所有字段</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> users <span class="keyword">ADD</span> INDEX idx_covering(city, age, id);</span><br></pre></td></tr></table></figure>

<p>最左前缀索引优化</p>
<p>查询需求：查询北京地区年龄大于 30 岁的用户，并按注册时间排序</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> city<span class="operator">=</span><span class="string">&#x27;北京&#x27;</span> <span class="keyword">AND</span> age<span class="operator">&gt;</span> <span class="number">30</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> created_at LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<img src="/post/be632046/image-20250302111551681.png" class="" title="image-20250302111551681">

<p>从<code>EXPLAIN</code>结果可以看出，这条查询语句需要用到耗时的文件排序，这是因为查询条件中存在范围查询，导致不能完全利用上组合索引。</p>
<p>优化方案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> users <span class="keyword">ADD</span> INDEX idx_city_created_age(city, created_at, age);</span><br></pre></td></tr></table></figure>

<img src="/post/be632046/image-20250302112330725.png" class="" title="image-20250302112330725">



<p>索引设计规范：</p>
<ul>
<li>组合索引字段按区分度从高到低排序</li>
<li>索引列数≤5列，避免更新开销太大</li>
<li>禁止<code>SELECT *</code>，尽量查询索引能覆盖的字段</li>
</ul>
<p>慢查询优化流程：</p>
<ol>
<li>抓取慢日志：<code>long_query_time=1s</code></li>
<li><code>EXPLAIN</code> 分析执行计划</li>
<li>检查索引使用情况<ul>
<li>是否触发覆盖索引</li>
<li>是否违反最左前缀原则</li>
</ul>
</li>
<li>使用<code>force index</code>验证索引有效性</li>
<li>调整索引或SQL写法</li>
</ol>
<p>监控指标</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看索引使用频率</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.schema_index_statistics <span class="keyword">WHERE</span> table_name<span class="operator">=</span><span class="string">&#x27;users&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检查冗余索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.schema_redundant_indexes;</span><br></pre></td></tr></table></figure>

<p><strong>Q：为什么InnoDB不保存表的总行数</strong></p>
<p>与MyISAM保存表的总行数不同，InnoDB统计行数需要扫描全表，因为MVCC，同一时刻多个查询返回的行数可能不一致。</p>
<p>对于需要经常统计表的行数的解决办法：</p>
<ul>
<li>在缓存（如 Redis）中保存计数</li>
<li>在 MySQL 中保存计数</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>count(*)</code></td>
<td>对于满足条件的数据行按行累加</td>
</tr>
<tr>
<td><code>count(1)</code></td>
<td>对于满足条件的每一行，放一个 1 进去，按行累加</td>
</tr>
<tr>
<td><code>count(主键)</code></td>
<td>对于满足条件的每一行，取出主键，判断非 null，按行累加</td>
</tr>
<tr>
<td><code>count(字段)</code></td>
<td>对于满足条件的每一行，取出字段，判断非 null，按行累加</td>
</tr>
</tbody></table>
<p>性能：<code>count(字段)</code> &lt; <code>count(主键)</code> &lt; <code>count(1)</code> ≈ <code>count(*)</code></p>
<p><code>count(主键/字段)</code> 的效率更低的原因是需要解析数据行，并拷贝要返回的字段值。</p>
<p><strong>Q：解释一下事务的基本特性和隔离级别</strong></p>
<p>事务保证一组操作要么全部成功，要么全部失败。在 MySQL 中，事务支持是在引擎层实现的。</p>
<table>
<thead>
<tr>
<th>基本特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>原子性（<code>atomicity</code>）</td>
<td>事务中的操作要么全都执行，要么都不执行</td>
</tr>
<tr>
<td>一致性（<code>consistency</code>）</td>
<td>事务的执行要保证数据的完整性和一致性</td>
</tr>
<tr>
<td>隔离性（<code>isolation</code>）</td>
<td>事务的执行互不干扰</td>
</tr>
<tr>
<td>持久性（<code>durability</code>）</td>
<td>事务一旦提交，对数据的修改就永久保存到数据库中，不可撤销</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>事务可能引发的问题</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>脏读</td>
<td>A 事务读取 B 事务尚未提交的修改</td>
</tr>
<tr>
<td>不可重复读</td>
<td>A 事务多次读取同一数据，结果前后不一致</td>
</tr>
<tr>
<td>幻读</td>
<td>A 事务多次读取，数据总量前后不一致</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>说明</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td><code>read uncommitted</code></td>
<td>一个事务执行过程中，能看到其他未提交事务做的变更</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td><code>read committed</code></td>
<td>一个事务执行过程中，能看到其他已提交事务做的变更（MySQL 会在每个 SQL 语句开始执行时创建一个视图）</td>
<td></td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td><code>repeatable read</code></td>
<td>一个事务执行过程中，其他事务的变更对它不可见（MySQL 会在事务启动时创建一个视图，整个事务执行期间都使用这个视图）</td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td><code>serializable</code></td>
<td>事务串行执行，隔离级别最高，不会出现上面所说的问题，但相应的效率也最低</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>Q：InnoDB如何解决幻读</strong></p>
<p>InnoDB解决幻读主要靠以下三大核心机制：</p>
<ul>
<li>多版本并发控制（<code>MVCC</code>）</li>
<li>间隙锁（<code>Gap Lock</code>）</li>
<li>临键锁（<code>Next-Key Lock</code>）</li>
</ul>
<p><strong><code>MVCC</code>实现原理：</strong></p>
<ul>
<li><code>Undo log</code>：每条数据维护多个历史版本</li>
<li><code>ReadView</code>：快照</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ReadView结构：</span><br><span class="line">&#123;</span><br><span class="line">  creator_trx_id: 150,      -- 当前事务ID</span><br><span class="line">  m_ids: [100, 120, 140],   -- 活跃事务ID列表</span><br><span class="line">  min_trx_id: 100,          -- 最小活跃事务ID</span><br><span class="line">  max_trx_id: 150           -- 预分配最大事务ID</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可见性判断规则</strong>：</p>
<ol>
<li>数据版本<code>trx_id</code> &lt; <code>min_trx_id</code> → 可见</li>
<li><code>trx_id</code>在<code>m_ids</code>中 → 不可见</li>
<li><code>trx_id</code> &gt;&#x3D; <code>max_trx_id</code> → 不可见</li>
</ol>
<p>InnoDB默认会为每行数据生成两个隐藏列：</p>
<ul>
<li><code>DB_TRX_ID</code>：最后修改该行的事务ID</li>
<li><code>DB_ROLL_PTR</code>：指向<code>Undo Log</code>的回滚指针</li>
</ul>
<p>不同隔离级别下<code>ReadView</code>的生成时机：</p>
<ul>
<li><code>READ COMMITTED(RC)</code>：每次<code>SELECT</code>都会创建新的<code>ReadView</code></li>
<li><code>REPEATABLE READ(RR)</code>：事务中第一次<code>SELECT</code>时创建<code>ReadView</code></li>
</ul>
<p><strong>间隙锁（<code>Gap Lock</code>）</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 表数据：5, 10, 15</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">10</span> <span class="keyword">AND</span> id <span class="operator">&lt;</span> <span class="number">20</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>这条语句会锁定区间 <code>(10, 15)</code>、<code>(15, +∞)</code>，在事务执行期间，其他事务无法在这两个区间插入数据</p>
<p><strong>临键锁（<code>Next-Key Lock</code>）</strong></p>
<p><strong>Q1：RR隔离级别如何既使用MVCC又用锁？</strong></p>
<ul>
<li><strong>快照读</strong>（普通SELECT）：依赖MVCC保证一致性</li>
<li><strong>当前读</strong>（SELECT FOR UPDATE）：使用临键锁保证物理数据一致</li>
</ul>
<p><strong>Q2：Gap Lock是否会导致死锁？</strong></p>
<p>间隙锁是有可能导致死锁的，如：事务A锁(5,10)，事务B锁(10,15)，两者同时请求对方区间的插入</p>
<p>解决方案：设置<code>innodb_deadlock_detect=ON</code>（默认开启检测）</p>
<p><strong>Q3：Purge线程的作用是什么？</strong></p>
<p>清理不再被任何事务需要的<code>Undo Log</code>，回收版本链中的过期数据版本</p>
<p><strong>Q：InnoDB和MyISAM的区别</strong></p>
<ol>
<li>数据的存储方式：MyISAM使用表级锁，而InnoDB使用行级锁。这意味着，在并发访问的情况下，InnoDB的并发性能更好。</li>
<li>事务支持：MyISAM不支持事务，而InnoDB支持事务，可以保证数据的一致性和完整性。</li>
<li>索引结构：MyISAM使用B树索引，而InnoDB使用B+树索引。B+树索引相对于B树索引，可以支持更快的范围查询和排序。</li>
<li>外键约束：MyISAM不支持外键约束，而InnoDB支持外键约束。</li>
<li>全文检索：MyISAM支持全文检索，而InnoDB不支持。</li>
<li>表空间管理：MyISAM每张表保存为三个文件（.frm、.MYD、.MYI），而InnoDB每张表只保存为一个文件。</li>
<li>内存和CPU的使用：MyISAM更注重查询的速度，因此会使用更多的内存和CPU资源，而InnoDB更注重事务的处理，因此会使用更多的磁盘I&#x2F;O资源。</li>
</ol>
<p>总体来说，如果需要支持事务、外键约束和高并发访问，那么InnoDB是更好的选择。如果需要进行全文检索，那么MyISAM是更好的选择。但是需要注意的是，MySQL 5.5版本之后，InnoDB已经支持了全文检索。</p>
<p><font color="red">为什么InnoDB不保存表行数？</font></p>
<p>InnoDB有个多版本并发控制的概念，这会导致不同的事务查询表的行数会获得不同的结果，因此维护一个表的行数没有意义。</p>
<p>需要注意的是，在使用InnoDB存储引擎时，通过类似<code>SELECT COUNT(*) FROM table</code>这样的查询来获取表的行数并不是一个好的做法，这种方式会遍历整张表，造成性能问题。如果需要获取准确的表的行数，可以通过查询<code>SHOW TABLE STATUS</code>的结果来获取。</p>
<p><strong>Q：为什么有时索引会失效或选错索引</strong></p>
<p><strong>Q：如何优化查询</strong></p>
<ol>
<li>编写高效的查询语句：合理编写查询语句是查询优化的基础。避免使用复杂的嵌套查询和子查询，尽量使用简单的查询语句；避免使用过多的通配符，尽量指定具体的查询条件；使用合适的连接方式，如INNER JOIN、LEFT JOIN、RIGHT JOIN等；避免使用不必要的排序和分组。</li>
<li>使用索引：合理使用索引可以显著提高查询性能。在查询条件中频繁使用的列上创建索引，避免在大表上进行全表扫描。</li>
<li>避免使用SELECT *：在查询时，避免使用SELECT *，而是只选择需要的列。这样可以减少数据库传输和处理的数据量，提高查询效率。</li>
<li>优化子查询和嵌套查询：子查询和嵌套查询可能导致查询性能下降，尽量避免在查询中多次嵌套子查询。可以考虑使用连接（JOIN）操作、临时表等替代子查询，从而优化查询性能。</li>
<li>使用合适的数据类型：在数据库设计和查询中，使用合适的数据类型可以避免数据类型转换和隐式转换，提高查询性能。例如，对于整数类型的列，使用整数类型的数据而不是字符类型的数据，可以提高查询效率。</li>
</ol>
<p><strong>Q：为什么有时只查询一行但是很慢</strong></p>
<ol>
<li>数据库表中数据量增加：随着表中数据量的增加，查询一行的时间可能会变得更长。</li>
<li>索引失效：如果查询条件中使用的列没有索引，或者索引失效（例如索引统计信息过期或者索引损坏），数据库可能会执行全表扫描或者其他低效的查询方法，从而导致查询一行的性能下降。</li>
<li>查询复杂度增加：如果查询的复杂度增加，例如涉及到多个表的联接、子查询、聚合函数等，查询一行的性能可能会受到影响。</li>
<li>数据库服务器负载增加：如果数据库服务器负载增加，例如同时有大量的查询和写入操作，数据库的性能可能会下降，从而导致查询一行变得很慢。</li>
</ol>
<p><strong>Q：慢SQL优化全流程</strong></p>
<p><strong>阶段1：问题定位与数据采集</strong></p>
<ul>
<li>开启慢日志查询</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 动态开启（重启失效）</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log <span class="operator">=</span> <span class="string">&#x27;ON&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> long_query_time <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">-- 阈值设为1秒</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log_file <span class="operator">=</span> <span class="string">&#x27;/var/log/mysql/slow.log&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 永久配置（my.cnf）</span><br><span class="line">[mysqld]</span><br><span class="line">slow_query_log = 1</span><br><span class="line">long_query_time = 1</span><br><span class="line">log_queries_not_using_indexes = 1  -- 记录未走索引的查询</span><br></pre></td></tr></table></figure>

<ul>
<li>实时监测工具</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前运行中的慢查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.PROCESSLIST </span><br><span class="line"><span class="keyword">WHERE</span> <span class="type">TIME</span> <span class="operator">&gt;</span> <span class="number">2</span> <span class="keyword">AND</span> COMMAND <span class="operator">=</span> <span class="string">&#x27;Query&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用Percona Toolkit抓取问题SQL</span></span><br><span class="line">pt<span class="operator">-</span>query<span class="operator">-</span>digest <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysql<span class="operator">/</span>slow.log</span><br></pre></td></tr></table></figure>

<ul>
<li>关键性能指标</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">重点监控项：</span><br><span class="line">- QPS/TPS波动</span><br><span class="line">- CPU使用率（特别是%sys）</span><br><span class="line">- 锁等待时间(Innodb_row_lock_time_avg)</span><br><span class="line">- 缓冲池命中率(Innodb_buffer_pool_reads)</span><br></pre></td></tr></table></figure>







<ol>
<li>主从同步原理（binlog格式差异）</li>
<li>分库分表策略（基因法 vs 时间分片）</li>
<li>死锁产生条件与排查方法（show engine innodb status）</li>
<li>大数据量count优化方案</li>
<li>线上DDL操作风险与pt-osc原理</li>
<li>索引下推与MRR优化原理</li>
<li>连接池参数配置与监控要点</li>
<li>双写一致性保障方案（延迟双删）</li>
<li>大数据量导出导致OOM的解决方案</li>
<li>线上事故：误删数据如何快速恢复？</li>
</ol>
<h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><ol>
<li><strong>Java中<code>==</code>和<code>equals()</code>的区别是什么？重写<code>equals()</code>时为什么要同时重写<code>hashCode()</code>？</strong></li>
<li><strong>String类的不可变性如何实现？<code>String</code>、<code>StringBuilder</code>、<code>StringBuffer</code>的区别及使用场景？</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The identifier of the encoding used to encode the bytes in &#123;<span class="doctag">@code</span> value&#125;. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span> coder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>value</code> 数组被声明为 <code>final</code>，这意味着 <code>value</code> 数组初始化之后就不能再引用其它数组。而 <code>String</code> 内部没有改变 <code>value</code> 数组内容的方法，这就保证了 <code>String</code> 不可变性。</p>
<ol>
<li><strong>Java泛型擦除机制的原理是什么？<code>List&lt;String&gt;</code>和<code>List&lt;Integer&gt;</code>在JVM中是否是同一个类？</strong></li>
<li><strong><code>final</code>关键字的作用（修饰类、方法、变量时的不同表现）？</strong></li>
<li><strong>自动装箱与拆箱的原理？<code>Integer a = 127; Integer b = 127;</code>和<code>Integer c = 128; Integer d = 128;</code>的比较结果差异原因？</strong></li>
<li><strong>抽象类与接口的区别？Java 8中接口的默认方法和静态方法对设计的影响？</strong></li>
<li><strong>什么是多态？如何通过方法重写和方法重载实现多态？</strong></li>
<li><strong>深拷贝与浅拷贝的区别？如何实现深拷贝？</strong></li>
<li><strong>类加载机制（双亲委派模型）及其如何避免类重复加载？如何破坏双亲委派模型？</strong></li>
<li><strong>HashMap的实现原理（数组+链表&#x2F;红黑树）？为什么容量是2的幂次？</strong></li>
</ol>
<ul>
<li>计算hash值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); // 减少碰撞</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>索引位置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (n - 1) &amp; hash</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>HashMap</code> 数组长度 n 为什么总是 2 的幂方</p>
<ol>
<li>提高计算索引效率。因为如果 n 是 2 的幂方，那么 <code>(n - 1) &amp; hash</code> &#x3D; <code>hash % n</code> ，但是 <code>&amp;</code> 运算效率比 <code>%</code> 运算更高。</li>
<li>扩容后，同一个桶中的数据要么留在原地，要么往后移 n 个位置，不同重新计算索引位置。</li>
</ol>
</li>
<li><p><code>fast-fail</code> 和 <code>ConcurrentModificationException</code></p>
</li>
<li><p><code>HashMap</code> 和 <code>HashTable</code> 的区别</p>
<table>
<thead>
<tr>
<th></th>
<th><code>HashMap</code></th>
<th><code>HashTable</code></th>
</tr>
</thead>
<tbody><tr>
<td>线程安全性</td>
<td>非线程安全</td>
<td>线程安全</td>
</tr>
<tr>
<td><code>null</code> 键值对的处理</td>
<td><code>HashMap</code> 允许使用 <code>null</code> 作为键和值</td>
<td><code>Hashtable</code> 不允许键或值为 <code>nul</code>l，这是因为 <code>Hashtable</code> 使用 <code>null</code> 作为结束标志</td>
</tr>
<tr>
<td>迭代顺序</td>
<td><code>HashMap</code> 的迭代顺序不确定</td>
<td><code>Hashtable</code> 的迭代顺序是按照插入顺序来的，<code>Hashtable</code> 使用了线性探测法</td>
</tr>
</tbody></table>
</li>
</ul>
<p>在 <code>Java 1.7</code>，<code>HashMap</code> 扩容后，同一条链表上的元素需要通过重新计算索引位置后，才能知道会被放在新数组的哪个位置。</p>
<p>而在 <code>Java 1.8</code> 中，不需要重新计算索引位置，只需判断之前计算得到的 <code>hashCode</code> 的下一位是 0 还是 1，即可知道在新数组中的位置。这里优化包括：</p>
<ul>
<li>省去重新计算索引位置的时间；</li>
<li>旧数组每个索引位置下的链表或红黑树中的节点会比较均匀地重新划分到新数组中。</li>
</ul>
<p>并且在 <code>Java 1.7</code> 中，<code>HashMap</code> 插入数据时是头插法，这样在 <code>rehash</code> 时，如果数据被分到同一个桶下，数据的相对位置会倒置（可能会导致死循环）；而 <code>Java 1.8</code> 采用的尾插法，<code>rehash</code> 不会导致倒置。</p>
<p><strong>Q：ConcurrentHashMap在JDK 7和JDK 8中的实现差异？</strong></p>
<ul>
<li>数据结构：Java 1.7 中的 <code>ConcurrentHashMap</code> 使用了数组+链表的方式来存储键值对，而 Java 1.8 中的 <code>ConcurrentHashMap</code> 则引入了红黑树，用于优化链表过长的情况，提高查找、插入和删除操作的性能。</li>
<li>加锁方式：Java 1.7 中的 <code>ConcurrentHashMap</code> 使用了分段锁（Segment）的机制来实现线程安全性，每个分段都有自己的锁。而 Java 1.8 中的 <code>ConcurrentHashMap</code> 则使用了基于 CAS（Compare and Swap）的算法来实现线程安全性，取代了分段锁的实现。</li>
<li>并发度：Java 1.8 中的 <code>ConcurrentHashMap</code> 支持更高的并发度，因为它不再使用分段锁，而是使用 CAS 算法，从而减少了锁的粒度和竞争，提供了更好的并发性能</li>
<li>扩容：Java 1.7 中的 <code>ConcurrentHashMap</code> 在扩容时采用的是分段锁的方式，每次只扩容一个段，而 Java 1.8 中的 <code>ConcurrentHashMap</code> 则采用了全局锁的方式，可以同时进行多个段的扩容，从而更快地完成扩容操作。</li>
</ul>
<ol>
<li><strong>ArrayList和LinkedList的底层结构及适用场景？ArrayList扩容机制？</strong></li>
<li><strong>Iterator和ListIterator的区别？如何实现快速失败（Fail-Fast）机制？</strong></li>
<li><strong>线程的6种状态（NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED）及状态转换条件？</strong></li>
<li><strong>synchronized和ReentrantLock的区别？什么是可重入锁？</strong></li>
<li><strong>volatile关键字的作用（可见性、禁止指令重排）？能否保证原子性？</strong></li>
</ol>
<p><code>volatile</code> 是 Java 中的关键字，用于修饰变量，用于保证变量的可见性、禁止指令重排序和禁止缓存优化，从而确保多线程环境下变量的正确访问。</p>
<p><code>volatile</code> 的主要作用包括：</p>
<ol>
<li>可见性（Visibility）：<code>volatile</code> 保证当一个线程修改了一个 <code>volatile</code> 变量的值时，其他线程能够立即看到最新的值。这避免了多个线程之间由于缓存导致的变量不一致的问题。</li>
<li>禁止指令重排序（Ordering）：<code>volatile</code> 保证指令不会被重排序，从而确保了程序执行顺序的一致性。</li>
</ol>
<p><code>volatile</code> 的底层实现原理是通过在编译器和CPU层面进行一系列的优化，包括插入内存屏障（Memory Barrier）指令来保证其作用。</p>
<p>在编译器层面，<code>volatile</code> 会生成对应的内存屏障指令，确保对 <code>volatile</code> 变量的读写操作不会被重排序。</p>
<p>在CPU层面，内存屏障指令会强制将 CPU 缓存中的数据刷回到主存，或者从主存中加载最新的数据到 CPU 缓存，从而保证了变量的可见性和禁止指令重排序。</p>
<p>需要注意的是，虽然 <code>volatile</code> 可以保证变量的可见性和禁止指令重排序，但它并不能保证原子性。如果需要在多线程环境中进行复合操作（如多次读取和写入操作）并且保持原子性，需要使用其他的同步机制，例如 <code>synchronized</code> 或者 <code>java.util.concurrent</code> 包中提供的线程安全类。</p>
<ol>
<li><strong>线程池的7个核心参数？<code>ThreadPoolExecutor</code>的饱和策略有哪些？</strong></li>
</ol>
<p>核心参数：</p>
<ul>
<li>核心线程数（corePoolSize）：线程池中一直存活的线程数量。当线程池中的线程数量小于核心线程数时，会创建新的线程来执行任务，直到达到核心线程数。</li>
<li>最大线程数（maximumPoolSize）：线程池中允许的最大线程数量。当线程池中的线程数量达到最大线程数时，新的任务会根据拒绝策略进行处理。</li>
<li>空闲线程存活时间（keepAliveTime）：线程池中的空闲线程存活时间。可以通过设置这个参数来控制线程池的动态伸缩能力。</li>
<li>任务队列（workQueue）：用于存放提交的任务的队列。</li>
<li>线程工厂（threadFactory）：用于创建线程的工厂，可以自定义线程的创建方式，如线程的命名、优先级等。</li>
<li>拒绝策略（handler）：当线程池和队列都满了时，新提交的任务会根据拒绝策略进行处理。</li>
</ul>
<p>饱和策略：</p>
<ul>
<li>AbortPolicy（默认）：直接抛出 RejectedExecutionException 异常，表示拒绝执行新的任务。</li>
<li>CallerRunsPolicy：由提交任务的线程自己执行该任务。这意味着任务提交线程会被阻塞，直到线程池中有可用的线程来执行任务。</li>
<li>DiscardPolicy：直接丢弃被拒绝的任务，不抛出异常，也不执行任务。</li>
<li>DiscardOldestPolicy：丢弃队列中最早（即最先提交的）的任务，然后尝试再次提交被拒绝的任务。</li>
</ul>
<ol>
<li><strong>JVM内存模型（程序计数器、栈、堆、方法区）？什么情况下会触发StackOverflowError和OutOfMemoryError？</strong></li>
<li><strong>垃圾回收算法（标记-清除、复制、标记-整理）及适用场景？G1收集器的特点？</strong></li>
<li><strong>强引用、软引用、弱引用、虚引用的区别及使用场景？</strong></li>
<li><strong>Java反射机制的原理及性能影响？如何通过反射获取私有字段并修改值？</strong></li>
<li><strong>动态代理的实现方式（JDK动态代理 vs CGLIB）？Spring AOP默认使用哪种？</strong></li>
<li><strong>Java 8新特性：Lambda表达式、Stream API、Optional类的核心用法？</strong></li>
</ol>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ol>
<li>对象内存布局（对象头对齐）</li>
<li>类加载过程（双亲委派破坏场景）</li>
<li>G1收集器Mixed GC过程解析</li>
<li>线上Full GC频繁的排查思路</li>
<li>内存泄漏定位（MAT使用技巧）</li>
<li>方法区演进（永久代-&gt;元空间）</li>
<li>四种引用类型与缓存设计应用</li>
<li>Arthas热更新代码原理</li>
<li>逃逸分析与栈上分配</li>
<li>ZGC颜色指针实现原理</li>
</ol>
<h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><ol>
<li>synchronized锁升级过程</li>
<li>AQS实现原理（以ReentrantLock为例）</li>
<li>ConcurrentHashMap分段锁演进</li>
<li>线程池参数动态调整方案</li>
<li>ThreadLocal内存泄漏问题</li>
<li>CompletableFuture编排异步任务</li>
<li>volatile内存屏障实现原理</li>
<li>如何设计百万级QPS的计数系统？</li>
<li>限制接口调用次数的5种方案</li>
<li>Happens-Before规则实战应用</li>
<li>异步编程的异常处理要点</li>
<li>无锁队列实现（CAS应用）</li>
</ol>
<h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><ol>
<li>循环依赖解决原理（三级缓存）</li>
<li>Spring事务失效的7种场景</li>
<li>Bean生命周期扩展点实战</li>
<li>动态代理选择策略（CGLib vs JDK）</li>
<li>SpringBoot自动配置原理</li>
<li>自定义Starter开发要点</li>
<li>如何设计可插拔的功能模块？</li>
<li>统一异常处理的最佳实践</li>
<li>配置加载优先级（命令行&gt;环境变量）</li>
<li>如何实现接口幂等性？</li>
</ol>
<h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><ol>
<li>服务注册发现AP与CP架构对比</li>
<li>熔断降级策略（滑动窗口实现）</li>
<li>分布式配置中心推拉模式对比</li>
<li>灰度发布实现方案</li>
<li>分布式链路追踪原理（Span树）</li>
<li>Seata AT模式实现原理</li>
<li>服务网格Sidecar设计理念</li>
<li>接口性能突增的限流策略</li>
<li>如何设计服务治理平台？</li>
<li>跨库事务解决方案</li>
</ol>
<h3 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h3><ol>
<li>分布式ID生成方案（雪花算法优化）</li>
<li>一致性Hash算法虚拟节点设计</li>
<li>分布式锁的三种实现方式对比</li>
<li>分布式Session解决方案</li>
<li>如何实现最终一致性（消息表+重试）</li>
<li>分库分表后分页查询方案</li>
<li>分布式事务最大努力通知型实现</li>
<li>数据同步方案（canal+MQ）</li>
<li>高并发下单系统设计（库存扣减）</li>
<li>分布式缓存更新策略（Cache Aside）</li>
<li>分布式系统时钟同步问题</li>
<li>脑裂问题解决方案</li>
</ol>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><ol>
<li>Kafka高吞吐量实现原理</li>
<li>消息丢失与重复消费解决方案</li>
<li>顺序消息实现方案</li>
<li>延迟消息实现原理</li>
<li>死信队列应用场景</li>
<li>消息堆积处理策略</li>
<li>RocketMQ事务消息流程</li>
<li>Pulsar分层存储架构优势</li>
<li>如何设计消息轨迹系统？</li>
<li>Broker选举机制对比（Kafka vs RocketMQ）</li>
</ol>
<h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><ol>
<li>动态代理在RPC中的应用</li>
<li>如何设计可扩展的序列化协议？</li>
<li>连接池管理策略（饿汉式 vs 懒汉式）</li>
<li>超时控制与重试策略设计</li>
<li>如何实现跨语言调用？</li>
<li>熔断限流在RPC层的实现</li>
<li>分布式跟踪上下文传递方案</li>
<li>服务端线程模型对比（Netty vs Tomcat）</li>
</ol>
<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><ol>
<li>设计微信朋友圈的存储架构</li>
<li>短链系统如何实现高并发写入？</li>
<li>分布式唯一ID生成方案（Snowflake优化）</li>
<li>如何设计一个分布式定时任务系统？</li>
<li>实现跨数据中心的数据同步方案</li>
<li>设计支持千万级用户的推送系统</li>
<li>微博热搜榜实时计算架构设计</li>
<li>电商库存扣减的防超卖方案</li>
<li>多级缓存架构设计（本地缓存+Redis+JVM）</li>
<li>设计支持PB级数据的日志分析系统</li>
<li>实现一个分布式配置中心</li>
<li>设计支持动态扩容的分库分表方案</li>
<li>如何设计API网关的限流熔断功能？</li>
<li>实时聊天系统的消息可靠投递方案</li>
<li>设计支持版本回滚的配置管理系统</li>
<li>实现跨语言服务调用（Thrift&#x2F;gRPC选型）</li>
<li>设计支持弹性伸缩的微服务架构</li>
<li>实现分布式Session一致性方案</li>
<li>设计一个高性能的日志采集系统</li>
<li>如何设计可追溯的操作日志系统？</li>
</ol>
<h3 id="云原生与容器化"><a href="#云原生与容器化" class="headerlink" title="云原生与容器化"></a>云原生与容器化</h3><ol>
<li>Kubernetes Pod调度策略（亲和性&#x2F;反亲和性）</li>
<li>Service Mesh中Sidecar模式的工作原理</li>
<li>Docker镜像分层原理与优化技巧</li>
<li>如何实现K8s集群的蓝绿发布？</li>
<li>Ingress与LoadBalancer的使用场景对比</li>
<li>容器网络模型（CNI）的实现原理</li>
<li>K8s中ConfigMap的热更新方案</li>
<li>如何排查容器内Java应用内存泄漏？</li>
<li>HPA自动扩缩容的指标采集方案</li>
<li>容器安全扫描与漏洞管理方案</li>
<li>有状态服务在K8s中的部署实践</li>
<li>如何实现跨集群的服务发现？</li>
<li>K8s中PV&#x2F;PVC的动态供给实现</li>
<li>容器日志收集的EFK架构实践</li>
<li>如何设计多租户的K8s集群？</li>
<li>Serverless冷启动优化方案</li>
<li>K8s中Pod的优雅终止流程</li>
<li>容器逃逸攻击的原理与防御</li>
<li>如何实现K8s集群的灾备方案？</li>
<li>基于Prometheus的自定义监控指标开发</li>
</ol>
<h3 id="架构设计模式"><a href="#架构设计模式" class="headerlink" title="架构设计模式"></a>架构设计模式</h3><ol>
<li>如何实现熔断器模式（Circuit Breaker）？</li>
<li>CQRS模式在电商系统中的应用</li>
<li>事件溯源（Event Sourcing）的优缺点分析</li>
<li>Sidecar模式在服务治理中的应用</li>
<li>网关模式中的路由策略设计</li>
<li>防腐层（Anti-Corruption Layer）设计实践</li>
<li>领域驱动设计（DDD）中的聚合根设计</li>
<li>重试模式中的指数退避算法实现</li>
<li>前端的后端模式（BFF）适用场景</li>
<li>分片模式（Sharding）的数据迁移方案</li>
<li>管道过滤器模式在ETL中的应用</li>
<li>物化视图模式优化查询性能案例</li>
<li>策略模式在支付渠道选择中的应用</li>
<li>观察者模式实现配置动态更新</li>
<li>代理模式在缓存穿透防护中的应用</li>
<li>工厂方法模式在连接池创建中的应用</li>
<li>装饰器模式实现API限流功能</li>
<li>状态模式在订单状态流转中的应用</li>
<li>组合模式实现权限树结构设计</li>
<li>模板方法模式在事务管理中的应用</li>
</ol>
<h3 id="工程实践与软技能"><a href="#工程实践与软技能" class="headerlink" title="工程实践与软技能"></a>工程实践与软技能</h3><ol>
<li>Git大型二进制文件存储优化方案</li>
<li>如何设计Code Review流程提升代码质量？</li>
<li>线上故障的标准化处理流程（SOP）</li>
<li>技术债务管理与重构策略</li>
<li>多团队协作中的接口版本管理方案</li>
<li>如何推动团队落地代码规范？</li>
<li>技术方案文档的撰写要点（含示例）</li>
<li>性能压测中的拐点分析方法</li>
<li>灰度发布中的流量染色方案</li>
<li>如何设计可观测性体系（Metrics&#x2F;Logs&#x2F;Traces）</li>
<li>研发流程中的流水线优化（CI&#x2F;CD）</li>
<li>技术选型的多维评估模型</li>
<li>遗留系统改造的渐进式方案</li>
<li>如何设计灾备演练方案？</li>
<li>容量规划中的峰值估算方法</li>
<li>生产环境调试的合规性方案</li>
<li>技术方案评审的常见陷阱</li>
<li>如何构建开发者体验（DX）体系？</li>
<li>技术TL的跨团队协作技巧</li>
<li>技术决策的沟通与推进策略</li>
</ol>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ol>
<li>用户态与内核态切换的开销来源？</li>
<li>进程间通信IPC的5种方式对比</li>
<li>虚拟内存与物理内存映射原理（页表寻址）</li>
<li>死锁的必要条件及银行家算法实现</li>
<li>自旋锁与互斥锁的使用场景差异</li>
<li>零拷贝技术实现原理（sendfile&#x2F;mmap）</li>
<li>孤儿进程与僵尸进程的区别及处理</li>
<li>CPU软中断与硬中断处理机制</li>
<li>如何用top命令分析CPU负载异常？</li>
<li>内存泄漏与内存溢出的定位方法</li>
<li>大页内存（HugePage）优化原理</li>
<li>协程与线程的调度效率差异</li>
<li>文件描述符（fd）耗尽如何处理？</li>
<li>CPU缓存行伪共享问题解决方案</li>
<li>NUMA架构下的性能调优要点</li>
<li>系统调用过程详解（int 0x80&#x2F;syscall）</li>
<li>实时操作系统与非实时系统的调度差异</li>
<li>容器与虚拟机的资源隔离原理对比</li>
<li>如何实现一个简单的线程池？</li>
<li>系统平均负载（Load Average）的深层含义</li>
</ol>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><ol>
<li>TCP三次握手与四次挥手的状态变迁图</li>
<li>TIME_WAIT状态过多如何优化？</li>
<li>HTTPS双向认证流程与中间人攻击防范</li>
<li>QUIC协议如何解决队头阻塞问题？</li>
<li>TCP拥塞控制算法（CUBIC&#x2F;BBR）</li>
<li>HTTP&#x2F;2多路复用与队头阻塞解决方案</li>
<li>Websocket握手协议与心跳机制实现</li>
<li>DNS解析过程（递归查询与迭代查询）</li>
<li>CDN动态加速与静态加速技术原理</li>
<li>如何设计一个高并发连接的服务端？</li>
<li>长连接保活策略（TCP Keepalive vs 应用层心跳）</li>
<li>网络抓包分析实战（Wireshark过滤技巧）</li>
<li>单机百万连接的实现与优化</li>
<li>HTTP Range请求与断点续传实现</li>
<li>5层协议栈中每层的典型设备</li>
<li>VLAN与VXLAN的区别及使用场景</li>
<li>如何实现UDP可靠传输？</li>
<li>MTU与MSS的关系及分片问题</li>
<li>SYN Flood攻击原理与防御方案</li>
<li>TLS1.3相比1.2的核心改进点</li>
</ol>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ol>
<li>HTTPS握手过程优化策略</li>
<li>零拷贝技术实现原理</li>
<li>百万连接服务器架构设计</li>
<li>线上CPU飙高排查流程</li>
<li>设计一个短链系统</li>
<li>接口性能优化全链路方案</li>
<li>海量数据判重方案（布隆过滤器）</li>
<li>如何设计秒杀系统？</li>
<li>大型项目代码规范落地实践</li>
<li>线上问题排查工具箱（arthas+prometheus）</li>
<li>技术方案文档编写要点</li>
</ol>
<h2 id="关键准备建议"><a href="#关键准备建议" class="headerlink" title="关键准备建议"></a>关键准备建议</h2><ol>
<li><strong>深度优先原则</strong>：每个技术栈准备3-5个可深入讲解的案例</li>
<li><strong>STAR法则训练</strong>：将项目经历整理成冲突-行动-结果的故事模板</li>
<li><strong>白板编程练习</strong>：每天1道LeetCode中等难度题（重点：链表&#x2F;树&#x2F;DFS）</li>
<li><strong>架构图绘制</strong>：准备可手绘的微服务架构图&#x2F;数据库分片图</li>
<li><strong>压力面试模拟</strong>：找同伴进行”为什么选择这个方案”的连续追问训练</li>
</ol>
<p>建议每天拿出2小时进行专题突破+1小时模拟面试。如果需要某个方向的详细解析或答案模板，可以告诉我具体方向，我会提供更深入的材料。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/8eda3648.html" rel="prev" title="Redis笔记">
                  <i class="fa fa-angle-left"></i> Redis笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/ee5ab589.html" rel="next" title="SQL进阶教程">
                  SQL进阶教程 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa-regular fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder"></span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Word count total">62k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">3:46</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>

  <script class="next-config" data-name="wavedrom" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/wavedrom.min.js","integrity":"sha256-INLAoJc6quTNfiMWkGZniYO2cxE8mHpddnLow1m6RFs="}}</script>
  <script class="next-config" data-name="wavedrom_skin" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/skins/default.js","integrity":"sha256-fduc/Zszk5ezWws2uInY/ALWVmIrmV6VTgXbsYSReFI="}}</script>
  <script src="/js/third-party/tags/wavedrom.js"></script>




  





</body>
</html>
