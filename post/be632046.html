<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"timewait7.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":true,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="深度优先原则：每个技术栈准备3-5个可深入讲解的案例 STAR法则训练：将项目经历整理成冲突-行动-结果的故事模板 白板编程练习：每天1道LeetCode中等难度题（重点：链表&#x2F;树&#x2F;DFS） 架构图绘制：准备可手绘的微服务架构图&#x2F;数据库分片图 压力面试模拟：找同伴进行”为什么选择这个方案”的连续追问训练  逻辑小白鼠试毒药100个人按灯 有100盏灯,编号依次为1,">
<meta property="og:type" content="article">
<meta property="og:title" content="八股文">
<meta property="og:url" content="http://timewait7.github.io/post/be632046.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="深度优先原则：每个技术栈准备3-5个可深入讲解的案例 STAR法则训练：将项目经历整理成冲突-行动-结果的故事模板 白板编程练习：每天1道LeetCode中等难度题（重点：链表&#x2F;树&#x2F;DFS） 架构图绘制：准备可手绘的微服务架构图&#x2F;数据库分片图 压力面试模拟：找同伴进行”为什么选择这个方案”的连续追问训练  逻辑小白鼠试毒药100个人按灯 有100盏灯,编号依次为1,">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://timewait7.github.io/post/be632046/image-20250504095140269.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-942a927a-86e4-4a01-8f52-9addd89642ff.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-df77ee15-2ff0-4ec7-8e65-e4ebb8ba88f1.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-e29a122b-db07-48b8-8289-7251032e87a1.png">
<meta property="og:image" content="http://timewait7.github.io/post/be632046/1726212535664-4bb3f3ff-704a-4706-84c8-a046a8486657.webp">
<meta property="og:image" content="http://timewait7.github.io/post/be632046/image-20250302111116621.png">
<meta property="og:image" content="http://timewait7.github.io/post/be632046/image-20250302111551681.png">
<meta property="og:image" content="http://timewait7.github.io/post/be632046/image-20250302112330725.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20240918114125.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-b7b24e25-d2dc-4457-994f-95bdb3674b8e.png">
<meta property="og:image" content="http://timewait7.github.io/post/be632046/image-20250505093121422.png">
<meta property="article:published_time" content="2025-02-25T15:09:43.000Z">
<meta property="article:modified_time" content="2025-07-19T05:57:09.540Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://timewait7.github.io/post/be632046/image-20250504095140269.png">


<link rel="canonical" href="http://timewait7.github.io/post/be632046.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://timewait7.github.io/post/be632046.html","path":"post/be632046.html","title":"八股文"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>八股文 | Hexo</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-archives"><a href="/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="Searching..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%BB%E8%BE%91"><span class="nav-number">1.</span> <span class="nav-text">逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%99%BD%E9%BC%A0%E8%AF%95%E6%AF%92%E8%8D%AF"><span class="nav-number">1.1.</span> <span class="nav-text">小白鼠试毒药</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#100%E4%B8%AA%E4%BA%BA%E6%8C%89%E7%81%AF"><span class="nav-number">1.2.</span> <span class="nav-text">100个人按灯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#100%E7%9A%84%E9%98%B6%E4%B9%98%E6%9C%89%E5%87%A0%E4%B8%AA0"><span class="nav-number">1.3.</span> <span class="nav-text">100的阶乘有几个0</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E5%A4%A9%E5%B9%B3%E6%89%BE%E6%9C%80%E8%BD%BB-%E9%87%8D%E7%9A%84%E7%90%83"><span class="nav-number">1.4.</span> <span class="nav-text">用天平找最轻&#x2F;重的球</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2017%E7%9A%842017-%E6%AC%A1%E6%96%B9%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%BD%8D%E6%95%B0"><span class="nav-number">1.5.</span> <span class="nav-text">2017的2017 次方的最后一位数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25%E5%8C%B9%E9%A9%AC%EF%BC%8C5%E4%B8%AA%E8%B7%91%E9%81%93%EF%BC%8C%E6%9C%80%E5%B0%91%E6%AF%94%E5%A4%9A%E5%B0%91%E6%AC%A1%E8%83%BD%E6%AF%94%E5%87%BA%E5%89%8D3%E5%90%8D"><span class="nav-number">1.6.</span> <span class="nav-text">25匹马，5个跑道，最少比多少次能比出前3名</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java"><span class="nav-number">2.</span> <span class="nav-text">Java</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="nav-number">2.1.</span> <span class="nav-text">Java基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">2.1.1.</span> <span class="nav-text">泛型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">2.1.2.</span> <span class="nav-text">反射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3"><span class="nav-number">2.1.3.</span> <span class="nav-text">注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">2.1.4.</span> <span class="nav-text">异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SPI%E6%9C%BA%E5%88%B6"><span class="nav-number">2.1.5.</span> <span class="nav-text">SPI机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E4%B8%AD-%E5%92%8Cequals-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">2.1.6.</span> <span class="nav-text">Java中&#x3D;&#x3D;和equals()的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%86%99equals-%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%90%8C%E6%97%B6%E9%87%8D%E5%86%99hashCode-%EF%BC%9F"><span class="nav-number">2.1.7.</span> <span class="nav-text">重写equals()时为什么要同时重写hashCode()？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4%EF%BC%9F"><span class="nav-number">2.1.8.</span> <span class="nav-text">什么是泛型擦除？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.9.</span> <span class="nav-text">异常的层次结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSPI%E6%9C%BA%E5%88%B6"><span class="nav-number">2.1.10.</span> <span class="nav-text">什么是SPI机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E7%B1%BB%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9FString%E3%80%81StringBuilder%E3%80%81StringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="nav-number">2.1.11.</span> <span class="nav-text">String类的不可变性如何实现？String、StringBuilder、StringBuffer的区别及使用场景？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%88%E4%BF%AE%E9%A5%B0%E7%B1%BB%E3%80%81%E6%96%B9%E6%B3%95%E3%80%81%E5%8F%98%E9%87%8F%E6%97%B6%E7%9A%84%E4%B8%8D%E5%90%8C%E8%A1%A8%E7%8E%B0%EF%BC%89%EF%BC%9F"><span class="nav-number">2.1.12.</span> <span class="nav-text">final关键字的作用（修饰类、方法、变量时的不同表现）？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">2.1.13.</span> <span class="nav-text">自动装箱与拆箱的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9FJava-8%E4%B8%AD%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%AF%B9%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%BD%B1%E5%93%8D%EF%BC%9F"><span class="nav-number">2.1.14.</span> <span class="nav-text">抽象类与接口的区别？Java 8中接口的默认方法和静态方法对设计的影响？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E6%80%81%EF%BC%9F%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E5%92%8C%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81%EF%BC%9F"><span class="nav-number">2.1.15.</span> <span class="nav-text">什么是多态？如何通过方法重写和方法重载实现多态？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E6%95%B0%E7%BB%84-%E9%93%BE%E8%A1%A8-%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%89%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%B9%E9%87%8F%E6%98%AF2%E7%9A%84%E5%B9%82%E6%AC%A1%EF%BC%9F"><span class="nav-number">2.1.16.</span> <span class="nav-text">HashMap的实现原理（数组+链表&#x2F;红黑树）？为什么容量是2的幂次？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Iterator%E5%92%8CListIterator%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5%EF%BC%88Fail-Fast%EF%BC%89%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="nav-number">2.1.17.</span> <span class="nav-text">Iterator和ListIterator的区别？如何实现快速失败（Fail-Fast）机制？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D%EF%BC%9F%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%A7%81%E6%9C%89%E5%AD%97%E6%AE%B5%E5%B9%B6%E4%BF%AE%E6%94%B9%E5%80%BC%EF%BC%9F"><span class="nav-number">2.1.18.</span> <span class="nav-text">Java反射机制的原理及性能影响？如何通过反射获取私有字段并修改值？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%88JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-vs-CGLIB%EF%BC%89%EF%BC%9FSpring-AOP%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8%E5%93%AA%E7%A7%8D%EF%BC%9F"><span class="nav-number">2.1.19.</span> <span class="nav-text">动态代理的实现方式（JDK动态代理 vs CGLIB）？Spring AOP默认使用哪种？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E9%9B%86%E5%90%88"><span class="nav-number">2.2.</span> <span class="nav-text">Java集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-IO"><span class="nav-number">2.3.</span> <span class="nav-text">Java IO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%B9%B6%E5%8F%91"><span class="nav-number">2.4.</span> <span class="nav-text">Java并发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF%EF%BC%9F"><span class="nav-number">2.4.1.</span> <span class="nav-text">线程安全有哪些实现思路？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8D%8F%E4%BD%9C%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">2.4.2.</span> <span class="nav-text">线程有哪些协作方式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wait%E5%92%8Csleep%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.4.3.</span> <span class="nav-text">wait和sleep的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JUC%E6%A1%86%E6%9E%B6%E4%B8%BB%E8%A6%81%E5%8C%85%E6%8B%AC%E5%93%AA%E5%87%A0%E9%83%A8%E5%88%86"><span class="nav-number">2.4.4.</span> <span class="nav-text">JUC框架主要包括哪几部分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFCAS%EF%BC%9FCAS%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">2.4.5.</span> <span class="nav-text">什么是CAS？CAS存在哪些问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">2.4.6.</span> <span class="nav-text">AQS的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%846%E7%A7%8D%E7%8A%B6%E6%80%81%E5%8F%8A%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E6%9D%A1%E4%BB%B6"><span class="nav-number">2.4.7.</span> <span class="nav-text">线程的6种状态及状态转换条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%847%E4%B8%AA%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%EF%BC%9FThreadPoolExecutor%E7%9A%84%E9%A5%B1%E5%92%8C%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">2.4.8.</span> <span class="nav-text">线程池的7个核心参数？ThreadPoolExecutor的饱和策略有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sleep-%E5%92%8C-wait-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.4.9.</span> <span class="nav-text">sleep() 和 wait() 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized%E5%92%8CReentrantLock%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.4.10.</span> <span class="nav-text">synchronized和ReentrantLock的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%88%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%EF%BC%89%EF%BC%9F%E8%83%BD%E5%90%A6%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9F"><span class="nav-number">2.4.11.</span> <span class="nav-text">volatile关键字的作用（可见性、禁止指令重排）？能否保证原子性？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B"><span class="nav-number">2.4.12.</span> <span class="nav-text">synchronized锁升级过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E4%BB%A5ReentrantLock%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="nav-number">2.4.13.</span> <span class="nav-text">AQS实现原理（以ReentrantLock为例）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMap%E5%88%86%E6%AE%B5%E9%94%81%E6%BC%94%E8%BF%9B"><span class="nav-number">2.4.14.</span> <span class="nav-text">ConcurrentHashMap分段锁演进</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal%E5%8E%9F%E7%90%86%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98"><span class="nav-number">2.4.15.</span> <span class="nav-text">ThreadLocal原理与内存泄漏问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Happens-Before%E8%A7%84%E5%88%99%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8"><span class="nav-number">2.4.16.</span> <span class="nav-text">Happens-Before规则实战应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM"><span class="nav-number">2.5.</span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E3%80%81%E6%A0%88%E3%80%81%E5%A0%86%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%89%EF%BC%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E8%A7%A6%E5%8F%91StackOverflowError%E5%92%8COutOfMemoryError%EF%BC%9F"><span class="nav-number">2.5.1.</span> <span class="nav-text">JVM内存模型（程序计数器、栈、堆、方法区）？什么情况下会触发StackOverflowError和OutOfMemoryError？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%88%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%EF%BC%89%E5%8F%8A%E5%85%B6%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%B1%BB%E9%87%8D%E5%A4%8D%E5%8A%A0%E8%BD%BD%EF%BC%9F%E5%A6%82%E4%BD%95%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="nav-number">2.5.2.</span> <span class="nav-text">类加载机制（双亲委派模型）及其如何避免类重复加载？如何破坏双亲委派模型？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%EF%BC%88%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E3%80%81%E5%A4%8D%E5%88%B6%E3%80%81%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%EF%BC%89%E5%8F%8A%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9FG1%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="nav-number">2.5.3.</span> <span class="nav-text">垃圾回收算法（标记-清除、复制、标记-整理）及适用场景？G1收集器的特点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="nav-number">2.5.4.</span> <span class="nav-text">强引用、软引用、弱引用、虚引用的区别及使用场景？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E4%B8%8AFull-GC%E9%A2%91%E7%B9%81%E7%9A%84%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF"><span class="nav-number">2.5.5.</span> <span class="nav-text">线上Full GC频繁的排查思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E6%BC%94%E8%BF%9B%EF%BC%88%E6%B0%B8%E4%B9%85%E4%BB%A3-%E5%85%83%E7%A9%BA%E9%97%B4%EF%BC%89"><span class="nav-number">2.5.6.</span> <span class="nav-text">方法区演进（永久代-&gt;元空间）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E4%B8%8E%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D"><span class="nav-number">2.5.7.</span> <span class="nav-text">逃逸分析与栈上分配</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring"><span class="nav-number">3.</span> <span class="nav-text">Spring</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E8%A7%A3%E5%86%B3%E5%8E%9F%E7%90%86"><span class="nav-number">3.1.</span> <span class="nav-text">循环依赖解决原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FactoryBean-%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="nav-number">3.2.</span> <span class="nav-text">FactoryBean 的作用与应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BeanFactoryPostProcessor-%E5%92%8C-BeanPostProcessor-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.3.</span> <span class="nav-text">BeanFactoryPostProcessor 和 BeanPostProcessor 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%89%A9%E5%B1%95%E7%82%B9%E5%AE%9E%E6%88%98"><span class="nav-number">3.4.</span> <span class="nav-text">Bean生命周期扩展点实战</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86"><span class="nav-number">3.5.</span> <span class="nav-text">SpringBoot自动配置原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89Starter%E5%BC%80%E5%8F%91%E8%A6%81%E7%82%B9"><span class="nav-number">3.6.</span> <span class="nav-text">自定义Starter开发要点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">3.7.</span> <span class="nav-text">统一异常处理的最佳实践</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%89"><span class="nav-number">3.8.</span> <span class="nav-text">配置加载优先级（命令行&gt;环境变量）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-AOP-%E5%92%8C-AspectJ-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">3.9.</span> <span class="nav-text">Spring AOP 和 AspectJ 有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8%E3%80%81%E6%8B%A6%E6%88%AA%E5%99%A8%E3%80%81AOP%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%AE%9E%E8%B7%B5"><span class="nav-number">3.10.</span> <span class="nav-text">过滤器、拦截器、AOP的区别与实践</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">3.11.</span> <span class="nav-text">注解的实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MapperScan-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">3.12.</span> <span class="nav-text">@MapperScan 的实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Autowired-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">3.13.</span> <span class="nav-text">@Autowired 的实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringMVC-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">3.14.</span> <span class="nav-text">SpringMVC 工作流程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="nav-number">4.</span> <span class="nav-text">数据存储</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL"><span class="nav-number">4.1.</span> <span class="nav-text">MySQL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">4.1.1.</span> <span class="nav-text">查询语句的执行顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84"><span class="nav-number">4.1.2.</span> <span class="nav-text">InnoDB索引结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88MongoDB%E4%BD%BF%E7%94%A8B%E6%A0%91%E8%80%8CMySQL%E7%94%A8B-%E6%A0%91"><span class="nav-number">4.1.3.</span> <span class="nav-text">为什么MongoDB使用B树而MySQL用B+树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-%E6%A0%91%E8%8A%82%E7%82%B9%E5%88%86%E8%A3%82%E7%9A%84%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B"><span class="nav-number">4.1.4.</span> <span class="nav-text">B+树节点分裂的具体过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EXPLAIN-%E5%AD%97%E6%AE%B5%E8%AF%B4%E6%98%8E"><span class="nav-number">4.1.5.</span> <span class="nav-text">EXPLAIN 字段说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B"><span class="nav-number">4.1.6.</span> <span class="nav-text">覆盖索引与最左前缀原则实战案例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="nav-number">4.1.7.</span> <span class="nav-text">慢查询优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88InnoDB%E4%B8%8D%E4%BF%9D%E5%AD%98%E8%A1%A8%E7%9A%84%E6%80%BB%E8%A1%8C%E6%95%B0"><span class="nav-number">4.1.8.</span> <span class="nav-text">为什么InnoDB不保存表的总行数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7%E5%92%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">4.1.9.</span> <span class="nav-text">解释一下事务的基本特性和隔离级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB"><span class="nav-number">4.1.10.</span> <span class="nav-text">InnoDB如何解决幻读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB%E5%92%8CMyISAM%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.1.11.</span> <span class="nav-text">InnoDB和MyISAM的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E7%B4%A2%E5%BC%95%E4%BC%9A%E5%A4%B1%E6%95%88%E6%88%96%E9%80%89%E9%94%99%E7%B4%A2%E5%BC%95"><span class="nav-number">4.1.12.</span> <span class="nav-text">为什么有时索引会失效或选错索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2"><span class="nav-number">4.1.13.</span> <span class="nav-text">如何优化查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E5%8F%AA%E6%9F%A5%E8%AF%A2%E4%B8%80%E8%A1%8C%E4%BD%86%E6%98%AF%E5%BE%88%E6%85%A2"><span class="nav-number">4.1.14.</span> <span class="nav-text">为什么有时只查询一行但是很慢</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%85%A2SQL%E4%BC%98%E5%8C%96%E5%85%A8%E6%B5%81%E7%A8%8B"><span class="nav-number">4.1.15.</span> <span class="nav-text">慢SQL优化全流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis"><span class="nav-number">4.2.</span> <span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB%EF%BC%9F%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E9%AB%98%E5%B9%B6%E5%8F%91%EF%BC%9F"><span class="nav-number">4.2.1.</span> <span class="nav-text">Redis为什么快？单线程如何处理高并发？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-%E9%9B%AA%E5%B4%A9-%E5%87%BB%E7%A9%BF%EF%BC%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">4.2.2.</span> <span class="nav-text">解释一下缓存穿透&#x2F;雪崩&#x2F;击穿，对应的解决方案是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB%E5%92%8CAOF%E6%8C%81%E4%B9%85%E5%8C%96%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8A%A3%E5%AF%B9%E6%AF%94"><span class="nav-number">4.2.3.</span> <span class="nav-text">RDB和AOF持久化原理及优劣对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%83%ADKey%E9%97%AE%E9%A2%98"><span class="nav-number">4.2.4.</span> <span class="nav-text">什么是热Key问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E4%BA%8B%E5%8A%A1%E4%B8%8EMySQL%E4%BA%8B%E5%8A%A1%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.5.</span> <span class="nav-text">Redis事务与MySQL事务有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E6%BC%94%E8%BF%9B%E8%BF%87%E7%A8%8B"><span class="nav-number">4.2.6.</span> <span class="nav-text">使用Redis实现分布式锁的演进过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5%E5%92%8C%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.7.</span> <span class="nav-text">全量同步和增量同步的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E4%B8%8ELRU%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.2.8.</span> <span class="nav-text">内存淘汰策略与LRU实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E5%92%8CMySQL%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.9.</span> <span class="nav-text">Redis和MySQL的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E5%92%8Cmemchahed%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.10.</span> <span class="nav-text">Redis和memchahed的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">4.2.11.</span> <span class="nav-text">Redis IO多路复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-6-0-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">4.2.12.</span> <span class="nav-text">Redis 6.0 多线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ElasticSearch"><span class="nav-number">4.3.</span> <span class="nav-text">ElasticSearch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MongoDB"><span class="nav-number">4.4.</span> <span class="nav-text">MongoDB</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">5.</span> <span class="nav-text">消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka"><span class="nav-number">5.1.</span> <span class="nav-text">Kafka</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Kafka-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%90%9E%E5%90%90%E9%87%8F%EF%BC%9F"><span class="nav-number">5.1.1.</span> <span class="nav-text">Kafka 为什么能实现高吞吐量？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A-Kafka-%E4%B8%AD-Topic%E3%80%81Partition%E3%80%81Replica-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">5.1.2.</span> <span class="nav-text">解释 Kafka 中 Topic、Partition、Replica 的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Producer-%E7%9A%84-acks-%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F%E5%88%86%E5%88%AB%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%E5%90%AB%E4%B9%89%EF%BC%9F"><span class="nav-number">5.1.3.</span> <span class="nav-text">Producer 的 acks 参数有哪几种？分别代表什么含义？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A-Consumer-Group-%E5%92%8C-Rebalance-%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%82"><span class="nav-number">5.1.4.</span> <span class="nav-text">解释 Consumer Group 和 Rebalance 的概念。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kafka-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1%EF%BC%9F"><span class="nav-number">5.1.5.</span> <span class="nav-text">Kafka 如何保证消息不丢失？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A-Kafka-%E7%9A%84-ISR-%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%9C%A8-Leader-%E9%80%89%E4%B8%BE%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%82"><span class="nav-number">5.1.6.</span> <span class="nav-text">解释 Kafka 的 ISR 机制及其在 Leader 选举中的作用。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kafka-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-Exactly-Once-%E8%AF%AD%E4%B9%89%EF%BC%9F"><span class="nav-number">5.1.7.</span> <span class="nav-text">Kafka 如何实现 Exactly-Once 语义？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kafka-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7%EF%BC%9F"><span class="nav-number">5.1.8.</span> <span class="nav-text">Kafka 如何保证消息的顺序性？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kafka-%E4%B8%AD-Zookeeper-%E5%92%8C-KRaft-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88-Kafka-%E8%A6%81%E5%8E%BB-Zookeeper-%E5%8C%96%EF%BC%9F"><span class="nav-number">5.1.9.</span> <span class="nav-text">Kafka 中 Zookeeper 和 KRaft 的区别？为什么 Kafka 要去 Zookeeper 化？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Consumer-Lag%EF%BC%9F%E5%A6%82%E4%BD%95%E7%9B%91%E6%8E%A7%E5%92%8C%E5%A4%84%E7%90%86-Lag%EF%BC%9F"><span class="nav-number">5.1.10.</span> <span class="nav-text">什么是 Consumer Lag？如何监控和处理 Lag？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kafka%E4%B8%BB%E8%A6%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A%E5%BC%82%E6%AD%A5%E3%80%81%E5%89%8A%E5%B3%B0%E3%80%81%E8%A7%A3%E8%80%A6"><span class="nav-number">5.1.11.</span> <span class="nav-text">kafka主要应用场景：异步、削峰、解耦</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="nav-number">6.</span> <span class="nav-text">微服务</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="nav-number">7.</span> <span class="nav-text">分布式系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFCAP"><span class="nav-number">7.1.</span> <span class="nav-text">什么是CAP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFBASE"><span class="nav-number">7.2.</span> <span class="nav-text">什么是BASE</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1"><span class="nav-number">8.</span> <span class="nav-text">系统设计</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%91%E5%8E%9F%E7%94%9F%E4%B8%8E%E5%AE%B9%E5%99%A8%E5%8C%96"><span class="nav-number">9.</span> <span class="nav-text">云原生与容器化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">10.</span> <span class="nav-text">架构设计模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5%E4%B8%8E%E8%BD%AF%E6%8A%80%E8%83%BD"><span class="nav-number">11.</span> <span class="nav-text">工程实践与软技能</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80"><span class="nav-number">12.</span> <span class="nav-text">计算机基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">12.1.</span> <span class="nav-text">操作系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="nav-number">12.2.</span> <span class="nav-text">计算机网络</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">13.</span> <span class="nav-text">其他</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/">
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="Back to top">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://timewait7.github.io/post/be632046.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="八股文 | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          八股文
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-02-25 23:09:43" itemprop="dateCreated datePublished" datetime="2025-02-25T23:09:43+08:00">2025-02-25</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>35k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>2:06</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><ol>
<li><strong>深度优先原则</strong>：每个技术栈准备3-5个可深入讲解的案例</li>
<li><strong>STAR法则训练</strong>：将项目经历整理成冲突-行动-结果的故事模板</li>
<li><strong>白板编程练习</strong>：每天1道LeetCode中等难度题（重点：链表&#x2F;树&#x2F;DFS）</li>
<li><strong>架构图绘制</strong>：准备可手绘的微服务架构图&#x2F;数据库分片图</li>
<li><strong>压力面试模拟</strong>：找同伴进行”为什么选择这个方案”的连续追问训练</li>
</ol>
<h1 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h1><h2 id="小白鼠试毒药"><a href="#小白鼠试毒药" class="headerlink" title="小白鼠试毒药"></a>小白鼠试毒药</h2><h2 id="100个人按灯"><a href="#100个人按灯" class="headerlink" title="100个人按灯"></a>100个人按灯</h2><blockquote>
<p>有100盏灯,编号依次为1,2,3…100,电灯全部关着。现在来了100个人,第一个人把所有的灯开关按下；第二个人隔一个灯按下（2,4,6…）；第三个人每隔两个灯按下（3,6,9…）.第100个人隔99个灯按下（100）,最后还有几盏灯，那几盏灯亮着？</p>
</blockquote>
<h2 id="100的阶乘有几个0"><a href="#100的阶乘有几个0" class="headerlink" title="100的阶乘有几个0"></a>100的阶乘有几个0</h2><p>100的阶乘（100!）有多少个末尾的零，可以通过计算其因式分解中10的因子个数来确定，因为末尾的零是由2和5相乘得到的。</p>
<p>首先，我们将100!进行因式分解。100!表示从1乘到100的连续整数的乘积，可以写成：</p>
<p>100! &#x3D; 1 × 2 × 3 × 4 × … × 99 × 100</p>
<p>接下来，我们观察乘法中每一项的因子中2和5的个数。</p>
<p>在100!中，偶数的因子2的个数明显比5多，因为每隔一个数就会有一个偶数出现，而偶数都包含因子2。所以，我们只需要关注100!中5的因子个数。</p>
<p>在100!中，5、10、15、20、…、95、100这些数都包含因子5，共有20个数。而25、50、75、100这些数包含两个因子5，所以需要将其计算在内。</p>
<p>因此，100!中总共有20 + 4 &#x3D; 24个因子5。</p>
<p>综上所述，100!末尾共有24个零。</p>
<h2 id="用天平找最轻-重的球"><a href="#用天平找最轻-重的球" class="headerlink" title="用天平找最轻&#x2F;重的球"></a>用天平找最轻&#x2F;重的球</h2><blockquote>
<p>8个球，一个轻，天平2次找出来</p>
</blockquote>
<p>第一次称重：将任意三个球放在天平的一边，再将另外三个球放在另一边，剩下的两个球不放在天平上。如果天平平衡，则轻的球在剩下的两个球中，可以直接通过目测或者手感来找出轻的球。如果天平不平衡，那么轻的球一定在轻的那一边。</p>
<p>第二次称重：将轻的那一边的三个球中的两个球放在天平的一边，将剩下的一个球放在另一边。如果天平平衡，则剩下的那个球就是轻的球；如果天平不平衡，那么轻的球就是轻的那一边的球。</p>
<h2 id="2017的2017-次方的最后一位数"><a href="#2017的2017-次方的最后一位数" class="headerlink" title="2017的2017 次方的最后一位数"></a>2017的2017 次方的最后一位数</h2><p>计算2017的2017次方的最后一位数，可以使用数论中的数学性质来简化计算。根据数学性质，一个整数的末位数只和该整数的个位数有关，而与其他位数无关。</p>
<p>首先，我们观察2017的个位数是什么。2017除以10的余数是7，因此2017的个位数是7。</p>
<p>接下来，我们观察7的幂的个位数的规律。我们可以列举一些7的幂，看看个位数的变化：</p>
<p>7^1 &#x3D; 7 7^2 &#x3D; 49 7^3 &#x3D; 343 7^4 &#x3D; 2401 7^5 &#x3D; 16807 …</p>
<p>可以观察到，7的幂的个位数会在7、9、3、1这四个数字之间循环。具体地，7^1的个位数是7，7^2的个位数是9，7^3的个位数是3，7^4的个位数是1，7^5的个位数又是7，以此类推。</p>
<p>因此，我们可以利用这个规律来简化计算2017的2017次方的个位数。2017除以4的余数是1，所以2017的2017次方的个位数也是1。</p>
<p>综上所述，2017的2017次方的最后一位数是1。</p>
<h2 id="25匹马，5个跑道，最少比多少次能比出前3名"><a href="#25匹马，5个跑道，最少比多少次能比出前3名" class="headerlink" title="25匹马，5个跑道，最少比多少次能比出前3名"></a>25匹马，5个跑道，最少比多少次能比出前3名</h2><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h3 id="SPI机制"><a href="#SPI机制" class="headerlink" title="SPI机制"></a>SPI机制</h3><h3 id="Java中-和equals-的区别是什么？"><a href="#Java中-和equals-的区别是什么？" class="headerlink" title="Java中==和equals()的区别是什么？"></a>Java中<code>==</code>和<code>equals()</code>的区别是什么？</h3><p><code>==</code> 用于比较基本数据类型的值或对象引用的内存地址，<code>equals</code> 用户比较对象内容。</p>
<h3 id="重写equals-时为什么要同时重写hashCode-？"><a href="#重写equals-时为什么要同时重写hashCode-？" class="headerlink" title="重写equals()时为什么要同时重写hashCode()？"></a>重写<code>equals()</code>时为什么要同时重写<code>hashCode()</code>？</h3><p>Java 规定：</p>
<ul>
<li>**若 <code>obj1.equals(obj2) == true</code>，则 <code>obj1.hashCode() == obj2.hashCode()</code>**。</li>
<li>**若 <code>obj1.hashCode() != obj2.hashCode()</code>，则 <code>obj1.equals(obj2)</code> 必须为 <code>false</code>**。</li>
</ul>
<p>如果只重写了 <code>equals</code> 方法，会导致逻辑相等的两个对象 <code>hashCode</code> 不等。</p>
<h3 id="什么是泛型擦除？"><a href="#什么是泛型擦除？" class="headerlink" title="什么是泛型擦除？"></a>什么是泛型擦除？</h3><h3 id="异常的层次结构"><a href="#异常的层次结构" class="headerlink" title="异常的层次结构"></a>异常的层次结构</h3><p><code>Throwable</code>：所有异常和错误的超类</p>
<p><code>Error</code>：</p>
<p><code>Exception</code>：</p>
<p><code>RuntimeException</code>：</p>
<p><code>checked exceptions</code>：</p>
<p><code>unchecked exceptions</code>：</p>
<h3 id="什么是SPI机制"><a href="#什么是SPI机制" class="headerlink" title="什么是SPI机制"></a>什么是SPI机制</h3><h3 id="String类的不可变性如何实现？String、StringBuilder、StringBuffer的区别及使用场景？"><a href="#String类的不可变性如何实现？String、StringBuilder、StringBuffer的区别及使用场景？" class="headerlink" title="String类的不可变性如何实现？String、StringBuilder、StringBuffer的区别及使用场景？"></a>String类的不可变性如何实现？<code>String</code>、<code>StringBuilder</code>、<code>StringBuffer</code>的区别及使用场景？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The identifier of the encoding used to encode the bytes in &#123;<span class="doctag">@code</span> value&#125;. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span> coder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>value</code> 数组被声明为 <code>final</code>，这意味着 <code>value</code> 数组初始化之后就不能再引用其它数组。而 <code>String</code> 内部没有改变 <code>value</code> 数组内容的方法，这就保证了 <code>String</code> 不可变性。</p>
<table>
<thead>
<tr>
<th align="left"><strong>类名</strong></th>
<th align="left"><strong>核心优势</strong></th>
<th align="left"><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>String</code></td>
<td align="left">不可变性、线程安全</td>
<td align="left">常量定义、少量不可变字符串操作</td>
</tr>
<tr>
<td align="left"><code>StringBuilder</code></td>
<td align="left">高性能、单线程优化</td>
<td align="left">单线程频繁修改字符串内容</td>
</tr>
<tr>
<td align="left"><code>StringBuffer</code></td>
<td align="left">线程安全</td>
<td align="left">多线程环境下的字符串操作</td>
</tr>
</tbody></table>
<h3 id="final关键字的作用（修饰类、方法、变量时的不同表现）？"><a href="#final关键字的作用（修饰类、方法、变量时的不同表现）？" class="headerlink" title="final关键字的作用（修饰类、方法、变量时的不同表现）？"></a><code>final</code>关键字的作用（修饰类、方法、变量时的不同表现）？</h3><ul>
<li>修饰变量</li>
<li>修饰方法：方法不能被重写或覆盖</li>
<li>修饰类：类不能被继承</li>
</ul>
<table>
<thead>
<tr>
<th align="left"><strong>场景</strong></th>
<th align="left"><strong>目的</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>变量</strong></td>
<td align="left">定义常量，确保数据不可变（如配置参数、数学常量）</td>
</tr>
<tr>
<td align="left"><strong>方法</strong></td>
<td align="left">防止关键方法被篡改（如模板方法模式中的固定步骤）</td>
</tr>
<tr>
<td align="left"><strong>类</strong></td>
<td align="left">保证类的完整性（如<code>String</code>类不可变，<code>工具类</code>禁止继承）</td>
</tr>
<tr>
<td align="left"><strong>并发编程</strong></td>
<td align="left">通过不可变对象（<code>final</code>修饰字段）简化线程安全设计</td>
</tr>
</tbody></table>
<h3 id="自动装箱与拆箱的原理"><a href="#自动装箱与拆箱的原理" class="headerlink" title="自动装箱与拆箱的原理"></a>自动装箱与拆箱的原理</h3><p><strong>自动装箱</strong>：编译器调用包装类的静态方法 <code>valueOf()</code> 实现转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源代码</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">boxedNum</span> <span class="operator">=</span> num; <span class="comment">// 自动装箱</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后代码</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">boxedNum</span> <span class="operator">=</span> Integer.valueOf(num); <span class="comment">// 实际调用valueOf方法</span></span><br></pre></td></tr></table></figure>

<p><strong><code>valueOf()</code> 的缓存优化</strong>：</p>
<p>Java 对部分包装类（如 <code>Integer</code>、<code>Long</code>）缓存了常用范围的值（**-128 ~ 127**），避免重复创建对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>验证缓存机制</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">// true（使用缓存对象）</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.println(c == d); <span class="comment">// false（超出缓存范围，新建对象）</span></span><br></pre></td></tr></table></figure>



<p><strong>自动拆箱</strong>：编译器调用包装类的实例方法（如 <code>intValue()</code>）实现转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源代码</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">boxedNum</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> boxedNum; <span class="comment">// 自动拆箱</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后代码</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">boxedNum</span> <span class="operator">=</span> Integer.valueOf(<span class="number">20</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> boxedNum.intValue(); <span class="comment">// 实际调用intValue方法</span></span><br></pre></td></tr></table></figure>

<p><strong>空指针风险</strong>：</p>
<p>若包装类对象为 <code>null</code>，拆箱时会抛出 <code>NullPointerException</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">boxedNum</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> boxedNum; <span class="comment">// 运行时抛出NullPointerException</span></span><br></pre></td></tr></table></figure>



<p><strong>最佳实践</strong>：</p>
<ul>
<li><strong>优先使用基本类型</strong>：在性能敏感场景（如循环、高频计算）中避免装箱。</li>
<li><strong>显式处理<code>null</code>值</strong>：拆箱前检查包装类对象是否为<code>null</code>。</li>
<li><strong>注意<code>==</code>比较</strong>：包装类的<code>==</code>比较的是对象地址，应使用<code>equals()</code>或先拆箱再比较。</li>
</ul>
<h3 id="抽象类与接口的区别？Java-8中接口的默认方法和静态方法对设计的影响？"><a href="#抽象类与接口的区别？Java-8中接口的默认方法和静态方法对设计的影响？" class="headerlink" title="抽象类与接口的区别？Java 8中接口的默认方法和静态方法对设计的影响？"></a>抽象类与接口的区别？Java 8中接口的默认方法和静态方法对设计的影响？</h3><table>
<thead>
<tr>
<th align="left"><strong>场景</strong></th>
<th align="left"><strong>选择</strong></th>
<th align="left"><strong>理由</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">需要共享代码或状态</td>
<td align="left"><strong>抽象类</strong></td>
<td align="left">抽象类可定义非静态成员变量和构造器，适合复用代码逻辑</td>
</tr>
<tr>
<td align="left">定义行为规范，无需共享状态</td>
<td align="left"><strong>接口</strong></td>
<td align="left">接口更轻量，支持多继承，适合定义能力（如 <code>Comparable</code>、<code>Serializable</code>）</td>
</tr>
<tr>
<td align="left">需要逐步扩展功能</td>
<td align="left"><strong>接口 + 默认方法</strong></td>
<td align="left">默认方法支持向后兼容，避免破坏现有代码</td>
</tr>
<tr>
<td align="left">提供工具方法</td>
<td align="left"><strong>接口 + 静态方法</strong></td>
<td align="left">替代工具类，提高内聚性（如 <code>Stream</code> 接口的工厂方法）</td>
</tr>
</tbody></table>
<h3 id="什么是多态？如何通过方法重写和方法重载实现多态？"><a href="#什么是多态？如何通过方法重写和方法重载实现多态？" class="headerlink" title="什么是多态？如何通过方法重写和方法重载实现多态？"></a>什么是多态？如何通过方法重写和方法重载实现多态？</h3><p>多态分为<strong>编译时多态（静态多态）</strong>和<strong>运行时多态（动态多态）</strong>，主要通过<strong>方法重载（Overload）</strong>和<strong>方法重写（Override）</strong>实现。</p>
<table>
<thead>
<tr>
<th align="left"><strong>类型</strong></th>
<th align="left"><strong>实现方式</strong></th>
<th align="left"><strong>核心特点</strong></th>
<th align="left"><strong>示例场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>编译时多态</strong></td>
<td align="left">方法重载（Overload）</td>
<td align="left">在编译时根据参数类型和数量确定调用的方法</td>
<td align="left">同一方法名处理不同类型数据</td>
</tr>
<tr>
<td align="left"><strong>运行时多态</strong></td>
<td align="left">方法重写（Override）</td>
<td align="left">在运行时根据对象实际类型确定调用的方法（动态绑定）</td>
<td align="left">子类扩展或修改父类行为</td>
</tr>
</tbody></table>
<p>运行时多态的核心机制：</p>
<ul>
<li><strong>动态绑定</strong>：JVM在运行时根据<strong>对象的实际类型</strong>（而非变量类型）确定调用哪个方法。</li>
<li><strong>依赖继承与向上转型</strong>：通过父类引用指向子类对象（<code>Animal dog = new Dog()</code>），实现多态行为。</li>
</ul>
<h3 id="HashMap的实现原理（数组-链表-红黑树）？为什么容量是2的幂次？"><a href="#HashMap的实现原理（数组-链表-红黑树）？为什么容量是2的幂次？" class="headerlink" title="HashMap的实现原理（数组+链表&#x2F;红黑树）？为什么容量是2的幂次？"></a>HashMap的实现原理（数组+链表&#x2F;红黑树）？为什么容量是2的幂次？</h3><ul>
<li>计算hash值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); // 减少碰撞</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>索引位置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (n - 1) &amp; hash</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>HashMap</code> 数组长度 n 为什么总是 2 的幂方</p>
<ol>
<li><p><strong>提高计算桶下标效率</strong></p>
<p><strong>按位与替代取模</strong>：当容量为2的幂次时，<code>(n - 1) &amp; hash</code>等价于<code>hash % n</code>，但位运算效率远高于取模。</p>
</li>
<li><p><strong>均匀分布元素</strong></p>
<p><strong>全低位参与计算</strong>：<code>n-1</code>的二进制全为1（如<code>15=01111</code>），确保哈希值的所有低位都参与桶下标计算，减少哈希冲突。</p>
</li>
<li><p><strong>优化扩容性能</strong></p>
<p><strong>扩容时元素迁移</strong>：新桶位置仅需判断哈希值下一个高位是0还是1。0留在原桶，1移到新桶（原索引+原容量）</p>
</li>
</ol>
</li>
<li><p><code>HashMap</code> 和 <code>HashTable</code> 的区别</p>
<table>
<thead>
<tr>
<th></th>
<th><code>HashMap</code></th>
<th><code>HashTable</code></th>
</tr>
</thead>
<tbody><tr>
<td>线程安全性</td>
<td>非线程安全</td>
<td>线程安全</td>
</tr>
<tr>
<td><code>null</code> 键值对的处理</td>
<td><code>HashMap</code> 允许使用 <code>null</code> 作为键和值</td>
<td><code>Hashtable</code> 不允许键或值为 <code>nul</code>l，这是因为 <code>Hashtable</code> 使用 <code>null</code> 作为结束标志</td>
</tr>
<tr>
<td>迭代顺序</td>
<td><code>HashMap</code> 的迭代顺序不确定</td>
<td><code>Hashtable</code> 的迭代顺序是按照插入顺序来的，<code>Hashtable</code> 使用了线性探测法</td>
</tr>
</tbody></table>
</li>
</ul>
<p>在 <code>Java 1.7</code>，<code>HashMap</code> 扩容后，同一条链表上的元素需要通过重新计算索引位置后，才能知道会被放在新数组的哪个位置。</p>
<p>而在 <code>Java 1.8</code> 中，不需要重新计算索引位置，只需判断之前计算得到的 <code>hashCode</code> 的下一位是 0 还是 1，即可知道在新数组中的位置。这里优化包括：</p>
<ul>
<li>省去重新计算索引位置的时间；</li>
<li>旧数组每个索引位置下的链表或红黑树中的节点会比较均匀地重新划分到新数组中。</li>
</ul>
<p>并且在 <code>Java 1.7</code> 中，<code>HashMap</code> 插入数据时是头插法，这样在 <code>rehash</code> 时，如果数据被分到同一个桶下，数据的相对位置会倒置（可能会导致死循环）；而 <code>Java 1.8</code> 采用的尾插法，<code>rehash</code> 不会导致倒置。</p>
<p><strong>Q：ConcurrentHashMap在JDK 7和JDK 8中的实现差异？</strong></p>
<ul>
<li>数据结构：Java 1.7 中的 <code>ConcurrentHashMap</code> 使用了数组+链表的方式来存储键值对，而 Java 1.8 中的 <code>ConcurrentHashMap</code> 则引入了红黑树，用于优化链表过长的情况，提高查找、插入和删除操作的性能。</li>
<li>加锁方式：Java 1.7 中的 <code>ConcurrentHashMap</code> 使用了分段锁（Segment）的机制来实现线程安全性，每个分段都有自己的锁。而 Java 1.8 中的 <code>ConcurrentHashMap</code> 则使用了基于 CAS（Compare and Swap）的算法来实现线程安全性，取代了分段锁的实现。</li>
<li>并发度：Java 1.8 中的 <code>ConcurrentHashMap</code> 支持更高的并发度，因为它不再使用分段锁，而是使用 CAS 算法，从而减少了锁的粒度和竞争，提供了更好的并发性能</li>
<li>扩容：Java 1.7 中的 <code>ConcurrentHashMap</code> 在扩容时采用的是分段锁的方式，每次只扩容一个段，而 Java 1.8 中的 <code>ConcurrentHashMap</code> 则采用了全局锁的方式，可以同时进行多个段的扩容，从而更快地完成扩容操作。</li>
</ul>
<h3 id="Iterator和ListIterator的区别？如何实现快速失败（Fail-Fast）机制？"><a href="#Iterator和ListIterator的区别？如何实现快速失败（Fail-Fast）机制？" class="headerlink" title="Iterator和ListIterator的区别？如何实现快速失败（Fail-Fast）机制？"></a>Iterator和ListIterator的区别？如何实现快速失败（Fail-Fast）机制？</h3><table>
<thead>
<tr>
<th align="left"><strong>维度</strong></th>
<th align="left"><strong>Iterator</strong></th>
<th align="left"><strong>ListIterator</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>遍历方向</strong></td>
<td align="left">单向（只能从前往后遍历）</td>
<td align="left">双向（支持从前往后或从后往前遍历）</td>
</tr>
<tr>
<td align="left"><strong>修改操作</strong></td>
<td align="left">仅支持删除（<code>remove()</code>）</td>
<td align="left">支持添加（<code>add()</code>）、删除（<code>remove()</code>）、替换（<code>set()</code>）</td>
</tr>
<tr>
<td align="left"><strong>索引访问</strong></td>
<td align="left">不支持</td>
<td align="left">支持获取当前索引（<code>nextIndex()</code>、<code>previousIndex()</code>）</td>
</tr>
<tr>
<td align="left"><strong>适用范围</strong></td>
<td align="left">所有集合（Collection）</td>
<td align="left">仅限列表（List，如ArrayList、LinkedList）</td>
</tr>
</tbody></table>
<p><strong>避免快速失败的方案</strong></p>
<ul>
<li><p><strong>使用迭代器自身的方法修改集合</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">    <span class="keyword">if</span> (s.equals(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">        it.remove(); <span class="comment">// 通过迭代器删除，不会触发异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用并发集合类</strong>（如<code>CopyOnWriteArrayList</code>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>));</span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">list.add(<span class="string">&quot;D&quot;</span>); <span class="comment">// 不会触发异常（迭代器遍历的是旧数组快照）</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Java反射机制的原理及性能影响？如何通过反射获取私有字段并修改值？"><a href="#Java反射机制的原理及性能影响？如何通过反射获取私有字段并修改值？" class="headerlink" title="Java反射机制的原理及性能影响？如何通过反射获取私有字段并修改值？"></a>Java反射机制的原理及性能影响？如何通过反射获取私有字段并修改值？</h3><p>反射（Reflection）是Java在<strong>运行时</strong>动态获取和操作类、方法、字段等元数据的能力，其核心基于<code>java.lang.reflect</code>包和<code>Class</code>类：</p>
<ul>
<li><p><strong><code>Class</code>对象</strong>：每个类在JVM中都有一个对应的<code>Class</code>对象，存储类的元数据（如方法、字段、构造器等）。</p>
</li>
<li><p><strong>获取<code>Class</code>对象的方式</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过类名获取</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"><span class="comment">// 通过对象获取</span></span><br><span class="line">Class&lt;?&gt; clazz = myObject.getClass();</span><br><span class="line"><span class="comment">// 通过.class语法获取</span></span><br><span class="line">Class&lt;?&gt; clazz = MyClass.class;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>反射操作流程</strong>：</p>
<ol>
<li>通过<code>Class</code>对象获取类的元数据（如<code>Field</code>、<code>Method</code>、<code>Constructor</code>）。</li>
<li>动态调用方法、访问字段或创建对象。</li>
</ol>
</li>
</ul>
<p>反射操作的性能通常低于直接代码调用，原因如下：</p>
<ul>
<li><strong>动态解析</strong>：反射需在运行时解析类型信息，而直接调用在编译时已确定。</li>
<li><strong>访问检查</strong>：每次调用<code>Method.invoke()</code>或<code>Field.set()</code>时，JVM需检查访问权限（可通过<code>setAccessible(true)</code>关闭，提升性能）。</li>
<li><strong>方法内联优化失效</strong>：反射调用无法被JIT编译器优化（如方法内联）。</li>
</ul>
<p><strong>性能优化建议：</strong></p>
<ul>
<li><p><strong>缓存反射对象</strong>：重复使用的<code>Field</code>、<code>Method</code>等应缓存，避免重复查找。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Field</span> <span class="variable">PRIVATE_FIELD</span> <span class="operator">=</span> MyClass.class.getDeclaredField(<span class="string">&quot;privateField&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>关闭访问检查</strong>：对频繁调用的反射操作设置<code>setAccessible(true)</code></p>
</li>
</ul>
<p>应用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取Class对象</span></span><br><span class="line">        Class&lt;?&gt; clazz = MyClass.class;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取私有字段</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">privateField</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;privateField&quot;</span>);</span><br><span class="line">        privateField.setAccessible(<span class="literal">true</span>); <span class="comment">// 关闭访问检查</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建对象实例</span></span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读取字段值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">originalValue</span> <span class="operator">=</span> (String) privateField.get(obj);</span><br><span class="line">        System.out.println(<span class="string">&quot;原始值: &quot;</span> + originalValue); <span class="comment">// 输出&quot;Initial Value&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改字段值</span></span><br><span class="line">        privateField.set(obj, <span class="string">&quot;Modified Value&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;修改后: &quot;</span> + privateField.get(obj)); <span class="comment">// 输出&quot;Modified Value&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">privateField</span> <span class="operator">=</span> <span class="string">&quot;Initial Value&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="动态代理的实现方式（JDK动态代理-vs-CGLIB）？Spring-AOP默认使用哪种？"><a href="#动态代理的实现方式（JDK动态代理-vs-CGLIB）？Spring-AOP默认使用哪种？" class="headerlink" title="动态代理的实现方式（JDK动态代理 vs CGLIB）？Spring AOP默认使用哪种？"></a>动态代理的实现方式（JDK动态代理 vs CGLIB）？Spring AOP默认使用哪种？</h3><table>
<thead>
<tr>
<th align="left"><strong>对比维度</strong></th>
<th align="left"><strong>JDK动态代理</strong></th>
<th align="left"><strong>CGLIB动态代理</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>实现原理</strong></td>
<td align="left">基于接口，通过反射生成代理类</td>
<td align="left">基于继承，通过字节码增强生成目标类的子类</td>
</tr>
<tr>
<td align="left"><strong>目标类要求</strong></td>
<td align="left">必须实现至少一个接口</td>
<td align="left">无需实现接口，但目标类和方法不能是<code>final</code></td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">调用速度略慢（反射开销），生成代理类较快</td>
<td align="left">调用速度较快（直接调用），生成代理类较慢（字节码操作）</td>
</tr>
<tr>
<td align="left"><strong>方法覆盖范围</strong></td>
<td align="left">仅代理接口声明的方法</td>
<td align="left">代理目标类的所有非<code>final</code>方法</td>
</tr>
<tr>
<td align="left"><strong>依赖</strong></td>
<td align="left">无需额外依赖（Java标准库）</td>
<td align="left">需要引入CGLIB库（如<code>cglib</code>或<code>spring-core</code>）</td>
</tr>
<tr>
<td align="left"><strong>兼容性</strong></td>
<td align="left">兼容所有Java版本</td>
<td align="left">对字节码操作可能受JVM版本限制</td>
</tr>
</tbody></table>
<p><strong>JDK动态代理的核心实现</strong></p>
<ol>
<li><p><strong>接口定义</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(String user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>目标类实现接口</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(String user)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存用户: &quot;</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>InvocationHandler实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target; <span class="comment">// 目标对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LogInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法调用前: &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args); <span class="comment">// 反射调用目标方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法调用后&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>生成代理对象</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserService</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line"><span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserService) Proxy.newProxyInstance(</span><br><span class="line">    target.getClass().getClassLoader(),</span><br><span class="line">    target.getClass().getInterfaces(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LogInvocationHandler</span>(target)</span><br><span class="line">);</span><br><span class="line">proxy.saveUser(<span class="string">&quot;Alice&quot;</span>); <span class="comment">// 代理方法调用</span></span><br></pre></td></tr></table></figure>

<p><strong>CGLIB动态代理的核心实现</strong></p>
<ol>
<li><p><strong>目标类（无需接口）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(String user)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存用户: &quot;</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>MethodInterceptor实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法调用前: &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args); <span class="comment">// 调用父类方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法调用后&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>生成代理对象</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">enhancer.setSuperclass(UserService.class); <span class="comment">// 设置父类</span></span><br><span class="line">enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">LogInterceptor</span>()); <span class="comment">// 设置回调</span></span><br><span class="line"><span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserService) enhancer.create(); <span class="comment">// 创建代理对象</span></span><br><span class="line">proxy.saveUser(<span class="string">&quot;Bob&quot;</span>); <span class="comment">// 代理方法调用</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<p>Spring AOP根据目标对象的特性动态选择代理机制：</p>
<ol>
<li><p><strong>默认行为</strong>：</p>
<ul>
<li><strong>若目标类实现了接口</strong>：优先使用<strong>JDK动态代理</strong>。</li>
<li><strong>若目标类未实现接口</strong>：使用<strong>CGLIB动态代理</strong>。</li>
</ul>
</li>
<li><p><strong>强制使用CGLIB</strong>：<br>通过配置<code>proxyTargetClass=true</code>，可强制Spring使用CGLIB代理（即使目标类实现了接口）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- XML配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java注解配置</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Spring Boot的默认调整</strong>：</p>
<ul>
<li><strong>Spring Boot 2.x+<strong>：默认启用<code>proxyTargetClass=true</code>，即</strong>优先使用CGLIB</strong>。</li>
<li><strong>原因</strong>：CGLIB能代理所有方法（包括非接口方法），避免因接口变更导致的代理遗漏问题。</li>
</ul>
</li>
</ol>
<h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h2><h2 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h2><h3 id="线程安全有哪些实现思路？"><a href="#线程安全有哪些实现思路？" class="headerlink" title="线程安全有哪些实现思路？"></a>线程安全有哪些实现思路？</h3><ul>
<li>互斥同步：<code>synchronized</code> 和 <code>ReentrantLock</code></li>
<li>非阻塞同步：<code>CAS</code></li>
<li>无同步：<code>ThreadLocal</code></li>
</ul>
<h3 id="线程有哪些协作方式？"><a href="#线程有哪些协作方式？" class="headerlink" title="线程有哪些协作方式？"></a>线程有哪些协作方式？</h3><ul>
<li><code>join</code>：在线程中调用另一个线程的 <code>join</code> 方法，会将当前线程挂起，直到目标线程结束。</li>
<li><code>wait&amp;notify/notifyAll</code> </li>
<li><code>await&amp;signal/signalAll</code></li>
</ul>
<h3 id="wait和sleep的区别"><a href="#wait和sleep的区别" class="headerlink" title="wait和sleep的区别"></a><code>wait</code>和<code>sleep</code>的区别</h3><ul>
<li><code>wait()</code> 是 <code>Object</code> 的方法，而 <code>sleep()</code> 是 <code>Thread</code> 的静态方法。</li>
<li><code>wait()</code> 会释放锁，<code>sleep()</code> 不会。</li>
</ul>
<h3 id="JUC框架主要包括哪几部分"><a href="#JUC框架主要包括哪几部分" class="headerlink" title="JUC框架主要包括哪几部分"></a>JUC框架主要包括哪几部分</h3><ul>
<li><code>locks</code> 和 <code>tools</code></li>
<li><code>atomic</code></li>
<li><code>excutor</code></li>
<li><code>colletions</code></li>
</ul>
<h3 id="什么是CAS？CAS存在哪些问题？"><a href="#什么是CAS？CAS存在哪些问题？" class="headerlink" title="什么是CAS？CAS存在哪些问题？"></a>什么是CAS？CAS存在哪些问题？</h3><h3 id="AQS的原理"><a href="#AQS的原理" class="headerlink" title="AQS的原理"></a>AQS的原理</h3><h3 id="线程的6种状态及状态转换条件"><a href="#线程的6种状态及状态转换条件" class="headerlink" title="线程的6种状态及状态转换条件"></a>线程的6种状态及状态转换条件</h3><table>
<thead>
<tr>
<th align="left"><strong>状态</strong></th>
<th align="left"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>NEW</strong></td>
<td align="left">线程被创建但未启动（未调用<code>start()</code>方法）。</td>
</tr>
<tr>
<td align="left"><strong>RUNNABLE</strong></td>
<td align="left">线程正在JVM中执行或等待操作系统资源（如CPU时间片）。</td>
</tr>
<tr>
<td align="left"><strong>BLOCKED</strong></td>
<td align="left">线程被阻塞，等待获取监视器锁（如进入<code>synchronized</code>代码块未获得锁）。</td>
</tr>
<tr>
<td align="left"><strong>WAITING</strong></td>
<td align="left">线程无限期等待其他线程的唤醒信号（如调用<code>Object.wait()</code>或<code>Thread.join()</code>）。</td>
</tr>
<tr>
<td align="left"><strong>TIMED_WAITING</strong></td>
<td align="left">线程在指定时间内等待（如调用<code>Thread.sleep(long)</code>或<code>Object.wait(long)</code>）。</td>
</tr>
<tr>
<td align="left"><strong>TERMINATED</strong></td>
<td align="left">线程执行完毕（<code>run()</code>方法正常结束或抛出未捕获异常）。</td>
</tr>
</tbody></table>
<img src="/post/be632046/image-20250504095140269.png" class="" title="image-20250504095140269">



<h3 id="线程池的7个核心参数？ThreadPoolExecutor的饱和策略有哪些？"><a href="#线程池的7个核心参数？ThreadPoolExecutor的饱和策略有哪些？" class="headerlink" title="线程池的7个核心参数？ThreadPoolExecutor的饱和策略有哪些？"></a>线程池的7个核心参数？<code>ThreadPoolExecutor</code>的饱和策略有哪些？</h3><p>核心参数：</p>
<ul>
<li><strong>核心线程数（corePoolSize）</strong>：线程池中一直存活的线程数量。当线程池中的线程数量小于核心线程数时，会创建新的线程来执行任务，直到达到核心线程数。</li>
<li><strong>最大线程数（maximumPoolSize）</strong>：线程池中允许的最大线程数量。当线程池中的线程数量达到最大线程数时，新的任务会根据拒绝策略进行处理。</li>
<li><strong>空闲线程存活时间（keepAliveTime）</strong>：线程池中的非核心空闲线程存活时间。可以通过设置这个参数来控制线程池的动态伸缩能力。</li>
<li><strong>时间单位（<code>unit</code>）</strong>：<code>keepAliveTime</code>的时间单位（如<code>TimeUnit.SECONDS</code>、<code>TimeUnit.MILLISECONDS</code>）。</li>
<li><strong>任务队列（workQueue）</strong>：用于保存等待执行的任务的阻塞队列。</li>
<li><strong>线程工厂（threadFactory）</strong>：用于创建新线程的工厂类，可自定义线程名称、优先级等属性。</li>
<li><strong>拒绝策略（handler）</strong>：当线程池和队列都满了时，处理新任务的策略。</li>
</ul>
<p>饱和策略：</p>
<ul>
<li><strong>AbortPolicy（默认）</strong>：直接抛出 RejectedExecutionException 异常。</li>
<li><strong>CallerRunsPolicy</strong>：由提交任务的线程执行该任务。</li>
<li><strong>DiscardPolicy</strong>：静默丢弃新提交的任务，不抛出异常。允许任务丢失的非关键场景（如监控数据采集）。</li>
<li>DiscardOldestPolicy：丢弃队列中最旧的任务（即队列头部的任务），然后重新尝试提交当前任务。</li>
</ul>
<h3 id="sleep-和-wait-的区别"><a href="#sleep-和-wait-的区别" class="headerlink" title="sleep() 和 wait() 的区别"></a><code>sleep()</code> 和 <code>wait()</code> 的区别</h3><table>
<thead>
<tr>
<th align="left"><strong>对比维度</strong></th>
<th align="left"><strong><code>Thread.sleep(long millis)</code></strong></th>
<th align="left"><strong><code>Object.wait()</code></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>所属类</strong></td>
<td align="left"><code>Thread</code> 类的静态方法</td>
<td align="left"><code>Object</code> 类的实例方法</td>
</tr>
<tr>
<td align="left"><strong>锁的释放</strong></td>
<td align="left"><strong>不释放锁</strong>（即使线程休眠，仍持有锁）</td>
<td align="left"><strong>释放锁</strong>（线程进入等待队列，允许其他线程获取锁）</td>
</tr>
<tr>
<td align="left"><strong>唤醒机制</strong></td>
<td align="left">休眠时间结束后自动唤醒，或通过 <code>interrupt()</code> 中断</td>
<td align="left">必须由其他线程调用 <code>notify()</code>&#x2F;<code>notifyAll()</code>，或超时自动唤醒</td>
</tr>
<tr>
<td align="left"><strong>调用要求</strong></td>
<td align="left">可在任何上下文中调用</td>
<td align="left">必须在同步代码块（<code>synchronized</code>块）内调用</td>
</tr>
<tr>
<td align="left"><strong>用途</strong></td>
<td align="left">让当前线程暂停执行一段时间（与锁无关）</td>
<td align="left">线程间协调（如生产者-消费者模型），需配合锁实现同步</td>
</tr>
<tr>
<td align="left"><strong>异常处理</strong></td>
<td align="left">必须捕获或声明抛出 <code>InterruptedException</code></td>
<td align="left">同左（需处理 <code>InterruptedException</code>）</td>
</tr>
</tbody></table>
<p>总结：</p>
<ul>
<li>**<code>sleep()</code>**：用于线程暂停，不涉及锁的协作。</li>
<li>**<code>wait()</code>**：用于线程间通信，需配合锁和<code>notify()</code>&#x2F;<code>notifyAll()</code>使用。</li>
<li><strong>关键区别</strong>：<code>sleep()</code>不释放锁，<code>wait()</code>释放锁。</li>
</ul>
<h3 id="synchronized和ReentrantLock的区别"><a href="#synchronized和ReentrantLock的区别" class="headerlink" title="synchronized和ReentrantLock的区别"></a>synchronized和ReentrantLock的区别</h3><table>
<thead>
<tr>
<th align="left"><strong>对比维度</strong></th>
<th align="left"><strong>synchronized</strong></th>
<th align="left"><strong>ReentrantLock</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>实现机制</strong></td>
<td align="left">JVM层面的关键字（基于监视器锁，自动管理锁的获取和释放）</td>
<td align="left">JDK API实现的类（需手动获取和释放锁）</td>
</tr>
<tr>
<td align="left"><strong>锁的获取方式</strong></td>
<td align="left">隐式获取，进入同步代码块或方法时自动获取锁</td>
<td align="left">显式调用<code>lock()</code>和<code>unlock()</code>方法</td>
</tr>
<tr>
<td align="left"><strong>锁的可中断性</strong></td>
<td align="left">不支持中断等待锁的线程</td>
<td align="left">支持通过<code>lockInterruptibly()</code>中断等待</td>
</tr>
<tr>
<td align="left"><strong>公平性</strong></td>
<td align="left">非公平锁（默认）</td>
<td align="left">可配置公平锁或非公平锁（构造函数参数控制）</td>
</tr>
<tr>
<td align="left"><strong>条件变量（Condition）</strong></td>
<td align="left">只能通过<code>Object.wait()</code>&#x2F;<code>notify()</code>实现单条件等待&#x2F;唤醒</td>
<td align="left">支持多个条件变量（<code>newCondition()</code>）</td>
</tr>
<tr>
<td align="left"><strong>锁的绑定</strong></td>
<td align="left">锁与对象或类绑定（无法跨方法释放）</td>
<td align="left">锁与代码逻辑解耦（可跨方法释放）</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">JDK6后优化（偏向锁、轻量级锁），多数场景性能接近ReentrantLock</td>
<td align="left">高竞争场景下吞吐量更高（如<code>tryLock()</code>减少阻塞）</td>
</tr>
<tr>
<td align="left"><strong>代码灵活性</strong></td>
<td align="left">语法简单，但功能有限</td>
<td align="left">提供更多高级功能（如超时锁、尝试获取锁等）</td>
</tr>
</tbody></table>
<h3 id="volatile关键字的作用（可见性、禁止指令重排）？能否保证原子性？"><a href="#volatile关键字的作用（可见性、禁止指令重排）？能否保证原子性？" class="headerlink" title="volatile关键字的作用（可见性、禁止指令重排）？能否保证原子性？"></a>volatile关键字的作用（可见性、禁止指令重排）？能否保证原子性？</h3><p><code>volatile</code>关键字用于确保变量的可见性和禁止指令重排序，但它<strong>不能保证原子性</strong>。</p>
<p><strong>保证可见性</strong></p>
<ul>
<li><strong>问题背景</strong>：<br>在多线程环境中，每个线程拥有自己的工作内存（缓存）。普通变量的修改可能不会立即同步到主内存，导致其他线程读取到旧值。</li>
<li><strong>解决方案</strong>：<br><code>volatile</code>修饰的变量遵循以下规则：<ul>
<li><strong>写操作</strong>：立即将线程工作内存中的值刷新到主内存。</li>
<li><strong>读操作</strong>：直接从主内存读取最新值，而非使用本地缓存。</li>
</ul>
</li>
</ul>
<p><strong>禁止指令重排序</strong></p>
<ul>
<li><p><strong>问题背景</strong>：<br>编译器和处理器可能对指令重排序以优化性能，但可能导致多线程执行结果不符合预期。</p>
</li>
<li><p><strong>解决方案</strong>：<br><code>volatile</code>通过插入<strong>内存屏障</strong>（Memory Barrier）禁止重排序：</p>
<ul>
<li><strong>写屏障</strong>：确保<code>volatile</code>写操作前的所有指令不会被重排序到写之后。</li>
<li><strong>读屏障</strong>：确保<code>volatile</code>读操作后的所有指令不会被重排序到读之前。</li>
</ul>
</li>
<li><p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;                     <span class="comment">// 第一次检查</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;             <span class="comment">// 第二次检查</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();     <span class="comment">// volatile禁止new操作的指令重排序</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>new Singleton()</code>可能被分解为：</p>
<ol>
<li>分配内存空间。</li>
<li>初始化对象。</li>
<li>将引用指向内存地址。</li>
</ol>
<p>若无<code>volatile</code>，若步骤2和3重排序，其他线程可能访问到未初始化的对象。</p>
</li>
</ul>
<h3 id="synchronized锁升级过程"><a href="#synchronized锁升级过程" class="headerlink" title="synchronized锁升级过程"></a>synchronized锁升级过程</h3><p>Java 中的 <code>synchronized</code> 锁机制通过 <strong>锁升级（Lock Escalation）</strong> 动态优化并发性能，根据线程竞争情况逐步从低开销锁升级到高开销锁，避免直接使用重量级锁导致性能浪费。其过程可分为以下四个阶段：</p>
<p><strong>1. 无锁（Unlocked）</strong></p>
<ul>
<li><strong>场景</strong>：对象未被任何线程锁定。</li>
<li><strong>对象头标记</strong>：<ul>
<li><code>Mark Word</code> 中的锁标志位为 <code>01</code>（无锁态）。</li>
<li>其他位存储哈希码（HashCode）或分代年龄（GC Age）。</li>
</ul>
</li>
</ul>
<p><strong>2. 偏向锁（Biased Lock）</strong></p>
<ul>
<li><strong>目的</strong>：优化 <strong>单线程重复访问同步块</strong> 的场景。</li>
<li><strong>触发条件</strong>：<br>首次有线程进入同步块时，JVM 启用偏向锁（需开启 <code>-XX:+UseBiasedLocking</code>，默认在 JDK 15 后被废弃）。</li>
<li><strong>对象头标记</strong>：<ul>
<li>锁标志位为 <code>01</code>，同时设置偏向模式位为 <code>1</code>。</li>
<li>记录 <strong>线程 ID</strong> 和 <strong>偏向时间戳</strong>。</li>
</ul>
</li>
<li><strong>锁升级条件</strong>：<ul>
<li>其他线程尝试获取锁时，触发偏向锁撤销（Revoke）。</li>
<li>若对象已偏向且线程存活，升级为轻量级锁；否则直接重置为无锁态。</li>
</ul>
</li>
</ul>
<p><strong>3. 轻量级锁（Lightweight Lock）</strong></p>
<ul>
<li><strong>目的</strong>：优化 <strong>低竞争、多线程交替执行</strong> 的场景（如短暂锁竞争）。</li>
<li><strong>触发条件</strong>：<br>偏向锁被撤销，或直接进入轻量级锁模式（如禁用偏向锁时）。</li>
<li><strong>加锁流程</strong>：<ol>
<li>线程在栈帧中创建 <strong>锁记录（Lock Record）</strong>，拷贝对象头的 <code>Mark Word</code>。</li>
<li>通过 <strong>CAS 操作</strong> 尝试将对象头的 <code>Mark Word</code> 替换为指向锁记录的指针。</li>
<li>若成功，线程获取轻量级锁；若失败，触发自旋重试。</li>
</ol>
</li>
<li><strong>对象头标记</strong>：<ul>
<li>锁标志位为 <code>00</code>，存储指向锁记录的指针。</li>
</ul>
</li>
<li><strong>锁升级条件</strong>：<ul>
<li>自旋超过阈值（<code>-XX:PreBlockSpin</code>，默认 10 次）。</li>
<li>等待线程数超过 CPU 核心数的一半，升级为重量级锁。</li>
</ul>
</li>
</ul>
<p><strong>4. 重量级锁（Heavyweight Lock）</strong></p>
<ul>
<li><strong>目的</strong>：处理 <strong>高竞争、长临界区</strong> 的场景。</li>
<li><strong>实现机制</strong>：<ul>
<li>基于操作系统 <strong>互斥量（Mutex）</strong> 实现，线程竞争锁时会进入阻塞状态。</li>
<li>依赖操作系统调度，涉及用户态与内核态切换，开销较大。</li>
</ul>
</li>
<li><strong>对象头标记</strong>：<ul>
<li>锁标志位为 <code>10</code>，存储指向 <strong>监视器（Monitor）</strong> 的指针。</li>
</ul>
</li>
<li><strong>锁释放</strong>：<br>持有锁的线程退出同步块时唤醒等待线程。</li>
</ul>
<p><strong>锁升级全流程</strong></p>
<ol>
<li><strong>初始状态</strong>：对象无锁（或偏向锁未激活）。</li>
<li><strong>首次加锁</strong>：启用偏向锁（若开启）或直接进入轻量级锁。</li>
<li><strong>竞争加剧</strong>：<ul>
<li>偏向锁 → 轻量级锁（多线程交替访问）。</li>
<li>轻量级锁 → 重量级锁（自旋失败或竞争激烈）。</li>
</ul>
</li>
<li><strong>释放锁</strong>：<ul>
<li>轻量级锁：CAS 恢复对象头。</li>
<li>重量级锁：释放监视器并唤醒等待线程</li>
</ul>
</li>
</ol>
<p><strong>锁升级性能对比</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>锁类型</strong></th>
<th align="left"><strong>适用场景</strong></th>
<th align="left"><strong>开销</strong></th>
<th align="left"><strong>实现方式</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">偏向锁</td>
<td align="left">单线程重复访问</td>
<td align="left">极低（仅 CAS 记录线程）</td>
<td align="left">对象头记录线程 ID</td>
</tr>
<tr>
<td align="left">轻量级锁</td>
<td align="left">低竞争、短临界区</td>
<td align="left">低（CAS + 自旋）</td>
<td align="left">栈帧锁记录 + CAS</td>
</tr>
<tr>
<td align="left">重量级锁</td>
<td align="left">高竞争、长临界区</td>
<td align="left">高（系统调用阻塞）</td>
<td align="left">操作系统互斥量</td>
</tr>
</tbody></table>
<p><strong>注意事项</strong></p>
<ol>
<li><strong>偏向锁的废弃</strong>：<br>JDK 15 后默认禁用偏向锁（<code>-XX:-UseBiasedLocking</code>），因其在多数场景下优化效果有限且增加复杂性。</li>
<li><strong>锁降级缺失</strong>：<br>HotSpot 未实现锁降级（如重量级锁→轻量级锁），锁升级是单向过程。</li>
<li><strong>性能权衡</strong>：<br>轻量级锁的自旋会消耗 CPU 资源，需根据竞争强度选择是否调整自旋策略。</li>
</ol>
<h3 id="AQS实现原理（以ReentrantLock为例）"><a href="#AQS实现原理（以ReentrantLock为例）" class="headerlink" title="AQS实现原理（以ReentrantLock为例）"></a>AQS实现原理（以ReentrantLock为例）</h3><p><strong>AbstractQueuedSynchronizer（AQS）</strong> 是 Java 并发包中构建锁和同步器的核心框架，<code>ReentrantLock</code>、<code>Semaphore</code> 等均基于 AQS 实现。以下以 <code>ReentrantLock</code> 为例，详细解析 AQS 的工作原理：</p>
<p><strong>AQS 核心结构</strong></p>
<p>AQS 通过 <strong>状态变量（<code>state</code>）</strong> 和 <strong>CLH 队列</strong> 实现同步机制：</p>
<ol>
<li><strong>状态变量（<code>state</code>）</strong><ul>
<li><strong>作用</strong>：表示锁的占用状态或资源数量。</li>
<li><strong>在 <code>ReentrantLock</code> 中的语义</strong>：<ul>
<li><code>state = 0</code>：锁未被占用。</li>
<li><code>state &gt; 0</code>：锁被占用，数值为当前持有锁线程的重入次数。</li>
</ul>
</li>
</ul>
</li>
<li><strong>CLH 队列（FIFO 线程等待队列）</strong><ul>
<li><strong>节点（<code>Node</code>）</strong>：每个等待线程被封装为一个 <code>Node</code> 对象，包含线程引用、等待状态（如 <code>CANCELLED</code>、<code>SIGNAL</code>）及前驱&#x2F;后继指针。</li>
<li><strong>头节点（<code>head</code>）</strong>：当前持有锁的线程节点（虚节点，不保存线程）。</li>
<li><strong>尾节点（<code>tail</code>）</strong>：队列末尾节点。</li>
</ul>
</li>
</ol>
<p><strong>ReentrantLock 的锁获取与释放流程</strong></p>
<p>以 <strong>非公平锁（默认实现）</strong> 为例：</p>
<p><strong>1. 加锁（<code>lock()</code>）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock.NonfairSync</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))  <span class="comment">// 直接尝试 CAS 抢锁</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread()); <span class="comment">// 成功则设置当前线程为持有者</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);  <span class="comment">// 进入 AQS 排队流程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>acquire(int)</code></strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;       <span class="comment">// 尝试获取锁（子类实现）</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) <span class="comment">// 创建节点并入队</span></span><br><span class="line">        selfInterrupt();          <span class="comment">// 若等待中线程被中断，补上中断标记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>tryAcquire(int)</code></strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;  <span class="comment">// 再次尝试 CAS 抢锁</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;  <span class="comment">// 重入逻辑</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 解锁（<code>unlock()</code>）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock.Sync</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>release(int)</code></strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AQS</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;      <span class="comment">// 尝试释放锁（子类实现）</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h); <span class="comment">// 唤醒后继节点线程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>tryRelease(int)</code></strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;  <span class="comment">// 完全释放锁</span></span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>公平锁vs非公平锁</strong>：</p>
<table>
<thead>
<tr>
<th align="left"><strong>锁类型</strong></th>
<th align="left"><strong><code>tryAcquire()</code> 实现差异</strong></th>
<th align="left"><strong>特点</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">非公平锁</td>
<td align="left">直接 CAS 抢锁，不检查队列中是否有等待线程。</td>
<td align="left">吞吐量高，可能存在线程“插队”。</td>
</tr>
<tr>
<td align="left">公平锁</td>
<td align="left">先检查队列是否有等待线程，若无才尝试 CAS 获取锁。</td>
<td align="left">保证 FIFO 公平性，但吞吐量较低。</td>
</tr>
</tbody></table>
<h3 id="ConcurrentHashMap分段锁演进"><a href="#ConcurrentHashMap分段锁演进" class="headerlink" title="ConcurrentHashMap分段锁演进"></a>ConcurrentHashMap分段锁演进</h3><p><code>ConcurrentHashMap</code> 是 Java 并发包中高效的线程安全哈希表实现，其锁机制从 <strong>分段锁（Segment）</strong> 演变为 <strong>CAS + <code>synchronized</code> 细粒度锁</strong>，显著提升了并发性能。以下是其核心演进过程：</p>
<p><strong>Java 7 及之前：分段锁（Segment）</strong></p>
<p><strong>1. 设计原理</strong></p>
<ul>
<li><p><strong>分段锁结构</strong>：<br><code>ConcurrentHashMap</code> 由多个 <strong>Segment 段</strong>（默认 16 个）组成，每个 Segment 是一个独立的 <code>ReentrantLock</code> 锁，内部维护一个哈希表（<code>HashEntry</code> 数组）。</p>
<ul>
<li><p><strong>分段粒度</strong>：锁的竞争范围限定在单个 Segment，不同 Segment 的操作可并行执行。</p>
</li>
<li><p><strong>默认参数</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CONCURRENCY_LEVEL</span> <span class="operator">=</span> <span class="number">16</span>;  <span class="comment">// 默认并发级别（Segment 数）</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>哈希寻址</strong>：<br>通过两次哈希计算确定键值对的位置：</p>
<ol>
<li>计算键的哈希值，定位到 Segment。</li>
<li>在 Segment 内部的哈希表中定位到具体的桶（<code>HashEntry</code>）。</li>
</ol>
</li>
</ul>
<p><strong>2. 核心流程</strong></p>
<ul>
<li><strong>写入（<code>put()</code>）</strong>：<ol>
<li>定位到目标 Segment，尝试获取该 Segment 的锁。</li>
<li>在 Segment 内部链表中插入或更新键值对。</li>
<li>释放锁。</li>
</ol>
</li>
<li><strong>读取（<code>get()</code>）</strong>：<br>无需加锁，通过 <code>volatile</code> 关键字保证 <code>HashEntry</code> 值的可见性。</li>
</ul>
<p><strong>3. 优缺点</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>优点</strong></th>
<th align="left"><strong>缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">减少锁竞争（段间并行）</td>
<td align="left">段数固定，无法动态扩展（默认 16 段可能不够）</td>
</tr>
<tr>
<td align="left">锁粒度较粗（段内所有桶共享锁）</td>
<td align="left">内存占用高（每个 Segment 独立哈希表结构）</td>
</tr>
</tbody></table>
<p><strong>Java 8 及之后：CAS + <code>synchronized</code> 细粒度锁</strong></p>
<p><strong>1. 设计原理</strong></p>
<ul>
<li><strong>结构优化</strong>：<ul>
<li>抛弃分段锁，采用 <strong><code>Node</code> 数组 + 链表&#x2F;红黑树</strong> 结构（类似 <code>HashMap</code>）。</li>
<li>锁粒度细化到 <strong>单个桶（Bucket）的头节点</strong>，通过 <code>synchronized</code> 锁定链表或树的头节点。</li>
</ul>
</li>
<li><strong>并发控制</strong>：<ul>
<li><strong>CAS 操作</strong>：用于无竞争条件下的快速更新（如初始化、扩容、计数器修改）。</li>
<li><strong><code>synchronized</code> 锁</strong>：仅在哈希冲突时锁定桶头节点，锁范围更小。</li>
</ul>
</li>
<li><strong>红黑树优化</strong>：<br>当链表长度超过阈值（默认 8），链表转为红黑树，减少查询时间复杂度（从 O(n) 到 O(log n)）。</li>
</ul>
<p><strong>2. 核心流程</strong></p>
<ul>
<li><strong>写入（<code>put()</code>）</strong>：<ol>
<li>计算哈希，定位到桶的头节点 <code>Node</code>。</li>
<li>若桶为空，通过 CAS 插入新节点。</li>
<li>若桶非空，使用 <code>synchronized</code> 锁住头节点，执行链表&#x2F;树插入或更新。</li>
<li>若链表长度超过阈值，转换为红黑树。</li>
</ol>
</li>
<li><strong>读取（<code>get()</code>）</strong>：<br>无需加锁，通过 <code>volatile</code> 和 <code>final</code> 关键字保证可见性与不变性。</li>
<li><strong>扩容（<code>transfer()</code>）</strong>：<br>采用多线程协同扩容机制（如 <code>ForwardingNode</code> 标记），每个线程负责迁移部分桶。</li>
</ul>
<p><strong>3. 优缺点</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>优点</strong></th>
<th align="left"><strong>缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">锁粒度更细（桶级别），并发度更高</td>
<td align="left"><code>synchronized</code> 在极端高竞争场景下可能退化为重量级锁</td>
</tr>
<tr>
<td align="left">内存占用低（共享 <code>Node</code> 数组，无冗余结构）</td>
<td align="left">红黑树转换增加代码复杂度</td>
</tr>
<tr>
<td align="left">动态扩展，无需固定并发级别</td>
<td align="left"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>分段锁（Java 7）</strong></th>
<th align="left"><strong>CAS + <code>synchronized</code>（Java 8+）</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>锁粒度</strong></td>
<td align="left">段级别（默认 16 段）</td>
<td align="left">桶级别（更细粒度）</td>
</tr>
<tr>
<td align="left"><strong>内存占用</strong></td>
<td align="left">高（每个 Segment 独立哈希表）</td>
<td align="left">低（共享 <code>Node</code> 数组）</td>
</tr>
<tr>
<td align="left"><strong>并发度</strong></td>
<td align="left">受限于段数（默认 16）</td>
<td align="left">动态扩展，与桶数量相关（更高）</td>
</tr>
<tr>
<td align="left"><strong>哈希冲突处理</strong></td>
<td align="left">链表</td>
<td align="left">链表 + 红黑树（优化查询性能）</td>
</tr>
<tr>
<td align="left"><strong>锁实现</strong></td>
<td align="left"><code>ReentrantLock</code></td>
<td align="left">CAS + <code>synchronized</code>（依赖 JVM 锁优化）</td>
</tr>
<tr>
<td align="left"><strong>扩容机制</strong></td>
<td align="left">段内独立扩容（可能不均匀）</td>
<td align="left">多线程协同扩容（更高效）</td>
</tr>
</tbody></table>
<h3 id="ThreadLocal原理与内存泄漏问题"><a href="#ThreadLocal原理与内存泄漏问题" class="headerlink" title="ThreadLocal原理与内存泄漏问题"></a>ThreadLocal原理与内存泄漏问题</h3><p><strong>ThreadLocal 原理</strong></p>
<ol>
<li><strong>线程隔离机制</strong><br>ThreadLocal 为每个线程提供独立的变量副本，通过线程内部的 <code>ThreadLocalMap</code> 实现数据隔离。每个线程（<code>Thread</code> 类）持有自己的 <code>ThreadLocalMap</code>，存储以 <code>ThreadLocal</code> 实例为键、线程局部变量为值的条目。</li>
<li><strong>ThreadLocalMap 结构</strong><ul>
<li><strong>键（Key）</strong>：<code>ThreadLocal</code> 实例的 <strong>弱引用</strong>（<code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>）。</li>
<li><strong>值（Value）</strong>：线程局部变量的 <strong>强引用</strong>。</li>
<li><strong>哈希冲突解决</strong>：采用 <strong>开放寻址法</strong>（线性探测），而非链表或红黑树。</li>
</ul>
</li>
</ol>
<p><strong>内存泄漏原因</strong></p>
<ol>
<li><strong>弱引用的键（Key）</strong><ul>
<li>当 <code>ThreadLocal</code> 实例失去所有强引用时，GC 会回收其内存，导致 <code>ThreadLocalMap</code> 中的键变为 <code>null</code>。</li>
<li><strong>问题</strong>：对应的值（Value）仍被 Entry 强引用，无法被自动回收。</li>
</ul>
</li>
<li><strong>线程生命周期过长</strong><ul>
<li>若线程属于线程池（如 Tomcat 的 Worker 线程），会长期存活并复用。</li>
<li><strong>结果</strong>：积累大量键为 <code>null</code> 的 Entry，导致内存泄漏。</li>
</ul>
</li>
<li><strong>惰性清理机制</strong><ul>
<li><code>ThreadLocalMap</code> 仅在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 时清理部分无效 Entry。</li>
<li><strong>风险</strong>：长期不操作 <code>ThreadLocal</code> 的线程可能堆积无效 Entry。</li>
</ul>
</li>
</ol>
<p><strong>内存泄漏示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemoryLeakDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;User&gt; userHolder = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        userHolder.set(<span class="keyword">new</span> <span class="title class_">User</span>());  <span class="comment">// User 对象被强引用在 Entry 中</span></span><br><span class="line">        <span class="comment">// 未调用 userHolder.remove()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 线程池复用线程处理多个请求</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            executor.submit(() -&gt; <span class="keyword">new</span> <span class="title class_">MemoryLeakDemo</span>().handleRequest());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong>：<br>每次请求后，<code>User</code> 对象因 Entry 未清理而堆积，最终导致 <code>OutOfMemoryError</code>。</p>
<p><strong>解决方案</strong></p>
<ol>
<li><p><strong>显式调用 <code>remove()</code></strong><br>在不再需要 <code>ThreadLocal</code> 变量时，立即清理当前线程的 Entry：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        userHolder.set(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        userHolder.remove();  <span class="comment">// 强制清理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>避免长生命周期的 <code>ThreadLocal</code> 引用</strong></p>
<ul>
<li>若非必要，避免将 <code>ThreadLocal</code> 声明为 <code>static</code>（减少长期引用风险）。</li>
<li>对于线程池场景，确保每次任务执行后清理 <code>ThreadLocal</code>。</li>
</ul>
</li>
<li><p><strong>使用 <code>InheritableThreadLocal</code> 的注意事项</strong></p>
<ul>
<li>子线程会继承父线程的 <code>ThreadLocal</code> 值，需同样关注清理逻辑。</li>
</ul>
</li>
</ol>
<h3 id="Happens-Before规则实战应用"><a href="#Happens-Before规则实战应用" class="headerlink" title="Happens-Before规则实战应用"></a>Happens-Before规则实战应用</h3><p><strong>Happens-Before 规则核心列表</strong></p>
<ol>
<li><strong>程序顺序规则</strong>：同一线程中的操作按程序顺序执行。</li>
<li><strong>锁规则</strong>：解锁操作先于后续的加锁操作。</li>
<li><strong>volatile规则</strong>：volatile写操作先于后续的volatile读操作。</li>
<li><strong>线程启动规则</strong>：<code>Thread.start()</code>前的操作先于新线程中的任何操作。</li>
<li><strong>线程终止规则</strong>：线程中的所有操作先于其他线程检测到该线程终止（如<code>Thread.join()</code>）。</li>
<li><strong>中断规则</strong>：调用<code>Thread.interrupt()</code>前的操作先于被中断线程检测到中断。</li>
<li><strong>传递性规则</strong>：若A先于B，B先于C，则A先于C。</li>
<li><strong>对象终结规则</strong>：对象的构造函数结束先于<code>finalize()</code>方法。</li>
</ol>
<p><strong>实战场景与解决方案</strong></p>
<p><strong>场景1：单例模式（DCL双重检查锁）</strong></p>
<p><strong>问题</strong>：未正确同步时，可能获取到未初始化完成的对象。<br><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance; <span class="comment">// volatile 保证可见性和禁止重排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); <span class="comment">// 非原子操作（分配内存、初始化、赋值）</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Happens-Before应用</strong>：</p>
<ul>
<li><code>volatile</code>写（<code>instance</code>赋值）与后续的<code>volatile</code>读（<code>instance == null</code>）构成Happens-Before关系，禁止指令重排序，确保其他线程看到完全初始化的对象。</li>
</ul>
<p><strong>场景2：线程间传递配置参数</strong></p>
<p><strong>问题</strong>：主线程配置参数未对工作线程可见。<br><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigLoader</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String config;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ConfigLoader.class) &#123; <span class="comment">// 通过锁建立Happens-Before</span></span><br><span class="line">                config = loadConfig(); <span class="comment">// 写操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ConfigLoader.class) &#123; <span class="comment">// 同一锁</span></span><br><span class="line">                System.out.println(config); <span class="comment">// 读操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Happens-Before应用</strong>：</p>
<ul>
<li><strong>锁规则</strong>：第一个线程的解锁操作先于第二个线程的加锁操作，确保<code>config</code>的写入对第二个线程可见。</li>
</ul>
<p><strong>场景3：状态标记终止线程</strong></p>
<p><strong>问题</strong>：工作线程无法及时感知终止标志。<br><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">stopped</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// volatile保证可见性</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        stopped = <span class="literal">true</span>; <span class="comment">// volatile写</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stopped) &#123; <span class="comment">// volatile读</span></span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Happens-Before应用</strong>：</p>
<ul>
<li><strong>volatile规则</strong>：<code>stop()</code>中的写操作先于<code>run()</code>中的读操作，确保修改立即可见。</li>
</ul>
<p><strong>场景4：线程间传递计算结果</strong></p>
<p><strong>问题</strong>：子线程计算结果未对主线程可见。<br><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResultTransfer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> result;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            result = compute(); <span class="comment">// 写操作</span></span><br><span class="line">        &#125;);</span><br><span class="line">        worker.start();</span><br><span class="line">        worker.join(); <span class="comment">// 线程终止规则</span></span><br><span class="line">        System.out.println(result); <span class="comment">// 读操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Happens-Before应用</strong>：</p>
<ul>
<li><strong>线程终止规则</strong>：<code>worker</code>线程中的所有操作先于<code>join()</code>后的操作，确保主线程读取到正确结果。</li>
</ul>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="JVM内存模型（程序计数器、栈、堆、方法区）？什么情况下会触发StackOverflowError和OutOfMemoryError？"><a href="#JVM内存模型（程序计数器、栈、堆、方法区）？什么情况下会触发StackOverflowError和OutOfMemoryError？" class="headerlink" title="JVM内存模型（程序计数器、栈、堆、方法区）？什么情况下会触发StackOverflowError和OutOfMemoryError？"></a>JVM内存模型（程序计数器、栈、堆、方法区）？什么情况下会触发StackOverflowError和OutOfMemoryError？</h3><table>
<thead>
<tr>
<th align="left"><strong>内存区域</strong></th>
<th align="left"><strong>描述</strong></th>
<th align="left"><strong>线程共享性</strong></th>
<th align="left"><strong>异常触发条件</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>程序计数器（PC）</strong></td>
<td align="left">记录当前线程执行的字节码指令地址，线程私有，唯一无OOM的区域。</td>
<td align="left">线程私有</td>
<td align="left">无（不会抛出内存相关异常）</td>
</tr>
<tr>
<td align="left"><strong>虚拟机栈（Java Stack）</strong></td>
<td align="left">存储方法调用的栈帧（局部变量表、操作数栈、动态链接、方法出口等），线程私有。</td>
<td align="left">线程私有</td>
<td align="left"><code>StackOverflowError</code>（栈深度溢出） <code>OutOfMemoryError</code>（无法扩展栈空间）</td>
</tr>
<tr>
<td align="left"><strong>本地方法栈（Native Stack）</strong></td>
<td align="left">为Native方法（如C&#x2F;C++实现的方法）提供栈空间，线程私有。</td>
<td align="left">线程私有</td>
<td align="left">同虚拟机栈</td>
</tr>
<tr>
<td align="left"><strong>堆（Heap）</strong></td>
<td align="left">存放对象实例和数组，所有线程共享，是垃圾回收的主要区域。</td>
<td align="left">线程共享</td>
<td align="left"><code>OutOfMemoryError</code>（堆内存不足）</td>
</tr>
<tr>
<td align="left"><strong>方法区（Method Area）</strong></td>
<td align="left">存储类信息、常量、静态变量、即时编译器代码等数据。JDK 8后由元空间（Metaspace）实现。</td>
<td align="left">线程共享</td>
<td align="left"><code>OutOfMemoryError</code>（元空间&#x2F;方法区内存不足）</td>
</tr>
</tbody></table>
<p><strong>触发StackOverflowError</strong></p>
<ul>
<li><p><strong>无限递归</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackOverflowExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recursiveMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        recursiveMethod(); <span class="comment">// 无限递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        recursiveMethod(); <span class="comment">// 触发StackOverflowError</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次方法调用都会在虚拟机栈中压入新栈帧，超出栈的最大深度限制（默认1MB，可通过<code>-Xss</code>调整）。</p>
</li>
<li><p>栈帧过大（局部变量过多或方法操作数栈过深）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">largeMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a1, a2, a3, ..., a10000; <span class="comment">// 大量局部变量占用栈空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单个栈帧占用的内存超过栈容量。</p>
</li>
</ul>
<p><strong>触发OutOfMemoryError</strong></p>
<ul>
<li><p><strong>堆内存溢出</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不断创建大对象，耗尽堆内存</span></span><br><span class="line">List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]); <span class="comment">// 每次分配1MB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原因</strong>：对象数量超过堆容量（可通过<code>-Xmx</code>和<code>-Xms</code>调整堆大小）。</p>
<p><strong>典型场景</strong>：内存泄漏（如静态集合未释放对象）或合理内存不足。</p>
</li>
<li><p><strong>方法区&#x2F;元空间溢出</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态生成大量类（如使用CGLIB）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MetaspaceOOM</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(OOMObject.class);</span><br><span class="line">        enhancer.setCallback((MethodInterceptor) (obj, method, args1, proxy) -&gt; proxy.invokeSuper(obj, args1));</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            enhancer.create(); <span class="comment">// 持续生成代理类</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OOMObject</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原因</strong>：加载的类数量或元数据量超过元空间容量（通过<code>-XX:MaxMetaspaceSize</code>设置上限）。</p>
<p><strong>典型场景</strong>：动态代理框架（如Spring AOP）、反射滥用。</p>
</li>
<li><p><strong>虚拟机栈或本地方法栈无法扩展</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动大量线程，每个线程的栈空间无法分配</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadOOM</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">1000000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原因</strong>：线程数量过多导致栈总内存超过系统限制（通过<code>-Xss</code>减少单个线程栈大小）。</p>
</li>
</ul>
<p><strong>总结</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>错误类型</strong></th>
<th align="left"><strong>触发场景</strong></th>
<th align="left"><strong>典型原因</strong></th>
<th align="left"><strong>解决方案</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>StackOverflowError</strong></td>
<td align="left">递归调用未终止、栈帧过大</td>
<td align="left">代码逻辑错误</td>
<td align="left">修复递归终止条件，减少局部变量数量</td>
</tr>
<tr>
<td align="left"><strong>OutOfMemoryError</strong></td>
<td align="left">堆内存不足、元空间溢出、线程数过多</td>
<td align="left">内存泄漏、配置不当、资源耗尽</td>
<td align="left">调整JVM参数，优化代码，增加物理内存</td>
</tr>
</tbody></table>
<h3 id="类加载机制（双亲委派模型）及其如何避免类重复加载？如何破坏双亲委派模型？"><a href="#类加载机制（双亲委派模型）及其如何避免类重复加载？如何破坏双亲委派模型？" class="headerlink" title="类加载机制（双亲委派模型）及其如何避免类重复加载？如何破坏双亲委派模型？"></a>类加载机制（双亲委派模型）及其如何避免类重复加载？如何破坏双亲委派模型？</h3><p>类加载器层级结构：</p>
<table>
<thead>
<tr>
<th align="left"><strong>类加载器</strong></th>
<th align="left"><strong>加载路径</strong></th>
<th align="left"><strong>父加载器</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Bootstrap ClassLoader</strong></td>
<td align="left"><code>JRE/lib/rt.jar</code>等核心库</td>
<td align="left">无（顶级加载器）</td>
</tr>
<tr>
<td align="left"><strong>Extension ClassLoader</strong></td>
<td align="left"><code>JRE/lib/ext</code>目录下扩展库</td>
<td align="left">Bootstrap</td>
</tr>
<tr>
<td align="left"><strong>Application ClassLoader</strong></td>
<td align="left">应用类路径（ClassPath）</td>
<td align="left">Extension</td>
</tr>
<tr>
<td align="left"><strong>自定义ClassLoader</strong></td>
<td align="left">用户自定义路径</td>
<td align="left">Application</td>
</tr>
</tbody></table>
<p><strong>避免类重复加载的机制</strong></p>
<ul>
<li><strong>唯一性保证</strong>：同一个类由<strong>同一个类加载器</strong>加载时，在JVM中仅存在一份<code>Class</code>对象。</li>
<li><strong>层级优先</strong>：父加载器优先加载核心类，避免子加载器重复加载核心类（如<code>java.lang.String</code>）</li>
</ul>
<p>双亲委派模型的优缺点：</p>
<table>
<thead>
<tr>
<th align="left"><strong>优点</strong></th>
<th align="left"><strong>缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">避免核心类被篡改（安全）</td>
<td align="left">灵活性较低，难以实现模块化隔离</td>
</tr>
<tr>
<td align="left">防止类重复加载（节省内存）</td>
<td align="left">父加载器无法访问子加载器的类</td>
</tr>
</tbody></table>
<p>破坏双亲委派模型：</p>
<ol>
<li><p>自定义类加载器重写<code>loadClass()</code>：覆盖默认的委派逻辑，直接由子加载器加载类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 1. 自定义逻辑优先加载特定类</span></span><br><span class="line">        <span class="keyword">if</span> (name.startsWith(<span class="string">&quot;com.example&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 其他类仍委派父加载器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.loadClass(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程上下文类加载器（Thread Context ClassLoader）：父加载器（如Bootstrap）需加载子加载器（如Application）的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置上下文类加载器</span></span><br><span class="line">Thread.currentThread().setContextClassLoader(customClassLoader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// SPI示例：加载JDBC驱动</span></span><br><span class="line">ServiceLoader&lt;Driver&gt; drivers = ServiceLoader.load(Driver.class);OSGi模块化热部</span><br></pre></td></tr></table></figure>
</li>
<li><p>OSGi模块化热部</p>
<ul>
<li><strong>原理</strong>：每个模块（Bundle）使用独立类加载器，形成网状结构，动态管理依赖。</li>
<li><strong>特点</strong>：允许不同模块加载同一类的不同版本。</li>
</ul>
</li>
</ol>
<p><strong>破坏双亲委派的典型场景</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>场景</strong></th>
<th align="left"><strong>实现方式</strong></th>
<th align="left"><strong>目的</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Tomcat Web应用隔离</strong></td>
<td align="left">每个Web应用使用独立的<code>WebappClassLoader</code></td>
<td align="left">隔离不同应用的类，避免冲突</td>
</tr>
<tr>
<td align="left"><strong>Java SPI机制</strong></td>
<td align="left">使用线程上下文类加载器</td>
<td align="left">核心库（如JDBC）加载第三方实现类</td>
</tr>
<tr>
<td align="left"><strong>热部署&#x2F;热更新</strong></td>
<td align="left">自定义类加载器动态加载新版本类</td>
<td align="left">无需重启JVM更新代码</td>
</tr>
</tbody></table>
<h3 id="垃圾回收算法（标记-清除、复制、标记-整理）及适用场景？G1收集器的特点？"><a href="#垃圾回收算法（标记-清除、复制、标记-整理）及适用场景？G1收集器的特点？" class="headerlink" title="垃圾回收算法（标记-清除、复制、标记-整理）及适用场景？G1收集器的特点？"></a>垃圾回收算法（标记-清除、复制、标记-整理）及适用场景？G1收集器的特点？</h3><table>
<thead>
<tr>
<th>算法</th>
<th>步骤</th>
<th>特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>标记-清除（Mark-Sweep）</strong></td>
<td>1. <strong>标记</strong>：遍历所有对象，标记存活对象。<br/>2. <strong>清除</strong>：回收未被标记的对象（垃圾）。</td>
<td><strong>优点</strong>：实现简单，不需要移动对象。<br/><strong>缺点</strong>：产生内存碎片，可能触发频繁的 Full GC。</td>
<td>1. 老年代回收（如 CMS 收集器的初始阶段）。<br/>2. 对内存碎片不敏感的场景，或短期运行的应用程序。</td>
</tr>
<tr>
<td><strong>复制算法（Copying）</strong></td>
<td>1. 将内存分为两块（From 和 To），对象分配在 From 区。<br/>2. 标记存活对象，将其复制到 To 区。 <br/>3. 清空 From 区，交换 From 和 To 的角色。</td>
<td><strong>优点</strong>：无内存碎片，回收高效。 <br/><strong>缺点</strong>：内存利用率低（需预留一半空间）。</td>
<td>1. 新生代回收（如 Serial、ParNew、Parallel Scavenge 等收集器）。<br/>2. 适用于对象存活率低的场景（如新生代 Eden 区）。</td>
</tr>
<tr>
<td><strong>标记-整理（Mark-Compact）</strong></td>
<td><strong>标记</strong>：遍历所有对象，标记存活对象。<br/><strong>整理</strong>：将存活对象向内存一端移动，清理边界外的空间。</td>
<td><strong>优点</strong>：避免内存碎片，适合长期运行的系统。 <strong>缺点</strong>：移动对象需要时间，导致停顿较长（STW）。</td>
<td>1. 老年代回收（如 Serial Old、Parallel Old 收集器）。 <br/>2. 对内存敏感且需要避免碎片的场景（如大数据应用）。</td>
</tr>
</tbody></table>
<h3 id="强引用、软引用、弱引用、虚引用的区别及使用场景？"><a href="#强引用、软引用、弱引用、虚引用的区别及使用场景？" class="headerlink" title="强引用、软引用、弱引用、虚引用的区别及使用场景？"></a>强引用、软引用、弱引用、虚引用的区别及使用场景？</h3><p><strong>1. 强引用（Strong Reference）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();  <span class="comment">// 默认引用类型</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>特点</strong>：<ul>
<li>对象<strong>不会被垃圾回收</strong>，只要存在强引用关联。</li>
<li>即使内存不足时，JVM 宁可抛出 <code>OutOfMemoryError</code> 也不回收强引用对象。</li>
</ul>
</li>
<li><strong>使用场景</strong>：<ul>
<li><strong>通用对象引用</strong>：日常代码中默认的引用类型。</li>
<li><strong>必须长期存在的对象</strong>：如核心业务对象、数据库连接池。</li>
</ul>
</li>
</ul>
<p><strong>2. 软引用（Soft Reference）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;Object&gt; softRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>特点</strong>：<ul>
<li>对象在<strong>内存不足时</strong>会被垃圾回收（在抛出 <code>OutOfMemoryError</code> 前触发回收）。</li>
<li>可通过 <code>softRef.get()</code> 获取对象，若返回 <code>null</code> 说明已被回收。</li>
</ul>
</li>
<li><strong>使用场景</strong>：<ul>
<li><strong>内存敏感缓存</strong>：如图片缓存、临时计算结果缓存。</li>
<li><strong>避免内存溢出</strong>：缓存数据允许在内存紧张时自动释放。</li>
</ul>
</li>
</ul>
<p><strong>3. 弱引用（Weak Reference）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;Object&gt; weakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>特点</strong>：<ul>
<li>对象在<strong>下一次垃圾回收时</strong>会被回收（无论内存是否充足）。</li>
<li>常用于解决内存泄漏问题（如 <code>WeakHashMap</code> 的键设计）。</li>
</ul>
</li>
<li><strong>使用场景</strong>：<ul>
<li><strong>监听器或临时映射</strong>：如 <code>WeakHashMap</code> 用于保存临时键值对。</li>
<li><strong>防止内存泄漏</strong>：如 Android 中的 <code>Handler</code> 弱引用持有 <code>Activity</code>。</li>
</ul>
</li>
</ul>
<p><strong>4. 虚引用（Phantom Reference）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">PhantomReference&lt;Object&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>(), queue);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>特点</strong>：<ul>
<li>无法通过 <code>phantomRef.get()</code> 获取对象（始终返回 <code>null</code>）。</li>
<li>对象被回收时，虚引用会被加入关联的 <code>ReferenceQueue</code>。</li>
<li>需与 <code>ReferenceQueue</code> 配合使用，用于<strong>跟踪对象回收事件</strong>。</li>
</ul>
</li>
<li><strong>使用场景</strong>：<ul>
<li><strong>堆外内存管理</strong>：如 <code>DirectByteBuffer</code> 回收后触发堆外内存释放（NIO 中使用）。</li>
<li><strong>资源清理监控</strong>：确保某些资源在对象回收后同步释放（如文件句柄）。</li>
</ul>
</li>
</ul>
<p><strong>对比总结</strong></p>
<table>
<thead>
<tr>
<th align="left">引用类型</th>
<th align="left">回收时机</th>
<th align="left">是否阻止 GC</th>
<th align="left">典型场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left">强引用</td>
<td align="left"><strong>永不回收</strong></td>
<td align="left">是</td>
<td align="left">默认对象引用</td>
</tr>
<tr>
<td align="left">软引用</td>
<td align="left"><strong>内存不足时回收</strong></td>
<td align="left">否</td>
<td align="left">内存敏感缓存</td>
</tr>
<tr>
<td align="left">弱引用</td>
<td align="left"><strong>下次 GC 时回收</strong></td>
<td align="left">否</td>
<td align="left">临时缓存、防内存泄漏</td>
</tr>
<tr>
<td align="left">虚引用</td>
<td align="left"><strong>对象回收后通知</strong></td>
<td align="left">否</td>
<td align="left">资源清理跟踪</td>
</tr>
</tbody></table>
<p><strong>关键机制</strong></p>
<ol>
<li><strong>引用队列（ReferenceQueue）</strong>：<ul>
<li>软引用、弱引用、虚引用可关联一个 <code>ReferenceQueue</code>。</li>
<li>对象被回收后，引用对象会被加入队列，用于后续处理（如资源清理）。</li>
</ul>
</li>
<li><strong>内存泄漏防护</strong>：<ul>
<li>弱引用和软引用可避免因疏忽导致的对象无法回收（如监听器未注销）。</li>
</ul>
</li>
</ol>
<p><strong>使用示例</strong></p>
<p><strong>1. 软引用实现缓存</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存图片数据</span></span><br><span class="line">SoftReference&lt;<span class="type">byte</span>[]&gt; imageCache = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(loadImage());</span><br><span class="line"><span class="type">byte</span>[] image = imageCache.get();</span><br><span class="line"><span class="keyword">if</span> (image == <span class="literal">null</span>) &#123;</span><br><span class="line">    image = loadImage();  <span class="comment">// 重新加载</span></span><br><span class="line">    imageCache = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 弱引用解决内存泄漏</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 WeakHashMap 保存临时数据</span></span><br><span class="line">WeakHashMap&lt;Thread, String&gt; threadContext = <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;&gt;();</span><br><span class="line">threadContext.put(Thread.currentThread(), <span class="string">&quot;current-context&quot;</span>);</span><br><span class="line"><span class="comment">// 当线程销毁时，Entry 自动被回收</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 虚引用管理堆外内存</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跟踪 DirectByteBuffer 回收</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line">ReferenceQueue&lt;ByteBuffer&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">PhantomReference&lt;ByteBuffer&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(buffer, queue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听队列，释放堆外内存</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        phantomRef.remove(queue.remove().get());</span><br><span class="line">        unsafe.freeMemory(address);  <span class="comment">// 释放堆外内存</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<ul>
<li><strong>避免滥用软&#x2F;弱引用</strong>：过度依赖会导致代码复杂度上升，优先使用强引用。</li>
<li><strong>虚引用需谨慎</strong>：需结合 <code>ReferenceQueue</code> 和后台线程处理，适用于底层资源管理。</li>
</ul>
<p><strong>Q：对象内存布局（对象头对齐）</strong></p>
<p><strong>Q：G1收集器Mixed GC过程解析</strong></p>
<h3 id="线上Full-GC频繁的排查思路"><a href="#线上Full-GC频繁的排查思路" class="headerlink" title="线上Full GC频繁的排查思路"></a>线上Full GC频繁的排查思路</h3><p><strong>1. 确认现象</strong></p>
<ul>
<li><strong>监控指标</strong>：<ul>
<li>通过 <code>jstat -gcutil &lt;pid&gt;</code> 或监控系统（如 Prometheus + Grafana）观察：<ul>
<li><strong>老年代使用率（Old&#x2F;O）</strong>：是否持续增长或快速填满。</li>
<li><strong>Full GC 频率</strong>：Full GC 次数（FGC）和时间（FGCT）是否异常。</li>
</ul>
</li>
<li><strong>应用表现</strong>：是否伴随服务延迟增加、请求超时或 OOM 错误。</li>
</ul>
</li>
</ul>
<p><strong>2. 收集关键数据</strong></p>
<ul>
<li><p><strong>开启 GC 日志</strong>（若无）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -Xloggc:/path/to/gc.log</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>生成堆转储文件</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=heapdump.hprof &lt;pid&gt;          <span class="comment"># 立即生成</span></span><br><span class="line">jmap -dump:live,format=b,file=heapdump.hprof &lt;pid&gt;    <span class="comment"># 触发 Full GC 后生成（更精确）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看线程和类加载信息</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jstack &lt;pid&gt; &gt; thread.txt    <span class="comment"># 线程快照（排查死锁或阻塞）</span></span><br><span class="line">jmap -histo:live &lt;pid&gt;       <span class="comment"># 存活对象直方图（初步分析大对象）</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>3. 分析 Full GC 触发原因</strong></p>
<p>通过 <strong>GC 日志</strong> 确定触发原因：</p>
<table>
<thead>
<tr>
<th align="left"><strong>触发类型</strong></th>
<th align="left"><strong>日志特征</strong></th>
<th align="left"><strong>常见原因</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>老年代空间不足</strong></td>
<td align="left"><code>[Full GC (Allocation Failure)]</code></td>
<td align="left">内存泄漏、大对象直接进入老年代、Survivor 区过小导致对象过早晋升。</td>
</tr>
<tr>
<td align="left"><strong>元空间不足</strong></td>
<td align="left"><code>[Full GC (Metadata GC Threshold)]</code></td>
<td align="left">元空间配置过小（<code>-XX:MetaspaceSize</code>）、动态生成类过多（如反射、CGLIB）。</td>
</tr>
<tr>
<td align="left"><strong>显式调用 System.gc()</strong></td>
<td align="left"><code>[Full GC (System.gc())]</code></td>
<td align="left">代码或第三方库中调用了 <code>System.gc()</code>。</td>
</tr>
<tr>
<td align="left"><strong>晋升失败（Promotion Failed）</strong></td>
<td align="left"><code>[Full GC (Promotion Failed)]</code></td>
<td align="left">新生代垃圾回收后 Survivor 区空间不足，且老年代无法容纳晋升对象。</td>
</tr>
</tbody></table>
<p><strong>4. 排查方向</strong></p>
<p><strong>(1) 内存泄漏</strong></p>
<ul>
<li><strong>分析堆转储</strong>：<ul>
<li>使用 <strong>MAT（Memory Analyzer Tool）</strong> 或 <strong>VisualVM</strong> 加载 <code>heapdump.hprof</code>。</li>
<li>查找 <strong>Dominator Tree</strong> 中占用内存最大的对象，检查是否合理。</li>
<li>查看 <strong>Leak Suspects</strong> 报告，定位疑似泄漏的代码位置。</li>
</ul>
</li>
<li><strong>对比堆转储</strong>：<ul>
<li>间隔一段时间生成多个堆转储，分析对象数量和内存占用的增长趋势。</li>
</ul>
</li>
</ul>
<p><strong>(2) 大对象分配</strong></p>
<ul>
<li><strong>检查大对象</strong>：<ul>
<li>通过 <code>jmap -histo &lt;pid&gt;</code> 或堆转储，查找占用大量内存的 <strong>大数组（如 byte[]）</strong> 或 <strong>缓存对象</strong>。</li>
<li>代码中是否有直接分配大对象（如文件读取未分块）或缓存未设置过期策略。</li>
</ul>
</li>
<li><strong>优化参数</strong>：<ul>
<li>增大 <code>-XX:PretenureSizeThreshold</code>（默认 0，大对象直接进老年代），避免大对象在新生代复制。</li>
</ul>
</li>
</ul>
<p><strong>(3) 内存分配不合理</strong></p>
<ul>
<li><strong>新生代&#x2F;老年代比例</strong>：<ul>
<li>若 Survivor 区过小（<code>-XX:SurvivorRatio</code> 不合理），对象会过早晋升到老年代。</li>
<li>调整比例（如 <code>-XX:NewRatio=2</code> 表示老年代:新生代&#x3D;2:1）。</li>
</ul>
</li>
<li><strong>元空间配置</strong>：<ul>
<li>增大 <code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code>（例如 <code>-XX:MaxMetaspaceSize=512M</code>）。</li>
</ul>
</li>
</ul>
<p><strong>(4) 垃圾收集器选择</strong></p>
<ul>
<li><strong>CMS&#x2F;G1 的 Full GC 触发机制差异</strong>：<ul>
<li><strong>CMS</strong> 并发模式失败时会触发 Full GC，需优化 <code>-XX:CMSInitiatingOccupancyFraction</code>。</li>
<li><strong>G1</strong> 的 Full GC 通常是疏散失败（Evacuation Failure），需降低 <code>-XX:InitiatingHeapOccupancyPercent</code>。</li>
</ul>
</li>
</ul>
<p><strong>5. 优化与验证</strong></p>
<ul>
<li><p><strong>代码优化</strong>：</p>
<ul>
<li>修复内存泄漏（如未关闭的数据库连接、静态集合缓存未清理）。</li>
<li>避免显式调用 <code>System.gc()</code>，或添加 <code>-XX:+DisableExplicitGC</code> 禁用。</li>
<li>使用对象池或软&#x2F;弱引用优化缓存。</li>
</ul>
</li>
<li><p><strong>参数调优</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例：增大堆大小、调整新生代比例、启用 G1 收集器</span></span><br><span class="line">-Xms4g -Xmx4g -XX:NewRatio=2 -XX:+UseG1GC -XX:MaxGCPauseMillis=200</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>压测验证</strong>：</p>
<ul>
<li>使用 JMeter 或模拟流量验证优化后 Full GC 频率是否降低。</li>
</ul>
</li>
</ul>
<p><strong>6. 高频问题速查表</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>现象</strong></th>
<th align="left"><strong>优先排查点</strong></th>
<th align="left"><strong>工具&#x2F;命令</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">Full GC 后老年代仍占满</td>
<td align="left">内存泄漏、大对象</td>
<td align="left">MAT 分析堆转储、<code>jmap -histo</code></td>
</tr>
<tr>
<td align="left">频繁元空间 Full GC</td>
<td align="left">动态类加载过多</td>
<td align="left"><code>jcmd &lt;pid&gt; VM.classloader_stats</code></td>
</tr>
<tr>
<td align="left">晋升失败（Promotion）</td>
<td align="left">Survivor 区过小、对象存活时间过长</td>
<td align="left">调整 <code>-XX:SurvivorRatio</code>、对象生命周期分析</td>
</tr>
<tr>
<td align="left">System.gc() 触发</td>
<td align="left">代码或第三方库调用</td>
<td align="left">代码扫描、<code>grep -R &quot;System.gc(&quot;</code></td>
</tr>
</tbody></table>
<p><strong>7. 注意事项</strong></p>
<ul>
<li><strong>谨慎处理线上堆转储</strong>：<ul>
<li>生成堆转储可能导致应用短暂停顿，建议在低峰期操作。</li>
<li>使用 <code>-XX:+HeapDumpOnOutOfMemoryError</code> 自动生成 OOM 时的堆转储。</li>
</ul>
</li>
<li><strong>监控常态化</strong>：<ul>
<li>集成 APM 工具（如 SkyWalking、Arthas）实时监控 GC 和内存指标。</li>
</ul>
</li>
</ul>
<p><strong>Q：内存泄漏定位（MAT使用技巧）</strong></p>
<h3 id="方法区演进（永久代-元空间）"><a href="#方法区演进（永久代-元空间）" class="headerlink" title="方法区演进（永久代-&gt;元空间）"></a>方法区演进（永久代-&gt;元空间）</h3><p>在 Java 虚拟机（JVM）中，<strong>方法区（Method Area）</strong> 是存储类元数据（如类结构、常量池、方法代码等）的逻辑区域。其具体实现随着 Java 版本的演进发生了重大变化：</p>
<ul>
<li><strong>JDK 7 及之前</strong>：方法区由 <strong>永久代（PermGen）</strong> 实现，属于堆内存的一部分。</li>
<li><strong>JDK 8 及之后</strong>：方法区由 <strong>元空间（Metaspace）</strong> 实现，使用本地内存（Native Memory）管理类元数据。</li>
</ul>
<p><strong>一、永久代（PermGen）的局限性</strong></p>
<p><strong>1. 内存管理问题</strong></p>
<ul>
<li><strong>固定大小</strong>：通过 <code>-XX:PermSize</code> 和 <code>-XX:MaxPermSize</code> 设置永久代大小，但易因内存不足触发 <code>java.lang.OutOfMemoryError: PermGen space</code>。</li>
<li><strong>调优困难</strong>：动态加载大量类（如反射、CGLIB 代理）时，需手动调整 PermGen 大小，容易出现配置错误。</li>
</ul>
<p><strong>2. 垃圾回收低效</strong></p>
<ul>
<li><strong>Full GC 依赖</strong>：永久代的垃圾回收与老年代耦合，触发 Full GC 时才会回收无用类元数据，导致停顿时间长。</li>
<li><strong>回收条件复杂</strong>：类卸载需满足严格条件（如类加载器被回收、所有实例被回收），实际场景中回收率低。</li>
</ul>
<p><strong>3. 元数据与堆内存竞争</strong></p>
<ul>
<li><strong>堆内存碎片</strong>：永久代作为堆的一部分，与对象实例内存共享空间，可能导致内存碎片化。</li>
</ul>
<p><strong>二、元空间（Metaspace）的设计优势</strong></p>
<p><strong>1. 内存分配机制</strong></p>
<ul>
<li><strong>本地内存管理</strong>：元空间直接使用操作系统的本地内存（Native Memory），而非 JVM 堆内存。</li>
<li><strong>动态扩展</strong>：默认无最大限制（受物理内存和操作系统约束），可通过 <code>-XX:MaxMetaspaceSize</code> 设置上限，避免无限增长。</li>
</ul>
<p><strong>2. 内存回收优化</strong></p>
<ul>
<li><strong>独立回收</strong>：元空间的垃圾回收与堆的 Young GC&#x2F;Full GC 解耦，由元空间自身触发（如类加载器死亡时）。</li>
<li><strong>高效内存释放</strong>：元数据内存以块（Chunk）为单位分配，整块回收效率更高。</li>
</ul>
<p><strong>3. 参数简化</strong></p>
<ul>
<li><p><strong>废弃 PermGen 参数</strong>：不再需要 <code>-XX:PermSize</code> 和 <code>-XX:MaxPermSize</code>。</p>
</li>
<li><p><strong>核心参数</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=128m          <span class="comment"># 初始大小（默认约 21MB）</span></span><br><span class="line">-XX:MaxMetaspaceSize=512m       <span class="comment"># 最大限制（默认无上限）</span></span><br><span class="line">-XX:MinMetaspaceFreeRatio=40    <span class="comment"># 扩容阈值：最小空闲比例</span></span><br><span class="line">-XX:MaxMetaspaceFreeRatio=70    <span class="comment"># 缩容阈值：最大空闲比例</span></span><br></pre></td></tr></table></figure></li>
</ul>
<table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>永久代（PermGen）</strong></th>
<th align="left"><strong>元空间（Metaspace）</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>内存位置</strong></td>
<td align="left">堆内存的一部分</td>
<td align="left">本地内存（Native Memory）</td>
</tr>
<tr>
<td align="left"><strong>内存管理</strong></td>
<td align="left">JVM 堆内存管理，固定大小</td>
<td align="left">操作系统动态管理，可扩展</td>
</tr>
<tr>
<td align="left"><strong>垃圾回收</strong></td>
<td align="left">依赖 Full GC，效率低</td>
<td align="left">独立回收，高效且与堆 GC 解耦</td>
</tr>
<tr>
<td align="left"><strong>内存溢出错误</strong></td>
<td align="left"><code>OutOfMemoryError: PermGen space</code></td>
<td align="left"><code>OutOfMemoryError: Metaspace</code></td>
</tr>
<tr>
<td align="left"><strong>调优参数</strong></td>
<td align="left"><code>-XX:PermSize</code>、<code>-XX:MaxPermSize</code></td>
<td align="left"><code>-XX:MetaspaceSize</code>、<code>-XX:MaxMetaspaceSize</code></td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">静态类加载场景</td>
<td align="left">动态类加载（如反射、动态代理、OSGi）</td>
</tr>
</tbody></table>
<h3 id="逃逸分析与栈上分配"><a href="#逃逸分析与栈上分配" class="headerlink" title="逃逸分析与栈上分配"></a>逃逸分析与栈上分配</h3><p><strong>逃逸分析（Escape Analysis）</strong></p>
<p><strong>定义</strong>：<br>逃逸分析是 JVM 在 <strong>编译阶段（如 JIT 即时编译）</strong> 分析对象的作用域，判断对象是否会“逃逸”出当前方法或线程的技术。</p>
<ul>
<li><strong>逃逸类型</strong>：<ul>
<li><strong>方法逃逸</strong>：对象被其他方法访问（如作为返回值或参数传递）。</li>
<li><strong>线程逃逸</strong>：对象被其他线程访问（如赋值给全局变量）。</li>
</ul>
</li>
</ul>
<p><strong>目的</strong>：<br>确定对象是否仅存活于当前方法栈帧内，从而进行内存分配优化（如栈上分配或标量替换），<strong>减少堆内存分配和垃圾回收压力</strong>。</p>
<p><strong>栈上分配（Stack Allocation）</strong></p>
<p><strong>机制</strong>：<br>若逃逸分析确定对象 <strong>未逃逸</strong>，JVM 可能将对象直接分配在 <strong>栈帧</strong> 中（而非堆内存）。</p>
<ul>
<li><strong>生命周期管理</strong>：栈帧随方法调用结束自动销毁，对象内存立即释放，无需 GC 介入。</li>
<li><strong>HotSpot 实现细节</strong>：<br>实际并非直接在栈上分配完整对象，而是通过 <strong>标量替换（Scalar Replacement）</strong> 将对象拆解为基本类型变量（如 <code>int</code>、<code>long</code>），直接在栈或寄存器中分配。</li>
</ul>
<p><strong>验证逃逸分析与栈上分配</strong></p>
<p><strong>1. 查看 JIT 编译日志</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintCompilation             <span class="comment"># 打印编译日志</span></span><br><span class="line">-XX:+PrintEscapeAnalysis          <span class="comment"># 输出逃逸分析结果（部分 JVM 版本支持）</span></span><br><span class="line">-XX:+PrintInlining                <span class="comment"># 显示内联优化</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 对比 GC 日志</strong></p>
<ul>
<li><strong>未优化时</strong>：大量临时对象分配触发 Young GC。</li>
<li><strong>优化后</strong>：相同代码段的 Young GC 频率显著降低。</li>
</ul>
<p><strong>3. 示例测试代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EscapeAnalysisDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        Point(<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="built_in">this</span>.x = x; <span class="built_in">this</span>.y = y; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100_000_000</span>; i++) &#123;</span><br><span class="line">            allocate();  <span class="comment">// 调用 1 亿次，观察 GC 情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时：&quot;</span> + (System.currentTimeMillis() - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">allocate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// 对象未逃逸，可能被优化</span></span><br><span class="line">        <span class="comment">// 无操作（仅测试分配开销）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>运行参数</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xmx100m -Xms100m -XX:+PrintGC -XX:-DoEscapeAnalysis  <span class="comment"># 关闭逃逸分析</span></span><br><span class="line">-Xmx100m -Xms100m -XX:+PrintGC -XX:+DoEscapeAnalysis   <span class="comment"># 开启逃逸分析</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>结果对比</strong>：<br>开启逃逸分析后，GC 次数显著减少，执行时间缩短。</p>
</li>
</ul>
<p><strong>逃逸分析的局限性</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>场景</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>对象实际逃逸</strong></td>
<td align="left">若逃逸分析误判（如对象被外部引用），优化失效。</td>
</tr>
<tr>
<td align="left"><strong>复杂对象结构</strong></td>
<td align="left">包含大字段或嵌套引用的对象可能无法完全优化。</td>
</tr>
<tr>
<td align="left"><strong>CPU 资源消耗</strong></td>
<td align="left">逃逸分析本身消耗 CPU 时间，极端情况下可能降低性能。</td>
</tr>
</tbody></table>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="循环依赖解决原理"><a href="#循环依赖解决原理" class="headerlink" title="循环依赖解决原理"></a>循环依赖解决原理</h2><p>Spring 通过<strong>三级缓存（三级 Map 结构）</strong>解决单例 Bean 的循环依赖问题，其核心原理是<strong>提前暴露未完成初始化的 Bean 引用</strong>，从而打破循环依赖的僵局。以下是详细原理和流程：</p>
<p><strong>三级缓存的定义与作用</strong></p>
<ol>
<li><strong>一级缓存（singletonObjects）</strong><br>存放<strong>完全初始化好的 Bean</strong>，可以直接使用。</li>
<li><strong>二级缓存（earlySingletonObjects）</strong><br>存放<strong>提前暴露的 Bean 的早期引用</strong>（仅实例化，尚未填充属性和初始化）。</li>
<li><strong>三级缓存（singletonFactories）</strong><br>存放 Bean 的 <strong>ObjectFactory</strong>，用于生成 Bean 的早期引用（可能生成代理对象，用于支持 AOP）。</li>
</ol>
<p><strong>解决循环依赖的流程</strong></p>
<p>以 <code>A → B → A</code> 的循环依赖为例：</p>
<ol>
<li><strong>创建 Bean A</strong></li>
</ol>
<ul>
<li><strong>实例化 A</strong>：调用构造函数创建 A 对象（此时属性未填充，称为“早期对象”）。</li>
<li><strong>将 A 的 ObjectFactory 放入三级缓存</strong>：<br><code>addSingletonFactory(A_name, () -&gt; getEarlyBeanReference(A))</code><br>（这一步是关键，允许后续依赖通过 ObjectFactory 获取 A 的早期引用）</li>
</ul>
<ol start="2">
<li><strong>填充 A 的属性</strong></li>
</ol>
<ul>
<li>发现 A 依赖 B，触发 <code>getBean(B)</code>。</li>
</ul>
<ol start="3">
<li><strong>创建 Bean B</strong></li>
</ol>
<ul>
<li><strong>实例化 B</strong>：构造函数创建 B 对象。</li>
<li><strong>将 B 的 ObjectFactory 放入三级缓存</strong>：<br><code>addSingletonFactory(B_name, () -&gt; getEarlyBeanReference(B))</code></li>
</ul>
<ol start="4">
<li><strong>填充 B 的属性</strong></li>
</ol>
<ul>
<li>发现 B 依赖 A，触发 <code>getBean(A)</code>。</li>
<li><strong>从三级缓存获取 A 的 ObjectFactory</strong>，生成 A 的早期引用（可能是原始对象或代理对象）。</li>
<li>将 A 的早期引用放入二级缓存，<strong>同时删除三级缓存中的 A</strong>。</li>
</ul>
<ol start="5">
<li><strong>完成 B 的初始化</strong></li>
</ol>
<ul>
<li>B 的早期引用注入 A 后，继续完成其他初始化和后置处理。</li>
<li>将 B 放入一级缓存，<strong>删除二级和三级缓存中的 B</strong>。</li>
</ul>
<ol start="6">
<li><strong>完成 A 的初始化</strong></li>
</ol>
<ul>
<li>B 已就绪，A 注入 B 后完成属性填充和初始化。</li>
<li>将 A 放入一级缓存，<strong>删除二级缓存中的 A</strong>。</li>
</ul>
<p><strong>关键设计点</strong></p>
<ol>
<li><strong>为什么需要三级缓存？</strong><ul>
<li><strong>支持 AOP 代理</strong>：<br>如果 Bean 需要被代理，三级缓存的 ObjectFactory 可以延迟生成代理对象，确保依赖注入的是最终代理对象，而非原始对象。</li>
<li><strong>避免重复创建代理</strong>：<br>二级缓存（<code>earlySingletonObjects</code>）保存已生成的早期对象（可能是代理），避免多次调用 ObjectFactory。</li>
</ul>
</li>
<li><strong>只能解决单例 Bean 的循环依赖</strong><br>原型（Prototype）Bean 每次都会新建实例，无法通过缓存提前暴露引用。</li>
<li><strong>构造函数循环依赖无法解决</strong><br>若循环依赖通过构造函数发生，Bean 尚未实例化，无法提前暴露引用，Spring 会抛出 <code>BeanCurrentlyInCreationException</code>。</li>
</ol>
<p><strong>总结</strong></p>
<p>Spring 通过三级缓存实现：</p>
<ol>
<li><strong>提前暴露未初始化的 Bean 引用</strong>（通过 ObjectFactory）。</li>
<li><strong>延迟代理对象的生成</strong>，确保依赖注入正确的对象。</li>
<li><strong>缓存层级隔离</strong>，平衡性能与正确性。</li>
</ol>
<p>这一机制使得大多数单例 Bean 的循环依赖问题得以解决，同时保持了框架的灵活性和扩展性。</p>
<h2 id="FactoryBean-的作用与应用"><a href="#FactoryBean-的作用与应用" class="headerlink" title="FactoryBean 的作用与应用"></a><code>FactoryBean</code> 的作用与应用</h2><p><strong>1. FactoryBean 的核心作用</strong><br>FactoryBean 是 Spring 框架中用于 <strong>封装复杂对象创建逻辑</strong> 的特殊接口，其核心作用如下：</p>
<ul>
<li><strong>隐藏复杂构造过程</strong>：将初始化繁琐的对象（如第三方库组件）的创建细节封装在 FactoryBean 中。</li>
<li><strong>动态决定对象类型</strong>：根据条件返回不同类型的 Bean 实例。</li>
<li><strong>延迟初始化</strong>：控制对象的创建时机，实现按需加载。</li>
<li><strong>统一管理依赖</strong>：集中处理对象创建时的依赖注入及配置。</li>
</ul>
<p><strong>2. FactoryBean 接口方法解析</strong><br>实现 <code>FactoryBean</code> 接口需重写以下方法：</p>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>T getObject()</code></td>
<td align="left">返回由 FactoryBean 创建的实际对象实例。</td>
</tr>
<tr>
<td align="left"><code>Class&lt;?&gt; getObjectType()</code></td>
<td align="left">返回创建的对象类型，用于 Spring 容器类型检查。</td>
</tr>
<tr>
<td align="left"><code>boolean isSingleton()</code></td>
<td align="left">决定对象是否为单例。默认 <code>true</code>，若返回 <code>false</code> 则每次请求创建新实例。</td>
</tr>
</tbody></table>
<p><strong>3. 实际应用示例：自定义加密工具 FactoryBean</strong><br>假设需创建一个根据配置动态选择加密算法的工具类，步骤如下：</p>
<p><strong>步骤 1：定义加密接口及实现类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EncryptionTool</span> &#123;</span><br><span class="line">    String <span class="title function_">encrypt</span><span class="params">(String text)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AES 加密实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AesEncryptionTool</span> <span class="keyword">implements</span> <span class="title class_">EncryptionTool</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encrypt</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;AES加密后的数据: &quot;</span> + text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RSA 加密实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RsaEncryptionTool</span> <span class="keyword">implements</span> <span class="title class_">EncryptionTool</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encrypt</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;RSA加密后的数据: &quot;</span> + text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 2：实现 EncryptionToolFactoryBean</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.FactoryBean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EncryptionToolFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;EncryptionTool&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> String algorithm; <span class="comment">// 配置属性，决定加密算法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置算法类型（通过Spring属性注入）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAlgorithm</span><span class="params">(String algorithm)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.algorithm = algorithm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> EncryptionTool <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;AES&quot;</span>.equalsIgnoreCase(algorithm)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AesEncryptionTool</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;RSA&quot;</span>.equalsIgnoreCase(algorithm)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RsaEncryptionTool</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;不支持的加密算法: &quot;</span> + algorithm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> EncryptionTool.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 单例模式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 3：配置 Spring Bean</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- XML 配置方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;encryptionTool&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.EncryptionToolFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;algorithm&quot;</span> <span class="attr">value</span>=<span class="string">&quot;AES&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>或使用 Java 配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FactoryBean&lt;EncryptionTool&gt; <span class="title function_">encryptionTool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">EncryptionToolFactoryBean</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EncryptionToolFactoryBean</span>();</span><br><span class="line">        factory.setAlgorithm(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 4：在业务类中注入使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EncryptionTool encryptionTool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">encrypted</span> <span class="operator">=</span> encryptionTool.encrypt(password);</span><br><span class="line">        System.out.println(<span class="string">&quot;加密后的密码: &quot;</span> + encrypted);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>执行结果</strong>：<br>根据配置的 <code>algorithm</code> 值（AES 或 RSA），<code>UserService</code> 将自动使用对应的加密工具。</p>
<p><strong>4. 获取 FactoryBean 实例本身</strong><br>若需直接获取 <code>FactoryBean</code> 而非其创建的对象，可在 Bean 名称前加 <code>&amp;</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FactoryBean&lt;?&gt; factory = context.getBean(<span class="string">&quot;&amp;encryptionTool&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>5. 实际应用场景总结</strong></p>
<ul>
<li><strong>MyBatis 的 SqlSessionFactoryBean</strong>：封装 <code>SqlSessionFactory</code> 的创建，处理数据源、Mapper 扫描等复杂配置。</li>
<li><strong>Spring 的 ScheduledTaskFactoryBean</strong>：用于动态创建定时任务 Bean。</li>
<li><strong>连接池配置</strong>：如自定义 Druid 数据源的详细参数初始化。</li>
<li><strong>动态代理生成</strong>：结合 AOP，为特定接口生成代理实例。</li>
</ul>
<p><strong>6. 对比普通 @Bean 方法</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>FactoryBean</strong></th>
<th align="left"><strong>@Bean 方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>灵活性</strong></td>
<td align="left">高（可动态决定对象类型，实现复杂初始化逻辑）</td>
<td align="left">中（适合简单对象创建）</td>
</tr>
<tr>
<td align="left"><strong>代码复用</strong></td>
<td align="left">可通过继承复用逻辑</td>
<td align="left">需重复编写相似代码</td>
</tr>
<tr>
<td align="left"><strong>生命周期控制</strong></td>
<td align="left">支持延迟初始化及单例控制</td>
<td align="left">依赖 <code>@Lazy</code> 和 <code>@Scope</code> 注解</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">复杂对象创建、框架集成</td>
<td align="left">简单 Bean 定义、快速配置</td>
</tr>
</tbody></table>
<p><strong>总结</strong><br>FactoryBean 是 Spring 中处理复杂对象创建的强大工具，特别适用于封装初始化逻辑、动态生成实例及框架集成。合理使用 FactoryBean 能显著提升代码的可维护性和扩展性，尤其在需要精细控制 Bean 创建过程时，其优势更为明显。</p>
<h2 id="BeanFactoryPostProcessor-和-BeanPostProcessor-的区别"><a href="#BeanFactoryPostProcessor-和-BeanPostProcessor-的区别" class="headerlink" title="BeanFactoryPostProcessor 和 BeanPostProcessor 的区别"></a><code>BeanFactoryPostProcessor</code> 和 <code>BeanPostProcessor</code> 的区别</h2><table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>BeanFactoryPostProcessor</strong></th>
<th align="left"><strong>BeanPostProcessor</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>作用阶段</strong></td>
<td align="left">Bean 定义加载后、Bean 实例化<strong>之前</strong></td>
<td align="left">Bean 实例化后、初始化（<code>init-method</code>）<strong>前后</strong></td>
</tr>
<tr>
<td align="left"><strong>操作对象</strong></td>
<td align="left">修改 Bean 的<strong>定义</strong>（<code>BeanDefinition</code>）</td>
<td align="left">修改或增强 Bean 的<strong>实例</strong></td>
</tr>
<tr>
<td align="left"><strong>触发次数</strong></td>
<td align="left">每个容器启动时<strong>执行一次</strong></td>
<td align="left"><strong>每个 Bean 初始化时都会触发</strong></td>
</tr>
<tr>
<td align="left"><strong>主要用途</strong></td>
<td align="left">动态修改 Bean 配置（如属性占位符替换）</td>
<td align="left">Bean 实例的代理增强（如 AOP）、属性注入</td>
</tr>
<tr>
<td align="left"><strong>接口方法</strong></td>
<td align="left"><code>postProcessBeanFactory(ConfigurableListableBeanFactory)</code></td>
<td align="left"><code>postProcessBeforeInitialization(Object, String)</code> <code>postProcessAfterInitialization(Object, String)</code></td>
</tr>
<tr>
<td align="left"><strong>典型实现类</strong></td>
<td align="left"><code>PropertySourcesPlaceholderConfigurer</code> <code>ConfigurationClassPostProcessor</code></td>
<td align="left"><code>AutowiredAnnotationBeanPostProcessor</code> <code>AnnotationAwareAspectJAutoProxyCreator</code></td>
</tr>
</tbody></table>
<p><strong>总结</strong></p>
<ul>
<li><strong>BeanFactoryPostProcessor</strong>：干预 Bean 的<strong>定义阶段</strong>，用于容器级配置调整。</li>
<li><strong>BeanPostProcessor</strong>：干预 Bean 的<strong>实例化阶段</strong>，用于 Bean 级功能增强。</li>
</ul>
<h2 id="Bean生命周期扩展点实战"><a href="#Bean生命周期扩展点实战" class="headerlink" title="Bean生命周期扩展点实战"></a>Bean生命周期扩展点实战</h2><p>Spring Bean 生命周期的核心阶段和扩展点顺序：</p>
<ol>
<li><strong>实例化</strong>（调用构造函数）</li>
<li><strong>属性赋值</strong>（依赖注入）</li>
<li><strong>BeanPostProcessor 前置处理</strong>（<code>postProcessBeforeInitialization</code>）</li>
<li><strong>初始化方法</strong>（<code>@PostConstruct</code> → <code>InitializingBean</code> → <code>init-method</code>）</li>
<li><strong>BeanPostProcessor 后置处理</strong>（<code>postProcessAfterInitialization</code>）</li>
<li><strong>Bean 就绪，进入运行期</strong></li>
<li><strong>销毁方法</strong>（<code>@PreDestroy</code> → <code>DisposableBean</code> → <code>destroy-method</code>）</li>
</ol>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-942a927a-86e4-4a01-8f52-9addd89642ff.png" alt="三分恶面渣逆袭：Spring Bean生命周期"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instantiate the bean.</span></span><br><span class="line">    <span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">    <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">            isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                    <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">                    mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">                String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(dependentBeans.length);</span><br><span class="line">                <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                        actualDependentBeans.add(dependentBean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName,</span><br><span class="line">                            <span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">                            StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                            <span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;&#x27;getBeanNamesForType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean as disposable.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SpringBoot自动配置原理"><a href="#SpringBoot自动配置原理" class="headerlink" title="SpringBoot自动配置原理"></a>SpringBoot自动配置原理</h2><p>Spring Boot的自动配置是其核心特性之一，旨在简化应用的配置过程。以下是其实现机制的详细步骤解析：</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-df77ee15-2ff0-4ec7-8e65-e4ebb8ba88f1.png" alt="三分恶面渣逆袭：SpringBoot自动配置原理"></p>
<ol>
<li><strong>启用自动配置</strong></li>
</ol>
<p>通过主类上的<code>@SpringBootApplication</code>注解，该注解组合了<code>@EnableAutoConfiguration</code>，从而触发自动配置机制。</p>
<ol start="2">
<li><strong>加载自动配置类</strong></li>
</ol>
<p>Spring Boot会扫描所有jar包中的<code>META-INF/spring.factories</code>文件，读取<code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>键下的配置类列表。例如：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>条件化筛选配置类</strong></li>
</ol>
<p>每个自动配置类使用条件注解决定是否生效，常见条件包括：</p>
<ul>
<li><strong>@ConditionalOnClass</strong>：类路径存在指定类时生效。</li>
<li><strong>@ConditionalOnMissingBean</strong>：容器中无指定Bean时生效。</li>
<li><strong>@ConditionalOnProperty</strong>：配置文件中存在特定属性时生效。</li>
</ul>
<p><strong>示例：DataSourceAutoConfiguration</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;DataSource.class, EmbeddedDatabaseType.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(DataSourceProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">(DataSourceProperties properties)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> properties.initializeDataSourceBuilder().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>@ConditionalOnClass</strong>确保存在数据库相关类。</li>
<li><strong>@ConditionalOnMissingBean</strong>仅在用户未自定义DataSource时创建Bean。</li>
</ul>
<ol start="4">
<li><strong>绑定配置属性</strong></li>
</ol>
<p>使用<code>@EnableConfigurationProperties</code>将配置属性类（如<code>DataSourceProperties</code>）与配置文件（如<code>application.yml</code>）绑定，允许通过属性动态配置Bean。</p>
<p><strong>application.yml示例</strong></p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mydb</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">secret</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>自动配置Bean的注册</strong></li>
</ol>
<p>满足条件的配置类中的Bean定义被注册到Spring应用上下文，供其他组件注入使用。</p>
<h2 id="自定义Starter开发要点"><a href="#自定义Starter开发要点" class="headerlink" title="自定义Starter开发要点"></a>自定义Starter开发要点</h2><p><strong>1. Starter 的核心组成</strong></p>
<p>一个完整的 Starter 包含两个模块（可合并）：</p>
<ol>
<li><strong><code>xxx-spring-boot-starter</code></strong><br>空模块，仅声明依赖（如自动配置模块和其他必要依赖），供用户直接引入。</li>
<li><strong><code>xxx-spring-boot-autoconfigure</code></strong><br>核心实现模块，包含自动配置类、条件注解、配置属性绑定等。</li>
</ol>
<p><strong>2. 开发步骤与关键代码</strong></p>
<p><strong>步骤 1：创建项目结构</strong></p>
<p>使用 Maven 或 Gradle 创建模块，建议结构：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">my-starter/</span><br><span class="line">  ├── my-starter-spring-boot-autoconfigure/  # 自动配置模块</span><br><span class="line">  │   ├── src/main/java</span><br><span class="line">  │   │   └── com/example/autoconfigure</span><br><span class="line">  │   │       ├── MyServiceAutoConfiguration.java  # 自动配置类</span><br><span class="line">  │   │       └── MyServiceProperties.java         # 配置属性类</span><br><span class="line">  │   └── src/main/resources/META-INF</span><br><span class="line">  │       ├── spring.factories                    # 自动配置注册</span><br><span class="line">  │       └── additional-spring-configuration-metadata.json  # 配置提示（可选）</span><br><span class="line">  │</span><br><span class="line">  └── my-starter-spring-boot-starter/         # Starter 入口模块</span><br><span class="line">      └── pom.xml                             # 仅依赖自动配置模块</span><br></pre></td></tr></table></figure>

<p><strong>步骤 2：编写自动配置类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(MyServiceProperties.class)</span>  <span class="comment">// 启用配置属性绑定</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(MyService.class)</span>  <span class="comment">// 类路径存在 MyService 时生效</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServiceAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>  <span class="comment">// 用户未自定义时注册 Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyService <span class="title function_">myService</span><span class="params">(MyServiceProperties properties)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyService</span>(properties.getUrl(), properties.getTimeout());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 3：定义配置属性类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;my.service&quot;)</span>  <span class="comment">// 配置前缀</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServiceProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://default-url&quot;</span>;  <span class="comment">// 默认值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">timeout</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter 和 Setter 必须提供</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUrl</span><span class="params">()</span> &#123; <span class="keyword">return</span> url; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUrl</span><span class="params">(String url)</span> &#123; <span class="built_in">this</span>.url = url; &#125;</span><br><span class="line">    <span class="comment">// ... 其他属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 4：注册自动配置类</strong></p>
<p>在 <code>resources/META-INF/spring.factories</code> 中声明：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">com.example.autoconfigure.MyServiceAutoConfiguration</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤 5：配置提示（可选）</strong></p>
<p>在 <code>resources/META-INF/additional-spring-configuration-metadata.json</code> 中为配置项添加描述：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my.service.url&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java.lang.String&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;服务 URL 地址&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;defaultValue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://default-url&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my.service.timeout&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java.lang.Integer&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;请求超时时间（毫秒）&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;defaultValue&quot;</span><span class="punctuation">:</span> <span class="number">5000</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤 6：打包并发布</strong></p>
<ul>
<li><strong>Maven</strong>：通过 <code>mvn clean install</code> 安装到本地仓库，或部署到 Nexus 私服。</li>
<li><strong>Gradle</strong>：使用 <code>publishToMavenLocal</code> 或配置发布任务。</li>
</ul>
<p><strong>3. 使用自定义 Starter</strong></p>
<p>用户引入依赖后，可直接通过配置文件（如 <code>application.yml</code>）配置参数：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">my:</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://custom-url</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure>

<p><strong>4. 关键注意事项</strong></p>
<ol>
<li><p><strong>条件化配置</strong><br>使用 <code>@ConditionalOnClass</code>, <code>@ConditionalOnProperty</code> 等注解，确保 Starter 灵活适配不同场景。</p>
</li>
<li><p><strong>避免 Bean 冲突</strong></p>
<ul>
<li>核心 Bean 使用 <code>@ConditionalOnMissingBean</code>，允许用户覆盖。</li>
<li>避免与其他 Starter 的 Bean 名称重复。</li>
</ul>
</li>
<li><p><strong>版本兼容性</strong></p>
<ul>
<li>Starter 的 Spring Boot 版本需与用户项目匹配。</li>
<li>使用 <code>spring-boot-dependencies</code> 管理依赖版本。</li>
</ul>
</li>
<li><p><strong>依赖范围控制</strong></p>
<ul>
<li>非必要依赖标记为 <code>optional</code>（Maven）或 <code>optional = true</code>（Gradle），避免传递依赖污染用户项目。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Maven 示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>some-library<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>日志与文档</strong></p>
<ul>
<li>在 Starter 中提供清晰的日志输出，帮助用户调试。</li>
<li>编写 README 说明配置项和使用示例。</li>
</ul>
</li>
</ol>
<p><strong>5. 测试 Starter</strong></p>
<p>编写测试类验证自动配置是否生效：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServiceAutoConfigurationTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="keyword">private</span> MyService myService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAutoConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">        assertNotNull(myService);</span><br><span class="line">        assertEquals(<span class="string">&quot;http://custom-url&quot;</span>, myService.getUrl());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6. 最佳实践</strong></p>
<ul>
<li><strong>模块化设计</strong>：将自动配置与 Starter 分离，方便其他模块复用。</li>
<li><strong>防御性编程</strong>：在自动配置类中检查依赖是否存在（如通过 <code>@ConditionalOnClass</code>）。</li>
<li><strong>默认配置合理</strong>：提供安全、通用的默认值，减少用户配置负担。</li>
</ul>
<h2 id="统一异常处理的最佳实践"><a href="#统一异常处理的最佳实践" class="headerlink" title="统一异常处理的最佳实践"></a>统一异常处理的最佳实践</h2><p>以下是 <strong>Spring Boot 统一异常处理的最佳实践</strong>，涵盖异常分类、全局处理、日志记录、错误响应规范等关键环节，帮助开发者构建健壮且易维护的应用程序：</p>
<p><strong>核心原则</strong></p>
<ol>
<li><strong>统一入口</strong>：所有异常由全局处理器捕获，避免分散在各处。</li>
<li><strong>友好响应</strong>：前端接收结构化错误信息（如JSON），包含错误码、提示消息等。</li>
<li><strong>分类处理</strong>：区分业务异常、系统异常、参数校验异常等，针对性处理。</li>
<li><strong>安全日志</strong>：敏感信息脱敏，异常日志详细记录，但避免暴露给客户端。</li>
</ol>
<p><strong>实现步骤与代码示例</strong></p>
<ol>
<li><strong>定义统一响应格式</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;    <span class="comment">// 状态码（如200成功，500系统错误）</span></span><br><span class="line">    <span class="keyword">private</span> String msg;  <span class="comment">// 提示信息（用户友好）</span></span><br><span class="line">    <span class="keyword">private</span> T data;      <span class="comment">// 响应数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功响应</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">success</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;(<span class="number">200</span>, <span class="string">&quot;操作成功&quot;</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 失败响应</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">error</span><span class="params">(<span class="type">int</span> code, String msg)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;(code, msg, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法、Getter/Setter省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>创建全局异常处理器</strong></li>
</ol>
<p>使用 <code>@ControllerAdvice</code> + <code>@ExceptionHandler</code> 捕获全局异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理业务异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(BusinessException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Void&gt; <span class="title function_">handleBusinessException</span><span class="params">(BusinessException e)</span> &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;业务异常: &#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> Result.error(e.getCode(), e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理参数校验异常（JSR-303）</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Void&gt; <span class="title function_">handleValidationException</span><span class="params">(MethodArgumentNotValidException e)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> e.getBindingResult().getFieldErrors().stream()</span><br><span class="line">                .map(fieldError -&gt; fieldError.getField() + <span class="string">&quot;: &quot;</span> + fieldError.getDefaultMessage())</span><br><span class="line">                .collect(Collectors.joining(<span class="string">&quot;; &quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="number">400</span>, <span class="string">&quot;参数校验失败: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理其他未捕获异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Void&gt; <span class="title function_">handleException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;系统异常: &quot;</span>, e);  <span class="comment">// 记录完整堆栈</span></span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="number">500</span>, <span class="string">&quot;系统繁忙，请稍后再试&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>自定义业务异常</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BusinessException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BusinessException</span><span class="params">(<span class="type">int</span> code, String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快速创建常用异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BusinessException <span class="title function_">of</span><span class="params">(<span class="type">int</span> code, String msg)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(code, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123; <span class="keyword">return</span> code; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>参数校验规范化</strong></li>
</ol>
<p>在 DTO 中使用校验注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDTO</span> &#123;</span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;用户名不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Email(message = &quot;邮箱格式不正确&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter/Setter省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>HTTP状态码与错误码映射</strong></li>
</ol>
<table>
<thead>
<tr>
<th align="left">异常类型</th>
<th align="left">HTTP状态码</th>
<th align="left">错误码</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>BusinessException</code></td>
<td align="left">200</td>
<td align="left">自定义</td>
<td align="left">业务逻辑错误（如订单状态异常）</td>
</tr>
<tr>
<td align="left"><code>MethodArgumentNotValid</code></td>
<td align="left">400</td>
<td align="left">400</td>
<td align="left">参数校验失败</td>
</tr>
<tr>
<td align="left"><code>AuthenticationException</code></td>
<td align="left">401</td>
<td align="left">401</td>
<td align="left">未登录或Token过期</td>
</tr>
<tr>
<td align="left"><code>AccessDeniedException</code></td>
<td align="left">403</td>
<td align="left">403</td>
<td align="left">无权限访问</td>
</tr>
<tr>
<td align="left"><code>其他未捕获异常</code></td>
<td align="left">500</td>
<td align="left">500</td>
<td align="left">系统内部错误</td>
</tr>
</tbody></table>
<p><strong>三、最佳实践</strong></p>
<ol>
<li><strong>异常分类分层处理</strong></li>
</ol>
<ul>
<li><strong>业务异常</strong>：由开发者主动抛出（如库存不足），明确提示用户。</li>
<li><strong>系统异常</strong>：数据库连接失败等，提示友好信息，记录详细日志。</li>
<li><strong>第三方服务异常</strong>：封装为特定异常（如 <code>ThirdPartyException</code>），避免污染核心逻辑。</li>
</ul>
<ol start="2">
<li><strong>日志记录规范</strong></li>
</ol>
<ul>
<li><strong>业务异常</strong>：记录 <code>WARN</code> 级别，包含关键参数。</li>
<li><strong>系统异常</strong>：记录 <code>ERROR</code> 级别，输出完整堆栈。</li>
<li><strong>敏感信息脱敏</strong>：如身份证号、手机号在日志中掩码处理。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(PaymentException.class)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;Void&gt; <span class="title function_">handlePaymentException</span><span class="params">(PaymentException e)</span> &#123;</span><br><span class="line">    log.warn(<span class="string">&quot;支付失败, 订单号: &#123;&#125;, 原因: &#123;&#125;&quot;</span>, e.getOrderId(), e.getMessage());</span><br><span class="line">    <span class="keyword">return</span> Result.error(<span class="number">1001</span>, <span class="string">&quot;支付失败，请重试&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>错误码规范</strong></li>
</ol>
<ul>
<li><strong>模块划分</strong>：按模块定义错误码范围（如用户模块1000-1999）。</li>
<li><strong>文档维护</strong>：提供错误码对照表，方便前后端协作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误码常量类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ErrorCode</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">USER_NOT_FOUND</span> <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ORDER_EXPIRED</span> <span class="operator">=</span> <span class="number">2001</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>前端友好提示</strong></li>
</ol>
<ul>
<li><strong>用户可见消息</strong>：简洁明确，如“密码强度不足，至少包含大小写字母”。</li>
<li><strong>技术细节隔离</strong>：不返回Java异常类名、堆栈信息。</li>
</ul>
<ol start="5">
<li><strong>测试覆盖</strong></li>
</ol>
<p>验证异常处理逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionHandlerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBusinessException</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        mockMvc.perform(get(<span class="string">&quot;/api/order/123&quot;</span>))</span><br><span class="line">               .andExpect(status().isOk())</span><br><span class="line">               .andExpect(jsonPath(<span class="string">&quot;$.code&quot;</span>).value(<span class="number">1001</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>四、常见问题与解决</strong></p>
<ol>
<li><strong>异常未被捕获</strong><ul>
<li>检查 <code>@ControllerAdvice</code> 是否在组件扫描路径内。</li>
<li>确认没有其他异常处理器冲突。</li>
</ul>
</li>
<li><strong>循环依赖导致处理器失效</strong><ul>
<li>确保全局处理器不依赖可能抛出异常的Bean。</li>
</ul>
</li>
<li><strong>异步线程异常丢失</strong><ul>
<li>使用 <code>AsyncUncaughtExceptionHandler</code> 处理异步任务异常。</li>
</ul>
</li>
</ol>
<p><strong>五、总结</strong></p>
<p>通过统一异常处理机制，可以实现：</p>
<ul>
<li><strong>代码简洁性</strong>：消除重复的 <code>try-catch</code> 块。</li>
<li><strong>维护便捷性</strong>：集中管理错误响应逻辑。</li>
<li><strong>接口规范性</strong>：前后端遵循统一的错误协议。</li>
<li><strong>系统健壮性</strong>：关键异常不漏处理，日志可追溯。</li>
</ul>
<h2 id="配置加载优先级（命令行-环境变量）"><a href="#配置加载优先级（命令行-环境变量）" class="headerlink" title="配置加载优先级（命令行&gt;环境变量）"></a>配置加载优先级（命令行&gt;环境变量）</h2><table>
<thead>
<tr>
<th align="left">优先级</th>
<th align="left">配置源</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>1</strong></td>
<td align="left"><strong>命令行参数</strong></td>
<td align="left"><code>--server.port=8081</code></td>
</tr>
<tr>
<td align="left"><strong>2</strong></td>
<td align="left">Java 系统属性 (<code>-D</code>)</td>
<td align="left"><code>-Dspring.datasource.url=jdbc:mysql://...</code></td>
</tr>
<tr>
<td align="left"><strong>3</strong></td>
<td align="left"><strong>操作系统环境变量</strong></td>
<td align="left"><code>export SERVER_PORT=8081</code> (Linux)</td>
</tr>
<tr>
<td align="left"><strong>4</strong></td>
<td align="left">配置文件（如 <code>application.yml</code>）</td>
<td align="left"><code>server.port: 8080</code></td>
</tr>
</tbody></table>
<h2 id="Spring-AOP-和-AspectJ-有什么区别"><a href="#Spring-AOP-和-AspectJ-有什么区别" class="headerlink" title="Spring AOP 和 AspectJ 有什么区别"></a><code>Spring AOP</code> 和 <code>AspectJ</code> 有什么区别</h2><h2 id="过滤器、拦截器、AOP的区别与实践"><a href="#过滤器、拦截器、AOP的区别与实践" class="headerlink" title="过滤器、拦截器、AOP的区别与实践"></a>过滤器、拦截器、AOP的区别与实践</h2><table>
<thead>
<tr>
<th align="left"><strong>维度</strong></th>
<th align="left"><strong>过滤器（Filter）</strong></th>
<th align="left"><strong>拦截器（Interceptor）</strong></th>
<th align="left"><strong>AOP（Aspect）</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>规范&#x2F;框架</strong></td>
<td align="left">Servlet 规范（Java EE）</td>
<td align="left">Spring MVC 框架</td>
<td align="left">Spring AOP &#x2F; AspectJ</td>
</tr>
<tr>
<td align="left"><strong>作用阶段</strong></td>
<td align="left">请求进入 Servlet 前&#x2F;响应返回客户端前</td>
<td align="left">Controller 方法执行前后</td>
<td align="left">任意 Bean 方法执行前后</td>
</tr>
<tr>
<td align="left"><strong>作用范围</strong></td>
<td align="left">所有 HTTP 请求（包括静态资源）</td>
<td align="left">Spring MVC 处理的请求（动态资源）</td>
<td align="left">Spring 管理的 Bean 方法</td>
</tr>
<tr>
<td align="left"><strong>依赖关系</strong></td>
<td align="left">依赖 Servlet 容器（Tomcat&#x2F;Jetty）</td>
<td align="left">依赖 Spring 容器</td>
<td align="left">依赖 Spring 容器</td>
</tr>
<tr>
<td align="left"><strong>可访问对象</strong></td>
<td align="left">ServletRequest&#x2F;ServletResponse</td>
<td align="left">HttpServletRequest&#x2F;ModelAndView</td>
<td align="left">方法参数、注解、返回值</td>
</tr>
<tr>
<td align="left"><strong>执行顺序</strong></td>
<td align="left">过滤器链顺序（web.xml 或注解顺序）</td>
<td align="left">拦截器注册顺序</td>
<td align="left">切面优先级（<code>@Order</code> 注解）</td>
</tr>
<tr>
<td align="left"><strong>典型场景</strong></td>
<td align="left">字符编码、跨域处理、请求日志</td>
<td align="left">权限校验、参数预处理、日志记录</td>
<td align="left">事务管理、性能监控、缓存控制</td>
</tr>
</tbody></table>
<p><strong>执行流程与顺序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// HTTP 请求处理流程</span><br><span class="line">HTTP Request → Filter Chain → DispatcherServlet → Interceptor Chain → Controller → AOP Advice → Response</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>过滤器（Filter）</strong>：最先执行，可拦截所有请求（如静态资源）。</li>
<li><strong>拦截器（Interceptor）</strong>：在 <code>DispatcherServlet</code> 之后、Controller 方法之前执行。</li>
<li><strong>AOP 切面（Aspect）</strong>：在 Controller 或 Service 方法执行前后触发。</li>
</ol>
<p><strong>实践场景与代码示例</strong></p>
<p><strong>场景 1：全局请求日志（跨所有请求）</strong></p>
<ul>
<li><p><strong>选择方案</strong>：<strong>过滤器（Filter）</strong><br><strong>原因</strong>：需记录所有请求（包括静态资源）的原始信息（如 IP、URL）。<br><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        chain.doFilter(req, res); <span class="comment">// 放行请求</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">cost</span> <span class="operator">=</span> System.currentTimeMillis() - start;</span><br><span class="line">        System.out.println(<span class="string">&quot;请求耗时: &quot;</span> + cost + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>场景 2：用户登录校验（仅动态请求）</strong></p>
<ul>
<li><p><strong>选择方案</strong>：<strong>拦截器（Interceptor）</strong><br><strong>原因</strong>：需访问 Spring 上下文（如获取用户 Session），且仅需拦截动态请求。<br><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest req, HttpServletResponse res, Object handler)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (req.getSession().getAttribute(<span class="string">&quot;user&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">            res.sendRedirect(<span class="string">&quot;/login&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 中断请求</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册拦截器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">AuthInterceptor</span>()).addPathPatterns(<span class="string">&quot;/api/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>场景 3：方法级事务管理</strong></p>
<ul>
<li><p><strong>选择方案</strong>：<strong>AOP（声明式事务）</strong><br><strong>原因</strong>：需在方法执行前后管理事务，与业务逻辑解耦。<br><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PlatformTransactionManager txManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(org.springframework.transaction.annotation.Transactional)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">manageTransaction</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> txManager.getTransaction(<span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">            txManager.commit(status);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            txManager.rollback(status);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>场景 4：接口耗时统计</strong></p>
<ul>
<li><p><strong>选择方案</strong>：<strong>AOP（环绕通知）</strong><br><strong>原因</strong>：需统计任意方法的执行时间，灵活作用于 Service 层或 Controller 层。<br><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PerformanceAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">logTime</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行耗时: &quot;</span> + (System.currentTimeMillis() - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>如何选择？</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>技术</strong></th>
<th align="left"><strong>优先使用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>过滤器</strong></td>
<td align="left">处理原始请求&#x2F;响应（如跨域、压缩）、全局日志、安全过滤（XSS&#x2F;SQL 注入防御）</td>
</tr>
<tr>
<td align="left"><strong>拦截器</strong></td>
<td align="left">需要 Spring 上下文支持、动态请求拦截（如权限校验、参数预处理）</td>
</tr>
<tr>
<td align="left"><strong>AOP</strong></td>
<td align="left">与业务逻辑解耦的横切关注点（如事务、日志、缓存、性能监控）</td>
</tr>
</tbody></table>
<p><strong>最佳实践</strong></p>
<ol>
<li><strong>避免功能重叠</strong>：<ul>
<li>若过滤器与拦截器实现相似功能（如日志），选择更靠近请求入口的组件（过滤器）。</li>
</ul>
</li>
<li><strong>慎用 AOP 拦截 Controller</strong>：<ul>
<li>Controller 方法通常已由拦截器处理，AOP 更适合 Service 层。</li>
</ul>
</li>
<li><strong>注意执行顺序</strong>：<ul>
<li>多个过滤器&#x2F;拦截器需明确顺序，避免依赖问题。</li>
</ul>
</li>
<li><strong>性能优化</strong>：<ul>
<li>过滤器链和拦截器链较长时，可能影响吞吐量，需合理设计。</li>
</ul>
</li>
</ol>
<p>通过合理选择过滤器、拦截器和 AOP，开发者可以高效管理横切关注点，提升代码的可维护性和系统性能。</p>
<h2 id="注解的实现原理"><a href="#注解的实现原理" class="headerlink" title="注解的实现原理"></a>注解的实现原理</h2><p>在 Java 中，<strong>注解（Annotation）</strong> 是一种元数据机制，其本质是代码中的特殊标记，需配合 <strong>注解处理器</strong> 实现具体功能。注解本身不包含逻辑，其作用由处理器决定。以下是注解的实现原理详解：</p>
<p><strong>一、注解的本质</strong></p>
<ol>
<li><strong>注解的底层结构</strong></li>
</ol>
<ul>
<li><p>注解本质是继承 <code>java.lang.annotation.Annotation</code> 的 <strong>接口</strong>。</p>
</li>
<li><p>通过 JDK 动态代理生成注解的实例。</p>
</li>
<li><p><strong>示例</strong>：反编译 <code>@Override</code> 注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Override</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span> &#123;</span><br><span class="line">    <span class="comment">// 空接口，仅作标记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><strong>元注解（Meta-Annotation）</strong></li>
</ol>
<p>用于定义注解的行为，常见元注解：</p>
<table>
<thead>
<tr>
<th align="left">元注解</th>
<th align="left">作用</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>@Target</code></td>
<td align="left">指定注解可应用的目标（类、方法、字段等）</td>
<td align="left"><code>@Target(ElementType.METHOD)</code></td>
</tr>
<tr>
<td align="left"><code>@Retention</code></td>
<td align="left">指定注解的保留策略（源码、类文件、运行时）</td>
<td align="left"><code>@Retention(RetentionPolicy.RUNTIME)</code></td>
</tr>
<tr>
<td align="left"><code>@Documented</code></td>
<td align="left">注解是否包含在 Javadoc 中</td>
<td align="left"><code>@Documented</code></td>
</tr>
<tr>
<td align="left"><code>@Inherited</code></td>
<td align="left">子类是否继承父类的注解</td>
<td align="left"><code>@Inherited</code></td>
</tr>
</tbody></table>
<p><strong>二、注解的处理机制</strong></p>
<ol>
<li><strong>编译时处理（Annotation Processing Tool, APT）</strong></li>
</ol>
<ul>
<li><p><strong>原理</strong>：在编译阶段，通过注解处理器（继承 <code>AbstractProcessor</code>）扫描和处理注解。</p>
</li>
<li><p><strong>应用场景</strong>：</p>
<ul>
<li>生成代码（如 Lombok 生成 Getter&#x2F;Setter）。</li>
<li>语法检查（如 <code>@Override</code> 验证方法重写）。</li>
</ul>
</li>
<li><p><strong>示例</strong>：自定义编译时注解处理器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SupportedAnnotationTypes(&quot;com.example.MyAnnotation&quot;)</span></span><br><span class="line"><span class="meta">@SupportedSourceVersion(SourceVersion.RELEASE_8)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProcessor</span> <span class="keyword">extends</span> <span class="title class_">AbstractProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理注解逻辑，如生成代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><strong>运行时处理（反射机制）</strong></li>
</ol>
<ul>
<li><p><strong>原理</strong>：通过反射 API（如 <code>Class.getAnnotation()</code>）在运行时读取注解信息。</p>
</li>
<li><p><strong>应用场景</strong>：</p>
<ul>
<li>动态配置（如 Spring 的 <code>@Autowired</code> 依赖注入）。</li>
<li>自定义逻辑（如权限校验、日志记录）。</li>
</ul>
</li>
<li><p><strong>示例</strong>：读取方法上的注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> obj.getClass().getMethod(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (method.isAnnotationPresent(MyAnnotation.class)) &#123;</span><br><span class="line">    <span class="type">MyAnnotation</span> <span class="variable">anno</span> <span class="operator">=</span> method.getAnnotation(MyAnnotation.class);</span><br><span class="line">    System.out.println(anno.value());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li><strong>字节码增强处理（AOP 框架）</strong></li>
</ol>
<ul>
<li><strong>原理</strong>：在类加载时修改字节码，植入与注解相关的逻辑。</li>
<li><strong>工具</strong>：AspectJ、ASM、Byte Buddy。</li>
<li><strong>应用场景</strong>：<ul>
<li>实现 AOP 切面（如 <code>@Transactional</code> 事务管理）。</li>
<li>动态代理（如 Spring AOP）。</li>
</ul>
</li>
</ul>
<p><strong>三、注解处理的核心流程</strong></p>
<ol>
<li><strong>定义注解</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LogExecution &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;default log&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>使用注解</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@LogExecution(&quot;用户查询方法&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>处理注解（以运行时为例）</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">logIfNeeded</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(LogExecution.class)) &#123;</span><br><span class="line">            <span class="type">LogExecution</span> <span class="variable">log</span> <span class="operator">=</span> method.getAnnotation(LogExecution.class);</span><br><span class="line">            System.out.println(<span class="string">&quot;执行日志: &quot;</span> + log.value());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> UserService.class.getMethod(<span class="string">&quot;getUser&quot;</span>);</span><br><span class="line">        logIfNeeded(method); <span class="comment">// 输出：执行日志: 用户查询方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>四、注解的底层实现（反射动态代理）</strong></p>
<p>当使用 <code>@LogExecution</code> 时，JVM 会通过动态代理生成注解实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成的代理类（简化版）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogExecutionProxy</span> <span class="keyword">implements</span> <span class="title class_">LogExecution</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;用户查询方法&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotationType() &#123;</span><br><span class="line">        <span class="keyword">return</span> LogExecution.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>五、常见框架中的注解应用</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>框架</strong></th>
<th align="left"><strong>注解示例</strong></th>
<th align="left"><strong>处理机制</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Spring</strong></td>
<td align="left"><code>@Autowired</code></td>
<td align="left">运行时反射 + 依赖注入</td>
</tr>
<tr>
<td align="left"><strong>Lombok</strong></td>
<td align="left"><code>@Data</code></td>
<td align="left">编译时 APT 生成代码</td>
</tr>
<tr>
<td align="left"><strong>JUnit</strong></td>
<td align="left"><code>@Test</code></td>
<td align="left">运行时反射执行测试方法</td>
</tr>
<tr>
<td align="left"><strong>Hibernate</strong></td>
<td align="left"><code>@Entity</code></td>
<td align="left">运行时反射映射数据库表</td>
</tr>
<tr>
<td align="left"><strong>AspectJ</strong></td>
<td align="left"><code>@Around</code></td>
<td align="left">编译时&#x2F;类加载时字节码增强</td>
</tr>
</tbody></table>
<p><strong>六、注解的局限性</strong></p>
<ol>
<li><strong>无法独立工作</strong>：必须依赖处理器（APT、反射、AOP 等）。</li>
<li><strong>性能开销</strong>：运行时反射处理可能影响性能。</li>
<li><strong>复杂度高</strong>：字节码增强需掌握 ASM 等工具。</li>
</ol>
<p><strong>七、最佳实践</strong></p>
<ol>
<li><strong>明确保留策略</strong>：<ul>
<li>若只需编译时检查（如 <code>@Override</code>），使用 <code>RetentionPolicy.SOURCE</code>。</li>
<li>若需运行时处理（如 Spring 注解），使用 <code>RetentionPolicy.RUNTIME</code>。</li>
</ul>
</li>
<li><strong>避免过度使用</strong>：注解滥用会导致代码可读性下降。</li>
<li><strong>结合工具链</strong>：使用 Lombok、MapStruct 等工具简化开发。</li>
</ol>
<p>通过理解注解的实现原理，开发者可以更高效地利用其实现代码解耦、动态配置和自动化处理，提升框架的灵活性和可维护性。</p>
<h2 id="MapperScan-的实现原理"><a href="#MapperScan-的实现原理" class="headerlink" title="@MapperScan 的实现原理"></a><code>@MapperScan</code> 的实现原理</h2><p><code>@MapperScan</code> 是 MyBatis-Spring 整合中的核心注解，用于自动扫描并注册 Mapper 接口为 Spring Bean。其实现原理基于 Spring 的扩展机制和 MyBatis 的动态代理，以下是详细步骤和核心逻辑：</p>
<p><strong>1. 注解定义与入口</strong></p>
<p><code>@MapperScan</code> 通过 <code>@Import</code> 引入 <code>MapperScannerRegistrar</code>，触发扫描和注册逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Import(MapperScannerRegistrar.class)</span> <span class="comment">// 关键：引入注册器</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MapperScan &#123;</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;; <span class="comment">// 扫描的包路径</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotationClass() <span class="keyword">default</span> Annotation.class;</span><br><span class="line">    <span class="comment">// 其他配置属性...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. MapperScannerRegistrar 注册 Bean 定义</strong></p>
<p><code>MapperScannerRegistrar</code> 实现 <code>ImportBeanDefinitionRegistrar</code> 接口，在 Spring 容器启动时动态注册 Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperScannerRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 解析 @MapperScan 注解的属性（如包路径）</span></span><br><span class="line">        <span class="type">AnnotationAttributes</span> <span class="variable">attrs</span> <span class="operator">=</span> AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(MapperScan.class.getName()));</span><br><span class="line">        <span class="comment">// 创建并配置 ClassPathMapperScanner</span></span><br><span class="line">        <span class="type">ClassPathMapperScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathMapperScanner</span>(registry);</span><br><span class="line">        scanner.scan(attrs.getStringArray(<span class="string">&quot;value&quot;</span>)); <span class="comment">// 执行扫描</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. ClassPathMapperScanner 扫描接口</strong></p>
<p><code>ClassPathMapperScanner</code> 继承自 Spring 的 <code>ClassPathBeanDefinitionScanner</code>，自定义扫描规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassPathMapperScanner</span> <span class="keyword">extends</span> <span class="title class_">ClassPathBeanDefinitionScanner</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">doScan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用父类扫描方法，筛选出符合条件的接口</span></span><br><span class="line">        Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="built_in">super</span>.doScan(basePackages);</span><br><span class="line">        <span class="comment">// 为每个接口生成 BeanDefinition，绑定到 MapperFactoryBean</span></span><br><span class="line">        <span class="keyword">for</span> (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class="line">            <span class="type">GenericBeanDefinition</span> <span class="variable">definition</span> <span class="operator">=</span> (GenericBeanDefinition) holder.getBeanDefinition();</span><br><span class="line">            <span class="comment">// 设置 Bean 的工厂类为 MapperFactoryBean</span></span><br><span class="line">            definition.getConstructorArgumentValues().addGenericArgumentValue(definition.getBeanClassName());</span><br><span class="line">            definition.setBeanClass(MapperFactoryBean.class); <span class="comment">// 关键：代理工厂</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isCandidateComponent</span><span class="params">(AnnotatedBeanDefinition beanDefinition)</span> &#123;</span><br><span class="line">        <span class="comment">// 仅选择接口作为候选组件（排除类）</span></span><br><span class="line">        <span class="keyword">return</span> beanDefinition.getMetadata().isInterface();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. MapperFactoryBean 创建代理对象</strong></p>
<p><code>MapperFactoryBean</code> 是 Spring 的 <code>FactoryBean</code> 实现，负责生成 Mapper 接口的代理实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperFactoryBean</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 通过 SqlSession 获取 Mapper 动态代理</span></span><br><span class="line">        <span class="keyword">return</span> getSqlSession().getMapper(<span class="built_in">this</span>.mapperInterface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;T&gt; <span class="title function_">getObjectType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.mapperInterface;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5. 动态代理与 SQL 执行</strong></p>
<p>MyBatis 通过 <code>MapperProxy</code> 生成接口的 JDK 动态代理对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperProxy</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>, Serializable &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 将方法调用转换为 MappedStatement 执行</span></span><br><span class="line">        <span class="type">MapperMethod</span> <span class="variable">mapperMethod</span> <span class="operator">=</span> cachedMapperMethod(method);</span><br><span class="line">        <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6. 整合 Spring 容器</strong></p>
<ul>
<li><strong>SqlSessionTemplate 注入</strong>：<br>MyBatis-Spring 配置 <code>SqlSessionTemplate</code>（线程安全的 SqlSession 实现），由 Spring 管理数据库连接和事务。</li>
<li><strong>依赖关系</strong>：<br><code>MapperFactoryBean</code> 依赖 <code>SqlSessionTemplate</code>，确保所有 Mapper 代理使用同一事务上下文。</li>
</ul>
<p><strong>7. 自动配置与 Spring Boot 集成</strong></p>
<p>在 Spring Boot 中，<code>@MapperScan</code> 通常与自动配置类 <code>MyBatisAutoConfiguration</code> 配合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfiguration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; SqlSessionFactory.class, SqlSessionFactoryBean.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建 SqlSessionFactory</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结流程</strong></p>
<ol>
<li><strong>注解触发</strong>：<code>@MapperScan</code> 引入 <code>MapperScannerRegistrar</code>。</li>
<li><strong>动态注册</strong>：<code>MapperScannerRegistrar</code> 使用 <code>ClassPathMapperScanner</code> 扫描指定包下的接口。</li>
<li><strong>Bean 定义生成</strong>：为每个 Mapper 接口创建绑定到 <code>MapperFactoryBean</code> 的 Bean 定义。</li>
<li><strong>代理实例化</strong>：Spring 容器实例化时，<code>MapperFactoryBean</code> 通过 <code>SqlSessionTemplate</code> 创建动态代理对象。</li>
<li><strong>方法拦截</strong>：调用 Mapper 方法时，代理对象将请求转发给 MyBatis 执行 SQL。</li>
</ol>
<p><strong>关键设计点</strong></p>
<ul>
<li><strong>解耦与扩展</strong>：通过 Spring 的 <code>FactoryBean</code> 和 <code>ImportBeanDefinitionRegistrar</code> 实现无缝整合。</li>
<li><strong>性能优化</strong>：动态代理和缓存机制（如 <code>MapperMethod</code> 缓存）减少反射开销。</li>
<li><strong>事务一致性</strong>：依赖 Spring 管理的事务，确保 Mapper 操作在同一个 <code>SqlSession</code> 中执行。</li>
</ul>
<p>通过 <code>@MapperScan</code>，开发者无需手动配置每个 Mapper，框架自动完成接口到 Bean 的映射及代理生成，极大简化了 MyBatis 在 Spring 中的使用。</p>
<h2 id="Autowired-的实现原理"><a href="#Autowired-的实现原理" class="headerlink" title="@Autowired 的实现原理"></a><code>@Autowired</code> 的实现原理</h2><p><code>@Autowired</code> 是 Spring 框架中实现依赖注入的核心注解，其底层原理基于 <strong>Bean 生命周期管理</strong>、<strong>反射机制</strong> 和 <strong>BeanPostProcessor</strong> 的协作。以下是其实现原理的详细分析：</p>
<p><strong>1. 核心流程</strong></p>
<p><code>@Autowired</code> 的依赖注入发生在 Bean 的实例化阶段（属性填充阶段），具体步骤如下：</p>
<p><strong>1.1 Bean 实例化</strong></p>
<p>Spring 容器通过反射调用构造函数创建 Bean 实例（若存在多个构造函数，优先选择无参构造函数，或标记 <code>@Autowired</code> 的构造函数）。</p>
<p><strong>1.2 属性填充（依赖注入）</strong></p>
<ul>
<li><strong>触发时机</strong>：在 <code>AbstractAutowireCapableBeanFactory</code> 的 <code>populateBean()</code> 方法中。</li>
<li><strong>处理组件</strong>：<code>AutowiredAnnotationBeanPostProcessor</code>（继承自 <code>BeanPostProcessor</code>）。</li>
</ul>
<p><strong>1.3 依赖解析与注入</strong></p>
<ol>
<li><strong>扫描注解</strong>：<br>通过反射检查 Bean 的字段、方法和构造函数上的 <code>@Autowired</code> 注解。</li>
<li><strong>解析依赖</strong>：<ul>
<li><strong>按类型匹配</strong>：查找与依赖类型匹配的候选 Bean。</li>
<li><strong>按名称匹配</strong>：若存在多个同类型 Bean，按字段&#x2F;方法参数名称匹配（需结合 <code>@Qualifier</code> 或 <code>@Primary</code> 解决歧义）。</li>
</ul>
</li>
<li><strong>注入依赖</strong>：<ul>
<li><strong>字段注入</strong>：通过反射 <code>Field.setAccessible(true)</code> 设置私有字段值。</li>
<li><strong>方法注入</strong>：反射调用 Setter 方法。</li>
<li><strong>构造函数注入</strong>：在实例化时通过构造函数参数注入。</li>
</ul>
</li>
</ol>
<p><strong>2. 关键组件解析</strong></p>
<p><strong>2.1 AutowiredAnnotationBeanPostProcessor</strong></p>
<p>Spring 内置的 <code>BeanPostProcessor</code>，负责处理 <code>@Autowired</code> 和 <code>@Value</code> 注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutowiredAnnotationBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span>, MergedBeanDefinitionPostProcessor &#123;</span><br><span class="line">    <span class="comment">// 存储待注入的元数据（字段、方法）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InjectionMetadata metadata;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PropertyValues <span class="title function_">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> &#123;</span><br><span class="line">        <span class="comment">// 查找并注入依赖</span></span><br><span class="line">        <span class="type">InjectionMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> findAutowiringMetadata(bean.getClass());</span><br><span class="line">        metadata.inject(bean, beanName, pvs);</span><br><span class="line">        <span class="keyword">return</span> pvs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.2 依赖解析流程</strong></p>
<p>在 <code>DefaultListableBeanFactory</code> 中解析依赖：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">resolveDependency</span><span class="params">(DependencyDescriptor descriptor, String beanName, Set&lt;String&gt; autowiredBeanNames, TypeConverter typeConverter)</span> &#123;</span><br><span class="line">    <span class="comment">// 按类型获取候选 Bean 名称</span></span><br><span class="line">    String[] candidateNames = findAutowireCandidates(beanName, type, descriptor);</span><br><span class="line">    <span class="comment">// 筛选唯一候选 Bean</span></span><br><span class="line">    <span class="keyword">if</span> (candidateNames.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> getBean(candidateNames[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (candidateNames.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 按名称或 @Primary/@Priority 解决冲突</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">primaryCandidate</span> <span class="operator">=</span> determinePrimaryCandidate(candidateNames);</span><br><span class="line">        <span class="keyword">return</span> primaryCandidate != <span class="literal">null</span> ? primaryCandidate : determineHighestPriorityCandidate(candidateNames);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 抛出 NoUniqueBeanDefinitionException 异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 注入方式与优先级</strong></p>
<p><strong>3.1 构造函数注入</strong></p>
<ul>
<li><p><strong>触发条件</strong>：若类中存在唯一构造函数，或构造函数标记了 <code>@Autowired</code>。</p>
</li>
<li><p><strong>优势</strong>：保证依赖不可变，符合不可变对象设计。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserRepository userRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>3.2 Setter 方法注入</strong></p>
<ul>
<li><p><strong>触发条件</strong>：Setter 方法标记 <code>@Autowired</code>。</p>
</li>
<li><p><strong>优势</strong>：允许可选依赖或动态更新依赖。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPaymentService</span><span class="params">(PaymentService paymentService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.paymentService = paymentService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>3.3 字段注入</strong></p>
<ul>
<li><p><strong>触发条件</strong>：字段直接标记 <code>@Autowired</code>。</p>
</li>
<li><p><strong>劣势</strong>：难以实现不可变性，测试时需通过反射注入。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> InventoryService inventoryService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>4. 解决依赖冲突</strong></p>
<p><strong>4.1 @Qualifier</strong></p>
<p>通过名称指定注入的 Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;mysqlDataSource&quot;)</span></span><br><span class="line"><span class="keyword">private</span> DataSource dataSource;</span><br></pre></td></tr></table></figure>

<p><strong>4.2 @Primary</strong></p>
<p>标记优先选择的 Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">primaryDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.3 自定义限定符</strong></p>
<p>结合自定义注解与 <code>@Qualifier</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MysqlDatabase &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@MysqlDatabase</span></span><br><span class="line"><span class="keyword">private</span> DataSource dataSource;</span><br></pre></td></tr></table></figure>

<p><strong>5. 源码级关键逻辑</strong></p>
<p><strong>5.1 字段注入实现</strong></p>
<p>反射设置字段值（简化代码）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> bean.getClass().getDeclaredField(<span class="string">&quot;userRepository&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(bean, userRepository);</span><br></pre></td></tr></table></figure>

<p><strong>5.2 方法注入实现</strong></p>
<p>反射调用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> bean.getClass().getMethod(<span class="string">&quot;setUserRepository&quot;</span>, UserRepository.class);</span><br><span class="line">method.invoke(bean, userRepository);</span><br></pre></td></tr></table></figure>

<p><strong>6. 总结与最佳实践</strong></p>
<ul>
<li><strong>原理本质</strong>：<code>@Autowired</code> 通过 <code>BeanPostProcessor</code> 在 Bean 生命周期中动态解析并注入依赖。</li>
<li><strong>推荐方式</strong>：优先使用 <strong>构造函数注入</strong> 保证依赖不可变。</li>
<li><strong>避免陷阱</strong>：<ul>
<li><strong>循环依赖</strong>：避免 A 依赖 B，B 又依赖 A，可通过 <code>@Lazy</code> 延迟加载解决。</li>
<li><strong>多实例冲突</strong>：使用 <code>@Qualifier</code> 或 <code>@Primary</code> 明确指定 Bean。</li>
</ul>
</li>
<li><strong>性能优化</strong>：反射操作有一定开销，但 Spring 通过缓存元数据（如 <code>InjectionMetadata</code>）减少重复解析。</li>
</ul>
<h2 id="SpringMVC-工作流程"><a href="#SpringMVC-工作流程" class="headerlink" title="SpringMVC 工作流程"></a>SpringMVC 工作流程</h2><p><strong>核心组件</strong></p>
<ol>
<li><strong>DispatcherServlet</strong>：前置控制器，是整个流程控制的<strong>核心</strong>，控制其他组件的执行，进行统一调度，降低组件之间的耦合性，相当于总指挥。</li>
<li><strong>Handler</strong>：处理器，完成具体的业务逻辑，相当于 Servlet 或 Action。</li>
<li><strong>HandlerMapping</strong>：DispatcherServlet 接收到请求之后，通过 HandlerMapping 将不同的请求映射到不同的 Handler。</li>
<li><strong>HandlerInterceptor</strong>：处理器拦截器，是一个接口，如果需要完成一些拦截处理，可以实现该接口。</li>
<li><strong>HandlerExecutionChain</strong>：处理器执行链，包括两部分内容：Handler 和 HandlerInterceptor（系统会有一个默认的 HandlerInterceptor，如果需要额外设置拦截，可以添加拦截器）。</li>
<li><strong>HandlerAdapter</strong>：处理器适配器，Handler 执行业务方法之前，需要进行一系列的操作，包括表单数据的验证、数据类型的转换、将表单数据封装到 JavaBean 等，这些操作都是由 HandlerApater 来完成，开发者只需将注意力集中业务逻辑的处理上，DispatcherServlet 通过 HandlerAdapter 执行不同的 Handler。</li>
<li><strong>ModelAndView</strong>：装载了模型数据和视图信息，作为 Handler 的处理结果，返回给 DispatcherServlet。</li>
<li><strong>ViewResolver</strong>：视图解析器，DispatcheServlet 通过它将逻辑视图解析为物理视图，最终将渲染结果响应给客户端。</li>
</ol>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-e29a122b-db07-48b8-8289-7251032e87a1.png" alt="三分恶面渣逆袭：Spring MVC的工作流程"></p>
<h1 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h1><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="查询语句的执行顺序"><a href="#查询语句的执行顺序" class="headerlink" title="查询语句的执行顺序"></a>查询语句的执行顺序</h3><p>MySQL 分为 server 层和存储引擎层。</p>
<p>server 层涵盖 MySQL 大多数核心功能（如存储过程、触发器、视图等）和所有内置函数（如日期、时间、数学函数等）。</p>
<p>存储引擎层负责数据的存储和提取。</p>
<p><code>from</code> -&gt; <code>where</code> -&gt; <code>group by</code> -&gt; <code>having</code> -&gt; <code>select</code> -&gt; <code>distinct</code> -&gt; <code>order by</code> -&gt; <code>limit</code></p>
<img src="/post/be632046/1726212535664-4bb3f3ff-704a-4706-84c8-a046a8486657.webp" class="" title="img">

<h3 id="InnoDB索引结构"><a href="#InnoDB索引结构" class="headerlink" title="InnoDB索引结构"></a>InnoDB索引结构</h3><p>B树结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">       [10 | 20]</span><br><span class="line">      /    |     \</span><br><span class="line">[5|8]  [12|15|18]  [25|30]</span><br></pre></td></tr></table></figure>

<p>特征：</p>
<ul>
<li>所有节点都存储完整数据</li>
<li>每个节点最多包涵 m-1 个键值和 m 个子节点</li>
</ul>
<p>B+树结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">               [15]</span><br><span class="line">              /    \</span><br><span class="line">     [10|15]          [20|25]</span><br><span class="line">     /     \          /     \ </span><br><span class="line">[10|...]→[15|...]→[20|...]→[25|...]（叶子节点链表）</span><br></pre></td></tr></table></figure>

<p>特征：</p>
<ul>
<li>只有叶子节点存储完整数据，内部节点只存储索引</li>
<li>叶子节点通过双向链表连接，支持高效范围查询</li>
<li>相同磁盘页可以存储更多索引，提高查询效率</li>
</ul>
<p><strong>InnoDB选择B+树的7大关键原因</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>对比维度</strong></th>
<th align="left"><strong>B树</strong></th>
<th align="left"><strong>B+树</strong></th>
<th align="left"><strong>InnoDB优势体现</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>数据存储位置</strong></td>
<td align="left">所有节点存储数据</td>
<td align="left">仅叶子节点存储数据</td>
<td align="left">减少磁盘IO次数</td>
</tr>
<tr>
<td align="left"><strong>树高度</strong></td>
<td align="left">较高（数据分散存储）</td>
<td align="left">较低（内部节点纯索引）</td>
<td align="left">3层B+树可支撑千万级数据</td>
</tr>
<tr>
<td align="left"><strong>范围查询</strong></td>
<td align="left">需要回溯父节点</td>
<td align="left">通过叶子链表顺序扫描</td>
<td align="left"><code>WHERE id &gt; 100</code> 效率提升10倍+</td>
</tr>
<tr>
<td align="left"><strong>全表扫描</strong></td>
<td align="left">需遍历整棵树</td>
<td align="left">直接顺序遍历叶子节点链表</td>
<td align="left">全表扫描速度接近顺序读</td>
</tr>
<tr>
<td align="left"><strong>磁盘利用率</strong></td>
<td align="left">节点包含数据导致存储键值数少</td>
<td align="left">单页可存储更多键值（高分支因子）</td>
<td align="left">相同数据量减少30%-50%树高度</td>
</tr>
<tr>
<td align="left"><strong>数据更新代价</strong></td>
<td align="left">可能引起复杂结构调整</td>
<td align="left">插入删除多数情况只需局部调整</td>
<td align="left">支持更高并发写入</td>
</tr>
<tr>
<td align="left"><strong>缓存命中率</strong></td>
<td align="left">热点数据分散在不同层级</td>
<td align="left">叶子节点集中存储所有数据</td>
<td align="left">Buffer Pool利用率提升40%+</td>
</tr>
</tbody></table>
<h3 id="为什么MongoDB使用B树而MySQL用B-树"><a href="#为什么MongoDB使用B树而MySQL用B-树" class="headerlink" title="为什么MongoDB使用B树而MySQL用B+树"></a>为什么MongoDB使用B树而MySQL用B+树</h3><p>MongoDB面向文档存储，需快速获取整个文档（B树的内部节点存储完整数据，可以减少寻址次数）</p>
<p>MySQL侧重范围查询和事务处理（B+树的顺序访问特性更优秀）</p>
<h3 id="B-树节点分裂的具体过程"><a href="#B-树节点分裂的具体过程" class="headerlink" title="B+树节点分裂的具体过程"></a>B+树节点分裂的具体过程</h3><p>InnoDB优化：预留1&#x2F;16页空间避免频繁分裂</p>
<p><strong>索引设计原则</strong></p>
<ul>
<li>前缀索引优化</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> <span class="keyword">ADD</span> INDEX (name(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>覆盖索引优化</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建包含所有查询字段的索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_cover <span class="keyword">ON</span> orders(user_id, status, create_time);</span><br></pre></td></tr></table></figure>



<p><strong>监控工具使用</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看索引使用情况</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.schema_index_statistics;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分析索引效率</span></span><br><span class="line">EXPLAIN ANALYZE <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> category_id<span class="operator">=</span><span class="number">5</span>;</span><br></pre></td></tr></table></figure>



<p><strong>维护策略</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 定期优化表（重建索引）</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 监控页分裂次数</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Innodb_page_splits%&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h3 id="EXPLAIN-字段说明"><a href="#EXPLAIN-字段说明" class="headerlink" title="EXPLAIN 字段说明"></a><code>EXPLAIN</code> 字段说明</h3><p>通常<code>EXPALIN</code>查询语句的输出如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="comment">// 每个select语句对应一个唯一的id</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询类型：</span></span><br><span class="line"><span class="comment">     * SIMPLE：不包含UNION或子查询的select（连接查询的每个查询都是simple查询）</span></span><br><span class="line"><span class="comment">     * PRIMARY：最外层查询</span></span><br><span class="line"><span class="comment">     * UNION</span></span><br><span class="line"><span class="comment">     * ...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="attr">&quot;select_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SIMPLE&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;users&quot;</span><span class="punctuation">,</span> <span class="comment">// 要查询的表</span></span><br><span class="line">    <span class="attr">&quot;partitions&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span> <span class="comment">// 分区信息</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 针对单表的访问方法：</span></span><br><span class="line"><span class="comment">     * system：当表中只有一条记录，并且该表使用的存储引擎的统计数据是精确的，访问方法就是system</span></span><br><span class="line"><span class="comment">     * constant：根据主键或唯一索引列与常数进行等值匹配时，访问方法就是const</span></span><br><span class="line"><span class="comment">     * eq_ref：连接查询中对被驱动表的主键或不允许为NULL的唯一索引进行等值查询时，访问方法就是eq_ref</span></span><br><span class="line"><span class="comment">     * ref：通过普通二级索引列与常量进行等值匹配时，对该表的访问方法就是 ref</span></span><br><span class="line"><span class="comment">     * ref_or_null：select * from single_table where key1 = &#x27;abc&#x27; or key1 is NULL;</span></span><br><span class="line"><span class="comment">     * index_merge：使用多个索引进行等值匹配</span></span><br><span class="line"><span class="comment">     * unique_subquery：在子查询中使用主键或不允许存储NULL值的唯一二级索引进行等值匹配</span></span><br><span class="line"><span class="comment">     * index_subquery：在子查询中使用普通二级索引进行等值匹</span></span><br><span class="line"><span class="comment">     * range：利用索引进行范围查询</span></span><br><span class="line"><span class="comment">     * index：当可以使用索引覆盖，但需要扫描全部索引记录</span></span><br><span class="line"><span class="comment">     * all：全表扫描</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ref&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;possible_keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;idx_composite&quot;</span><span class="punctuation">,</span> <span class="comment">// 可能使用的索引</span></span><br><span class="line">    <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;idx_composite&quot;</span><span class="punctuation">,</span> <span class="comment">// 实际使用的索引</span></span><br><span class="line">    <span class="attr">&quot;key_len&quot;</span><span class="punctuation">:</span> <span class="string">&quot;208&quot;</span><span class="punctuation">,</span> <span class="comment">// 实际使用的索引长度</span></span><br><span class="line">    <span class="attr">&quot;ref&quot;</span><span class="punctuation">:</span> <span class="string">&quot;const&quot;</span><span class="punctuation">,</span> <span class="comment">// 使用索引列等值查询时，与索引列进行等值匹配的对象信息</span></span><br><span class="line">    <span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="comment">// 预估需要读取的记录行数</span></span><br><span class="line">    <span class="attr">&quot;filtered&quot;</span><span class="punctuation">:</span> <span class="number">100.0</span><span class="punctuation">,</span> <span class="comment">// 过滤后剩余记录行数百分比</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 额外信息：</span></span><br><span class="line"><span class="comment">     * Using index：使用覆盖索引</span></span><br><span class="line"><span class="comment">     * Using index condition：使用索引条件下推</span></span><br><span class="line"><span class="comment">     * Using where：需要在server层判断条件是否成立</span></span><br><span class="line"><span class="comment">     * Using join buffer：执行连接查询时，被驱动表不能有效利用索引加快访问速度时，会分配一块内存用来保存被驱动表的查询结果，</span></span><br><span class="line"><span class="comment">     					  利用join buffer可以减少访问被驱动表的次数</span></span><br><span class="line"><span class="comment">     * Using filesort：</span></span><br><span class="line"><span class="comment">     * Using temporary</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="attr">&quot;Extra&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Using index&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h3 id="覆盖索引与最左前缀原则实战案例"><a href="#覆盖索引与最左前缀原则实战案例" class="headerlink" title="覆盖索引与最左前缀原则实战案例"></a>覆盖索引与最左前缀原则实战案例</h3><p><strong>回表</strong>：查询需要的字段没有全部包含在索引中，需要根据索引找到主键，再从主键索引中找到完整数据才能获取所需字段。</p>
<p><strong>覆盖索引</strong>：查询所需的字段都包含在索引中，无需回表操作。</p>
<p>优点：</p>
<ul>
<li>减少IO操作</li>
<li>避免回表（减少随机读）</li>
</ul>
<p><strong>最左前缀原则</strong>：复合索引 <code>(a, b, c)</code> 的查询条件必须从最左列开始，且不能跳过中间列才能命中索引。</p>
<p>具体规则：</p>
<ul>
<li>等值查询：<code>WHERE a = 1 and b = 2</code> → 命中索引</li>
<li>范围查询：<code>WHERE a &gt; 1 and b = 2</code> → 仅能命中 <code>a</code> 列</li>
<li>跳跃查询：<code>WHERE b = 2 and c = 3</code> → 不能能命中索引</li>
</ul>
<p>覆盖索引优化：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `users` (</span><br><span class="line">	`id` <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">	`name` <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">	`age` <span class="type">INT</span>,</span><br><span class="line">	`city` <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">	`created_at` DATETIME,</span><br><span class="line">	KEY `idx_composite` (`city`, `age`, `created_at`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>

<p>查询需求：统计北京25岁用户的数量</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> city<span class="operator">=</span><span class="string">&#x27;北京&#x27;</span> <span class="keyword">AND</span> age<span class="operator">=</span><span class="number">25</span>;</span><br></pre></td></tr></table></figure>

<img src="/post/be632046/image-20250302111116621.png" class="" title="image-20250302111116621">

<p>之前的版本<code>Extra</code>中应该是<code>Using where</code>，因为需要回表确认数据是否存在。</p>
<p>优化方案：添加覆盖索引覆盖统计需要的所有字段</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> users <span class="keyword">ADD</span> INDEX idx_covering(city, age, id);</span><br></pre></td></tr></table></figure>

<p>最左前缀索引优化</p>
<p>查询需求：查询北京地区年龄大于 30 岁的用户，并按注册时间排序</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> city<span class="operator">=</span><span class="string">&#x27;北京&#x27;</span> <span class="keyword">AND</span> age<span class="operator">&gt;</span> <span class="number">30</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> created_at LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<img src="/post/be632046/image-20250302111551681.png" class="" title="image-20250302111551681">

<p>从<code>EXPLAIN</code>结果可以看出，这条查询语句需要用到耗时的文件排序，这是因为查询条件中存在范围查询，导致不能完全利用上组合索引。</p>
<p>优化方案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> users <span class="keyword">ADD</span> INDEX idx_city_created_age(city, created_at, age);</span><br></pre></td></tr></table></figure>

<img src="/post/be632046/image-20250302112330725.png" class="" title="image-20250302112330725">



<p>索引设计规范：</p>
<ul>
<li>组合索引字段按区分度从高到低排序</li>
<li>索引列数≤5列，避免更新开销太大</li>
<li>禁止<code>SELECT *</code>，尽量查询索引能覆盖的字段</li>
</ul>
<h3 id="慢查询优化"><a href="#慢查询优化" class="headerlink" title="慢查询优化"></a>慢查询优化</h3><p>慢查询优化流程：</p>
<ol>
<li>抓取慢日志：<code>long_query_time=1s</code></li>
<li><code>EXPLAIN</code> 分析执行计划</li>
<li>检查索引使用情况<ul>
<li>是否触发覆盖索引</li>
<li>是否违反最左前缀原则</li>
</ul>
</li>
<li>使用<code>force index</code>验证索引有效性</li>
<li>调整索引或SQL写法</li>
</ol>
<ul>
<li>索引优化</li>
<li>使用覆盖索引，避免回表</li>
<li>最左前缀匹配，</li>
</ul>
<p>监控指标</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看索引使用频率</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.schema_index_statistics <span class="keyword">WHERE</span> table_name<span class="operator">=</span><span class="string">&#x27;users&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检查冗余索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.schema_redundant_indexes;</span><br></pre></td></tr></table></figure>



<h3 id="为什么InnoDB不保存表的总行数"><a href="#为什么InnoDB不保存表的总行数" class="headerlink" title="为什么InnoDB不保存表的总行数"></a>为什么InnoDB不保存表的总行数</h3><p>与MyISAM保存表的总行数不同，InnoDB统计行数需要扫描全表，因为MVCC，同一时刻多个查询返回的行数可能不一致。</p>
<p>对于需要经常统计表的行数的解决办法：</p>
<ul>
<li>在缓存（如 Redis）中保存计数</li>
<li>在 MySQL 中保存计数</li>
</ul>
<table>
<thead>
<tr>
<th><strong>语法</strong></th>
<th><strong>统计逻辑</strong></th>
<th><strong>是否包含 NULL</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>COUNT(*)</code></td>
<td>统计所有行（包括所有列），即使所有字段都为 <code>NULL</code> 也会计数</td>
<td><strong>包含</strong></td>
</tr>
<tr>
<td><code>COUNT(1)</code></td>
<td>统计所有行（<code>1</code> 是常量表达式，与列无关）</td>
<td><strong>包含</strong></td>
</tr>
<tr>
<td><code>COUNT(id)</code></td>
<td>统计 <code>id</code> 列中 <strong>非 NULL</strong> 的行数（<code>id</code> 是主键或普通列）</td>
<td><strong>不包含 NULL</strong></td>
</tr>
<tr>
<td><code>COUNT(某个字段)</code></td>
<td>统计该字段中 <strong>非 NULL</strong> 的行数（如果字段允许 <code>NULL</code>）</td>
<td><strong>不包含 NULL</strong></td>
</tr>
</tbody></table>
<p>性能：<code>count(字段)</code> &lt; <code>count(主键)</code> &lt; <code>count(1)</code> ≈ <code>count(*)</code></p>
<p><code>count(主键/字段)</code> 的效率更低的原因是需要解析数据行，并拷贝要返回的字段值。</p>
<h3 id="解释一下事务的基本特性和隔离级别"><a href="#解释一下事务的基本特性和隔离级别" class="headerlink" title="解释一下事务的基本特性和隔离级别"></a>解释一下事务的基本特性和隔离级别</h3><p>事务保证一组操作要么全部成功，要么全部失败。在 MySQL 中，事务支持是在引擎层实现的。</p>
<table>
<thead>
<tr>
<th>基本特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>原子性（<code>atomicity</code>）</td>
<td>事务中的操作要么全都执行，要么都不执行</td>
</tr>
<tr>
<td>一致性（<code>consistency</code>）</td>
<td>事务的执行要保证数据的完整性和一致性</td>
</tr>
<tr>
<td>隔离性（<code>isolation</code>）</td>
<td>事务的执行互不干扰</td>
</tr>
<tr>
<td>持久性（<code>durability</code>）</td>
<td>事务一旦提交，对数据的修改就永久保存到数据库中，不可撤销</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>事务可能引发的问题</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>脏读</td>
<td>A 事务读取 B 事务尚未提交的修改</td>
</tr>
<tr>
<td>不可重复读</td>
<td>A 事务多次读取同一数据，结果前后不一致</td>
</tr>
<tr>
<td>幻读</td>
<td>A 事务多次读取，数据总量前后不一致</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>说明</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td><code>read uncommitted</code></td>
<td>一个事务执行过程中，能看到其他未提交事务做的变更</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td><code>read committed</code></td>
<td>一个事务执行过程中，能看到其他已提交事务做的变更（MySQL 会在每个 SQL 语句开始执行时创建一个视图）</td>
<td></td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td><code>repeatable read</code></td>
<td>一个事务执行过程中，其他事务的变更对它不可见（MySQL 会在事务启动时创建一个视图，整个事务执行期间都使用这个视图）</td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td><code>serializable</code></td>
<td>事务串行执行，隔离级别最高，不会出现上面所说的问题，但相应的效率也最低</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="InnoDB如何解决幻读"><a href="#InnoDB如何解决幻读" class="headerlink" title="InnoDB如何解决幻读"></a>InnoDB如何解决幻读</h3><p>InnoDB解决幻读主要靠以下三大核心机制：</p>
<ul>
<li>多版本并发控制（<code>MVCC</code>）</li>
<li>间隙锁（<code>Gap Lock</code>）</li>
<li>临键锁（<code>Next-Key Lock</code>）</li>
</ul>
<p><strong><code>MVCC</code>实现原理：</strong></p>
<ul>
<li><code>Undo log</code>：每条数据维护多个历史版本</li>
<li><code>ReadView</code>：快照</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ReadView结构：</span><br><span class="line">&#123;</span><br><span class="line">  creator_trx_id: 150,      -- 当前事务ID</span><br><span class="line">  m_ids: [100, 120, 140],   -- 活跃事务ID列表</span><br><span class="line">  min_trx_id: 100,          -- 最小活跃事务ID</span><br><span class="line">  max_trx_id: 150           -- 预分配最大事务ID</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可见性判断规则</strong>：</p>
<ol>
<li>数据版本<code>trx_id</code> &lt; <code>min_trx_id</code> → 可见</li>
<li><code>trx_id</code>在<code>m_ids</code>中 → 不可见</li>
<li><code>trx_id</code> &gt;&#x3D; <code>max_trx_id</code> → 不可见</li>
</ol>
<p>InnoDB默认会为每行数据生成两个隐藏列：</p>
<ul>
<li><code>DB_TRX_ID</code>：最后修改该行的事务ID</li>
<li><code>DB_ROLL_PTR</code>：指向<code>Undo Log</code>的回滚指针</li>
</ul>
<p>不同隔离级别下<code>ReadView</code>的生成时机：</p>
<ul>
<li><code>READ COMMITTED(RC)</code>：每次<code>SELECT</code>都会创建新的<code>ReadView</code></li>
<li><code>REPEATABLE READ(RR)</code>：事务中第一次<code>SELECT</code>时创建<code>ReadView</code></li>
</ul>
<p><strong>间隙锁（<code>Gap Lock</code>）</strong></p>
<p>锁定记录之间的间隙，不锁定记录本身。防止幻读。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 表数据：5, 10, 15</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">10</span> <span class="keyword">AND</span> id <span class="operator">&lt;</span> <span class="number">20</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>这条语句会锁定区间 <code>(10,15)</code>、<code>(15,+∞)</code>，在事务执行期间，其他事务无法在这两个区间插入数据</p>
<p><strong>临键锁（<code>Next-Key Lock</code>）</strong></p>
<p>锁定记录本身及之前的间隙。同时防止幻读和不可重复读。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 事务A执行：</span><br><span class="line">SELECT * FROM users WHERE id &gt; 15 AND id &lt; 25 FOR UPDATE;</span><br><span class="line">-- 假设存在id=20的记录，临键锁会锁定：(15,20],(20,+∞)</span><br></pre></td></tr></table></figure>



<p><strong>Q1：RR隔离级别如何既使用MVCC又用锁？</strong></p>
<ul>
<li><strong>快照读</strong>（普通SELECT）：依赖MVCC保证一致性</li>
<li><strong>当前读</strong>（SELECT FOR UPDATE）：使用临键锁保证物理数据一致</li>
</ul>
<p><strong>Q2：Gap Lock是否会导致死锁？</strong></p>
<p>间隙锁是有可能导致死锁的，如：事务A锁(5,10)，事务B锁(10,15)，两者同时请求对方区间的插入</p>
<p>解决方案：设置<code>innodb_deadlock_detect=ON</code>（默认开启检测）</p>
<p><strong>Q3：Purge线程的作用是什么？</strong></p>
<p>清理不再被任何事务需要的<code>Undo Log</code>，回收版本链中的过期数据版本</p>
<h3 id="InnoDB和MyISAM的区别"><a href="#InnoDB和MyISAM的区别" class="headerlink" title="InnoDB和MyISAM的区别"></a>InnoDB和MyISAM的区别</h3><table>
<thead>
<tr>
<th></th>
<th>MyISAM</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td>锁</td>
<td>表级锁</td>
<td>行级锁</td>
</tr>
<tr>
<td>事务支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>索引结构</td>
<td>B树</td>
<td>B+树</td>
</tr>
<tr>
<td>全文检索</td>
<td>支持</td>
<td>5.5版本后支持</td>
</tr>
</tbody></table>
<p>总体来说，如果需要支持事务、外键约束和高并发访问，那么InnoDB是更好的选择。如果需要进行全文检索，那么MyISAM是更好的选择。但是需要注意的是，MySQL 5.5版本之后，InnoDB已经支持了全文检索。</p>
<h3 id="为什么有时索引会失效或选错索引"><a href="#为什么有时索引会失效或选错索引" class="headerlink" title="为什么有时索引会失效或选错索引"></a>为什么有时索引会失效或选错索引</h3><p>索引失效的常见场景：</p>
<ul>
<li>违反最左前缀原则</li>
<li>对索引列进行运算或函数操作</li>
<li>使用 <code>or</code> 连接非索引列</li>
<li>索引列存在大量重复值，如性别</li>
<li>使用 <code>like &#39;%地址&#39;</code></li>
</ul>
<p>选错索引的常见原因：</p>
<ul>
<li><p>统计信息不准确：优化器依赖的统计信息（如 <code>cardinality</code>）过时，误判索引效率。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 表数据分布已变化，但统计信息未更新</span><br><span class="line">ANALYZE TABLE users; -- 手动更新统计信息</span><br></pre></td></tr></table></figure>
</li>
<li><p>索引覆盖不足：索引未覆盖查询所需字段，导致回表成本过高。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 索引 (a) 无法覆盖 SELECT *</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用覆盖索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">table</span> <span class="keyword">ADD</span> INDEX idx_a_b_c (a, b, c);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="如何优化查询"><a href="#如何优化查询" class="headerlink" title="如何优化查询"></a>如何优化查询</h3><ol>
<li>编写高效的查询语句：合理编写查询语句是查询优化的基础。避免使用复杂的嵌套查询和子查询，尽量使用简单的查询语句；避免使用过多的通配符，尽量指定具体的查询条件；使用合适的连接方式，如INNER JOIN、LEFT JOIN、RIGHT JOIN等；避免使用不必要的排序和分组。</li>
<li>使用索引：合理使用索引可以显著提高查询性能。在查询条件中频繁使用的列上创建索引，避免在大表上进行全表扫描。</li>
<li>避免使用SELECT *：在查询时，避免使用SELECT *，而是只选择需要的列。这样可以减少数据库传输和处理的数据量，提高查询效率。</li>
<li>优化子查询和嵌套查询：子查询和嵌套查询可能导致查询性能下降，尽量避免在查询中多次嵌套子查询。可以考虑使用连接（JOIN）操作、临时表等替代子查询，从而优化查询性能。</li>
<li>使用合适的数据类型：在数据库设计和查询中，使用合适的数据类型可以避免数据类型转换和隐式转换，提高查询性能。例如，对于整数类型的列，使用整数类型的数据而不是字符类型的数据，可以提高查询效率。</li>
</ol>
<h3 id="为什么有时只查询一行但是很慢"><a href="#为什么有时只查询一行但是很慢" class="headerlink" title="为什么有时只查询一行但是很慢"></a>为什么有时只查询一行但是很慢</h3><ol>
<li>数据库表中数据量增加：随着表中数据量的增加，查询一行的时间可能会变得更长。</li>
<li>索引失效：如果查询条件中使用的列没有索引，或者索引失效（例如索引统计信息过期或者索引损坏），数据库可能会执行全表扫描或者其他低效的查询方法，从而导致查询一行的性能下降。</li>
<li>查询复杂度增加：如果查询的复杂度增加，例如涉及到多个表的联接、子查询、聚合函数等，查询一行的性能可能会受到影响。</li>
<li>数据库服务器负载增加：如果数据库服务器负载增加，例如同时有大量的查询和写入操作，数据库的性能可能会下降，从而导致查询一行变得很慢。</li>
</ol>
<h3 id="慢SQL优化全流程"><a href="#慢SQL优化全流程" class="headerlink" title="慢SQL优化全流程"></a>慢SQL优化全流程</h3><p><strong>阶段1：问题定位与数据采集</strong></p>
<ul>
<li>开启慢日志查询</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 动态开启（重启失效）</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log <span class="operator">=</span> <span class="string">&#x27;ON&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> long_query_time <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">-- 阈值设为1秒</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log_file <span class="operator">=</span> <span class="string">&#x27;/var/log/mysql/slow.log&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 永久配置（my.cnf）</span><br><span class="line">[mysqld]</span><br><span class="line">slow_query_log = 1</span><br><span class="line">long_query_time = 1</span><br><span class="line">log_queries_not_using_indexes = 1  -- 记录未走索引的查询</span><br></pre></td></tr></table></figure>

<ul>
<li>实时监测工具</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前运行中的慢查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.PROCESSLIST </span><br><span class="line"><span class="keyword">WHERE</span> <span class="type">TIME</span> <span class="operator">&gt;</span> <span class="number">2</span> <span class="keyword">AND</span> COMMAND <span class="operator">=</span> <span class="string">&#x27;Query&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用Percona Toolkit抓取问题SQL</span></span><br><span class="line">pt<span class="operator">-</span>query<span class="operator">-</span>digest <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysql<span class="operator">/</span>slow.log</span><br></pre></td></tr></table></figure>

<ul>
<li>关键性能指标</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">重点监控项：</span><br><span class="line">- QPS/TPS波动</span><br><span class="line">- CPU使用率（特别是%sys）</span><br><span class="line">- 锁等待时间(Innodb_row_lock_time_avg)</span><br><span class="line">- 缓冲池命中率(Innodb_buffer_pool_reads)</span><br></pre></td></tr></table></figure>



<p>Q：<code>IN</code> 和 <code>EXISTS</code> 的区别</p>
<p>当使用 <code>IN</code> 时，MySQL 会首先执行子查询，然后将子查询的结果集用于外部查询的条件。这意味着子查询的结果集需要全部加载到内存中。</p>
<p>而 <code>EXISTS</code> 会对外部查询的每一行，执行一次子查询。如果子查询返回任何行，则 <code>EXISTS</code> 条件为真。<code>EXISTS</code> 关注的是子查询是否返回行，而不是返回的具体值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- IN 的临时表可能成为性能瓶颈</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> user_id <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> amount <span class="operator">&gt;</span> <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- EXISTS 可以利用关联索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users u</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> orders o </span><br><span class="line">            <span class="keyword">WHERE</span> o.user_id <span class="operator">=</span> u.id <span class="keyword">AND</span> o.amount <span class="operator">&gt;</span> <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p><code>IN</code> 适用于子查询结果集较小的情况。如果子查询返回大量数据，<code>IN</code> 的性能可能会下降，因为它需要将整个结果集加载到内存。</p>
<p>而 EXISTS 适用于子查询结果集可能很大的情况。由于 <code>EXISTS</code> 只需要判断子查询是否返回行，而不需要加载整个结果集，因此在某些情况下性能更好，特别是当子查询可以使用索引时。</p>
<p><strong>NULL值陷</strong></p>
<p><code>IN</code>: 如果子查询的结果集中包含 <code>NULL</code> 值，可能会导致意外的结果。例如，<code>WHERE column IN (subquery)</code>，如果 <code>subquery</code> 返回 <code>NULL</code>，则 <code>column IN (subquery)</code> 永远不会为真，除非 <code>column</code> 本身也为 <code>NULL</code>。</p>
<p><code>EXISTS</code>: 对 <code>NULL</code> 值的处理更加直接。<code>EXISTS</code> 只是检查子查询是否返回行，不关心行的具体值，因此不受 <code>NULL</code> 值的影响。</p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="Redis为什么快？单线程如何处理高并发？"><a href="#Redis为什么快？单线程如何处理高并发？" class="headerlink" title="Redis为什么快？单线程如何处理高并发？"></a>Redis为什么快？单线程如何处理高并发？</h3><p>对于Redis的高性能设计，我的理解主要得益于以下几点：</p>
<ul>
<li>内存操作：Redis数据存储在内存，相比于磁盘数据库，减少了IO开销</li>
<li>高效的数据结构：Redis针对不同场景设计了不同的数据结构，优化了空间和访问效率</li>
<li>单线程：Redis使用单线程处理命令，避免了多线程之间的竞争和上下文切换的开销</li>
<li>IO多路复用：Redis基于epoll&#x2F;kqueue实现了非阻塞的网络模型，通过事件机制循环处理请求</li>
</ul>
<p><strong>追问1：单线程如何利用多核CPU</strong></p>
<p>可以部署分片集群，每个Redis实例绑定一个CPU核（如何部署和绑定？）</p>
<p><strong>追问2：为什么选用单线程而不是多线程</strong></p>
<ul>
<li>避免锁竞争</li>
<li>避免上下文切换开销</li>
<li>多线程内存管理复杂</li>
</ul>
<p><strong>追问3： 什么场景下单线程会成为瓶颈</strong></p>
<ul>
<li>超大 Value 操作（如10MB的string）（什么操作，普通读写就会阻塞吗）</li>
<li>复杂 Lua 脚本执行（阻塞其他命令）</li>
</ul>
<p><strong>Q：Redis有哪些数据结构，分别有哪些使用场景场景？</strong></p>
<p>Redis的基础数据结构包括string、hash、list、set、zset，高级数据结构包括hyperloglog、geo、bitmap、stream</p>
<h3 id="解释一下缓存穿透-雪崩-击穿，对应的解决方案是什么"><a href="#解释一下缓存穿透-雪崩-击穿，对应的解决方案是什么" class="headerlink" title="解释一下缓存穿透&#x2F;雪崩&#x2F;击穿，对应的解决方案是什么"></a>解释一下缓存穿透&#x2F;雪崩&#x2F;击穿，对应的解决方案是什么</h3><p><strong>缓存穿透</strong>是指查询数据库中不存在的数据，导致请求每次都穿过缓存查询数据库。</p>
<p>解决方案：</p>
<ul>
<li><strong>布隆过滤器（Bloom Filter）</strong></li>
</ul>
<p>服务启动时加载全量有效key，标记数据是否存在；新增数据时同步更新过滤器</p>
<p>缺点：存在一定的误判率</p>
<ul>
<li><strong>缓存空值</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getData</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> redis.get(key);</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> NullValue) &#123; <span class="comment">// 空值标记</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    value = db.query(key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        redis.setex(key, <span class="number">300</span>, <span class="keyword">new</span> <span class="title class_">NullValue</span>()); <span class="comment">// 缓存空值5分钟</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redis.setex(key, <span class="number">3600</span>, value); <span class="comment">// 正常缓存1小时</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>增强请求参数的复杂度，避免被猜测，同时做好数据的基础格式校验</li>
</ul>
<p><strong>缓存雪崩</strong>是指<strong>大量key</strong>同时失效，导致大量请求都去查询数据库，造成数据库压力骤增。</p>
<p>解决方案：</p>
<ul>
<li><strong>差异化过期时间</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基础过期时间，1小时</span></span><br><span class="line"><span class="type">int</span> <span class="variable">baseExpire</span> <span class="operator">=</span> <span class="number">3600</span>;</span><br><span class="line"><span class="comment">// 随机0-5分钟</span></span><br><span class="line"><span class="type">int</span> <span class="variable">randomExpire</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">300</span>);</span><br><span class="line">redis.setex(key, baseExpire + randomExpire, value);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>永不过期+异步更新</strong></li>
<li><strong>添加降级限流策略</strong></li>
<li><strong>添加多级缓存</strong></li>
</ul>
<p><strong>缓存击穿</strong>是指某个<strong>热点key</strong>失效的瞬间，有大量请求同时访问这个key，导致所有请求都去查询数据库。</p>
<p>解决方案：</p>
<ul>
<li><strong>互斥锁</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> Redission.getLock(<span class="string">&quot;PREFIX:&quot;</span> + key);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lock.tryLock(<span class="number">3</span>, <span class="number">30</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">        <span class="comment">// 查库并重建缓存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>逻辑过期</strong></li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;真实数据&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;expire_ts&quot;</span><span class="punctuation">:</span> <span class="number">1672502400</span> <span class="comment">// 逻辑过期时间戳</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>处理流程：</p>
<ol>
<li>判断逻辑过期时间<ol>
<li>未过期，直接返回数据</li>
<li>已过期，创建子线程，异步重建缓存</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th>解决方案</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>互斥锁</td>
<td>实现简单；保证一致性；无需消耗额外内存</td>
<td>线程需等待，影响性能</td>
</tr>
<tr>
<td>逻辑过期</td>
<td>线程无需等待，性能较好</td>
<td>存在不一致性；消耗额外内存；实现复杂</td>
</tr>
</tbody></table>
<h3 id="RDB和AOF持久化原理及优劣对比"><a href="#RDB和AOF持久化原理及优劣对比" class="headerlink" title="RDB和AOF持久化原理及优劣对比"></a>RDB和AOF持久化原理及优劣对比</h3><p>RDB，存储某一时刻内存中所有的数据，触发命令<code>save</code>、<code>bgsave</code>，主进程<code>fork</code>子进程，阻塞。</p>
<p>触发条件：</p>
<ol>
<li>客户端发送<code>shutdown</code></li>
<li>从节点要进行全量复制</li>
<li>达到<code>redis.conf</code>文件中配置的条件</li>
<li>客户端执行<code>flushall</code>（生成空的<code>dump.rdb</code>，慎用）</li>
</ol>
<p>不能频繁生成 RBD 快照，原因：</p>
<ul>
<li>多次 RDB 会竞争磁盘带宽</li>
<li><code>fork</code> 子进程会阻塞主进程</li>
</ul>
<p>写时复制<code>copy-on-write</code>：</p>
<ul>
<li><strong>共享内存初始化</strong>：子进程刚创建时，<strong>与父进程共享全部内存页</strong>，此时内存占用几乎无额外开销。</li>
<li><strong>写操作触发复制</strong>：若父进程收到写请求（修改数据），操作系统会<strong>将被修改的内存页复制一份</strong>，父进程在副本上修改，子进程仍读取原始页。</li>
<li><strong>子进程视角固定</strong>：子进程看到的数据始终是 <code>fork()</code> 瞬间的状态，确保快照一致性。</li>
</ul>
<p>AOF，所有写命令追加到 <code>aof_buf</code>，刷盘策略由 <code>appendfsync</code> 决定。</p>
<p>如果有 AOF 文件，加载 AOF；否则，加载 RDB 文件。AOF 最多丢失 1s 数据。</p>
<p>AOF重写是直接为当前内存的数据生成对应命令，并不是读取旧AOF文件进行命令合并</p>
<ul>
<li>父子进程写同一个文件会产生竞争问题，影响父进程的性能。</li>
<li>如果AOF重写过程中失败了，相当于污染了原本的AOF文件，无法做恢复数据使用</li>
</ul>
<p>修复已损害的AOF文件：<code>redis-check-aof --fix appendonly.aof</code></p>
<table>
<thead>
<tr>
<th></th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody><tr>
<td>启动加载优先级</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>体积</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>恢复速度</td>
<td>慢</td>
<td>快</td>
</tr>
</tbody></table>
<p>总结：RDB适合用作数据备份，AOF适合用作数据恢复。</p>
<h3 id="什么是热Key问题"><a href="#什么是热Key问题" class="headerlink" title="什么是热Key问题"></a>什么是热Key问题</h3><h3 id="Redis事务与MySQL事务有什么区别"><a href="#Redis事务与MySQL事务有什么区别" class="headerlink" title="Redis事务与MySQL事务有什么区别"></a>Redis事务与MySQL事务有什么区别</h3><h3 id="使用Redis实现分布式锁的演进过程"><a href="#使用Redis实现分布式锁的演进过程" class="headerlink" title="使用Redis实现分布式锁的演进过程"></a>使用Redis实现分布式锁的演进过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.ValueOperations;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisDistributedLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_KEY</span> <span class="operator">=</span> <span class="string">&quot;myLock&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LOCK_EXPIRE_TIME</span> <span class="operator">=</span> <span class="number">5000</span>; <span class="comment">// 锁过期时间，单位毫秒</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisDistributedLock</span><span class="params">(RedisTemplate&lt;String, String&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">acquireLock</span><span class="params">()</span> &#123;</span><br><span class="line">        ValueOperations&lt;String, String&gt; valueOperations = redisTemplate.opsForValue();</span><br><span class="line">        <span class="comment">// 尝试获取分布式锁</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">result</span> <span class="operator">=</span> valueOperations.setIfAbsent(LOCK_KEY, <span class="string">&quot;locked&quot;</span>); <span class="comment">// RedisTemplate 的 setIfAbsent 方法，如果键不存在则设置键值对并返回 true，否则返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span> &amp;&amp; result) &#123;</span><br><span class="line">            <span class="comment">// 成功获取到锁，设置锁的过期时间</span></span><br><span class="line">            redisTemplate.expire(LOCK_KEY, LOCK_EXPIRE_TIME, TimeUnit.MILLISECONDS); <span class="comment">// 设置键的过期时间，单位毫秒</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">releaseLock</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.delete(LOCK_KEY); <span class="comment">// 删除键</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用分布式锁的业务逻辑</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBusinessWithLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acquireLock()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获得分布式锁后执行业务逻辑</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Acquired lock, do business logic...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>); <span class="comment">// 模拟业务处理时间</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                releaseLock(); <span class="comment">// 业务处理完成后释放锁</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Released lock.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 未获得分布式锁，执行其他逻辑</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Failed to acquire lock, do other logic...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 RedisTemplate 实例并设置连接信息</span></span><br><span class="line">        RedisTemplate&lt;String, String&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置 Redis 连接工厂、序列化方式等</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="type">RedisDistributedLock</span> <span class="variable">distributedLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisDistributedLock</span>(redisTemplate);</span><br><span class="line">        distributedLock.doBusinessWithLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>竞争条件（Race Condition）：在多个客户端同时尝试获取锁时，可能会出现竞争条件，导致多个客户端都成功获得锁，从而引发并发访问资源的问题。</li>
<li>死锁（Deadlock）：如果某个持有锁的客户端在业务处理期间发生异常或崩溃，导致没有释放锁的操作，可能会出现死锁的情况，导致其他客户端无法获得锁。</li>
<li>锁过期（Lock Expiration）：为了避免死锁，通常会给锁设置过期时间，但如果业务处理时间较长，超过了锁的过期时间，可能会导致其他客户端误认为锁已经释放，从而引发并发访问资源的问题。</li>
<li>锁的重入性（Lock Reentrancy）：在某些场景下，同一个客户端可能需要多次获取同一个锁，例如嵌套的业务处理逻辑。如果分布式锁没有支持锁的重入性，可能会导致同一个客户端无法在业务处理期间重新获取锁，从而引发死锁或并发访问资源的问题。</li>
<li>性能开销（Performance Overhead）：使用分布式锁可能会增加系统的性能开销，例如频繁的锁获取和锁释放操作，以及锁的管理和维护。如果锁的使用不当，可能会影响系统的性能和响应时间。</li>
</ol>
<h3 id="全量同步和增量同步的区别"><a href="#全量同步和增量同步的区别" class="headerlink" title="全量同步和增量同步的区别"></a>全量同步和增量同步的区别</h3><p>全量同步：master生成当前内存中所有数据的RDB文件，将RDB发送给slave。在此过程中，master将新的命令记录在<code>repl_backlog</code>中，后续再发送给slave。</p>
<p>执行时机：</p>
<ol>
<li>slave第一次连接到master</li>
<li>slave宕机太久，导致它在<code>repl_backlog</code>中的<code>offset</code>已经被覆盖掉了</li>
</ol>
<p>增量同步：salve将自己的<code>offset</code>发送到master，master将<code>repl_backlog</code>中<code>offset</code>之后的命令发送给slave</p>
<p>执行时机：</p>
<ol>
<li>slave断开重连之后，<code>repl_backlog</code>中的<code>offset</code>尚未被覆盖</li>
</ol>
<h3 id="内存淘汰策略与LRU实现"><a href="#内存淘汰策略与LRU实现" class="headerlink" title="内存淘汰策略与LRU实现"></a>内存淘汰策略与LRU实现</h3><table>
<thead>
<tr>
<th align="left"><strong>数据范围</strong></th>
<th align="left"><strong>策略</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>所有Key</strong></td>
<td align="left"><code>allkeys-lru</code></td>
<td align="left">从所有Key中淘汰最近最少使用的</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>allkeys-lfu</code></td>
<td align="left">从所有Key中淘汰最不经常使用的（Redis 4.0+）</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>allkeys-random</code></td>
<td align="left">从所有Key中随机淘汰</td>
</tr>
<tr>
<td align="left"><strong>过期Key</strong></td>
<td align="left"><code>volatile-lru</code></td>
<td align="left">从设置了过期时间的Key中淘汰最近最少使用的</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>volatile-lfu</code></td>
<td align="left">从设置了过期时间的Key中淘汰最不经常使用的</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>volatile-random</code></td>
<td align="left">从设置了过期时间的Key中随机淘汰</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>volatile-ttl</code></td>
<td align="left">淘汰剩余存活时间（TTL）最短的Key</td>
</tr>
<tr>
<td align="left"><strong>不淘汰</strong></td>
<td align="left"><code>noeviction</code>（默认）</td>
<td align="left">内存不足时拒绝写入，返回错误</td>
</tr>
</tbody></table>
<h3 id="Redis和MySQL的区别"><a href="#Redis和MySQL的区别" class="headerlink" title="Redis和MySQL的区别"></a>Redis和MySQL的区别</h3><table>
<thead>
<tr>
<th></th>
<th>Redis</th>
<th>MySQL</th>
</tr>
</thead>
<tbody><tr>
<td>数据结构</td>
<td>非结构化</td>
<td>结构化</td>
</tr>
<tr>
<td>持久化</td>
<td>可选持久化</td>
<td>默认持久化</td>
</tr>
<tr>
<td>事务支持</td>
<td>简单支持</td>
<td>支持完整的ACID</td>
</tr>
<tr>
<td>扩展性</td>
<td>通过分片水平扩展</td>
<td>复杂，需分库分表或中间件</td>
</tr>
<tr>
<td>数据一致性</td>
<td>最终一致性</td>
<td>强一致性</td>
</tr>
</tbody></table>
<p>总结：</p>
<ul>
<li>当需要复杂查询和事务支持，对数据一致性要求较高，需要长期持久化存储的场景，选择MySQL</li>
<li>当需要超高性能和灵活数据类型，对数据的一致性要求不那么高，且容忍一定的数据丢失的情况下，选择Redis</li>
</ul>
<h3 id="Redis和memchahed的区别"><a href="#Redis和memchahed的区别" class="headerlink" title="Redis和memchahed的区别"></a>Redis和memchahed的区别</h3><table>
<thead>
<tr>
<th></th>
<th>Redis</th>
<th>Memcached</th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>丰富的数据类型：string、hash、list等</td>
<td>只支持string</td>
</tr>
<tr>
<td>持久化</td>
<td>支持（RDB、AOF）</td>
<td>不支持</td>
</tr>
<tr>
<td>事务</td>
<td>简单支持（MULTI&#x2F;EXEC）</td>
<td>不支持</td>
</tr>
<tr>
<td>分布式</td>
<td>支持，集群自动分片</td>
<td>依赖客户端一致性哈希或第三方工具实现分布式</td>
</tr>
<tr>
<td>命令</td>
<td>支持丰富的命令</td>
<td>仅支持SET、GET、ADD、DELTE等基础操作</td>
</tr>
<tr>
<td>内存占用</td>
<td>复杂数据结构可能导致内存消耗较高</td>
<td>内存利用率高，但灵活性较低</td>
</tr>
</tbody></table>
<p>总结：</p>
<ul>
<li>需要复杂数据结构、持久化、事务支持和高可用性的场景，选择Redis</li>
<li>追求极致的性能和简单性，数据结构简单且无需持久化的场景，可以选择Memcached</li>
</ul>
<h3 id="Redis-IO多路复用"><a href="#Redis-IO多路复用" class="headerlink" title="Redis IO多路复用"></a>Redis IO多路复用</h3><p>常见的 I&#x2F;O 多路复用机制包括 select、poll 和 epoll 等。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>select</code></th>
<th><code>poll</code></th>
<th><code>epoll</code></th>
</tr>
</thead>
<tbody><tr>
<td>文件描述符限制</td>
<td>受 <code>FD_SETSIZE</code> 限制</td>
<td>无限制</td>
<td>无限制</td>
</tr>
<tr>
<td>时间复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>数据复制</td>
<td>需要</td>
<td>需要</td>
<td>不需要</td>
</tr>
<tr>
<td>工作方式</td>
<td>线性扫描</td>
<td>线性扫描</td>
<td>事件通知</td>
</tr>
<tr>
<td>内核支持</td>
<td>所有 UNIX 系统</td>
<td>所有 UNIX 系统</td>
<td>Linux 2.6 及以上版本</td>
</tr>
<tr>
<td>适用场景</td>
<td>少量连接</td>
<td>中等连接</td>
<td>大量并发连接</td>
</tr>
</tbody></table>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/redis-20240918114125.png" alt="有盐先生：IO 多路复用"></p>
<h3 id="Redis-6-0-多线程"><a href="#Redis-6-0-多线程" class="headerlink" title="Redis 6.0 多线程"></a>Redis 6.0 多线程</h3><p>在 Redis 6.0 中，多线程主要用来处理网络 IO 操作，命令解析和执行仍然是单线程完成，这样既可以发挥多核 CPU 的优势，又能避免锁和上下文切换带来的性能损耗。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-b7b24e25-d2dc-4457-994f-95bdb3674b8e.png" alt="三分恶面渣逆袭：Redis6.0多线程"></p>
<h2 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h2><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><ol>
<li>Kafka高吞吐量实现原理</li>
<li>消息丢失与重复消费解决方案</li>
<li>顺序消息实现方案</li>
<li>延迟消息实现原理</li>
<li>死信队列应用场景</li>
<li>消息堆积处理策略</li>
<li>RocketMQ事务消息流程</li>
<li>Pulsar分层存储架构优势</li>
<li>如何设计消息轨迹系统？</li>
<li>Broker选举机制对比（Kafka vs RocketMQ）</li>
</ol>
<h3 id="Kafka-为什么能实现高吞吐量？"><a href="#Kafka-为什么能实现高吞吐量？" class="headerlink" title="Kafka 为什么能实现高吞吐量？"></a>Kafka 为什么能实现高吞吐量？</h3><ul>
<li><strong>顺序读写磁盘:</strong> 消息按顺序追加到 Partition 文件末尾，充分利用磁盘顺序 I&#x2F;O 的高性能（远高于随机 I&#x2F;O）。</li>
<li><strong>Page Cache:</strong> 利用操作系统 Page Cache 缓存数据，减少直接磁盘访问。</li>
<li><strong>零拷贝 (Zero-Copy):</strong> 使用 <code>**sendfile**</code> 和 <code>**mmap**</code> 等技术，减少数据在用户空间和内核空间之间的拷贝次数，降低 CPU 开销和上下文切换。</li>
<li><strong>批量处理 (Batching):</strong> Producer 批量发送消息，Broker 批量写入磁盘和批量发送给 Consumer，减少网络和 I&#x2F;O 开销。</li>
<li><strong>消息压缩:</strong> Producer 端可配置压缩算法 (Snappy, LZ4, Gzip, Zstd)，减少网络传输和磁盘存储开销。</li>
<li><strong>Partition 并行:</strong> Topic 被分成多个 Partition，分布在多个 Broker 上，读写操作可以并行发生在不同 Partition，充分利用多 Broker、多磁盘、多核 CPU。</li>
</ul>
<h3 id="解释-Kafka-中-Topic、Partition、Replica-的关系"><a href="#解释-Kafka-中-Topic、Partition、Replica-的关系" class="headerlink" title="解释 Kafka 中 Topic、Partition、Replica 的关系"></a>解释 Kafka 中 Topic、Partition、Replica 的关系</h3><ul>
<li><strong>Topic</strong> 是消息发布的类别或主题。</li>
<li>一个 <strong>Topic</strong> 被划分为一个或多个 <strong>Partition</strong>。Partition 是物理存储单元，分布在不同的 Broker 上。</li>
<li>每个 <strong>Partition</strong> 可以有多个 <strong>Replica</strong> (副本)。其中一个 Replica 是 <strong>Leader</strong>，负责读写；其他是 <strong>Follower</strong>，只负责从 Leader 同步数据。Replica 也分布在不同的 Broker 上，提供容错能力。</li>
</ul>
<h3 id="Producer-的-acks-参数有哪几种？分别代表什么含义？"><a href="#Producer-的-acks-参数有哪几种？分别代表什么含义？" class="headerlink" title="Producer 的 acks 参数有哪几种？分别代表什么含义？"></a>Producer 的 <code>acks</code> <strong>参数有哪几种？分别代表什么含义？</strong></h3><ul>
<li><code>**acks=0**</code>: Producer 发送消息后<strong>不等待</strong> Broker 的任何确认。<strong>最高吞吐，最低延迟，最低可靠性</strong> (可能丢失数据)。</li>
<li><code>**acks=1**</code>: Producer 发送消息后，等待 <strong>Leader 副本成功写入本地日志</strong> 的确认。<strong>折中方案</strong>。Leader 故障但数据未同步到 Follower 时可能丢失数据。</li>
<li><code>**acks=all**</code> <strong>(或</strong> <code>**acks=-1**</code><strong>)</strong>: Producer 发送消息后，等待 <strong>Leader 收到消息并确认该消息已被当前 ISR 集合中的所有副本成功写入本地日志</strong>。<strong>最高可靠性</strong>，最低丢失风险，但延迟最高，吞吐可能最低。需要配合 <code>**min.insync.replicas**</code> 参数使用。</li>
</ul>
<h3 id="解释-Consumer-Group-和-Rebalance-的概念。"><a href="#解释-Consumer-Group-和-Rebalance-的概念。" class="headerlink" title="解释 Consumer Group 和 Rebalance 的概念。"></a>解释 Consumer Group 和 Rebalance 的概念。</h3><ul>
<li><p><strong>Consumer Group (CG):</strong> 一组 Consumer 实例的集合，它们共同消费一个或多个 Topic。组内消费实例<strong>协作消费</strong>订阅 Topic 的所有 Partition。一个 Partition 只能被组内<strong>一个</strong> Consumer 实例消费，实现负载均衡。</p>
</li>
<li><p><strong>Rebalance (重平衡):</strong> 当以下情况发生时，Kafka 会重新分配 CG 内 Consumer 负责的 Partition：</p>
</li>
<li><p>组内 Consumer 数量变化 (新 Consumer 加入、Consumer 崩溃或主动离开)。</p>
</li>
<li><p>订阅的 Topic Partition 数量变化 (如 Topic 被修改增加了 Partition)。</p>
</li>
<li><p>订阅的 Topic 本身变化。</p>
</li>
<li><p><strong>影响:</strong> Rebalance 期间，整个 CG 会<strong>短暂停止消费</strong>，直到分配完成。频繁或长时间的 Rebalance 会影响消费进度和系统稳定性。</p>
</li>
</ul>
<h3 id="Kafka-如何保证消息不丢失？"><a href="#Kafka-如何保证消息不丢失？" class="headerlink" title="Kafka 如何保证消息不丢失？"></a>Kafka 如何保证消息不丢失？</h3><ul>
<li><p><strong>Producer 端:</strong></p>
</li>
<li><p>设置 <code>**acks=all**</code>，确保消息被 ISR 所有副本确认。</p>
</li>
<li><p>使用带回调的异步发送或同步发送，正确处理发送失败（重试 + 业务逻辑处理）。</p>
</li>
<li><p>设置 <code>**retries**</code> &gt; 0 和合理的 <code>**retry.backoff.ms**</code>。</p>
</li>
<li><p><strong>Broker 端:</strong></p>
</li>
<li><p>设置 <code>**unclean.leader.election.enable=false**</code>，防止落后太多的非 ISR 副本成为 Leader（可能导致数据丢失）。</p>
</li>
<li><p>设置 <code>**replication.factor &gt;= 3**</code>，保证足够的副本数。</p>
</li>
<li><p>设置 <code>**min.insync.replicas &gt; 1**</code> (通常 &#x3D; <code>**replication.factor - 1**</code>)，确保 ISR 最小存活副本数。当 ISR 数量不足 <code>**min.insync.replicas**</code> 时，Producer <code>**acks=all**</code> 的请求会失败。</p>
</li>
<li><p>确保 Broker 磁盘可靠 (RAID，监控)。</p>
</li>
<li><p><strong>Consumer 端:</strong></p>
</li>
<li><p>关闭自动提交 (<code>**enable.auto.commit=false**</code>)，在消息<strong>业务逻辑处理完成并确认成功后</strong>再<strong>手动提交 Offset</strong>。</p>
</li>
<li><p>处理好消费逻辑异常，避免因异常导致消息未处理但 Offset 已提交。</p>
</li>
</ul>
<h3 id="解释-Kafka-的-ISR-机制及其在-Leader-选举中的作用。"><a href="#解释-Kafka-的-ISR-机制及其在-Leader-选举中的作用。" class="headerlink" title="解释 Kafka 的 ISR 机制及其在 Leader 选举中的作用。"></a>解释 Kafka 的 ISR 机制及其在 Leader 选举中的作用。</h3><ul>
<li><p><strong>ISR (In-Sync Replicas):</strong> 指与 Partition Leader 副本<strong>保持同步</strong>的 Follower 副本集合。Leader 维护 ISR 列表。</p>
</li>
<li><p><strong>同步标准:</strong> Follower 副本在 <code>**replica.lag.time.max.ms**</code> 时间内成功从 Leader 拉取到最新数据。</p>
</li>
<li><p><strong>Leader 选举:</strong> 当 Leader 副本所在 Broker 宕机时，Controller 会<strong>从当前 ISR 集合中选择一个副本</strong>作为新的 Leader。这是为了保证新 Leader 拥有最新的已提交数据，避免数据丢失或不一致。</p>
</li>
<li><p><code>**unclean.leader.election.enable**</code><strong>:</strong></p>
</li>
<li><p><code>**false**</code> (默认推荐): 必须从 ISR 中选举 Leader。如果 ISR 为空，则分区不可用（牺牲可用性保一致性）。</p>
</li>
<li><p><code>**true**</code>: 允许从非 ISR (不同步) 的副本中选举 Leader。可能丢失数据或导致数据不一致（牺牲一致性保可用性）。</p>
</li>
</ul>
<h3 id="Kafka-如何实现-Exactly-Once-语义？"><a href="#Kafka-如何实现-Exactly-Once-语义？" class="headerlink" title="Kafka 如何实现 Exactly-Once 语义？"></a>Kafka 如何实现 Exactly-Once 语义？</h3><ul>
<li><p><strong>幂等性 (Idempotence -</strong> <code>**enable.idempotence=true**</code><strong>)：</strong></p>
</li>
<li><p>解决单个 Producer 会话内发送<strong>单分区</strong>的<strong>重复</strong>问题 (at-least-once 引起的重复)。</p>
</li>
<li><p>原理：Producer 为每个发送批次分配唯一 PID (Producer ID) 和序列号 (Sequence Number)。Broker 根据 PID+Partition+SeqNum 去重，丢弃重复的批次。</p>
</li>
<li><p><strong>事务 (Transactions)：</strong></p>
</li>
<li><p>解决跨分区、跨会话的“读-处理-写”模式下的<strong>精确一次</strong>语义 (例如 Kafka Streams 应用)。</p>
</li>
<li><p>原理：</p>
</li>
<li><p>Producer 开启事务 (<code>**initTransactions()**</code>)。</p>
</li>
<li><p>发送的消息标记为事务性消息。</p>
</li>
<li><p>将消费和生产的 Offset 提交都包含在同一个事务中 (<code>**sendOffsetsToTransaction()**</code> + <code>**commitTransaction()**</code>)。</p>
</li>
<li><p>Broker 使用事务协调器 (Transaction Coordinator) 管理事务状态 (PREPARE_COMMIT, COMMITTED, ABORTED)。</p>
</li>
<li><p>消费者配置 <code>**isolation.level=read_committed**</code> 只读取已提交的事务消息。</p>
</li>
<li><p><strong>注意:</strong> 严格意义的端到端 EOS 还需要 Consumer 的输出操作是幂等的。</p>
</li>
</ul>
<h3 id="Kafka-如何保证消息的顺序性？"><a href="#Kafka-如何保证消息的顺序性？" class="headerlink" title="Kafka 如何保证消息的顺序性？"></a>Kafka 如何保证消息的顺序性？</h3><ul>
<li><strong>Kafka 仅保证单个 Partition 内消息的严格顺序 (FIFO)。</strong> 这是由其追加写入和单线程消费分区的特性保证的。</li>
<li><strong>无法保证跨 Partition 的消息全局顺序。</strong></li>
<li><strong>需要全局顺序怎么办？</strong> 将所有需要保证顺序的消息发送到<strong>同一个 Partition</strong>。通常通过为这些消息指定<strong>相同的 Key</strong> 来实现 (Producer 根据 Key 的哈希值决定 Partition)。</li>
<li><strong>需要分区顺序怎么办？</strong> 确保同一个 Key 的消息总是发到同一个 Partition (同样通过 Key 哈希)，则该 Key 相关的消息在该 Partition 内是顺序的。</li>
</ul>
<h3 id="Kafka-中-Zookeeper-和-KRaft-的区别？为什么-Kafka-要去-Zookeeper-化？"><a href="#Kafka-中-Zookeeper-和-KRaft-的区别？为什么-Kafka-要去-Zookeeper-化？" class="headerlink" title="Kafka 中 Zookeeper 和 KRaft 的区别？为什么 Kafka 要去 Zookeeper 化？"></a>Kafka 中 Zookeeper 和 KRaft 的区别？为什么 Kafka 要去 Zookeeper 化？</h3><ul>
<li><p><strong>Zookeeper (ZK)：</strong> 是 Kafka 2.7 及之前版本的核心外部依赖。负责：</p>
</li>
<li><p>Broker 注册与发现</p>
</li>
<li><p>Controller 选举</p>
</li>
<li><p>Topic 配置存储</p>
</li>
<li><p>ACL 权限存储</p>
</li>
<li><p>(旧版) Consumer Offset 存储</p>
</li>
<li><p><strong>KRaft：</strong> 是 Kafka 内部实现的基于 Raft 共识协议的元数据管理系统，从 Kafka 2.8 (预览) &#x2F; 3.0+ (生产可用) 开始引入，旨在完全取代 Zookeeper。</p>
</li>
<li><p><strong>去 ZK 化原因 (KRaft 优势)：</strong></p>
</li>
<li><p><strong>简化架构与部署：</strong> 移除外部依赖，Kafka 自包含，部署、配置、监控更简单。</p>
</li>
<li><p><strong>提升性能与可伸缩性：</strong> 元数据操作直接在 Kafka 协议上处理，减少一次网络跳转和序列化开销。KRaft 设计上能更好地支持大规模集群（数万个 Partition）。</p>
</li>
<li><p><strong>更强的元数据一致性模型：</strong> KRaft 使用 Raft 强一致性协议管理元数据状态机。</p>
</li>
<li><p><strong>更直接的运维：</strong> 所有操作通过 Kafka API 或 <code>**kafka-metadata-shell**</code> 完成，无需单独管理 ZK。</p>
</li>
<li><p><strong>统一安全模型：</strong> 元数据通信复用 Kafka 的安全机制 (SSL&#x2F;SASL)，无需单独配置 ZK 安全。</p>
</li>
<li><p><strong>现状：</strong> KRaft 已成为生产推荐模式，新集群应优先使用 KRaft。Zookeeper 模式在逐步淘汰。</p>
</li>
</ul>
<h3 id="什么是-Consumer-Lag？如何监控和处理-Lag？"><a href="#什么是-Consumer-Lag？如何监控和处理-Lag？" class="headerlink" title="什么是 Consumer Lag？如何监控和处理 Lag？"></a>什么是 Consumer Lag？如何监控和处理 Lag？</h3><ul>
<li><p><strong>定义：</strong> Consumer Lag 指 Consumer Group 在某个 Partition 上<strong>最新提交的 Offset</strong> 与 <strong>Partition 当前最新消息的 Offset (LEO)</strong> 之间的差值。即 <strong>未消费的消息数量</strong>。</p>
</li>
<li><p><strong>监控重要性：</strong> Lag 是衡量消费健康状况的关键指标。持续增长的 Lag 意味着消费速度跟不上生产速度，可能导致延迟和数据积压。</p>
</li>
<li><p><strong>原因：</strong></p>
</li>
<li><p>消费者处理能力不足 (CPU, 内存, 逻辑复杂, I&#x2F;O 慢)。</p>
</li>
<li><p>消费者实例数量不足 (Partition 数 &gt; Consumer 实例数)。</p>
</li>
<li><p>下游系统故障或慢。</p>
</li>
<li><p>消费者代码 Bug 或配置问题 (如 <code>**max.poll.records**</code> 太大导致单次处理时间过长)。</p>
</li>
<li><p>网络问题。</p>
</li>
<li><p><strong>处理：</strong></p>
</li>
<li><p><strong>监控:</strong> 使用 Kafka 自带工具 (<code>**kafka-consumer-groups.sh**</code>)，JMX 指标 (&#96;&#96;&#96;, <code>**,** </code>, &#96;&#96;)，或第三方监控系统 (Prometheus+Grafana, Confluent Control Center)。</p>
</li>
<li><p><strong>扩容：</strong> 增加 Consumer Group 内的 Consumer 实例数 (确保 &lt;&#x3D; Partition 数)。</p>
</li>
<li><p><strong>优化消费者：</strong> 提升单 Consumer 处理能力 (优化代码逻辑、异步处理、批处理、调优 JVM)。</p>
</li>
<li><p><strong>调整参数：</strong> 适当增加 <code>**fetch.min.bytes**</code>, <code>**fetch.max.wait.ms**</code> 提高拉取效率；调整 <code>**max.poll.records**</code> 避免单次处理过多消息超时；检查 <code>**session.timeout.ms**</code> 和 <code>**max.poll.interval.ms**</code> 避免误判离线触发 Rebalance。</p>
</li>
<li><p><strong>排查下游依赖。</strong></p>
</li>
</ul>
<h3 id="kafka主要应用场景：异步、削峰、解耦"><a href="#kafka主要应用场景：异步、削峰、解耦" class="headerlink" title="kafka主要应用场景：异步、削峰、解耦"></a>kafka主要应用场景：异步、削峰、解耦</h3><p>异步：缩短响应时间</p>
<p>实际应用</p>
<p>削峰：</p>
<p>解耦：</p>
<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><ol>
<li>服务注册发现AP与CP架构对比</li>
<li>熔断降级策略（滑动窗口实现）</li>
<li>分布式配置中心推拉模式对比</li>
<li>灰度发布实现方案</li>
<li>分布式链路追踪原理（Span树）</li>
<li>Seata AT模式实现原理</li>
<li>接口性能突增的限流策略</li>
<li>如何设计服务治理平台？</li>
</ol>
<h1 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h1><h2 id="什么是CAP"><a href="#什么是CAP" class="headerlink" title="什么是CAP"></a>什么是CAP</h2><p>CAP定理是分布式系统设计中的一个核心原则，由计算机科学家Eric Brewer在2000年提出，后于2002年被证明。它指出，在存在<strong>网络分区（Partition Tolerance）</strong>的情况下，分布式系统无法同时满足以下三个特性：</p>
<ol>
<li><strong>一致性（Consistency）</strong><br>所有节点在同一时刻看到的数据完全相同。写入操作后，所有读取请求都会立即获得最新数据，不会出现数据不一致的情况。</li>
<li><strong>可用性（Availability）</strong><br>每个请求（无论读写）都能在合理时间内获得非错误响应，但不保证返回的数据是最新版本。即使部分节点故障，系统仍能正常响应。</li>
<li><strong>分区容忍性（Partition Tolerance）</strong><br>系统在网络分区（节点间通信中断，形成孤岛）时仍能继续运行。网络分区是分布式系统的客观现实，因此这一特性通常被视为必须支持的基础。</li>
</ol>
<img src="/post/be632046/image-20250505093121422.png" class="" title="image-20250505093121422">

<h2 id="什么是BASE"><a href="#什么是BASE" class="headerlink" title="什么是BASE"></a>什么是BASE</h2><p>BASE 是基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语的缩写。</p>
<p>BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>
<p><strong>基本可用</strong></p>
<p>指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。</p>
<p>例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。</p>
<p><strong>软状态</strong></p>
<p>指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在时延。</p>
<p><strong>最终一致性</strong></p>
<p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。</p>
<p>ACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。</p>
<p>在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用。</p>
<ol>
<li>分布式ID生成方案（雪花算法优化）</li>
<li>一致性Hash算法虚拟节点设计</li>
<li>分布式锁的三种实现方式对比</li>
<li>分布式Session解决方案</li>
<li>如何实现最终一致性（消息表+重试）</li>
<li>分库分表后分页查询方案</li>
<li>分布式事务最大努力通知型实现</li>
<li>数据同步方案（canal+MQ）</li>
<li>高并发下单系统设计（库存扣减）</li>
<li>分布式缓存更新策略（Cache Aside）</li>
<li>分布式系统时钟同步问题</li>
<li>脑裂问题解决方案</li>
</ol>
<h1 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h1><ol>
<li>设计微信朋友圈的存储架构</li>
<li>短链系统如何实现高并发写入？</li>
<li>分布式唯一ID生成方案（Snowflake优化）</li>
<li>如何设计一个分布式定时任务系统？</li>
<li>实现跨数据中心的数据同步方案</li>
<li>设计支持千万级用户的推送系统</li>
<li>微博热搜榜实时计算架构设计</li>
<li>电商库存扣减的防超卖方案</li>
<li>多级缓存架构设计（本地缓存+Redis+JVM）</li>
<li>设计支持PB级数据的日志分析系统</li>
<li>实现一个分布式配置中心</li>
<li>设计支持动态扩容的分库分表方案</li>
<li>如何设计API网关的限流熔断功能？</li>
<li>实时聊天系统的消息可靠投递方案</li>
<li>设计支持版本回滚的配置管理系统</li>
<li>实现跨语言服务调用（Thrift&#x2F;gRPC选型）</li>
<li>设计支持弹性伸缩的微服务架构</li>
<li>实现分布式Session一致性方案</li>
<li>设计一个高性能的日志采集系统</li>
<li>如何设计可追溯的操作日志系统？</li>
</ol>
<h1 id="云原生与容器化"><a href="#云原生与容器化" class="headerlink" title="云原生与容器化"></a>云原生与容器化</h1><ol>
<li>Kubernetes Pod调度策略（亲和性&#x2F;反亲和性）</li>
<li>Service Mesh中Sidecar模式的工作原理</li>
<li>Docker镜像分层原理与优化技巧</li>
<li>如何实现K8s集群的蓝绿发布？</li>
<li>Ingress与LoadBalancer的使用场景对比</li>
<li>容器网络模型（CNI）的实现原理</li>
<li>K8s中ConfigMap的热更新方案</li>
<li>如何排查容器内Java应用内存泄漏？</li>
<li>HPA自动扩缩容的指标采集方案</li>
<li>容器安全扫描与漏洞管理方案</li>
<li>有状态服务在K8s中的部署实践</li>
<li>如何实现跨集群的服务发现？</li>
<li>K8s中PV&#x2F;PVC的动态供给实现</li>
<li>容器日志收集的EFK架构实践</li>
<li>如何设计多租户的K8s集群？</li>
<li>Serverless冷启动优化方案</li>
<li>K8s中Pod的优雅终止流程</li>
<li>容器逃逸攻击的原理与防御</li>
<li>如何实现K8s集群的灾备方案？</li>
<li>基于Prometheus的自定义监控指标开发</li>
</ol>
<h1 id="架构设计模式"><a href="#架构设计模式" class="headerlink" title="架构设计模式"></a>架构设计模式</h1><ol>
<li>如何实现熔断器模式（Circuit Breaker）？</li>
<li>CQRS模式在电商系统中的应用</li>
<li>事件溯源（Event Sourcing）的优缺点分析</li>
<li>Sidecar模式在服务治理中的应用</li>
<li>网关模式中的路由策略设计</li>
<li>防腐层（Anti-Corruption Layer）设计实践</li>
<li>领域驱动设计（DDD）中的聚合根设计</li>
<li>重试模式中的指数退避算法实现</li>
<li>前端的后端模式（BFF）适用场景</li>
<li>分片模式（Sharding）的数据迁移方案</li>
<li>管道过滤器模式在ETL中的应用</li>
<li>物化视图模式优化查询性能案例</li>
<li>策略模式在支付渠道选择中的应用</li>
<li>观察者模式实现配置动态更新</li>
<li>代理模式在缓存穿透防护中的应用</li>
<li>工厂方法模式在连接池创建中的应用</li>
<li>装饰器模式实现API限流功能</li>
<li>状态模式在订单状态流转中的应用</li>
<li>组合模式实现权限树结构设计</li>
<li>模板方法模式在事务管理中的应用</li>
</ol>
<h1 id="工程实践与软技能"><a href="#工程实践与软技能" class="headerlink" title="工程实践与软技能"></a>工程实践与软技能</h1><ol>
<li>Git大型二进制文件存储优化方案</li>
<li>线上故障的标准化处理流程（SOP）</li>
<li>多团队协作中的接口版本管理方案</li>
<li>如何推动团队落地代码规范？</li>
<li>技术方案文档的撰写要点（含示例）</li>
<li>性能压测中的拐点分析方法</li>
<li>灰度发布中的流量染色方案</li>
<li>如何设计可观测性体系（Metrics&#x2F;Logs&#x2F;Traces）</li>
<li>研发流程中的流水线优化（CI&#x2F;CD）</li>
<li>技术选型的多维评估模型</li>
<li>遗留系统改造的渐进式方案</li>
<li>如何设计灾备演练方案？</li>
<li>容量规划中的峰值估算方法</li>
<li>生产环境调试的合规性方案</li>
<li>技术方案评审的常见陷阱</li>
<li>如何构建开发者体验（DX）体系？</li>
<li>技术TL的跨团队协作技巧</li>
<li>技术决策的沟通与推进策略</li>
</ol>
<h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h1><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ol>
<li>用户态与内核态切换的开销来源？</li>
<li>进程间通信IPC的5种方式对比</li>
<li>虚拟内存与物理内存映射原理（页表寻址）</li>
<li>死锁的必要条件及银行家算法实现</li>
<li>自旋锁与互斥锁的使用场景差异</li>
<li>零拷贝技术实现原理（sendfile&#x2F;mmap）</li>
<li>孤儿进程与僵尸进程的区别及处理</li>
<li>CPU软中断与硬中断处理机制</li>
<li>如何用top命令分析CPU负载异常？</li>
<li>内存泄漏与内存溢出的定位方法</li>
<li>大页内存（HugePage）优化原理</li>
<li>协程与线程的调度效率差异</li>
<li>文件描述符（fd）耗尽如何处理？</li>
<li>CPU缓存行伪共享问题解决方案</li>
<li>NUMA架构下的性能调优要点</li>
<li>系统调用过程详解（int 0x80&#x2F;syscall）</li>
<li>实时操作系统与非实时系统的调度差异</li>
<li>容器与虚拟机的资源隔离原理对比</li>
<li>如何实现一个简单的线程池？</li>
<li>系统平均负载（Load Average）的深层含义</li>
</ol>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ol>
<li>TCP三次握手与四次挥手的状态变迁图</li>
<li>TIME_WAIT状态过多如何优化？</li>
<li>HTTPS双向认证流程与中间人攻击防范</li>
<li>QUIC协议如何解决队头阻塞问题？</li>
<li>TCP拥塞控制算法（CUBIC&#x2F;BBR）</li>
<li>HTTP&#x2F;2多路复用与队头阻塞解决方案</li>
<li>Websocket握手协议与心跳机制实现</li>
<li>DNS解析过程（递归查询与迭代查询）</li>
<li>CDN动态加速与静态加速技术原理</li>
<li>如何设计一个高并发连接的服务端？</li>
<li>长连接保活策略（TCP Keepalive vs 应用层心跳）</li>
<li>网络抓包分析实战（Wireshark过滤技巧）</li>
<li>单机百万连接的实现与优化</li>
<li>HTTP Range请求与断点续传实现</li>
<li>5层协议栈中每层的典型设备</li>
<li>VLAN与VXLAN的区别及使用场景</li>
<li>如何实现UDP可靠传输？</li>
<li>MTU与MSS的关系及分片问题</li>
<li>SYN Flood攻击原理与防御方案</li>
<li>TLS1.3相比1.2的核心改进点</li>
</ol>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ol>
<li>HTTPS握手过程优化策略</li>
<li>零拷贝技术实现原理</li>
<li>百万连接服务器架构设计</li>
<li>线上CPU飙高排查流程</li>
<li>设计一个短链系统</li>
<li>接口性能优化全链路方案</li>
<li>海量数据判重方案（布隆过滤器）</li>
<li>如何设计秒杀系统？</li>
<li>大型项目代码规范落地实践</li>
<li>线上问题排查工具箱（arthas+prometheus）</li>
</ol>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/8eda3648.html" rel="prev" title="Redis笔记">
                  <i class="fa fa-angle-left"></i> Redis笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/ee5ab589.html" rel="next" title="SQL进阶教程">
                  SQL进阶教程 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa-regular fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder"></span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Word count total">90k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">5:27</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>

  <script class="next-config" data-name="wavedrom" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/wavedrom.min.js","integrity":"sha256-INLAoJc6quTNfiMWkGZniYO2cxE8mHpddnLow1m6RFs="}}</script>
  <script class="next-config" data-name="wavedrom_skin" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/skins/default.js","integrity":"sha256-fduc/Zszk5ezWws2uInY/ALWVmIrmV6VTgXbsYSReFI="}}</script>
  <script src="/js/third-party/tags/wavedrom.js"></script>




  





</body>
</html>
