<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"timewait7.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":true,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="新特性Java 8Lambda 表达式12345678910111213&#x2F;&#x2F; 传统方式Runnable r1 &#x3D; new Runnable() &#123;    @Override    public void run() &#123;        System.out.println(&quot;Runnable 1&quot;);    &#125;&#125;;&#x2F;&#x2F; Lambda 方式R">
<meta property="og:type" content="article">
<meta property="og:title" content="学习&amp;面试-Java">
<meta property="og:url" content="http://timewait7.github.io/post/7992e236.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="新特性Java 8Lambda 表达式12345678910111213&#x2F;&#x2F; 传统方式Runnable r1 &#x3D; new Runnable() &#123;    @Override    public void run() &#123;        System.out.println(&quot;Runnable 1&quot;);    &#125;&#125;;&#x2F;&#x2F; Lambda 方式R">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://timewait7.github.io/post/7992e236/image-20250720163023390.png">
<meta property="og:image" content="http://timewait7.github.io/post/7992e236/image-20250725195316321.png">
<meta property="og:image" content="http://timewait7.github.io/post/7992e236/image-20250807001016383.png">
<meta property="og:image" content="http://timewait7.github.io/post/7992e236/image-20250725210437363.png">
<meta property="og:image" content="http://timewait7.github.io/post/7992e236/image-20250725203542235.png">
<meta property="article:published_time" content="2025-07-26T11:19:10.000Z">
<meta property="article:modified_time" content="2025-08-26T00:13:06.906Z">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://timewait7.github.io/post/7992e236/image-20250720163023390.png">


<link rel="canonical" href="http://timewait7.github.io/post/7992e236.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://timewait7.github.io/post/7992e236.html","path":"post/7992e236.html","title":"学习&面试-Java"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>学习&面试-Java | Hexo</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-archives"><a href="/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="Searching..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.</span> <span class="nav-text">新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-8"><span class="nav-number">1.1.</span> <span class="nav-text">Java 8</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.1.1.</span> <span class="nav-text">Lambda 表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.1.2.</span> <span class="nav-text">函数式接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="nav-number">1.1.3.</span> <span class="nav-text">方法引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.4.</span> <span class="nav-text">默认方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Stream-API"><span class="nav-number">1.1.5.</span> <span class="nav-text">Stream API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Optional-%E7%B1%BB"><span class="nav-number">1.1.6.</span> <span class="nav-text">Optional 类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4-API"><span class="nav-number">1.1.7.</span> <span class="nav-text">新的日期时间 API</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-11"><span class="nav-number">1.2.</span> <span class="nav-text">Java 11</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%E5%A2%9E%E5%BC%BA"><span class="nav-number">1.2.1.</span> <span class="nav-text">局部变量类型推断增强</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B0%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.2.</span> <span class="nav-text">新的字符串方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%87%86HTTP%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">1.2.3.</span> <span class="nav-text">标准HTTP客户端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E7%AE%80%E5%8C%96"><span class="nav-number">1.2.4.</span> <span class="nav-text">文件读写简化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E4%BE%BF%E6%8D%B7%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.5.</span> <span class="nav-text">集合转数组的便捷方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-17"><span class="nav-number">1.3.</span> <span class="nav-text">Java 17</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D-instanceof"><span class="nav-number">1.3.1.</span> <span class="nav-text">模式匹配 instanceof</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E5%9D%97"><span class="nav-number">1.3.2.</span> <span class="nav-text">文本块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8-API"><span class="nav-number">1.3.3.</span> <span class="nav-text">伪随机数生成器 API</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-21"><span class="nav-number">1.4.</span> <span class="nav-text">Java 21</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.4.1.</span> <span class="nav-text">虚拟线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91"><span class="nav-number">1.4.2.</span> <span class="nav-text">结构化并发</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="nav-number">2.</span> <span class="nav-text">Java基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80"><span class="nav-number">2.1.</span> <span class="nav-text">语法基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.1.1.</span> <span class="nav-text">&#x3D;&#x3D;和equals的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#equals%E5%92%8ChashCode%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%90%8C%E6%97%B6%E9%87%8D%E5%86%99"><span class="nav-number">2.1.2.</span> <span class="nav-text">equals和hashCode为什么要同时重写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.3.</span> <span class="nav-text">异常的层次结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">2.2.</span> <span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B3%9B%E5%9E%8B"><span class="nav-number">2.2.1.</span> <span class="nav-text">为什么需要泛型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="nav-number">2.2.2.</span> <span class="nav-text">什么是泛型擦除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E9%99%90%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.2.3.</span> <span class="nav-text">泛型的上下限及应用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">2.3.</span> <span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84"><span class="nav-number">2.3.1.</span> <span class="nav-text">什么是反射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84-Class-%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.3.2.</span> <span class="nav-text">如何获取一个类的 Class 对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="nav-number">2.3.3.</span> <span class="nav-text">如何通过反射创建一个类的实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Class-forName-%E5%92%8C-ClassLoader-loadClass-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.3.4.</span> <span class="nav-text">Class.forName() 和 ClassLoader.loadClass() 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%B0%84%E7%A0%B4%E5%9D%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.3.5.</span> <span class="nav-text">如何防止反射破坏单例模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">2.3.6.</span> <span class="nav-text">动态代理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E9%9B%86%E5%90%88"><span class="nav-number">3.</span> <span class="nav-text">Java集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-number">3.1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-fail-fast-%E6%9C%BA%E5%88%B6"><span class="nav-number">3.1.1.</span> <span class="nav-text">什么是 fail-fast 机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fail-fast-%E5%92%8C-fail-safe-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.1.2.</span> <span class="nav-text">fail-fast 和 fail-safe 的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List"><span class="nav-number">3.2.</span> <span class="nav-text">List</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="nav-number">3.2.1.</span> <span class="nav-text">ArrayList的扩容机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set"><span class="nav-number">3.3.</span> <span class="nav-text">Set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map"><span class="nav-number">3.4.</span> <span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">3.4.1.</span> <span class="nav-text">HashMap 的实现原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-IO"><span class="nav-number">4.</span> <span class="nav-text">Java IO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.1.</span> <span class="nav-text">字节流与字符流的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BIO%E3%80%81NIO%E3%80%81AIO%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.</span> <span class="nav-text">BIO、NIO、AIO的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NIO-%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="nav-number">4.3.</span> <span class="nav-text">NIO 三大核心组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E5%A4%A7IO%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.4.</span> <span class="nav-text">五大IO模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reactor%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.5.</span> <span class="nav-text">Reactor模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#select%E3%80%81poll%E3%80%81epoll%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.6.</span> <span class="nav-text">select、poll、epoll的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%B9%B6%E5%8F%91"><span class="nav-number">5.</span> <span class="nav-text">Java并发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">5.1.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%85%B3%E9%94%AE%E5%8F%82%E6%95%B0"><span class="nav-number">5.1.1.</span> <span class="nav-text">线程池关键参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="nav-number">5.1.2.</span> <span class="nav-text">常见的拒绝策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4%E5%88%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">5.1.3.</span> <span class="nav-text">任务提交到线程池的工作流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shutdown-%E5%92%8CshutdownNow-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">5.1.4.</span> <span class="nav-text">shutdown()和shutdownNow()有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84execute-%E5%92%8Csubmit%EF%BC%88%EF%BC%89%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">5.1.5.</span> <span class="nav-text">线程池的execute()和submit（）有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="nav-number">5.1.6.</span> <span class="nav-text">线程池异常的处理方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%A4%BA%E4%BE%8B"><span class="nav-number">5.1.7.</span> <span class="nav-text">线程池示例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86-%E5%8F%AF%E6%89%A9%E5%AE%B9%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E6%97%A0%E7%95%8C-%E6%9C%89%E7%95%8C%E9%98%9F%E5%88%97"><span class="nav-number">5.1.7.1.</span> <span class="nav-text">批量数据处理 (可扩容线程池 + 无界&#x2F;有界队列)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">5.2.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">5.2.1.</span> <span class="nav-text">synchronized 实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReentrantLock-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">5.2.2.</span> <span class="nav-text">ReentrantLock 实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReentrantLock-%E4%B8%8E-synchronized-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.2.3.</span> <span class="nav-text">ReentrantLock 与 synchronized 的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">5.3.</span> <span class="nav-text">ThreadLocal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JUC%E9%9B%86%E5%90%88"><span class="nav-number">5.4.</span> <span class="nav-text">JUC集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentHashMap-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">5.4.1.</span> <span class="nav-text">ConcurrentHashMap 的实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-ConcurrentHashMap-%E6%AF%94-Hashtable-%E6%95%88%E7%8E%87%E9%AB%98"><span class="nav-number">5.4.2.</span> <span class="nav-text">为什么 ConcurrentHashMap 比 Hashtable 效率高</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="nav-number">5.5.</span> <span class="nav-text">异步编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CompletableFuture%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="nav-number">5.5.1.</span> <span class="nav-text">CompletableFuture的原理与应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CompletableFuture-%E5%92%8C%E4%BC%A0%E7%BB%9F%E7%9A%84-Future-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">5.5.2.</span> <span class="nav-text">CompletableFuture 和传统的 Future 有什么区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM"><span class="nav-number">6.</span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="nav-number">6.1.</span> <span class="nav-text">内存区域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-number">6.1.1.</span> <span class="nav-text">JVM内存结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-number">6.2.</span> <span class="nav-text">类加载机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-number">6.3.</span> <span class="nav-text">垃圾收集算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98"><span class="nav-number">6.4.</span> <span class="nav-text">性能监控与调优</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="nav-number">6.5.</span> <span class="nav-text">类加载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%E4%BC%9A%E8%A7%A6%E5%8F%91%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="nav-number">6.5.1.</span> <span class="nav-text">哪些场景会触发类的加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Class-forName-%E5%92%8CClassLoader-loadClass-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">6.5.2.</span> <span class="nav-text">Class.forName()和ClassLoader.loadClass()有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">6.5.3.</span> <span class="nav-text">类加载器的层次结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.5.4.</span> <span class="nav-text">什么是双亲委派模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#loadClass-%E5%92%8C-findClass-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">6.5.5.</span> <span class="nav-text">loadClass 和 findClass() 有什么区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-number">6.6.</span> <span class="nav-text">内存结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM-%E7%9A%84%E6%96%B0%E7%94%9F%E4%BB%A3%E5%88%92%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%86%E4%B8%BA%E4%B8%80%E4%B8%AA-Eden-%E5%8C%BA%E5%92%8C%E4%B8%A4%E4%B8%AA-Survivor-%E5%8C%BA"><span class="nav-number">6.6.1.</span> <span class="nav-text">JVM 的新生代划为什么分为一个 Eden 区和两个 Survivor 区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">6.6.2.</span> <span class="nav-text">运行时常量池和字符串常量池有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String-s-new-String-a-new-String-a-%E4%B8%80%E5%85%B1%E5%88%9B%E5%BB%BA%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="nav-number">6.6.3.</span> <span class="nav-text">String s &#x3D; new String(&quot;a&quot;) + new String(&quot;a&quot;) 一共创建几个对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E8%A7%A6%E5%8F%91StackOverflowError%E5%92%8COutOfMemoryError"><span class="nav-number">6.6.4.</span> <span class="nav-text">什么情况下会触发StackOverflowError和OutOfMemoryError</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B0%B8%E4%B9%85%E4%BB%A3%E5%92%8C%E5%85%83%E7%A9%BA%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.6.5.</span> <span class="nav-text">永久代和元空间的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E6%98%AF%E6%80%8E%E4%B9%88%E7%BB%86%E5%88%86%E7%9A%84"><span class="nav-number">6.6.6.</span> <span class="nav-text">堆内存是怎么细分的</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="nav-number">6.7.</span> <span class="nav-text">内存溢出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98"><span class="nav-number">6.7.1.</span> <span class="nav-text">如何定位内存溢出问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">6.8.</span> <span class="nav-text">垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E5%9B%9E%E6%94%B6"><span class="nav-number">6.8.1.</span> <span class="nav-text">如何判断一个对象是否可回收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.8.2.</span> <span class="nav-text">4种引用类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CMS%E6%94%B6%E9%9B%86%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">6.8.3.</span> <span class="nav-text">CMS收集器工作原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#G1%E6%94%B6%E9%9B%86%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">6.8.4.</span> <span class="nav-text">G1收集器工作原理</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/">
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="Back to top">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://timewait7.github.io/post/7992e236.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="学习&面试-Java | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          学习&面试-Java
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-07-26 19:19:10" itemprop="dateCreated datePublished" datetime="2025-07-26T19:19:10+08:00">2025-07-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>23k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>1:25</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><h3 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8"></a>Java 8</h3><h4 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统方式</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Runnable 1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda 方式</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">r2</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Runnable 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">r1.run();  <span class="comment">// 输出: Runnable 1</span></span><br><span class="line">r2.run();  <span class="comment">// 输出: Runnable 2</span></span><br></pre></td></tr></table></figure>

<h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>只有一个抽象方法的接口，可用 <code>@FunctionalInterface</code> 注解标记</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MathOperation</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">operate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MathOperation</span> <span class="variable">add</span> <span class="operator">=</span> (a, b) -&gt; a + b;</span><br><span class="line">        System.out.println(add.operate(<span class="number">5</span>, <span class="number">3</span>));  <span class="comment">// 输出: 8</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>简化 Lambda 表达式，直接引用已有方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda 表达式</span></span><br><span class="line">names.forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法引用</span></span><br><span class="line">names.forEach(System.out::println);  <span class="comment">// 输出所有元素</span></span><br></pre></td></tr></table></figure>

<h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><p>在接口中提供默认实现，避免破坏现有实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一辆车!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">Vehicle</span> &#123;&#125;  <span class="comment">// 无需实现print方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Car</span>().print();  <span class="comment">// 输出: 我是一辆车!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h4><p>函数式处理集合数据（过滤、映射、归约等）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求所有偶数的平方和</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers.stream()</span><br><span class="line">        .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        .map(n -&gt; n * n)</span><br><span class="line">        .reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"></span><br><span class="line">System.out.println(sum);  <span class="comment">// 输出: 20 (2^2 + 4^2)</span></span><br></pre></td></tr></table></figure>

<h4 id="Optional-类"><a href="#Optional-类" class="headerlink" title="Optional 类"></a>Optional 类</h4><p>优雅处理 <code>null</code> 值，避免 <code>NullPointerException</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; name = Optional.ofNullable(getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存在时输出，不存在输出默认值</span></span><br><span class="line">System.out.println(name.orElse(<span class="string">&quot;Unknown&quot;</span>));  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全使用方法引用</span></span><br><span class="line">name.ifPresent(System.out::println);  </span><br><span class="line"></span><br><span class="line">String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Math.random() &gt; <span class="number">0.5</span> ? <span class="string">&quot;Alice&quot;</span> : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="新的日期时间-API"><a href="#新的日期时间-API" class="headerlink" title="新的日期时间 API"></a>新的日期时间 API</h4><p>解决旧 <code>java.util.Date</code> 线程安全问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前日期和时间</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">System.out.println(<span class="string">&quot;当前时间: &quot;</span> + now);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日期操作</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.of(<span class="number">2023</span>, Month.JANUARY, <span class="number">1</span>);</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">nextWeek</span> <span class="operator">=</span> date.plusWeeks(<span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;下周日期: &quot;</span> + nextWeek);  <span class="comment">// 2023-01-08</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算时间差</span></span><br><span class="line"><span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(LocalTime.NOON, LocalTime.now());</span><br><span class="line">System.out.println(<span class="string">&quot;距中午过去秒数: &quot;</span> + duration.getSeconds());</span><br></pre></td></tr></table></figure>

<h3 id="Java-11"><a href="#Java-11" class="headerlink" title="Java 11"></a>Java 11</h3><h4 id="局部变量类型推断增强"><a href="#局部变量类型推断增强" class="headerlink" title="局部变量类型推断增强"></a>局部变量类型推断增强</h4><p>允许在Lambda表达式中使用<code>var</code>声明参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaVarExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; names = List.of(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在Lambda中使用var声明参数</span></span><br><span class="line">        names.forEach((<span class="keyword">var</span> name) -&gt; System.out.println(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="新的字符串方法"><a href="#新的字符串方法" class="headerlink" title="新的字符串方法"></a>新的字符串方法</h4><p>新增<code>isBlank()</code>、<code>lines()</code>、<code>strip()</code>、<code>repeat()</code>等方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringMethodsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// isBlank(): 检查空或空白</span></span><br><span class="line">        System.out.println(<span class="string">&quot; &quot;</span>.isBlank()); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// lines(): 分割为行流</span></span><br><span class="line">        <span class="string">&quot;Line1\nLine2&quot;</span>.lines().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// strip(): 去除首尾空白（比trim()更智能）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;  Hello  &quot;</span>.strip()); <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// repeat(): 重复字符串</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Java&quot;</span>.repeat(<span class="number">3</span>)); <span class="comment">// &quot;JavaJavaJava&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="标准HTTP客户端"><a href="#标准HTTP客户端" class="headerlink" title="标准HTTP客户端"></a>标准HTTP客户端</h4><p>替代旧<code>HttpURLConnection</code>，支持HTTP&#x2F;2和WebSocket。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.http.HttpClient;</span><br><span class="line"><span class="keyword">import</span> java.net.http.HttpRequest;</span><br><span class="line"><span class="keyword">import</span> java.net.http.HttpResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpClientDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClient.newHttpClient();</span><br><span class="line">        <span class="type">HttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> HttpRequest.newBuilder()</span><br><span class="line">                .uri(URI.create(<span class="string">&quot;https://httpbin.org/get&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送同步请求</span></span><br><span class="line">        HttpResponse&lt;String&gt; response = </span><br><span class="line">            client.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;Status: &quot;</span> + response.statusCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;Body: &quot;</span> + response.body());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="文件读写简化"><a href="#文件读写简化" class="headerlink" title="文件读写简化"></a>文件读写简化</h4><p>新增<code>readString()</code>和<code>writeString()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReadWriteDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 写入文件</span></span><br><span class="line">        Files.writeString(path, <span class="string">&quot;Hello Java 11!&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读取文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> Files.readString(path);</span><br><span class="line">        System.out.println(content); <span class="comment">// &quot;Hello Java 11!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="集合转数组的便捷方法"><a href="#集合转数组的便捷方法" class="headerlink" title="集合转数组的便捷方法"></a>集合转数组的便捷方法</h4><p><code>Collection.toArray(IntFunction)</code>简化数组转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionToArrayDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 直接传入数组构造函数引用</span></span><br><span class="line">        String[] array = list.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (String s : array) &#123;</span><br><span class="line">            System.out.println(s); <span class="comment">// 输出A, B, C</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java-17"><a href="#Java-17" class="headerlink" title="Java 17"></a>Java 17</h3><h4 id="模式匹配-instanceof"><a href="#模式匹配-instanceof" class="headerlink" title="模式匹配 instanceof"></a>模式匹配 <code>instanceof</code></h4><p>简化类型检查和转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="string">&quot;Hello Java 17&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) obj;</span><br><span class="line">    System.out.println(s.toLowerCase());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法：自动类型转换</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">    System.out.println(s.toLowerCase()); <span class="comment">// 直接使用变量 s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="文本块"><a href="#文本块" class="headerlink" title="文本块"></a>文本块</h4><p>简化多行字符串处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧写法（需手动换行和转义）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">oldHtml</span> <span class="operator">=</span> <span class="string">&quot;&lt;html&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;  &lt;body&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;     &lt;p&gt;Hello&lt;/p&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;  &lt;/body&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;/html&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法：文本块（自动保留格式）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">newHtml</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                &lt;html&gt;</span></span><br><span class="line"><span class="string">                  &lt;body&gt;</span></span><br><span class="line"><span class="string">                    &lt;p&gt;Hello Java 17&lt;/p&gt;</span></span><br><span class="line"><span class="string">                  &lt;/body&gt;</span></span><br><span class="line"><span class="string">                &lt;/html&gt;</span></span><br><span class="line"><span class="string">                &quot;&quot;&quot;</span>;</span><br><span class="line">System.out.println(newHtml);</span><br></pre></td></tr></table></figure>

<h4 id="伪随机数生成器-API"><a href="#伪随机数生成器-API" class="headerlink" title="伪随机数生成器 API"></a>伪随机数生成器 API</h4><p>统一随机数生成器接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.random.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 选择算法（如 L32X64MixRandom）</span></span><br><span class="line">        <span class="type">RandomGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> RandomGeneratorFactory.of(<span class="string">&quot;L32X64MixRandom&quot;</span>).create();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成随机数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">randomNum</span> <span class="operator">=</span> generator.nextInt(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Random: &quot;</span> + randomNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java-21"><a href="#Java-21" class="headerlink" title="Java 21"></a>Java 21</h3><h4 id="虚拟线程"><a href="#虚拟线程" class="headerlink" title="虚拟线程"></a>虚拟线程</h4><p>轻量级线程，显著提升并发性能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">var</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;</span><br><span class="line">    IntStream.range(<span class="number">0</span>, <span class="number">10_000</span>).forEach(i -&gt; </span><br><span class="line">        executor.submit(() -&gt; &#123;</span><br><span class="line">            Thread.sleep(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125; <span class="comment">// 自动等待所有线程结束</span></span><br></pre></td></tr></table></figure>

<h4 id="结构化并发"><a href="#结构化并发" class="headerlink" title="结构化并发"></a>结构化并发</h4><p>简化多线程任务管理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">var</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;</span><br><span class="line">    Future&lt;String&gt; user  = scope.fork(() -&gt; fetchUser());</span><br><span class="line">    Future&lt;Integer&gt; order = scope.fork(() -&gt; fetchOrder());</span><br><span class="line"></span><br><span class="line">    scope.join();          <span class="comment">// 等待所有任务</span></span><br><span class="line">    scope.throwIfFailed(); <span class="comment">// 异常传播</span></span><br><span class="line"></span><br><span class="line">    System.out.println(user.resultNow() + <span class="string">&quot;: &quot;</span> + order.resultNow());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><ul>
<li><strong>精通 Java 8+ 特性:</strong> Lambda 表达式、Stream API（并行流原理与陷阱）、Optional、新的日期时间 API、接口默认&#x2F;静态方法、方法引用等。理解其设计思想和内部机制。</li>
</ul>
<h3 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h3><h4 id="和equals的区别"><a href="#和equals的区别" class="headerlink" title="==和equals的区别"></a><code>==</code>和<code>equals</code>的区别</h4><p><code>==</code> 用于比较基本数据类型的值或对象引用的内存地址，<code>equals</code> 用户比较对象内容。</p>
<h4 id="equals和hashCode为什么要同时重写"><a href="#equals和hashCode为什么要同时重写" class="headerlink" title="equals和hashCode为什么要同时重写"></a><code>equals</code>和<code>hashCode</code>为什么要同时重写</h4><p><strong><code>Object</code>类的规范</strong>明确规定：如果两个对象通过<code>equals()</code>方法比较是相等的，那么它们的<code>hashCode()</code><strong>必须</strong>返回相同的值。</p>
<p>未重写的<code>hasoCode()</code>默认返回内存地址，如果只重写了<code>equals()</code>，两个对象<code>a</code>和<code>b</code>满足<code>a.equals(b) == true</code>，但<code>a.hashCode() != b.hashCode()</code>，基于哈希的集合如（<code>HashMap</code>, <code>HashSet</code>）会存储多个逻辑相等的对象。</p>
<p>因此重写<code>equals()</code>同时也要重写<code>hashCode()</code>，推荐实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(name, age); <span class="comment">// 包含所有equals中使用的字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="异常的层次结构"><a href="#异常的层次结构" class="headerlink" title="异常的层次结构"></a>异常的层次结构</h4><p><code>Throwable</code>：所有异常和错误的父类</p>
<p><code>Error</code>：<strong>系统级严重问题</strong>，应用程序通常无法恢复。如<code>OutOfMemoryError</code>、<code>StackOverflowError</code>：、<code>VirtualMachineError</code></p>
<p><code>Exception</code>：<strong>程序可处理的异常</strong>，分为两类：</p>
<ul>
<li><p><strong>Checked Exceptions（受检异常）</strong><br>编译器强制要求处理（必须<code>try-catch</code>或<code>throws</code>）<br>✅ <strong>典型代表</strong>：<code>IOException</code>、<code>SQLException</code>、<code>ClassNotFoundException</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须处理IOException的示例</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Files.readString(Path.of(<span class="string">&quot;file.txt&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123; <span class="comment">// 必须捕获</span></span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>RuntimeException</code>（运行时异常&#x2F;非受检异常）</strong><br>编译器不强制处理，通常由<strong>编程逻辑错误</strong>引起<br>⚠️ <strong>典型代表</strong>：<code>NullPointerException</code>、<code>IndexOutOfBoundsException</code>、<code>IllegalArgumentException</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可选的运行时异常处理</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  System.out.println(str.length()); <span class="comment">// 抛出NullPointerException</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// 非强制捕获</span></span><br><span class="line">  System.out.println(<span class="string">&quot;逻辑错误！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<img src="/post/7992e236/image-20250720163023390.png" class="" title="image-20250720163023390">



<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="为什么需要泛型"><a href="#为什么需要泛型" class="headerlink" title="为什么需要泛型"></a>为什么需要泛型</h4><p>泛型（Generics）是现代编程语言中一项极其重要的特性，它的出现主要是为了解决<strong>类型安全</strong>、<strong>代码复用</strong>两大问题。</p>
<p>📍 1. <strong>类型安全（Type Safety）</strong></p>
<ul>
<li><strong>问题：</strong> 在没有泛型之前，容器类可以存放任何类型的对象。当你从容器中取出对象时，你需要进行强制类型转换 (<code>(String) myList.get(0)</code>)。</li>
<li><strong>风险：</strong> 如果容器里不小心放入了错误的类型（比如你期望是 <code>String</code>，但实际放入了 <code>Integer</code>），这个错误在<strong>编译时不会被发现</strong>，只有在<strong>运行时进行强制转换时</strong>才会抛出 <code>ClassCastException</code>，导致程序崩溃。</li>
<li><strong>泛型解决方案：</strong> 泛型允许你在<strong>声明</strong>容器时就指定它只能存放特定类型（如 <code>List&lt;String&gt;</code>）。编译器会在<strong>编译时</strong>严格检查你放入容器的对象类型是否匹配。如果尝试放入错误类型，编译器会直接报错，阻止潜在的类型错误运行到生产环境。使用泛型容器（如 <code>List&lt;String&gt;</code>）后，当你从容器中获取元素时（如 <code>String s = myList.get(0);</code>），<strong>编译器会自动知道返回的是 <code>String</code> 类型，不需要任何强制转换</strong>。代码更简洁，更安全。</li>
</ul>
<p>♻ 2. <strong>代码复用（Code Reuse）</strong></p>
<ul>
<li><strong>问题：</strong> 编写一个算法（比如排序、搜索、比较），你希望它能作用于多种不同类型的对象（整数、字符串、自定义对象等）。没有泛型时，你需要为每种类型重写算法，或者使用 <code>Object</code> 并伴随类型检查和转换。</li>
<li><strong>泛型解决方案：</strong> 泛型允许你编写<strong>类型无关的算法</strong>。你可以定义一个操作在类型参数 <code>T</code> 上的方法或类（例如 <code>public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code>）。只要类型 <code>T</code> 满足算法所需的基本条件（比如实现了 <code>Comparable</code> 接口），同一个算法代码就可以安全地应用于各种不同的数据类型。</li>
</ul>
<h4 id="什么是泛型擦除"><a href="#什么是泛型擦除" class="headerlink" title="什么是泛型擦除"></a>什么是泛型擦除</h4><p>泛型擦除（Type Erasure）是 <strong>Java 泛型实现的核心机制</strong>，它指编译器在编译阶段<strong>移除所有泛型类型信息</strong>，将其替换为原始类型（Raw Type）或边界类型（Bound Type），并在必要时插入强制类型转换。这一设计主要是为了<strong>兼容旧版本的 Java（JDK 5 之前）</strong>，确保泛型代码能与非泛型遗留代码互操作。</p>
<p><strong>一、泛型擦除的核心规则</strong></p>
<ol>
<li><p><strong>类型参数替换为边界类型</strong></p>
<ul>
<li>若类型参数有上限（如 <code>&lt;T extends Number&gt;</code>），<code>T</code> 被替换为<strong>边界类型</strong>（<code>Number</code>）。</li>
<li>若无明确上限（如 <code>&lt;T&gt;</code>），<code>T</code> 被替换为 <code>Object</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123; <span class="built_in">this</span>.value = value; &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后（擦除后）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object value;         <span class="comment">// T → Object</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Object value)</span> &#123; <span class="built_in">this</span>.value = value; &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> value; &#125; <span class="comment">// 返回 Object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在调用处插入强制类型转换</strong><br>编译器在<strong>使用泛型的地方</strong>自动添加类型转换代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line">Box&lt;String&gt; box = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();</span><br><span class="line">box.set(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> box.get(); <span class="comment">// 无需显式转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后（擦除后）</span></span><br><span class="line"><span class="type">Box</span> <span class="variable">box</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Box</span>();</span><br><span class="line">box.set(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) box.get(); <span class="comment">// 编译器插入 (String) 强制转换</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>保证类型安全的桥接方法（Bridge Methods）</strong><br>当泛型类继承或实现接口时，编译器会生成<strong>合成方法</strong>确保多态性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T other)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String other)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后（擦除后）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="comment">// 编译器生成的桥接方法（保持多态）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object other)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> compareTo((String) other); <span class="comment">// 调用实际方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际编写的泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String other)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>二、泛型擦除导致的关键限制</strong></p>
<ol>
<li><p><strong>无法使用基本类型作为类型参数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 编译错误！不能使用 int</span></span><br><span class="line">List&lt;<span class="type">int</span>&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br><span class="line"><span class="comment">// 必须使用包装类</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>无法获取泛型具体类型的 <code>Class</code> 对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// ❌ 编译错误！List&lt;String&gt;.class 不存在</span></span><br><span class="line">Class&lt;?&gt; clazz = list.getClass(); </span><br><span class="line"><span class="comment">// 输出：java.util.ArrayList（无法得知是 List&lt;String&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>无法创建泛型数组</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 编译错误！</span></span><br><span class="line">T[] array = <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">10</span>]; </span><br><span class="line"><span class="comment">// 替代方案：使用反射或 ArrayList</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>方法签名冲突（重载失效）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 编译错误！擦除后都是 void print(List list)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;String&gt; list)</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;Integer&gt; list)</span> &#123; ... </span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>三、如何绕过擦除的限制？</strong></p>
<ol>
<li><p><strong>类型令牌（Type Token）</strong><br>通过传递 <code>Class&lt;T&gt;</code> 对象保留类型信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Box</span><span class="params">(Class&lt;T&gt; type)</span> &#123; <span class="built_in">this</span>.type = type; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInstance</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type.isInstance(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>反射 API（Reflection）</strong><br>运行时获取泛型参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取泛型类的泛型类型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassGenericReflection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建具有具体类型的Box实例</span></span><br><span class="line">        Box&lt;String&gt; stringBox = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;String&gt;() &#123;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取实际泛型参数</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Type</span> <span class="variable">genericSuperclass</span> <span class="operator">=</span> stringBox.getClass().getGenericSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (genericSuperclass <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) genericSuperclass;</span><br><span class="line">            <span class="keyword">final</span> Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">            <span class="keyword">if</span> (actualTypeArguments.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;泛型参数: &quot;</span> + actualTypeArguments[<span class="number">0</span>]); <span class="comment">// 输出: class java.lang.String</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取泛型字段的泛型类型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldGenericReflection</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Box&lt;String&gt; stringBox;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> FieldGenericReflection.class.getDeclaredField(<span class="string">&quot;stringBox&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Type</span> <span class="variable">genericType</span> <span class="operator">=</span> field.getGenericType();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (genericType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) genericType;</span><br><span class="line">            <span class="keyword">final</span> Type[] arguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">            <span class="keyword">if</span> (arguments.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Box的泛型参数: &quot;</span> + arguments[<span class="number">0</span>]); <span class="comment">// class java.lang.String</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取泛型方法形参的类型参数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParameterGenericReflection</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(List&lt;Box&lt;String&gt;&gt; boxes)</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> Processor.class.getMethod(<span class="string">&quot;process&quot;</span>, List.class);</span><br><span class="line">        <span class="keyword">final</span> Type[] parameterTypes = method.getGenericParameterTypes();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Type parameterType : parameterTypes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parameterType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">ParameterizedType</span> <span class="variable">pt</span> <span class="operator">=</span> (ParameterizedType) parameterType;</span><br><span class="line">                System.out.println(<span class="string">&quot;参数类型：&quot;</span> + pt.getRawType());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> Type[] typeArguments = pt.getActualTypeArguments();</span><br><span class="line">                <span class="keyword">for</span> (Type typeArgument : typeArguments) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (typeArgument <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="type">ParameterizedType</span> <span class="variable">nestedPt</span> <span class="operator">=</span> (ParameterizedType) typeArgument;</span><br><span class="line">                        System.out.println(<span class="string">&quot;嵌套类型：&quot;</span> + nestedPt.getRawType());</span><br><span class="line">                        <span class="keyword">final</span> Type[] nestedTypeArguments = nestedPt.getActualTypeArguments();</span><br><span class="line">                        <span class="keyword">if</span> (nestedTypeArguments.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;嵌套泛型参数：&quot;</span> + nestedTypeArguments[<span class="number">0</span>]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取泛型方法返回值的类型参数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReturnTypeGenericReflection</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Integer&gt; <span class="title function_">getMappings</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> ReturnTypeGenericReflection.class.getMethod(<span class="string">&quot;getMappings&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Type</span> <span class="variable">returnType</span> <span class="operator">=</span> method.getGenericReturnType();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (returnType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) returnType;</span><br><span class="line">            <span class="keyword">final</span> Type[] typeArguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; typeArguments.length; i++) &#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">&quot;第%d个泛型参数：%s&quot;</span>, i + <span class="number">1</span>, typeArguments[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="泛型的上下限及应用场景"><a href="#泛型的上下限及应用场景" class="headerlink" title="泛型的上下限及应用场景"></a>泛型的上下限及应用场景</h4><p>泛型的<strong>上限（Upper Bound）</strong> 和<strong>下限（Lower Bound）</strong> 是用于<strong>约束类型参数范围</strong>的关键机制，主要解决泛型代码需要<strong>限制可接受的类型</strong>或<strong>支持更灵活的子类型关系</strong>的问题。以下是详细解释：</p>
<p><strong>一、泛型的上限（Upper Bound）</strong></p>
<p>定义：限制类型参数必须是<strong>某个类&#x2F;接口本身或其子类</strong>。<br>语法：<code>&lt;T extends 类/接口&gt;</code> 或 <code>&lt;? extends 类/接口&gt;</code>（通配符形式）。</p>
<p><strong>核心作用</strong></p>
<ol>
<li><p><strong>确保类型具备某些能力</strong><br>要求类型 <code>T</code> 必须实现特定接口（如 <code>Comparable</code>）或继承特定类，从而在泛型代码中安全调用其方法。<br><strong>示例</strong>：要求类型必须可比较</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T 必须是实现了 Comparable 接口的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; T <span class="title function_">max</span><span class="params">(T a, T b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.compareTo(b) &gt; <span class="number">0</span> ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可安全调用 a.compareTo(b)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安全访问数据（只读不写）</strong><br>在通配符 <code>? extends T</code> 中，表示“某个 <code>T</code> 的子类型”，此时容器<strong>只能读取数据</strong>（返回 <code>T</code> 类型），<strong>不能写入数据</strong>（除 <code>null</code> 外）。<br><strong>示例</strong>：安全读取数字集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">printNumbers</span><span class="params">(List&lt;? extends Number&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Number n : list) &#123;</span><br><span class="line">        System.out.println(n);  <span class="comment">// ✅ 可读</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// list.add(10); ❌ 编译错误！无法写入（除 null 外）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>典型场景</strong></p>
<ul>
<li>定义泛型类&#x2F;方法时，约束类型参数的能力（如 <code>T extends Runnable</code>）。</li>
<li>作为方法参数时，安全接收<strong>某种子类型的集合</strong>（生产者场景）。</li>
</ul>
<p><strong>二、泛型的下限（Lower Bound）</strong></p>
<p>定义：限制类型参数必须是<strong>某个类&#x2F;接口本身或其父类</strong>。<br>语法：<code>&lt;? super 类/接口&gt;</code>（仅通配符形式）。</p>
<p><strong>核心作用</strong></p>
<ol>
<li><p><strong>支持安全写入数据</strong><br>表示“某个 <code>T</code> 的父类型”，此时容器<strong>可以写入 <code>T</code> 及其子类型对象</strong>，但读取时只能视为 <code>Object</code>。<br><strong>示例</strong>：向集合添加元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addNumbers</span><span class="params">(List&lt;? <span class="built_in">super</span> Integer&gt; list)</span> &#123;</span><br><span class="line">    list.add(<span class="number">10</span>);     <span class="comment">// ✅ 可写入 Integer</span></span><br><span class="line">    list.add(<span class="number">1000L</span>);  <span class="comment">// ❌ 错误！Long 不是 Integer 的子类</span></span><br><span class="line">    <span class="comment">// Object obj = list.get(0);  // 读取时只能视为 Object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>实现灵活的子类型兼容</strong><br>允许方法接收比预期更宽泛的容器（如需要 <code>List&lt;Number&gt;</code> 时，也可传入 <code>List&lt;Object&gt;</code>）。</p>
</li>
</ol>
<p><strong>典型场景</strong></p>
<ul>
<li><p>向泛型容器<strong>写入数据</strong>（消费者场景）。</p>
</li>
<li><p>配合 <code>Comparator</code> 等接口实现类型灵活的API：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可接收 Person 或其父类的 Comparator</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;Person&gt; list, Comparator&lt;? <span class="built_in">super</span> Person&gt; comparator)</span> &#123;</span><br><span class="line">    Collections.sort(list, comparator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>三、关键对比：<code>extends</code> vs <code>super</code></strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>上限 (<code>? extends T</code>)</strong></th>
<th align="left"><strong>下限 (<code>? super T</code>)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>类型范围</strong></td>
<td align="left"><code>T</code> 或其<strong>子类型</strong></td>
<td align="left"><code>T</code> 或其<strong>父类型</strong></td>
</tr>
<tr>
<td align="left"><strong>数据读取</strong></td>
<td align="left">✅ 返回 <code>T</code> 类型</td>
<td align="left">❌ 只能视为 <code>Object</code></td>
</tr>
<tr>
<td align="left"><strong>数据写入</strong></td>
<td align="left">❌ 禁止（除 <code>null</code>）</td>
<td align="left">✅ 可写入 <code>T</code> <strong>及其子类</strong></td>
</tr>
<tr>
<td align="left"><strong>设计意图</strong></td>
<td align="left"><strong>生产者</strong>（Producer）只提供数据</td>
<td align="left"><strong>消费者</strong>（Consumer）只消费数据</td>
</tr>
<tr>
<td align="left"><strong>经典口诀</strong></td>
<td align="left"><strong>PECS</strong> (Producer-Extends, Consumer-Super)</td>
<td align="left"></td>
</tr>
</tbody></table>
<p><strong>四、实际应用：PECS 原则</strong></p>
<p>在泛型编程中，遵循 <strong>PECS（Producer-Extends, Consumer-Super）</strong> 原则：</p>
<ul>
<li><strong>生产者（Producer）</strong>：产生 <code>T</code> 的对象 → 用 <code>&lt;? extends T&gt;</code></li>
<li><strong>消费者（Consumer）</strong>：消费 <code>T</code> 的对象 → 用 <code>&lt;? super T&gt;</code></li>
</ul>
<p><strong>示例</strong>：Java 集合工具类 <code>Collections.copy()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(</span></span><br><span class="line"><span class="params">    List&lt;? <span class="built_in">super</span> T&gt; dest,    // 消费者：写入目标集合</span></span><br><span class="line"><span class="params">    List&lt;? extends T&gt; src    // 生产者：读取源集合</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; src.size(); i++) &#123;</span><br><span class="line">        dest.set(i, src.get(i));  <span class="comment">// ✅ 安全读写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h4 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h4><p>在程序运行期间动态获取类或对象信息以及动态调用对象方法的功能称为 Java 的反射机制。</p>
<p><strong>优点：</strong>动态、灵活。IOC、AOP设计的基石。</p>
<p><strong>缺点：</strong>性能开销大、破坏封装、实现复杂。</p>
<p><strong>反射的实际应用场景</strong></p>
<ul>
<li><strong>框架开发：</strong> 是几乎所有 Java 框架的核心（如 Spring, Hibernate, MyBatis, JUnit）。<ul>
<li><strong>Spring IOC：</strong> 通过反射读取配置（XML 或注解），动态创建 Bean 实例，注入依赖。</li>
<li><strong>Spring AOP：</strong> 动态代理（JDK Proxy 或 CGLIB）底层依赖反射调用目标方法。</li>
<li><strong>Hibernate&#x2F;MyBatis：</strong> 将数据库结果集映射到 Java 对象时，通过反射设置对象的属性值。</li>
</ul>
</li>
<li><strong>注解处理：</strong> 在运行时通过反射读取类、方法、字段上的注解信息，并根据注解执行特定逻辑（如 JUnit 查找 <code>@Test</code> 方法）。</li>
<li><strong>动态代理：</strong> JDK 动态代理 (<code>java.lang.reflect.Proxy</code>) 的核心就是利用反射调用被代理对象的方法。</li>
<li><strong>通用工具库：</strong> 如 Apache Commons BeanUtils, Jackson&#x2F;Gson (JSON 序列化&#x2F;反序列化)，通过反射操作对象的属性。</li>
<li><strong>IDE 和开发工具：</strong> 代码提示、调试器、反编译工具等利用反射获取类的结构信息。</li>
</ul>
<h4 id="如何获取一个类的-Class-对象"><a href="#如何获取一个类的-Class-对象" class="headerlink" title="如何获取一个类的 Class 对象"></a>如何获取一个类的 <code>Class</code> 对象</h4><ol>
<li><code>Class clazz = instance.getClass();</code> (通过对象实例获取)</li>
<li><code>Class clazz = ClassName.class;</code> (通过类字面常量 <code>.class</code> 获取)</li>
<li><code>Class clazz = Class.forName(&quot;fully.qualified.ClassName&quot;);</code> (通过完整类名字符串获取，常用，可能抛出 <code>ClassNotFoundException</code>)</li>
<li>(对于基本类型和数组) <code>Class clazz = int.class;</code> &#x2F; <code>Class clazz = String[].class;</code></li>
</ol>
<h4 id="如何通过反射创建一个类的实例"><a href="#如何通过反射创建一个类的实例" class="headerlink" title="如何通过反射创建一个类的实例"></a>如何通过反射创建一个类的实例</h4><p><strong>使用 <code>Class.newInstance()</code>（已过时）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) clazz.newInstance(); <span class="comment">// 调用无参构造器</span></span><br></pre></td></tr></table></figure>

<p><strong>使用 <code>Constructor.newInstance()</code> (推荐)：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getConstructor(String.class, <span class="type">int</span>.class); <span class="comment">// 获取特定参数类型的构造器</span></span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) constructor.newInstance(<span class="string">&quot;arg1&quot;</span>, <span class="number">42</span>); <span class="comment">// 传入参数创建实例</span></span><br></pre></td></tr></table></figure>

<p><code>clazz.newInstance()</code>只能调用无参构造器，在 Java 9 开始被标记为 <code>@Deprecated(since=&quot;9&quot;)</code>，推荐使用 <code>Constructor.newInstance()</code>。</p>
<h4 id="Class-forName-和-ClassLoader-loadClass-的区别"><a href="#Class-forName-和-ClassLoader-loadClass-的区别" class="headerlink" title="Class.forName() 和 ClassLoader.loadClass() 的区别"></a><code>Class.forName()</code> 和 <code>ClassLoader.loadClass()</code> 的区别</h4><ul>
<li><code>Class.forName(String name)</code>：<ul>
<li>默认会触发类的<strong>加载、链接（验证、准备）、初始化</strong>（执行 <code>&lt;clinit&gt;</code> 静态初始化块）。</li>
<li>有一个重载方法 <code>Class.forName(String name, boolean initialize, ClassLoader loader)</code> 可以控制是否初始化 (<code>initialize</code>) 和指定类加载器 (<code>loader</code>)。</li>
</ul>
</li>
<li><code>ClassLoader.loadClass(String name)</code>：<ul>
<li>只触发类的<strong>加载</strong>和<strong>链接（验证、准备）</strong> 阶段，<strong>不会执行初始化</strong> (<code>&lt;clinit&gt;</code>)。只有首次主动使用时（如创建实例、访问静态字段&#x2F;方法）才会初始化。</li>
</ul>
</li>
</ul>
<h4 id="如何防止反射破坏单例模式"><a href="#如何防止反射破坏单例模式" class="headerlink" title="如何防止反射破坏单例模式"></a><strong>如何防止反射破坏单例模式</strong></h4><p><strong>使用枚举实现单例 (推荐)：</strong> 枚举的单例实现是《Effective Java》作者 Josh Bloch 强烈推荐的方式。JVM 从根本上保证了枚举类型的构造器只会被调用一次，且反射 API 被设计为<strong>不能通过反射创建枚举实例</strong>（<code>Constructor.newInstance()</code> 方法内部会检查并阻止）。这是最安全、简洁的方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE; <span class="comment">// 唯一的单例实例</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单例的业务方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Singleton instance is working...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单例的业务属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ++counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取单例实例</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> Singleton.INSTANCE;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用业务方法</span></span><br><span class="line">        singleton.doSomething();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用业务属性</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Counter: &quot;</span> + singleton.incrementAndGet());</span><br><span class="line">        System.out.println(<span class="string">&quot;Counter: &quot;</span> + singleton.incrementAndGet());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 验证单例性</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">anotherInstance</span> <span class="operator">=</span> Singleton.INSTANCE;</span><br><span class="line">        System.out.println(<span class="string">&quot;Same instance? &quot;</span> + (singleton == anotherInstance));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">Singleton instance is working...</span><br><span class="line">Counter: <span class="number">1</span></span><br><span class="line">Counter: <span class="number">2</span></span><br><span class="line">Same instance? <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>动态代理是一种在运行时生成代理对象的机制，它在不改变原有代码的情况下，通过代理对象对原有对象进行增强、扩展或限制等操作。</p>
<p>在 Java 中，动态代理主要有两种实现方式：<strong>基于接口的动态代理</strong>和<strong>基于类的动态代理</strong>。其中，基于接口的动态代理使用 Java 自带的 java.lang.reflect.Proxy 类实现，而基于类的动态代理则需要使用第三方库，如 CGLIB 或 ByteBuddy 等。</p>
<p><strong>基于接口的动态代理</strong></p>
<p>基于接口的动态代理要求目标对象必须实现一个或多个接口，动态代理对象会实现这些接口。在创建动态代理对象时，需要提供一个实现了 InvocationHandler 接口的代理处理器对象，它会在代理对象方法调用时被回调。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloImpl</span> <span class="keyword">implements</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HelloHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before method invocation&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;After method invocation&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloImpl</span>();</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">proxy</span> <span class="operator">=</span> (Hello) Proxy.newProxyInstance(</span><br><span class="line">            hello.getClass().getClassLoader(),</span><br><span class="line">            hello.getClass().getInterfaces(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">HelloHandler</span>(hello)</span><br><span class="line">        );</span><br><span class="line">        proxy.sayHello(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>基于类的动态代理</strong></p>
<p>基于类的动态代理则不要求目标对象必须实现接口，而是通过创建目标对象的子类来实现代理。在创建动态代理对象时，需要提供一个实现了 MethodInterceptor 接口的拦截器对象，它会在代理对象方法调用时被回调。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before method invocation&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;After method invocation&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(Hello.class);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">HelloInterceptor</span>());</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">proxy</span> <span class="operator">=</span> (Hello) enhancer.create();</span><br><span class="line">        proxy.sayHello(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><p>Java 集合框架主要包括 <code>Collection</code> 和 <code>Map</code> 两大接口体系。<code>Collection</code> 主要有 <code>List</code>、<code>Set</code>、<code>Queue</code> 几个核心子接口。</p>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="什么是-fail-fast-机制"><a href="#什么是-fail-fast-机制" class="headerlink" title="什么是 fail-fast 机制"></a><strong>什么是 <code>fail-fast</code> 机制</strong></h4><ul>
<li>一种<strong>错误检测机制</strong>。当使用迭代器 (<code>Iterator</code>) 遍历集合时，如果<strong>在遍历过程中（除了通过迭代器自身的 <code>remove()</code> 方法外）集合结构被修改</strong>（添加、删除元素），会立即抛出 <code>ConcurrentModificationException</code>。</li>
<li><strong>实现原理</strong>：集合内部维护一个 <code>modCount</code> (修改计数器)。创建迭代器时，会将当前的 <code>modCount</code> 记录为 <code>expectedModCount</code>。在迭代过程中，每次调用 <code>next()</code>、<code>remove()</code> 等方法前都会检查 <code>modCount == expectedModCount</code>。如果不相等，说明有其他线程或本线程其他操作修改了集合结构，抛出异常。</li>
<li><strong>目的</strong>：快速失败，避免在不确定状态下继续操作导致更难以预料的结果。<strong>它不能保证并发修改一定被检测到，主要用于单线程环境下的错误检测</strong>。</li>
</ul>
<h4 id="fail-fast-和-fail-safe-的区别"><a href="#fail-fast-和-fail-safe-的区别" class="headerlink" title="fail-fast 和 fail-safe 的区别"></a><strong><code>fail-fast</code> 和 <code>fail-safe</code> 的区别</strong></h4><ul>
<li><strong><code>fail-fast</code><strong>：直接在原集合上操作。迭代时检测到并发修改就</strong>立即抛异常</strong>。代表：<code>ArrayList</code>, <code>HashMap</code> 等非并发集合的迭代器。</li>
<li><strong><code>fail-safe</code> (Concurrent Modification Tolerance)<strong>：</strong>不在原集合上操作</strong>，而是基于原集合的<strong>快照 (snapshot)</strong> 或 <strong>只读视图</strong> 进行迭代。迭代过程中原集合的修改不会影响迭代器，不会抛异常。代表：<code>ConcurrentHashMap</code>, <code>CopyOnWriteArrayList</code> 的迭代器。</li>
</ul>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a><code>List</code></h3><h4 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a><code>ArrayList</code>的扩容机制</h4><ul>
<li>使用 <code>Object[] elementData</code> 存储元素。</li>
<li>创建时如果未指定大小，初始容量为 <strong>0</strong> (JDK 1.8+) 或 <strong>10</strong> (旧版本，需确认具体版本)，第一次添加元素时扩容到 <strong>10</strong>。</li>
<li>当添加元素时发现容量不足（<code>size + 1 &gt; elementData.length</code>），触发扩容， <strong>新容量是原容量的1.5倍</strong>。</li>
<li>创建一个新的更大的数组，将旧数组元素<strong>复制</strong>到新数组。</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a><code>Set</code></h3><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a><code>Map</code></h3><h4 id="HashMap-的实现原理"><a href="#HashMap-的实现原理" class="headerlink" title="HashMap 的实现原理"></a><code>HashMap</code> 的实现原理</h4><p><strong>JDK7：数组 + 链表</strong></p>
<ul>
<li><strong>扩容</strong>：创建新数组 (通常是原数组长度的 <strong>2倍</strong>)，遍历所有元素，<strong>重新计算每个元素在新数组中的位置</strong> (<code>rehash</code>)，将元素转移到新数组。<strong>头插法会导致扩容时链表元素顺序反转</strong>。</li>
</ul>
<p><strong>JDK8：数组 + 链表 &#x2F; 红黑树</strong></p>
<p><strong>主要改进</strong>：</p>
<ul>
<li><strong>尾插法</strong>：解决 JDK7 头插法多线程下可能导致死循环的问题（未解决线程安全问题）。</li>
<li><strong>链表转红黑树</strong>：当链表长度 <strong>&gt;&#x3D; 8 (TREEIFY_THRESHOLD)</strong> 且 <strong>数组长度 &gt;&#x3D; 64 (MIN_TREEIFY_CAPACITY)</strong> 时，链表转换为红黑树，提高长链表的查找效率 (O(n) -&gt; O(log n))。</li>
<li><strong>优化哈希算法</strong>：<code>(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，高位参与运算，减少哈希冲突。</li>
<li><strong>扩容</strong>：根据 <code>(e.hash &amp; oldCap) == 0</code> 将链表拆分成两个子链表，结果为 0 的节点保持原索引位置 <code>i</code>，结果不为 0 的节点放到新位置 <code>i + oldCap</code>，避免全量 <code>rehash</code>，提升了效率。</li>
</ul>
<h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h2><h3 id="字节流与字符流的区别"><a href="#字节流与字符流的区别" class="headerlink" title="字节流与字符流的区别"></a>字节流与字符流的区别</h3><ul>
<li><strong>字节流</strong>：<code>InputStream</code>&#x2F;<code>OutputStream</code>，处理二进制数据（如图片、视频），核心类如 <code>FileInputStream</code>。</li>
<li><strong>字符流</strong>：<code>Reader</code>&#x2F;<code>Writer</code>，处理文本数据（自动处理编码），核心类如 <code>FileReader</code>、<code>InputStreamReader</code>。</li>
<li><strong>关键点</strong>：字符流底层依赖字节流 + 编码转换（如 <code>InputStreamReader</code> 是字节到字符的桥梁）。</li>
</ul>
<p><strong>为什么要有字符流？</strong></p>
<ul>
<li>直接操作字符更高效，避免手动处理编码（如 UTF-8 转码），解决乱码问题。</li>
</ul>
<h3 id="BIO、NIO、AIO的区别"><a href="#BIO、NIO、AIO的区别" class="headerlink" title="BIO、NIO、AIO的区别"></a>BIO、NIO、AIO的区别</h3><table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left">传统 IO</th>
<th align="left">NIO</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>模型</strong></td>
<td align="left">阻塞式（Blocking）</td>
<td align="left">非阻塞式（Non-blocking）</td>
</tr>
<tr>
<td align="left"><strong>数据单位</strong></td>
<td align="left">流（Stream）</td>
<td align="left">缓冲区（Buffer） + 通道（Channel）</td>
</tr>
<tr>
<td align="left"><strong>多路复用</strong></td>
<td align="left">不支持</td>
<td align="left">Selector 轮询机制</td>
</tr>
</tbody></table>
<h3 id="NIO-三大核心组件"><a href="#NIO-三大核心组件" class="headerlink" title="NIO 三大核心组件"></a>NIO 三大核心组件</h3><ul>
<li><strong>Buffer</strong>：数据容器（如 <code>ByteBuffer</code>），支持 <code>flip()</code>、<code>clear()</code> 等操作。</li>
<li><strong>Channel</strong>：双向数据传输通道（如 <code>FileChannel</code>、<code>SocketChannel</code>）。</li>
<li><strong>Selector</strong>：单线程监听多个 Channel 事件（<code>OP_READ</code>、<code>OP_WRITE</code>）。</li>
</ul>
<h3 id="五大IO模型"><a href="#五大IO模型" class="headerlink" title="五大IO模型"></a>五大IO模型</h3><p><strong>1. 阻塞 I&#x2F;O 模型 (Blocking I&#x2F;O)</strong></p>
<p><strong>特点</strong>：线程发起 I&#x2F;O 操作后会被挂起，直到操作完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器端</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>)) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 阻塞直到客户端连接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">clientSocket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> clientSocket.getInputStream()) &#123;</span><br><span class="line">                <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="comment">// 阻塞直到数据到达</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> in.read(buffer);</span><br><span class="line">                <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">                System.out.println(<span class="string">&quot;Received: &quot;</span> + data);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 非阻塞 I&#x2F;O 模型 (Non-blocking I&#x2F;O)</strong></p>
<p><strong>特点</strong>：线程立即返回结果，通过轮询检查就绪状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器端</span></span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">serverChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">serverChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">serverChannel.configureBlocking(<span class="literal">false</span>); <span class="comment">// 设置为非阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 立即返回，可能为 null</span></span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> serverChannel.accept();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (clientChannel != <span class="literal">null</span>) &#123;</span><br><span class="line">        clientChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 非阻塞读取</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> clientChannel.read(buffer);</span><br><span class="line">        <span class="keyword">if</span> (bytesRead &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[buffer.limit()];</span><br><span class="line">            buffer.get(data);</span><br><span class="line">            System.out.println(<span class="string">&quot;Received: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 可执行其他任务</span></span><br><span class="line">        Thread.sleep(<span class="number">100</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. I&#x2F;O 多路复用模型 (I&#x2F;O Multiplexing)</strong></p>
<p><strong>特点</strong>：使用单个线程管理多个 I&#x2F;O 通道</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器端</span></span><br><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">serverChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">serverChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">serverChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 阻塞直到有就绪事件</span></span><br><span class="line">    selector.select();</span><br><span class="line">    </span><br><span class="line">    Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; iter = selectedKeys.iterator();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            <span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> server.accept();</span><br><span class="line">            client.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            client.read(buffer);</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">// 处理数据...</span></span><br><span class="line">        &#125;</span><br><span class="line">        iter.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 信号驱动 I&#x2F;O 模型 (Signal-driven I&#x2F;O)</strong></p>
<p><strong>特点</strong>：通过信号通知 I&#x2F;O 就绪状态（Java 不直接支持）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* C语言示例（Java无直接对应API） */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigio_handler</span><span class="params">(<span class="type">int</span> signo)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理I/O就绪事件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    signal(SIGIO, sigio_handler);</span><br><span class="line">    fcntl(sockfd, F_SETOWN, getpid());</span><br><span class="line">    fcntl(sockfd, F_SETFL, O_ASYNC | O_NONBLOCK);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5. 异步 I&#x2F;O 模型 (Asynchronous I&#x2F;O)</strong></p>
<p><strong>特点</strong>：I&#x2F;O 操作完成后自动通知，无需等待</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器端</span></span><br><span class="line"><span class="type">AsynchronousServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> </span><br><span class="line">    AsynchronousServerSocketChannel.open().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步接受连接</span></span><br><span class="line">server.accept(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, Void&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(AsynchronousSocketChannel client, Void attachment)</span> &#123;</span><br><span class="line">        server.accept(<span class="literal">null</span>, <span class="built_in">this</span>); <span class="comment">// 继续接受新连接</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 异步读取数据</span></span><br><span class="line">        client.read(buffer, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, Void&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer bytesRead, Void attachment)</span> &#123;</span><br><span class="line">                buffer.flip();</span><br><span class="line">                <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[buffer.limit()];</span><br><span class="line">                buffer.get(data);</span><br><span class="line">                System.out.println(<span class="string">&quot;Async received: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, Void attachment)</span> &#123;</span><br><span class="line">                exc.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, Void attachment)</span> &#123;</span><br><span class="line">        exc.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>各模型对比总结</strong></p>
<table>
<thead>
<tr>
<th align="left">模型</th>
<th align="left">阻塞阶段</th>
<th align="left">Java 实现</th>
<th align="left">优点</th>
<th align="left">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>阻塞 I&#x2F;O</strong></td>
<td align="left">等待数据到达和复制</td>
<td align="left"><code>Socket</code>, <code>ServerSocket</code></td>
<td align="left">编程简单</td>
<td align="left">线程资源浪费</td>
</tr>
<tr>
<td align="left"><strong>非阻塞 I&#x2F;O</strong></td>
<td align="left">无（但需轮询）</td>
<td align="left">NIO <code>configureBlocking(false)</code></td>
<td align="left">单线程管理多连接</td>
<td align="left">轮询消耗 CPU</td>
</tr>
<tr>
<td align="left"><strong>I&#x2F;O 多路复用</strong></td>
<td align="left">等待事件通知</td>
<td align="left">NIO <code>Selector</code></td>
<td align="left">高效管理大量连接</td>
<td align="left">编程较复杂</td>
</tr>
<tr>
<td align="left"><strong>信号驱动 I&#x2F;O</strong></td>
<td align="left">无（但需处理信号）</td>
<td align="left">Java 不支持</td>
<td align="left">减少轮询开销</td>
<td align="left">编程复杂，信号队列溢出</td>
</tr>
<tr>
<td align="left"><strong>异步 I&#x2F;O</strong></td>
<td align="left">无（完全异步）</td>
<td align="left">NIO.2 <code>AsynchronousChannel</code></td>
<td align="left">真正非阻塞，资源利用率高</td>
<td align="left">编程模型复杂</td>
</tr>
</tbody></table>
<h3 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h3><ul>
<li>单Reactor单线程</li>
<li>单Reactor多线程</li>
<li>主从Reactor多线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleReactor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Reactor</span>(<span class="number">8083</span>)).start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Reactor服务器启动，监听端口: 8083&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Reactor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Selector selector;</span><br><span class="line">        <span class="keyword">final</span> ServerSocketChannel serverSocket;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">workerPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        Reactor(<span class="type">int</span> port) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            serverSocket = ServerSocketChannel.open();</span><br><span class="line">            serverSocket.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port));</span><br><span class="line">            serverSocket.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册ACCEPT事件到Selector</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">SelectionKey</span> <span class="variable">sk</span> <span class="operator">=</span> serverSocket.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            sk.attach(<span class="keyword">new</span> <span class="title class_">Acceptor</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                    <span class="comment">// 阻塞等待事件</span></span><br><span class="line">                    selector.select();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();</span><br><span class="line">                    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                        <span class="comment">// 分发事件</span></span><br><span class="line">                        dispatch(it.next());</span><br><span class="line">                        it.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(SelectionKey key)</span> &#123;</span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">handler</span> <span class="operator">=</span> (Runnable) key.attachment();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">                handler.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Acceptor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                    <span class="keyword">if</span> (client != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 创建业务处理器</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Handler</span>(selector, client, workerPool);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Handler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="comment">// 最大输入数据</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_IN</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> SocketChannel socket;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> SelectionKey sk;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService workerPool;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">ByteBuffer</span> <span class="variable">input</span> <span class="operator">=</span> ByteBuffer.allocate(MAX_IN);</span><br><span class="line">        <span class="keyword">private</span> <span class="type">ByteBuffer</span> <span class="variable">output</span> <span class="operator">=</span> ByteBuffer.allocate(MAX_IN);</span><br><span class="line"></span><br><span class="line">        Handler(Selector selector, SocketChannel socket, ExecutorService workerPool) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="built_in">this</span>.socket = socket;</span><br><span class="line">            <span class="built_in">this</span>.workerPool = workerPool;</span><br><span class="line">            socket.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册READ事件</span></span><br><span class="line">            sk = socket.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            <span class="comment">// 绑定handler</span></span><br><span class="line">            sk.attach(<span class="built_in">this</span>);</span><br><span class="line">            <span class="comment">// 唤醒selector</span></span><br><span class="line">            selector.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (sk.isReadable()) &#123;</span><br><span class="line">                    read();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sk.isWritable()) &#123;</span><br><span class="line">                    write();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                closeConnection();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            input.clear();</span><br><span class="line">            <span class="comment">// 读操作依然在Reactor主线程</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> socket.read(input);</span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 业务处理另起线程</span></span><br><span class="line">                workerPool.execute(<span class="keyword">new</span> <span class="title class_">Processor</span>(<span class="keyword">new</span> <span class="title class_">String</span>(input.array(), <span class="number">0</span>, n)));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                closeConnection();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            output.flip();</span><br><span class="line">            <span class="comment">// 写操作依然在Reactor主线</span></span><br><span class="line">            socket.write(output);</span><br><span class="line">            <span class="keyword">if</span> (!output.hasRemaining()) &#123;</span><br><span class="line">                <span class="comment">// 写完后重新注册读事件</span></span><br><span class="line">                sk.interestOps(SelectionKey.OP_READ);</span><br><span class="line">            &#125;</span><br><span class="line">            output.compact();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">closeConnection</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sk.cancel();</span><br><span class="line">                socket.close();</span><br><span class="line">                System.out.println(<span class="string">&quot;连接关闭：&quot;</span> + socket.getRemoteAddress());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Processor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> String request;</span><br><span class="line"></span><br><span class="line">            Processor(String request) &#123;</span><br><span class="line">                <span class="built_in">this</span>.request = request;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟业务操作</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> request.toUpperCase(Locale.ROOT);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 注意：非Reactor线程操作，需要同步</span></span><br><span class="line">                <span class="keyword">synchronized</span> (output) &#123;</span><br><span class="line">                    output.put(response.getBytes());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 注册写事件</span></span><br><span class="line">                    sk.interestOps(SelectionKey.OP_WRITE);</span><br><span class="line">                &#125;</span><br><span class="line">                sk.selector().wakeup();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReactorClient</span> &#123;</span><br><span class="line">    <span class="comment">// 客户端数量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CLIENT_COUNT</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    <span class="comment">// 每个客户端请求次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REQUEST_PER_CLIENT</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SERVER_HOST</span> <span class="operator">=</span> <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SERVER_PORT</span> <span class="operator">=</span> <span class="number">8083</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(CLIENT_COUNT);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; CLIENT_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">clientId</span> <span class="operator">=</span> i;</span><br><span class="line">            pool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; REQUEST_PER_CLIENT; j++) &#123;</span><br><span class="line">                        sendRequest(clientId, j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        latch.await();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">duration</span> <span class="operator">=</span> System.currentTimeMillis() - start;</span><br><span class="line">        System.out.printf(<span class="string">&quot;\n测试完成! 总请求: %d, 耗时: %dms, QPS: %.1f\n&quot;</span>,</span><br><span class="line">            CLIENT_COUNT * REQUEST_PER_CLIENT,</span><br><span class="line">            duration,</span><br><span class="line">            CLIENT_COUNT * REQUEST_PER_CLIENT * <span class="number">1000.0</span> / duration);</span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendRequest</span><span class="params">(<span class="type">int</span> clientId, <span class="type">int</span> requestId)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">SocketChannel</span> <span class="variable">socket</span> <span class="operator">=</span> SocketChannel.open()) &#123;</span><br><span class="line">            <span class="comment">// 连接服务器</span></span><br><span class="line">            socket.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(SERVER_HOST, SERVER_PORT));</span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> String.format(<span class="string">&quot;Client-%d_Req-%d&quot;</span>, clientId, requestId);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送请求</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            socket.write(buffer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接收响应</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">ByteBuffer</span> <span class="variable">response</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            socket.read(response);</span><br><span class="line">            response.flip();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印结果（实际压力测试应注释掉）</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;Client-%d 收到响应: %s\n&quot;</span>,</span><br><span class="line">                clientId,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>(response.array(), <span class="number">0</span>, response.limit()));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加延迟模拟真实场景</span></span><br><span class="line">            Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="select、poll、epoll的区别"><a href="#select、poll、epoll的区别" class="headerlink" title="select、poll、epoll的区别"></a><code>select</code>、<code>poll</code>、<code>epoll</code>的区别</h3><h2 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h2><ul>
<li><strong>深入并发编程:</strong> 彻底掌握 <code>java.util.concurrent</code> 包 (<code>ExecutorService</code>, <code>ThreadPoolExecutor</code>, <code>Future</code>, <code>CompletableFuture</code>, <code>ConcurrentHashMap</code>, <code>ReentrantLock</code>, <code>StampedLock</code>, <code>Semaphore</code>, <code>CountDownLatch</code>, <code>CyclicBarrier</code>, <code>Phaser</code>)。理解 Java 内存模型（JMM）、Happens-Before 原则、volatile、synchronized 的底层实现（偏向锁、轻量级锁、重量级锁、锁升级过程）、CAS、AQS 框架。能诊断和解决死锁、活锁、线程饥饿、上下文切换开销高等复杂并发问题。</li>
</ul>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="线程池关键参数"><a href="#线程池关键参数" class="headerlink" title="线程池关键参数"></a>线程池关键参数</h4><ul>
<li><code>corePoolSize</code>：核心线程数。即使线程空闲，也会保留在线程池中（除非设置 <code>allowCoreThreadTimeOut</code>）。</li>
<li><code>maximumPoolSize</code>：线程池允许的最大线程数。</li>
<li><code>keepAliveTime</code>：当线程数超过 <code>corePoolSize</code> 时，多余的空闲线程在终止前等待新任务的最长时间。</li>
<li><code>unit</code>：<code>keepAliveTime</code> 的时间单位。</li>
<li><code>workQueue</code>：用于保存等待执行任务的阻塞队列（如 <code>LinkedBlockingQueue</code>, <code>ArrayBlockingQueue</code>, <code>SynchronousQueue</code>）。</li>
<li><code>threadFactory</code>：用于创建新线程的工厂（可定制线程名、优先级、守护状态等）。</li>
<li><code>handler</code>：当线程池和队列都饱和时，新提交任务的拒绝策略（<code>RejectedExecutionHandler</code> 的实现）。</li>
</ul>
<h4 id="常见的拒绝策略"><a href="#常见的拒绝策略" class="headerlink" title="常见的拒绝策略"></a>常见的拒绝策略</h4><ul>
<li><code>AbortPolicy</code>（默认）：直接抛出 <code>RejectedExecutionException</code> 异常。</li>
<li><code>CallerRunsPolicy</code>：由提交任务的线程（调用 <code>execute</code> 方法的线程）自己执行该任务。</li>
<li><code>DiscardPolicy</code>：静默丢弃被拒绝的任务，不做任何处理。</li>
<li><code>DiscardOldestPolicy</code>：丢弃队列中最前面的任务（等待最久的），然后尝试重新提交当前任务。</li>
<li>自定义策略：实现 <code>RejectedExecutionHandler</code> 接口定义自己的逻辑（如记录日志、持久化任务等）。</li>
</ul>
<h4 id="任务提交到线程池的工作流程"><a href="#任务提交到线程池的工作流程" class="headerlink" title="任务提交到线程池的工作流程"></a>任务提交到线程池的工作流程</h4><ol>
<li>提交一个新任务。</li>
<li>当前线程数 &lt; <code>corePoolSize</code>，创建新线程执行任务（即使有空闲核心线程）。</li>
<li>当前线程数 &gt;&#x3D; <code>corePoolSize</code>，将任务放入 <code>workQueue</code>。</li>
<li>队列已满，且当前线程数 &lt; <code>maximumPoolSize</code>，创建新线程执行任务。</li>
<li>队列已满，且当前线程数 &gt;&#x3D; <code>maximumPoolSize</code>，触发拒绝策略 (<code>handler</code>) 处理该任务。</li>
<li>当一个线程空闲时间超过 <code>keepAliveTime</code>：<ul>
<li>大于 <code>corePoolSize</code> 的空闲线程会被终止。</li>
<li>如果 <code>allowCoreThreadTimeOut</code> 为 <code>true</code>，核心线程空闲超时也会被终止。</li>
</ul>
</li>
</ol>
<h4 id="shutdown-和shutdownNow-有什么区别"><a href="#shutdown-和shutdownNow-有什么区别" class="headerlink" title="shutdown()和shutdownNow()有什么区别"></a><code>shutdown()</code>和<code>shutdownNow()</code>有什么区别</h4><ul>
<li><code>shutdown()</code>：温和关闭。不再接受新任务，但会执行完已提交的任务（包括队列中的）。</li>
<li><code>shutdownNow()</code>：尝试立即停止所有正在执行的任务，暂停处理等待的任务，并返回等待执行的任务列表。通过调用线程的 <code>interrupt()</code> 方法尝试中断任务（如果任务不响应中断，则无法停止）。</li>
</ul>
<h4 id="线程池的execute-和submit（）有什么区别"><a href="#线程池的execute-和submit（）有什么区别" class="headerlink" title="线程池的execute()和submit（）有什么区别"></a>线程池的<code>execute()</code>和<code>submit（）</code>有什么区别</h4><p><code>void execute(Runnable command)</code> 主要用来提交不需要返回值的异步任务。</p>
<p><code>submit</code> 主要用来提交需要返回值的异步任务。</p>
<h4 id="线程池异常的处理方法"><a href="#线程池异常的处理方法" class="headerlink" title="线程池异常的处理方法"></a>线程池异常的处理方法</h4><ul>
<li><strong>使用Future对象捕获异常</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExceptionHandling</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">workerTask</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务 &quot;</span> + n + <span class="string">&quot; 开始执行&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">400</span>) + <span class="number">100</span>); <span class="comment">// 100-500ms随机睡眠</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 随机抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">Random</span>().nextDouble() &lt; <span class="number">0.3</span>) &#123; <span class="comment">// 30%的概率抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;任务 &quot;</span> + n + <span class="string">&quot; 执行出错&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;任务 &quot;</span> + n + <span class="string">&quot; 完成&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        List&lt;Future&lt;String&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 提交任务到线程池</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            Future&lt;String&gt; future = executor.submit(() -&gt; workerTask(taskId));</span><br><span class="line">            futures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理完成的任务</span></span><br><span class="line">        <span class="keyword">for</span> (Future&lt;String&gt; future : futures) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get(); <span class="comment">// 获取结果，如果有异常会在这里抛出</span></span><br><span class="line">                System.out.println(<span class="string">&quot;成功: &quot;</span> + result);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;捕获到异常: &quot;</span> + e.getCause().getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用UncaughtExceptionHandler</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ExceptionHandlingThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadFactory</span> <span class="variable">defaultFactory</span> <span class="operator">=</span> Executors.defaultThreadFactory();</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> defaultFactory.newThread(r);</span><br><span class="line">            thread.setUncaughtExceptionHandler((t, e) -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 &quot;</span> + t.getName() + <span class="string">&quot; 中未捕获的异常: &quot;</span> + e.getMessage());</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">worker</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;任务 &quot;</span> + n + <span class="string">&quot; 出错了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;任务 &quot;</span> + n + <span class="string">&quot; 完成&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">ExceptionHandlingThreadFactory</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> worker(taskId);</span><br><span class="line">                    System.out.println(result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">// 异常会被UncaughtExceptionHandler处理</span></span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            executor.awaitTermination(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;所有任务处理完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程池示例"><a href="#线程池示例" class="headerlink" title="线程池示例"></a>线程池示例</h4><h5 id="批量数据处理-可扩容线程池-无界-有界队列"><a href="#批量数据处理-可扩容线程池-无界-有界队列" class="headerlink" title="批量数据处理 (可扩容线程池 + 无界&#x2F;有界队列)"></a>批量数据处理 (可扩容线程池 + 无界&#x2F;有界队列)</h5><ul>
<li><strong>场景描述：</strong> 需要处理一个包含大量数据（如百万条记录）的文件或数据库查询结果集。可以将每条记录的处理作为一个任务。</li>
<li><strong>线程池选择：</strong> 使用 <code>corePoolSize</code> 较小，<code>maximumPoolSize</code> 较大的线程池，配合无界队列（如果内存充足且任务量可控）或有界队列。允许在任务突增时创建更多线程加速处理。</li>
<li><strong>拒绝策略：</strong> 如果使用有界队列，根据业务重要性选择（如 <code>AbortPolicy</code> 记录日志后跳过，或 <code>CallerRunsPolicy</code> 让主线程处理）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BatchDataProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CORE_POOL_SIZE</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors(); <span class="comment">// 比如等于CPU核心数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_POOL_SIZE</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">QUEUE_CAPACITY</span> <span class="operator">=</span> <span class="number">10000</span>; <span class="comment">// 有界队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">KEEP_ALIVE_TIME</span> <span class="operator">=</span> <span class="number">60L</span>; <span class="comment">// 空闲线程60秒后回收</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">batchExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            CORE_POOL_SIZE,</span><br><span class="line">            MAX_POOL_SIZE,</span><br><span class="line">            KEEP_ALIVE_TIME,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NamedThreadFactory</span>(<span class="string">&quot;BatchProcessor-&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy() <span class="comment">// 队列满时抛出异常，外层需要捕获处理</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processLargeDataset</span><span class="params">(List&lt;DataRecord&gt; records)</span> &#123;</span><br><span class="line">        List&lt;Future&lt;?&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (DataRecord record : records) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 使用submit可以获取Future，便于后续检查完成状态或异常</span></span><br><span class="line">                Future&lt;?&gt; future = batchExecutor.submit(() -&gt; processSingleRecord(record));</span><br><span class="line">                futures.add(future);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">                <span class="comment">// 处理被拒绝的任务 (如记录日志、放入重试队列等)</span></span><br><span class="line">                log.error(<span class="string">&quot;Task rejected for record: &quot;</span> + record.getId(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有提交的任务完成 (简单等待)</span></span><br><span class="line">        <span class="keyword">for</span> (Future&lt;?&gt; future : futures) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                future.get(); <span class="comment">// 阻塞等待任务完成，捕获可能的ExecutionException</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                <span class="comment">// 处理任务执行中的异常</span></span><br><span class="line">                log.error(<span class="string">&quot;Error processing task&quot;</span>, e.getCause()); <span class="comment">// 获取原始异常</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processSingleRecord</span><span class="params">(DataRecord record)</span> &#123;</span><br><span class="line">        <span class="comment">// ... 处理单条记录的复杂逻辑 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="synchronized-实现原理"><a href="#synchronized-实现原理" class="headerlink" title="synchronized 实现原理"></a><code>synchronized</code> 实现原理</h4><p><code>synchronized</code> 关键字在 Java 中的底层实现依赖于 <strong>JVM 对象头、Monitor 监视器锁以及锁升级机制</strong>。</p>
<p><strong>对象头与 Mark Word</strong></p>
<ul>
<li><p>每个 Java 对象在内存中分为三部分：</p>
<ul>
<li><strong>对象头（Header）</strong>：存储锁状态、GC 年龄等元数据。<ul>
<li><strong>Mark Word</strong>（对象头的核心部分）：<strong>锁状态的变化直接体现在 Mark Word 的比特位组合上。</strong></li>
</ul>
</li>
<li>实例数据（Instance Data）：对象字段值。</li>
</ul>
</li>
<li><p>对齐填充（Padding）：保证内存对齐。</p>
</li>
</ul>
<p><strong>Monitor 的核心结构</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectMonitor</span> &#123;</span><br><span class="line">    <span class="type">void</span>*     _header;      <span class="comment">// 存储 Mark Word 的备份</span></span><br><span class="line">    <span class="type">void</span>*     _owner;       <span class="comment">// 持有锁的线程（如：Thread*）</span></span><br><span class="line">    <span class="type">intptr_t</span>  _count;       <span class="comment">// 重入次数</span></span><br><span class="line">    ObjectWaiter* _WaitSet; <span class="comment">// 调用 wait() 后进入等待队列</span></span><br><span class="line">    ObjectWaiter* _EntryList; <span class="comment">// 阻塞等待锁的线程队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>锁升级机制</strong></p>
<p>为提高性能，从 java1.6 开始采用渐进式锁升级策略：</p>
<p><strong>偏向锁（Biased Locking）</strong></p>
<ul>
<li><strong>目标</strong>：减少无竞争时的开销。</li>
<li><strong>流程</strong>：<ul>
<li>首次加锁时，通过 CAS 将 Mark Word 的锁标志置为 <code>101</code>（偏向锁），并写入当前线程 ID。</li>
<li>后续同一线程进入同步块时，只需检查线程 ID 匹配即可直接执行（零开销）。</li>
</ul>
</li>
<li><strong>撤销</strong>：当其他线程尝试获取锁时，撤销偏向锁（Stop-The-World 操作）。</li>
</ul>
<p><strong>轻量级锁（Lightweight Locking）</strong></p>
<ul>
<li><strong>目标</strong>：避免短时阻塞的线程切换开销。</li>
<li><strong>流程</strong>：<ol>
<li>在栈帧中创建 <strong>锁记录（Lock Record）</strong>。</li>
<li>通过 CAS 将 Mark Word 复制到锁记录，并尝试将 Mark Word 替换为指向锁记录的指针。</li>
<li>成功则获得锁；失败则自旋（循环尝试）一定次数。</li>
</ol>
</li>
<li><strong>自旋失败后升级为重量级锁</strong>。</li>
</ul>
<p><strong>重量级锁（Heavyweight Locking）</strong></p>
<ul>
<li>当竞争激烈时，最终升级为重量级锁。</li>
<li>线程通过操作系统互斥量（mutex）阻塞，进入内核态，性能开销最大。</li>
</ul>
<img src="/post/7992e236/image-20250725195316321.png" class="" title="image-20250725195316321">

<h4 id="ReentrantLock-实现原理"><a href="#ReentrantLock-实现原理" class="headerlink" title="ReentrantLock 实现原理"></a><code>ReentrantLock</code> 实现原理</h4><p><code>ReentrantLock</code> 基于 **AbstractQueuedSynchronizer (AQS)**。AQS 提供了一个框架，用于构建依赖先进先出 (FIFO) 等待队列的阻塞锁和相关同步器（如信号量、倒计时门栓等）。</p>
<ol>
<li><strong>核心组件 - AQS：</strong><ul>
<li><code>state</code> (volatile int)： 表示锁的状态。0 表示锁空闲，&gt;0 表示被持有（通常是持有线程的重入次数）。</li>
<li><code>exclusiveOwnerThread</code> (Thread)： 记录当前持有独占锁（如 ReentrantLock）的线程。</li>
<li><strong>CLH 队列 (变体的 FIFO 队列)：</strong> 由 <code>Node</code> 节点构成的双向链表，用于管理等待获取锁的线程。每个节点代表一个等待线程。</li>
</ul>
</li>
<li><strong>获取锁 (lock() &#x2F; tryLock())：</strong><ul>
<li><strong>非公平模式 (默认)：</strong><ol>
<li>线程直接尝试通过 CAS (Compare-And-Swap) 操作将 <code>state</code> 从 0 设置为 1（尝试快速获取）。</li>
<li>如果成功，设置 <code>exclusiveOwnerThread</code> 为当前线程。</li>
<li>如果失败（锁已被持有）：<ul>
<li>如果当前线程就是持有锁的线程（重入），则直接将 <code>state</code> 加 1。</li>
<li>否则，创建一个代表当前线程的 <code>Node</code> 节点，通过 CAS 操作将其安全地加入到 CLH 队列的尾部。</li>
<li>进入自旋或阻塞状态（通常通过 <code>LockSupport.park()</code>），等待前驱节点释放锁后唤醒。</li>
</ul>
</li>
</ol>
</li>
<li><strong>公平模式：</strong><ol>
<li>检查 CLH 队列中是否有等待时间比自己长的线程。</li>
<li>如果有，则直接将自己加入队列尾部排队。</li>
<li>如果没有，才尝试通过 CAS 获取锁（后续步骤与非公平模式失败后的步骤相同）。</li>
<li>公平模式保证了严格按照线程请求锁的顺序（FIFO）来授予锁，避免了线程饥饿，但通常吞吐量低于非公平模式。</li>
</ol>
</li>
</ul>
</li>
<li><strong>释放锁 (unlock())：</strong><ol>
<li>检查当前线程是否是锁的持有者（防止非法释放）。</li>
<li>将 <code>state</code> 减 1（对于重入锁，需要释放多次直到 <code>state</code> 为 0）。</li>
<li>如果 <code>state</code> 减到 0：<ul>
<li>设置 <code>exclusiveOwnerThread</code> 为 <code>null</code>。</li>
<li>唤醒 CLH 队列中下一个等待的线程（如果存在）。</li>
</ul>
</li>
</ol>
</li>
<li><strong>可重入性：</strong><ul>
<li>通过 <code>state</code> 变量记录重入次数。每次持有锁的线程再次获取锁，<code>state</code> 就加 1。每次释放锁，<code>state</code> 就减 1。只有减到 0 时，锁才真正被释放。</li>
</ul>
</li>
</ol>
<h4 id="ReentrantLock-与-synchronized-的区别"><a href="#ReentrantLock-与-synchronized-的区别" class="headerlink" title="ReentrantLock 与 synchronized 的区别"></a><code>ReentrantLock</code> 与 <code>synchronized</code> 的区别</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>ReentrantLock</code></th>
<th align="left"><code>synchronized</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>灵活性</strong></td>
<td align="left"><strong>高</strong>：支持尝试获取锁(<code>tryLock</code>)、超时获取(<code>tryLock(time)</code>)、可中断获取(<code>lockInterruptibly</code>)、公平锁</td>
<td align="left"><strong>低</strong>：获取锁只有阻塞一种方式，不支持超时和公平性控制</td>
</tr>
<tr>
<td align="left"><strong>公平性</strong></td>
<td align="left"><strong>可配置</strong>：构造函数可指定公平锁(<code>true</code>)或非公平锁(<code>false</code>)</td>
<td align="left"><strong>仅非公平锁</strong></td>
</tr>
<tr>
<td align="left"><strong>等待条件</strong></td>
<td align="left"><strong>支持多个条件队列</strong>：一个锁可关联多个 <code>Condition</code> 对象，实现更精细的线程等待&#x2F;唤醒</td>
<td align="left"><strong>仅一个隐式条件队列</strong>：每个对象关联一个内置锁，只有一个 <code>wait()</code>&#x2F;<code>notify()</code>&#x2F;<code>notifyAll()</code> 队列</td>
</tr>
<tr>
<td align="left"><strong>中断响应</strong></td>
<td align="left"><strong>支持</strong>：<code>lockInterruptibly()</code> 方法允许在等待锁时响应中断</td>
<td align="left"><strong>不支持</strong>：在等待内置锁 (<code>synchronized</code> 块) 时，线程无法响应中断</td>
</tr>
</tbody></table>
<p><strong>总结与选择建议</strong></p>
<ul>
<li><strong>优先考虑 <code>synchronized</code>：</strong> 在大多数不需要 <code>ReentrantLock</code> 高级特性的场景下，优先使用 <code>synchronized</code>。理由：<ul>
<li>语法简洁清晰，不易出错（自动释放锁）。</li>
<li>JVM 持续优化，性能优异且稳定。</li>
<li>是 Java 语言的核心特性，代码可读性更高，开发者更熟悉。</li>
</ul>
</li>
<li><strong>考虑使用 <code>ReentrantLock</code>：</strong> 当你的需求超出了 <code>synchronized</code> 的能力范围时：<ul>
<li><strong>需要尝试获取锁 (<code>tryLock</code>) 或超时获取锁。</strong></li>
<li><strong>需要可中断地等待一个锁 (<code>lockInterruptibly</code>)。</strong></li>
<li><strong>需要实现公平锁策略 (避免线程饥饿)。</strong></li>
<li><strong>需要多个等待&#x2F;通知条件 (<code>Condition</code>)。</strong></li>
<li><strong>需要在同一个锁上跨越多个方法进行加锁和解锁操作（虽然 <code>synchronized</code> 通过嵌套或方法调用也能实现，但 <code>ReentrantLock</code> 的控制粒度更灵活）。</strong></li>
</ul>
</li>
</ul>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a><code>ThreadLocal</code></h3><p>ThreadLocal 是 Java 中一个用于实现<strong>线程局部变量</strong>的工具类。它为每个使用该变量的线程提供了一个独立的变量副本，从而实现了线程间的数据隔离。</p>
<p><strong>核心原理：</strong></p>
<ol>
<li><p><strong>Thread 类中的 ThreadLocalMap：</strong></p>
<ul>
<li><code>Thread</code> 有一个类型为 <code>ThreadLocal.ThreadLocalMap</code>的私有成员变量 <code>threadLocals</code>。</li>
<li><code>ThreadLocalMap</code> 是一个定制的、类似 <code>HashMap</code> 的结构，专门用于存储线程局部变量。键是 <code>ThreadLocal</code> ，值是该线程对应的变量副本。</li>
</ul>
</li>
<li><p><strong>ThreadLocal 的操作机制：</strong></p>
<ul>
<li><p><strong><code>set(T value)</code>：</strong> 当调用 <code>threadLocal.set(value)</code> 时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 用当前ThreadLocal作为key存储值</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createMap(t, value); <span class="comment">// 首次使用创建Map</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>get()</code>：</strong> 当调用 <code>threadLocal.get()</code> 时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread(); <span class="comment">// 1. 获取当前线程</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);    <span class="comment">// 2. 获取线程的ThreadLocalMap</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 3. 用当前ThreadLocal实例作为key查找Entry</span></span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (T)e.value; <span class="comment">// 4. 返回找到的值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue(); <span class="comment">// 5. 找不到时初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>remove()</code>：</strong> 当调用 <code>threadLocal.remove()</code> 时：</p>
<ol>
<li>获取当前线程的 <code>threadLocals</code>。</li>
<li>如果 <code>threadLocals</code> 不为 <code>null</code>，则从中移除以当前 <code>ThreadLocal</code> 实例为键的条目。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>关键点：</strong></p>
<ul>
<li><p><strong>数据存储位置：</strong> 变量副本实际存储在<strong>线程对象</strong>内部的 <code>ThreadLocalMap</code> 里，而不是存储在 <code>ThreadLocal</code> 对象本身。<code>ThreadLocal</code> 只是一个访问这些副本的工具和键。</p>
</li>
<li><p><strong>键的引用：</strong> <code>ThreadLocalMap</code> 中的键 (<code>ThreadLocal</code> 对象) 是<strong>弱引用</strong>。这是为了在 <code>ThreadLocal</code> 实例本身不再被强引用时（比如被 GC 回收了），<code>ThreadLocalMap</code> 中的键能自动被 GC 回收，避免内存泄漏（键部分）。</p>
</li>
<li><p><strong>值的引用：</strong> <code>ThreadLocalMap</code> 中的值是<strong>强引用</strong>。这就是为什么如果 <code>ThreadLocal</code> 被回收了（键变 <code>null</code>），但线程（尤其是线程池中的线程）长期存活，且没有调用 <code>remove()</code> 方法，那么值对象会一直被 <code>ThreadLocalMap</code> 的条目强引用着，导致值对象无法被回收，造成<strong>内存泄漏</strong>（值部分）。</p>
</li>
<li><p><strong>内存泄漏风险：</strong> 这是使用 <code>ThreadLocal</code> 最大的隐患。主要发生在：</p>
<ul>
<li>使用了<strong>线程池</strong>（线程复用，生命周期长）。</li>
<li>在 <code>ThreadLocal</code> 中存储了<strong>大对象</strong>。</li>
<li>在任务执行完毕后，<strong>没有调用 <code>threadLocal.remove()</code></strong> 来清理当前线程的副本。</li>
</ul>
<img src="/post/7992e236/image-20250807001016383.png" class="" title="image-20250807001016383"></li>
<li><p><strong>继承性：</strong> <code>ThreadLocal</code> 本身不支持变量从父线程传递给子线程。如果需要这种能力，可以使用 <code>InheritableThreadLocal</code>。</p>
</li>
</ul>
</li>
</ol>
<img src="/post/7992e236/image-20250725210437363.png" class="" title="image-20250725210437363">

<p><strong>示例1：存储用户信息</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserContextHolder</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个ThreadLocal变量，用于存储用户ID。通常声明为private static final</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; currentUser = ThreadLocal.withInitial(() -&gt; <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 设置当前线程的用户ID</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setCurrentUser</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">        currentUser.set(userId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前线程的用户ID</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getCurrentUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currentUser.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清除当前线程的用户ID（重要！避免内存泄漏）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        currentUser.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在拦截器或过滤器中设置和清除</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> &#123;</span><br><span class="line">        <span class="comment">// 从请求中获取用户信息（比如token解析）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> ...; </span><br><span class="line">        UserContextHolder.setCurrentUser(userId);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> &#123;</span><br><span class="line">        <span class="comment">// 请求处理完成后，清除ThreadLocal，防止内存泄漏</span></span><br><span class="line">        UserContextHolder.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例2：事务管理</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionContextHolder</span> &#123;</span><br><span class="line">    <span class="comment">// 存储当前线程的事务连接</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Connection&gt; currentConnection = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> currentConnection.get();</span><br><span class="line">        <span class="keyword">if</span> (conn == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果没有，则从连接池获取一个新的连接，并设置到ThreadLocal</span></span><br><span class="line">            conn = DataSourceUtils.getConnection(); <span class="comment">// 假设的工具类</span></span><br><span class="line">            currentConnection.set(conn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bindConnection</span><span class="params">(Connection conn)</span> &#123;</span><br><span class="line">        currentConnection.set(conn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unbindConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        currentConnection.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionManager</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> TransactionContextHolder.getConnection();</span><br><span class="line">        conn.setAutoCommit(<span class="literal">false</span>); <span class="comment">// 开启事务</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> TransactionContextHolder.getConnection();</span><br><span class="line">        conn.commit();</span><br><span class="line">        TransactionContextHolder.unbindConnection(); <span class="comment">// 提交后移除连接，并释放到连接池</span></span><br><span class="line">        DataSourceUtils.releaseConnection(conn); <span class="comment">// 假设的工具类，将连接归还连接池</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...类似commit，回滚事务并清理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JUC集合"><a href="#JUC集合" class="headerlink" title="JUC集合"></a>JUC集合</h3><h4 id="ConcurrentHashMap-的实现原理"><a href="#ConcurrentHashMap-的实现原理" class="headerlink" title="ConcurrentHashMap 的实现原理"></a><code>ConcurrentHashMap</code> 的实现原理</h4><p>ConcurrentHashMap 是 Java 并发编程中至关重要的数据结构。它在 Java 7 和 Java 8 中经历了重大的重构，核心目标都是提高并发性能、减少竞争、优化内存和计算开销。以下是它们的实现差异和 Java 8 的优化：</p>
<p><strong>Java 7 实现 (基于分段锁 - Segment Locking)</strong></p>
<ol>
<li><strong>核心结构：</strong><ul>
<li><strong>Segment 数组：</strong> <code>ConcurrentHashMap</code> 内部维护一个固定大小的 <code>Segment</code> 数组（默认为 16）。每个 <code>Segment</code> 本质上是一个独立的、线程安全的哈希表（类似于一个小的 <code>ReentrantReadWriteLock</code> 或 <code>ReentrantLock</code> 保护的 <code>HashMap</code>）。</li>
<li><strong>Segment 继承 ReentrantLock：</strong> 每个 <code>Segment</code> 类继承自 <code>ReentrantLock</code>，这意味着每个段拥有自己独立的锁。</li>
<li><strong>HashEntry 数组：</strong> 每个 <code>Segment</code> 内部维护一个 <code>HashEntry</code> 数组（桶数组）。<code>HashEntry</code> 是链表节点，包含 <code>final</code> 的 <code>key</code>、<code>hash</code>、<code>volatile</code> 的 <code>value</code> 和指向下一个节点的 <code>next</code> 指针。<code>value</code> 的 <code>volatile</code> 保证了可见性。</li>
<li><strong>锁粒度：</strong> 锁的粒度是 <strong>段（Segment）</strong>。对同一个段的修改操作（如 <code>put</code>, <code>remove</code>）需要获取该段的锁。不同段上的操作可以并发执行。</li>
</ul>
</li>
<li><strong>关键操作原理：</strong><ul>
<li><strong><code>put(key, value)</code>：</strong><ol>
<li>根据 <code>key</code> 的 <code>hash</code> 计算它属于哪个 <code>Segment</code> (通常用高位哈希位)。</li>
<li>获取该 <code>Segment</code> 的锁。</li>
<li>在 <code>Segment</code> 内部的 <code>HashEntry</code> 数组中找到对应的桶（链表头）。</li>
<li>遍历链表查找是否已存在相同 <code>key</code>：<ul>
<li>存在：更新 <code>value</code> (利用 <code>volatile</code> 写)。</li>
<li>不存在：将新 <code>HashEntry</code> 节点插入链表头部。</li>
</ul>
</li>
<li>释放 <code>Segment</code> 的锁。</li>
</ol>
</li>
<li><strong><code>get(key)</code>：</strong><ol>
<li>根据 <code>key</code> 的 <code>hash</code> 计算它属于哪个 <code>Segment</code>。</li>
<li><strong>不需要获取锁！</strong></li>
<li>根据 <code>hash</code> 定位到该 <code>Segment</code> 内部 <code>HashEntry</code> 数组中的桶。</li>
<li>遍历链表（<code>HashEntry.next</code>）查找匹配的 <code>key</code>。</li>
<li>依赖 <code>HashEntry.value</code> 的 <code>volatile</code> 读保证看到最新值。</li>
</ol>
</li>
<li><strong><code>size()</code>：</strong><ul>
<li>实现相对低效。尝试不加锁地遍历所有 <code>Segment</code>，累加各 <code>Segment</code> 的 <code>modCount</code> (修改计数器) 和 <code>count</code> (元素数量)。</li>
<li>如果连续两次累加过程中发现总的 <code>modCount</code> 没有变化，说明没有发生并发修改，返回累加的 <code>size</code>。</li>
<li>如果多次尝试后 <code>modCount</code> 总在变化（高并发），则最终会<strong>强制锁住所有 <code>Segment</code></strong> 再进行统计，性能开销很大。</li>
</ul>
</li>
<li><strong>扩容 (Rehashing)：</strong><ul>
<li>发生在 <code>Segment</code> 内部。当某个 <code>Segment</code> 的元素数量超过阈值时，仅对该 <code>Segment</code> 内部的 <code>HashEntry</code> 数组进行扩容（通常翻倍），并重新分配链表元素。扩容时需要持有该 <code>Segment</code> 的锁。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Java 7 实现的优缺点：</strong><ul>
<li><strong>优点：</strong> 相比锁住整个 <code>HashMap</code>，分段锁显著提高了并发度（最多允许等于 <code>Segment</code> 数量的线程并发写）。读操作完全无锁，非常快。</li>
<li><strong>缺点：</strong><ul>
<li><strong>锁粒度不够细：</strong> 如果大量写操作恰好落在同一个 <code>Segment</code> 上，该段会成为瓶颈。<code>Segment</code> 数量在创建后固定，无法动态调整。</li>
<li><strong><code>size()</code> 和 <code>containsValue()</code> 低效：</strong> 统计全表或全值操作可能需要全局锁，开销大。</li>
<li><strong>内存开销：</strong> <code>Segment</code> 数组本身和每个 <code>Segment</code> 的结构（锁、计数等）带来额外内存消耗。</li>
<li><strong>链表查询效率：</strong> 冲突严重时，长链表遍历影响 <code>get</code> 性能。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>Java 8 实现 (基于 CAS + <code>synchronized</code> + 红黑树)</strong></p>
<p>Java 8 对 <code>ConcurrentHashMap</code> 进行了彻底重构，摒弃了分段锁模型，采用了更细粒度的锁和现代并发技术。</p>
<ol>
<li><p><strong>核心结构：</strong></p>
<ul>
<li><strong>Node 数组 (Table)：</strong> 只有一个 <code>volatile Node[] table</code>。<code>Node</code> 是链表节点或树节点（<code>TreeNode</code>）的基础类，包含 <code>final</code> 的 <code>key</code> 和 <code>hash</code>，<code>volatile</code> 的 <code>value</code> 和 <code>volatile</code> 的 <code>next</code> 指针（用于链表）。</li>
<li><strong>链表转红黑树：</strong> 当单个桶（链表）中的元素数量超过阈值（默认为 8）<strong>且</strong> 当前 <code>table</code> 的长度大于等于最小树化容量（<code>MIN_TREEIFY_CAPACITY</code>，默认为 64）时，该链表会被转换为 <strong><code>TreeNode</code></strong> 组成的红黑树。这大大提高了高冲突桶的查询效率（O(n) -&gt; O(log n)）。</li>
<li><strong>锁粒度：</strong> 锁的粒度细化到 <strong>单个桶（桶的头节点）</strong>。使用 <code>synchronized</code> 块锁定桶的头节点。</li>
<li><strong>CAS (Compare-And-Swap)：</strong> 大量使用 CAS 操作进行无锁化的状态更新（如 <code>tabAt</code>, <code>casTabAt</code> 访问和修改 <code>table</code> 数组元素；<code>setTabAt</code> 保证 <code>volatile</code> 写），以及 <code>sizeCtl</code> 等控制变量的更新。</li>
<li><strong>ForwardingNode：</strong> 一个特殊的 <code>Node</code> 子类，在扩容（<code>resize</code>）过程中使用。当桶被迁移完毕，会放置一个 <code>ForwardingNode</code> 作为标记，并指向新表。其他线程遇到这个节点时，知道正在扩容，会协助扩容或在新表中查找。</li>
<li><strong>CounterCell：</strong> 用于高效、无竞争地统计元素总数 (<code>size()</code>)，避免全局锁。基于类似 <code>LongAdder</code> 的思想。</li>
</ul>
</li>
<li><p><strong>关键操作原理 (体现优化)：</strong></p>
<ul>
<li><strong><code>put(key, value)</code>：</strong><ol>
<li>计算 <code>key</code> 的 <code>hash</code> (优化了扰动函数)。</li>
<li>如果 <code>table</code> 未初始化，则初始化（使用 <code>sizeCtl</code> 和 CAS 控制并发初始化）。</li>
<li>根据 <code>hash</code> 定位到 <code>table</code> 中的桶 <code>i</code>。</li>
<li><strong>无锁尝试 (CAS)：</strong> 如果桶 <code>i</code> 为空 (<code>null</code>)，尝试用 CAS 将新节点放入桶 <code>i</code>。成功则结束。</li>
<li><strong>特殊状态处理：</strong> 如果桶 <code>i</code> 的头节点是 <code>ForwardingNode</code>，表示正在扩容，当前线程会<strong>协助扩容</strong> (<code>helpTransfer</code>)。</li>
<li><strong>锁定头节点 (<code>synchronized</code>)：</strong> 如果桶 <code>i</code> 不为空且不是 <code>ForwardingNode</code>，则使用 <code>synchronized</code> <strong>锁定该桶的头节点</strong>。<ul>
<li>如果头节点是链表节点：遍历链表查找 <code>key</code>，存在则更新 <code>value</code>；不存在则添加到链表尾部（Java 8 改为尾插法，避免死循环隐患）。</li>
<li>如果头节点是树节点 (<code>TreeNode</code>)：调用红黑树的插入方法。</li>
</ul>
</li>
<li>检查是否需要树化（链表长度 &gt;&#x3D; 8）或解树化（树节点数 &lt;&#x3D; 6）。</li>
<li>释放 <code>synchronized</code> 锁。</li>
<li>检查是否需要扩容（元素总数超过阈值）。</li>
</ol>
</li>
<li><strong><code>get(key)</code>：</strong><ol>
<li>计算 <code>key</code> 的 <code>hash</code>。</li>
<li>根据 <code>hash</code> 定位到 <code>table</code> 中的桶。</li>
<li><strong>完全无锁！</strong></li>
<li>如果桶的头节点就是匹配项，直接返回。</li>
<li>如果头节点 <code>hash &lt; 0</code>，说明是特殊节点：<ul>
<li>如果是 <code>ForwardingNode</code>，则去新表 <code>nextTable</code> 中查找。</li>
<li>如果是 <code>TreeBin</code> (红黑树的包装节点，<code>hash</code> 固定为 <code>-2</code>)，则调用树节点的 <code>find</code> 方法查找。</li>
</ul>
</li>
<li>否则，遍历链表查找。</li>
<li>依赖 <code>Node.value</code> 的 <code>volatile</code> 读保证可见性。</li>
</ol>
</li>
<li><strong><code>size()</code>：</strong><ul>
<li><strong>不再需要全局锁！</strong></li>
<li>尝试直接读取 <code>baseCount</code>（一个基础计数器，通过 CAS 更新）。</li>
<li>如果存在并发竞争（<code>CounterCell</code> 数组不为空），则累加 <code>baseCount</code> 和所有 <code>CounterCell</code> 中的值。<code>CounterCell</code> 通过 <code>@sun.misc.Contended</code> 避免伪共享。</li>
<li>结果是一个<strong>估计值</strong>（<code>sumCount()</code>），因为在累加过程中可能有线程在更新。但对于大多数并发场景，这个估计值足够精确且开销极低。</li>
</ul>
</li>
<li><strong>扩容 (Transfer)：</strong><ul>
<li><strong>多线程协同扩容：</strong> 这是 Java 8 <code>ConcurrentHashMap</code> 最精妙的优化之一。</li>
<li>当需要扩容时，会创建一个新表 <code>nextTable</code>（通常是原表的两倍）。</li>
<li>不是由一个线程完成所有迁移，而是将迁移任务划分为多个**小段 (stride)**。</li>
<li>第一个触发扩容的线程初始化迁移并设置 <code>transferIndex</code> 指向迁移范围的末尾。</li>
<li>后续进行写操作的线程（<code>put</code>, <code>remove</code>）如果发现正在扩容（遇到 <code>ForwardingNode</code>），会<strong>主动协助迁移</strong>一部分桶（领取一段 <code>stride</code> 的任务），然后再执行自己的操作。<code>get</code> 或只读操作不会协助。</li>
<li>使用 <code>ForwardingNode</code> 标记已迁移的桶，引导查找操作到新表。</li>
<li>迁移完成一个桶后，用 <code>ForwardingNode</code> 替换原桶中的节点。</li>
<li>所有桶迁移完成后，用 <code>nextTable</code> 替换 <code>table</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Java 8 的主要优化总结：</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Java 7</th>
<th align="left">Java 8</th>
<th align="left">优化点</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>锁机制</strong></td>
<td align="left">分段锁 (<code>Segment</code>, 继承 <code>ReentrantLock</code>)</td>
<td align="left"><strong>桶级别锁 (<code>synchronized</code>)</strong> + <strong>CAS</strong></td>
<td align="left"><strong>锁粒度更细</strong> (桶 vs 段)，<strong>CAS 无锁化</strong>初始化、计数等，**<code>synchronized</code> 在 JVM 层面持续优化**</td>
</tr>
<tr>
<td align="left"><strong>数据结构</strong></td>
<td align="left"><strong>数组 + 链表</strong> (仅 <code>HashEntry</code>)</td>
<td align="left"><strong>数组 + 链表 + 红黑树</strong> (<code>Node</code> &#x2F; <code>TreeNode</code>)</td>
<td align="left"><strong>树化大幅提升高冲突桶的查询效率</strong> (O(n) -&gt; O(log n))</td>
</tr>
<tr>
<td align="left"><strong><code>size()</code></strong></td>
<td align="left">可能锁全表，低效</td>
<td align="left"><strong>无锁 (<code>baseCount</code> + <code>CounterCell</code>)</strong>, <strong>高并发下高性能、近似值</strong></td>
<td align="left"><strong>避免全局锁，基于分片计数</strong>，读性能极大提升</td>
</tr>
<tr>
<td align="left"><strong>扩容</strong></td>
<td align="left">段内扩容，独立进行</td>
<td align="left"><strong>多线程协同扩容 (协助迁移)</strong></td>
<td align="left"><strong>利用并发加速扩容</strong>，减少扩容带来的停顿</td>
</tr>
<tr>
<td align="left"><strong>内存开销</strong></td>
<td align="left">较高 (<code>Segment</code> 数组及结构)</td>
<td align="left"><strong>更低</strong> (单一 <code>Node</code> 数组，树节点仅在需要时创建)</td>
<td align="left">结构更精简</td>
</tr>
<tr>
<td align="left"><strong>读操作</strong></td>
<td align="left">无锁 (<code>volatile</code> value)</td>
<td align="left"><strong>完全无锁</strong> (利用 <code>volatile</code> 和特殊节点 <code>find</code> 方法)</td>
<td align="left">读性能极高且稳定</td>
</tr>
<tr>
<td align="left"><strong>哈希计算</strong></td>
<td align="left">多次哈希</td>
<td align="left"><strong>优化扰动函数 (简化一次位运算)</strong></td>
<td align="left">计算开销略降</td>
</tr>
<tr>
<td align="left"><strong><code>ForwardingNode</code></strong></td>
<td align="left">无</td>
<td align="left"><strong>有</strong>，用于标记迁移状态和引导查找</td>
<td align="left"><strong>实现无锁读和协助扩容的关键</strong></td>
</tr>
<tr>
<td align="left"><strong><code>CounterCell</code></strong></td>
<td align="left">无</td>
<td align="left"><strong>有</strong>，用于分片计数</td>
<td align="left"><strong>实现高效无锁 <code>size()</code> 的核心</strong></td>
</tr>
</tbody></table>
</li>
</ol>
<p><strong>核心优化思想：</strong></p>
<ol>
<li><strong>更细粒度的锁：</strong> 从段锁到桶锁，显著减少锁竞争。</li>
<li><strong>无锁化：</strong> 广泛使用 CAS 进行轻量级状态更新（初始化、计数），读操作完全无锁。</li>
<li><strong>数据结构升级：</strong> 引入红黑树解决哈希冲突恶化导致的性能问题。</li>
<li><strong>操作并行化：</strong> 多线程协同扩容，将扩容压力分摊，极大缩短扩容时间。</li>
<li><strong>分离计数：</strong> 使用 <code>CounterCell</code> 分片计数消除 <code>size()</code> 的瓶颈。</li>
<li><strong>利用现代 JVM 优化：</strong> 依赖 JVM 对 <code>synchronized</code> 的持续优化（偏向锁、轻量级锁、锁消除、锁膨胀），使其在低竞争场景下性能接近 CAS。</li>
</ol>
<p><strong>结论：</strong></p>
<p>Java 8 的 <code>ConcurrentHashMap</code> 实现是一次巨大的飞跃。它通过采用桶级别 <code>synchronized</code>、CAS、红黑树、多线程协同扩容、分片计数 (<code>CounterCell</code>) 和 <code>ForwardingNode</code> 等关键技术，在锁粒度、并发度、查询效率（尤其是高冲突时）、扩容速度、<code>size()</code> 计算效率和内存开销等方面都带来了显著的优化。它更好地适应了现代多核处理器和高并发场景的需求，是 Java 并发容器库中的典范之作。Java 7 的分段锁实现在当时是巨大的进步，但已被更先进的设计所取代。</p>
<h4 id="为什么-ConcurrentHashMap-比-Hashtable-效率高"><a href="#为什么-ConcurrentHashMap-比-Hashtable-效率高" class="headerlink" title="为什么 ConcurrentHashMap 比 Hashtable 效率高"></a><strong>为什么 <code>ConcurrentHashMap</code> 比 <code>Hashtable</code> 效率高</strong></h4><ul>
<li><strong>锁粒度</strong>：<ul>
<li><code>Hashtable</code>：<strong>全局锁</strong>。锁住整个表，一次只允许一个线程操作。</li>
<li><code>ConcurrentHashMap</code> (JDK7)：分段锁。锁住一个段，不同段操作可并发。</li>
<li><code>ConcurrentHashMap</code> (JDK8)：桶锁 (头节点锁)。锁粒度更细，冲突概率更低，并发度更高。</li>
</ul>
</li>
<li><strong>无锁读</strong>：<ul>
<li><code>Hashtable</code>：读操作也需要获取锁。</li>
<li><code>ConcurrentHashMap</code> (JDK7 &amp; JDK8)：<strong>读操作完全无锁</strong> (JDK7 利用 volatile value，JDK8 利用 volatile val&#x2F;next 和 Unsafe 的原子读)，极大提升读性能。</li>
</ul>
</li>
</ul>
<h3 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h3><h4 id="CompletableFuture的原理与应用"><a href="#CompletableFuture的原理与应用" class="headerlink" title="CompletableFuture的原理与应用"></a><code>CompletableFuture</code>的原理与应用</h4><p><code>CompletableFuture</code> 是 Java 8 引入的核心并发工具类（位于 <code>java.util.concurrent</code> 包），它代表一个<strong>异步计算的结果</strong>。它不仅是对传统 <code>Future</code> 接口的增强，更是一个强大的<strong>异步编程框架</strong>，支持显式地完成计算、链式组合多个异步任务、处理结果和异常，是实现响应式、非阻塞编程的关键组件。</p>
<p><strong>一、核心原理</strong></p>
<ol>
<li><strong>异步执行与结果容器：</strong><ul>
<li>它本质上是一个<strong>容器</strong>，用于承载将来某个时刻计算完成的结果（或异常）。</li>
<li>计算任务通常被提交给 <code>Executor</code>（线程池）在后台线程中执行，避免阻塞调用线程。</li>
<li>创建时结果未知，计算完成后结果被设置（<code>complete(result)</code> 或 <code>completeExceptionally(throwable)</code>）。</li>
</ul>
</li>
<li><strong>显式完成：</strong><ul>
<li>与传统 <code>Future</code> 只能被动等待不同，<code>CompletableFuture</code> 可以被<strong>主动完成</strong>。</li>
<li>任何拥有该对象引用的线程都可以调用 <code>complete()</code> 或 <code>completeExceptionally()</code> 手动设置结果或异常。这是实现超时控制、外部事件触发完成等场景的基础。</li>
</ul>
</li>
<li><strong>链式组合与回调 (CompletionStage)：</strong><ul>
<li><code>CompletableFuture</code> 实现了 <code>CompletionStage</code> 接口，这是其强大能力的核心。</li>
<li><code>CompletionStage</code> 定义了丰富的链式方法（<code>thenApply</code>, <code>thenAccept</code>, <code>thenRun</code>, <code>thenCompose</code>, <code>thenCombine</code>, <code>handle</code>, <code>whenComplete</code>, <code>exceptionally</code> 等）。</li>
<li>这些方法允许你<strong>声明式地</strong>描述：“<strong>当当前阶段完成时，接下来应该做什么</strong>”。回调函数（lambda 表达式或方法引用）会被挂接到当前阶段的完成事件上。</li>
<li>每个链式调用都会返回一个<strong>新的 <code>CompletionStage</code>（通常是另一个 <code>CompletableFuture</code>）</strong>，代表下一个异步步骤。这形成了<strong>异步任务流水线</strong>。</li>
</ul>
</li>
<li><strong>依赖关系与内部状态机：</strong><ul>
<li>当多个 <code>CompletableFuture</code> 通过 <code>thenXxx</code> 方法链接起来时，后续阶段依赖于前驱阶段的完成。</li>
<li><code>CompletableFuture</code> 内部维护一个<strong>状态机</strong>（如 <code>NEW</code>, <code>COMPLETING</code>, <code>NORMAL</code>, <code>EXCEPTIONAL</code>, <code>CANCELLED</code>）和一个<strong>依赖栈</strong>（指向所有依赖于它完成的后续阶段）。</li>
<li>当一个阶段完成时，它会遍历其依赖栈，<strong>尝试触发所有后续阶段</strong>的执行（可能立即执行，也可能提交到线程池）。</li>
</ul>
</li>
<li><strong>非阻塞与事件驱动：</strong><ul>
<li>整个流程是<strong>非阻塞</strong>的。调用 <code>thenXxx</code> 只是注册回调，并不等待前驱完成。主线程可以继续执行其他任务。</li>
<li>执行由<strong>完成事件驱动</strong>：前驱完成 -&gt; 触发回调 -&gt; 执行回调逻辑 -&gt; 完成后继 -&gt; 触发后继的回调…。</li>
</ul>
</li>
<li><strong>组合多个 Future：</strong><ul>
<li>提供 <code>allOf()</code>, <code>anyOf()</code> 等静态方法，用于组合多个独立的 <code>CompletableFuture</code>：<ul>
<li><code>allOf(futures...)</code>: 创建一个新的 Future，当<strong>所有</strong>输入 Future 完成时（无论成功失败），它才完成（本身无结果，需手动获取各Future结果）。</li>
<li><code>anyOf(futures...)</code>: 创建一个新的 Future，当<strong>任意一个</strong>输入 Future 完成时（无论成功失败），它就完成（结果是最先完成的那个Future的结果）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>线程池控制：</strong><ul>
<li>默认情况下，链式调用中后续任务的执行线程由前驱任务的完成线程执行（通常是执行前驱任务的线程或调用 <code>complete</code> 的线程）。</li>
<li>可以使用带有 <code>Executor</code> 参数的变体方法（如 <code>thenApplyAsync(func, executor)</code>）<strong>显式指定</strong>后续任务在特定的线程池中执行，避免线程饥饿或控制资源。</li>
</ul>
</li>
</ol>
<p><strong>二、主要应用场景</strong></p>
<ol>
<li><p><strong>异步任务编排与流水线：</strong> 将复杂的业务逻辑拆分成多个异步步骤，按顺序或条件链式执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; fetchUserData(userId), ioPool) <span class="comment">// 步骤1：IO操作</span></span><br><span class="line">    .thenApply(userData -&gt; processData(userData))              <span class="comment">// 步骤2：CPU密集型处理（默认同线程或ForkJoinPool）</span></span><br><span class="line">    .thenApplyAsync(processedData -&gt; saveToDB(processedData), dbPool) <span class="comment">// 步骤3：另一个IO操作，指定DB线程池</span></span><br><span class="line">    .thenAccept(savedResult -&gt; sendNotification(savedResult))  <span class="comment">// 步骤4：最终处理</span></span><br><span class="line">    .exceptionally(ex -&gt; &#123;                                     <span class="comment">// 统一异常处理</span></span><br><span class="line">        log.error(<span class="string">&quot;Pipeline failed&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> handleFailure(ex);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>并行执行与结果聚合：</strong> 同时发起多个独立任务，等所有&#x2F;任意一个完成后再处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;ResultA&gt; futureA = CompletableFuture.supplyAsync(() -&gt; serviceA.call());</span><br><span class="line">CompletableFuture&lt;ResultB&gt; futureB = CompletableFuture.supplyAsync(() -&gt; serviceB.call());</span><br><span class="line">CompletableFuture&lt;ResultC&gt; futureC = CompletableFuture.supplyAsync(() -&gt; serviceC.call());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等所有任务完成</span></span><br><span class="line">CompletableFuture&lt;Void&gt; allFutures = CompletableFuture.allOf(futureA, futureB, futureC);</span><br><span class="line">allFutures.thenRun(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 手动获取各个结果（此时肯定已完成）</span></span><br><span class="line">    <span class="type">ResultA</span> <span class="variable">a</span> <span class="operator">=</span> futureA.join(); <span class="comment">// 或 get() (需处理异常)</span></span><br><span class="line">    <span class="type">ResultB</span> <span class="variable">b</span> <span class="operator">=</span> futureB.join();</span><br><span class="line">    <span class="type">ResultC</span> <span class="variable">c</span> <span class="operator">=</span> futureC.join();</span><br><span class="line">    aggregateResults(a, b, c);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等任意一个任务完成</span></span><br><span class="line">CompletableFuture&lt;Object&gt; anyFuture = CompletableFuture.anyOf(futureA, futureB, futureC);</span><br><span class="line">anyFuture.thenAccept(result -&gt; handleFirstResult(result));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>结果转换与处理：</strong> 使用 <code>thenApply</code> 将上一步的结果转换成另一种形式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;123&quot;</span>);</span><br><span class="line">CompletableFuture&lt;Integer&gt; intFuture = future.thenApply(Integer::parseInt);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>副作用操作：</strong> 使用 <code>thenAccept</code> 消费结果但不产生新结果（如日志、发送消息），或使用 <code>thenRun</code> 执行不依赖结果的动作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">future.thenAccept(result -&gt; System.out.println(<span class="string">&quot;Result: &quot;</span> + result));</span><br><span class="line">future.thenRun(() -&gt; cleanupResources());</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>组合异步任务：</strong></p>
<ul>
<li><code>thenCompose(Function&lt;T, CompletionStage&lt;U&gt;&gt;)</code>: <strong>扁平化</strong>组合。当前 Future 完成后，用其结果作为输入，<strong>启动并返回另一个 Future</strong> (避免嵌套 <code>CompletableFuture&lt;CompletableFuture&lt;U&gt;&gt;</code>)。</li>
<li><code>thenCombine(CompletionStage&lt;U&gt;, BiFunction&lt;T, U, V&gt;)</code>: 等待<strong>当前 Future 和另一个 Future</strong> 都完成，然后用两者的结果执行一个函数，返回新的 Future。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thenCompose 示例 (获取用户后获取订单)</span></span><br><span class="line">CompletableFuture&lt;User&gt; userFuture = getUserAsync(userId);</span><br><span class="line">CompletableFuture&lt;Order&gt; orderFuture = userFuture.thenCompose(user -&gt; getOrdersAsync(user));</span><br><span class="line"></span><br><span class="line"><span class="comment">// thenCombine 示例 (并行计算价格和库存，然后组合)</span></span><br><span class="line">CompletableFuture&lt;Price&gt; priceFuture = getPriceAsync(productId);</span><br><span class="line">CompletableFuture&lt;Inventory&gt; inventoryFuture = getInventoryAsync(productId);</span><br><span class="line">CompletableFuture&lt;ProductInfo&gt; productInfoFuture = priceFuture.thenCombine(inventoryFuture,</span><br><span class="line">    (price, inventory) -&gt; <span class="keyword">new</span> <span class="title class_">ProductInfo</span>(price, inventory));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>异常处理：</strong></p>
<ul>
<li><code>exceptionally(Function&lt;Throwable, T&gt;)</code>: 捕获异常并提供一个<strong>恢复值</strong>，返回一个正常完成的 Future。</li>
<li><code>handle(BiFunction&lt;T, Throwable, U&gt;)</code>: 无论正常完成还是异常，都会被调用。可以检查结果或异常，并返回一个新结果（或抛出新异常）。</li>
<li><code>whenComplete(BiConsumer&lt;T, Throwable&gt;)</code>: 类似 <code>handle</code>，但它是消费者（不改变结果），用于记录日志、清理等，返回一个结果类型相同的 Future（异常会传播）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">future.exceptionally(ex -&gt; defaultValue) <span class="comment">// 异常时提供默认值</span></span><br><span class="line">     .handle((result, ex) -&gt; &#123;</span><br><span class="line">         <span class="keyword">if</span> (ex != <span class="literal">null</span>) &#123; <span class="keyword">return</span> fallback; &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123; <span class="keyword">return</span> transform(result); &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">     .whenComplete((result, ex) -&gt; &#123;</span><br><span class="line">         <span class="keyword">if</span> (ex != <span class="literal">null</span>) log.error(<span class="string">&quot;Oops&quot;</span>, ex);</span><br><span class="line">         <span class="keyword">else</span> metrics.recordSuccess();</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>超时控制 (Java 9+):</strong> 使用 <code>orTimeout(timeout, timeUnit)</code> 或 <code>completeOnTimeout(value, timeout, timeUnit)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = someLongRunningTask()</span><br><span class="line">    .orTimeout(<span class="number">5</span>, TimeUnit.SECONDS) <span class="comment">// 超时抛出 TimeoutException</span></span><br><span class="line">    .exceptionally(ex -&gt; (ex <span class="keyword">instanceof</span> TimeoutException) ? <span class="string">&quot;Timed out&quot;</span> : <span class="string">&quot;Other error&quot;</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;String&gt; future = someLongRunningTask()</span><br><span class="line">    .completeOnTimeout(<span class="string">&quot;Fallback Value&quot;</span>, <span class="number">5</span>, TimeUnit.SECONDS); <span class="comment">// 超时提供默认值</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>三、关键优势</strong></p>
<ol>
<li><strong>非阻塞异步：</strong> 提高系统吞吐量和响应性。</li>
<li><strong>声明式 &amp; 链式编程：</strong> 代码更简洁、易读、易维护，接近同步代码的风格（避免回调地狱）。</li>
<li><strong>强大的组合能力：</strong> 轻松编排复杂异步工作流（顺序、并行、聚合、条件）。</li>
<li><strong>灵活的异常处理：</strong> 提供多种方式处理异步管道中的错误。</li>
<li><strong>显式完成控制：</strong> 支持手动设置结果，适应更多场景（如超时、外部事件）。</li>
<li><strong>线程池集成：</strong> 可精细控制任务执行位置。</li>
</ol>
<p><strong>四、注意事项与最佳实践</strong></p>
<ol>
<li><strong>避免阻塞：</strong> 不要在 <code>CompletableFuture</code> 的回调方法（如 <code>thenApply</code>, <code>thenAccept</code> 内部）执行长时间阻塞操作，这会卡住执行线程（可能是公共的 ForkJoinPool 线程）。使用 <code>thenApplyAsync</code> 等带 <code>Executor</code> 的方法将阻塞操作提交到专用线程池。</li>
<li><strong>线程池选择：</strong><ul>
<li>CPU 密集型任务：考虑使用 <code>ForkJoinPool.commonPool()</code> (默认) 或固定大小线程池（线程数 ≈ CPU 核心数）。</li>
<li>IO 密集型任务：<strong>务必使用</strong> 足够大的缓存线程池（如 <code>Executors.newCachedThreadPool()</code>）或专门配置的线程池，避免线程饥饿。<strong>强烈推荐为不同资源（如DB、HTTP）使用独立线程池。</strong></li>
</ul>
</li>
<li><strong>异常传播：</strong> 理解异常在链式调用中的传播机制。如果某个阶段抛出异常且未被捕获（如 <code>exceptionally</code>），后续依赖它的 <code>thenApply</code>&#x2F;<code>thenAccept</code> 等<strong>不会被执行</strong>，异常会传递到链的末端或等待 <code>get()</code>&#x2F;<code>join()</code> 时抛出。使用 <code>handle</code>&#x2F;<code>whenComplete</code>&#x2F;<code>exceptionally</code> 妥善处理。</li>
<li><strong>结果获取：</strong><ul>
<li><code>get()</code>: 阻塞等待结果，需处理 <code>InterruptedException</code> 和 <code>ExecutionException</code>（封装了原始异常）。</li>
<li><code>join()</code>: 类似 <code>get()</code>，但抛出未经检查的 <code>CompletionException</code>（其 <code>getCause()</code> 是原始异常）。通常在链的末端或明确知道会很快完成时使用。</li>
<li><strong>尽量使用回调</strong>（<code>thenAccept</code>, <code>thenApply</code>, <code>whenComplete</code>）而非阻塞获取，以保持非阻塞性。</li>
</ul>
</li>
<li><strong>资源清理：</strong> 使用 <code>whenComplete</code> 或 <code>handle</code> 确保资源（如文件句柄、网络连接）在任务完成（无论成功失败）后被正确关闭。</li>
<li><strong>避免过度嵌套：</strong> 虽然链式调用避免回调地狱，但深度嵌套仍可能降低可读性。考虑将复杂步骤抽取成独立方法。</li>
<li><strong>取消传播：</strong> <code>CompletableFuture.cancel(true)</code> 会尝试中断当前正在执行的任务，但<strong>不会自动取消它依赖的或依赖它的其他 Future</strong>。需要手动设计取消逻辑。</li>
</ol>
<p><strong>总结</strong></p>
<p><code>CompletableFuture</code> 是 Java 现代异步编程的基石。它通过<strong>链式组合</strong>、<strong>非阻塞回调</strong>和<strong>显式完成</strong>机制，提供了强大而优雅的方式来构建复杂、高效的异步应用程序。深入理解其原理（状态机、依赖管理）和熟练掌握其 API（<code>supplyAsync</code>, <code>thenXxx</code>, <code>handle</code>, <code>allOf</code>, <code>anyOf</code>, <code>thenCompose</code>, <code>thenCombine</code>, 异常处理）是编写高性能、高响应性 Java 服务的关键。合理使用线程池和遵循最佳实践（避免阻塞回调、妥善处理异常、管理资源）至关重要。</p>
<h4 id="CompletableFuture-和传统的-Future-有什么区别"><a href="#CompletableFuture-和传统的-Future-有什么区别" class="headerlink" title="CompletableFuture 和传统的 Future 有什么区别"></a><strong><code>CompletableFuture</code> 和传统的 <code>Future</code> 有什么区别</strong></h4><ul>
<li>考察点：理解其核心优势（链式编程、组合能力、手动完成、异常处理）。</li>
<li>期望回答：<code>Future</code> 仅支持阻塞获取结果或轮询，无法组合；<code>CompletableFuture</code> 实现了 <code>CompletionStage</code>，支持非阻塞回调、任务链式组合、手动设置结果&#x2F;异常、更强大的异常处理。</li>
</ul>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h3><p>内存区域（堆、栈、方法区&#x2F;元空间、程序计数器、本地方法栈）及其作用。</p>
<h4 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h4><table>
<thead>
<tr>
<th><strong>内存区域</strong></th>
<th><strong>描述</strong></th>
<th><strong>线程共享性</strong></th>
<th><strong>异常触发条件</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>程序计数器（PC）</strong></td>
<td>记录当前线程执行的字节码指令地址，线程私有，唯一无OOM的区域。</td>
<td>线程私有</td>
<td>无（不会抛出内存相关异常）</td>
</tr>
<tr>
<td><strong>虚拟机栈（Java Stack）</strong></td>
<td>存储方法调用的栈帧（局部变量表、操作数栈、动态链接、方法出口等），线程私有。</td>
<td>线程私有</td>
<td><code>StackOverflowError</code>（栈深度溢出） <code>OutOfMemoryError</code>（无法扩展栈空间）</td>
</tr>
<tr>
<td><strong>本地方法栈（Native Stack）</strong></td>
<td>为Native方法（如C&#x2F;C++实现的方法）提供栈空间，线程私有。</td>
<td>线程私有</td>
<td>同虚拟机栈</td>
</tr>
<tr>
<td><strong>堆（Heap）</strong></td>
<td>存放对象实例和数组，所有线程共享，是垃圾回收的主要区域。</td>
<td>线程共享</td>
<td><code>OutOfMemoryError</code>（堆内存不足）</td>
</tr>
<tr>
<td><strong>方法区（Method Area）</strong></td>
<td>存储类信息、常量、静态变量、即时编译器代码等数据。JDK 8后由元空间（Metaspace）实现。</td>
<td>线程共享</td>
<td><code>OutOfMemoryError</code>（元空间&#x2F;方法区内存不足）</td>
</tr>
</tbody></table>
<h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><p>类加载机制（加载、验证、准备、解析、初始化）、类加载器（双亲委派模型及打破场景）、字节码指令。</p>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><p>垃圾收集算法（标记-清除、标记-整理、复制）和主流垃圾收集器（Serial, Parallel, CMS, G1, ZGC, Shenandoah）的工作原理、优缺点、适用场景和调优参数。</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>步骤</th>
<th>特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>标记-清除（Mark-Sweep）</strong></td>
<td>1. <strong>标记</strong>：遍历所有对象，标记存活对象。 2. <strong>清除</strong>：回收未被标记的对象（垃圾）。</td>
<td><strong>优点</strong>：实现简单，不需要移动对象。 <strong>缺点</strong>：产生内存碎片，可能触发频繁的 Full GC。</td>
<td>1. 老年代回收（如 CMS 收集器的初始阶段）。 2. 对内存碎片不敏感的场景，或短期运行的应用程序。</td>
</tr>
<tr>
<td><strong>复制算法（Copying）</strong></td>
<td>1. 将内存分为两块（From 和 To），对象分配在 From 区。 2. 标记存活对象，将其复制到 To 区。 3. 清空 From 区，交换 From 和 To 的角色。</td>
<td><strong>优点</strong>：无内存碎片，回收高效。 <strong>缺点</strong>：内存利用率低（需预留一半空间）。</td>
<td>1. 新生代回收（如 Serial、ParNew、Parallel Scavenge 等收集器）。 2. 适用于对象存活率低的场景（如新生代 Eden 区）。</td>
</tr>
<tr>
<td><strong>标记-整理（Mark-Compact）</strong></td>
<td><strong>标记</strong>：遍历所有对象，标记存活对象。 <strong>整理</strong>：将存活对象向内存一端移动，清理边界外的空间。</td>
<td><strong>优点</strong>：避免内存碎片，适合长期运行的系统。 <strong>缺点</strong>：移动对象需要时间，导致停顿较长（STW）。</td>
<td>1. 老年代回收（如 Serial Old、Parallel Old 收集器）。 2. 对内存敏感且需要避免碎片的场景（如大数据应用）。</td>
</tr>
</tbody></table>
<h3 id="性能监控与调优"><a href="#性能监控与调优" class="headerlink" title="性能监控与调优"></a>性能监控与调优</h3><p>熟练使用 <code>jps</code>, <code>jstat</code>, <code>jmap</code>, <code>jstack</code>, <code>jcmd</code>, <code>jconsole</code>, <code>VisualVM</code>, 以及更强大的 <code>Java Flight Recorder</code> 和 <code>Mission Control</code>。理解 GC 日志分析。掌握常见性能问题（内存泄漏、OOM、CPU 飙高、线程阻塞）的诊断思路和工具链。</p>
<h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><p>类加载的过程包括了<strong>加载、验证、准备、解析、初始化</strong>五个阶段。</p>
<h4 id="哪些场景会触发类的加载"><a href="#哪些场景会触发类的加载" class="headerlink" title="哪些场景会触发类的加载"></a>哪些场景会触发类的加载</h4><ul>
<li>类的实例化</li>
<li>访问类的静态成员</li>
<li>调用类的静态方法</li>
<li><code>Class.forName()</code>、<code>ClassLoader.loadClass()</code>等反射方法</li>
<li>加载子类时会加载父类</li>
</ul>
<h4 id="Class-forName-和ClassLoader-loadClass-有什么区别"><a href="#Class-forName-和ClassLoader-loadClass-有什么区别" class="headerlink" title="Class.forName()和ClassLoader.loadClass()有什么区别"></a><code>Class.forName()</code>和<code>ClassLoader.loadClass()</code>有什么区别</h4><ul>
<li><code>Class.forName()</code>: 将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li>
<li><code>ClassLoader.loadClass()</code>: 只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li>
<li><code>Class.forName(name, initialize, loader)</code>带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。</li>
</ul>
<h4 id="类加载器的层次结构"><a href="#类加载器的层次结构" class="headerlink" title="类加载器的层次结构"></a>类加载器的层次结构</h4><p>类加载器层级结构：</p>
<table>
<thead>
<tr>
<th><strong>类加载器</strong></th>
<th><strong>加载路径</strong></th>
<th><strong>父加载器</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Bootstrap ClassLoader</strong></td>
<td><code>JRE/lib/rt.jar</code>等核心库</td>
<td>无（顶级加载器）</td>
</tr>
<tr>
<td><strong>Extension ClassLoader</strong></td>
<td><code>JRE/lib/ext</code>目录下扩展库</td>
<td>Bootstrap</td>
</tr>
<tr>
<td><strong>Application ClassLoader</strong></td>
<td>应用类路径（ClassPath）</td>
<td>Extension</td>
</tr>
<tr>
<td><strong>自定义ClassLoader</strong></td>
<td>用户自定义路径</td>
<td>Application</td>
</tr>
</tbody></table>
<h4 id="什么是双亲委派模型"><a href="#什么是双亲委派模型" class="headerlink" title="什么是双亲委派模型"></a>什么是双亲委派模型</h4><p>双亲委派模型（Parent Delegation Model）是Java类加载机制中的一种设计模式，用于控制类的加载顺序和避免类的重复加载。在双亲委派模型中，类加载器会按照一定的顺序进行类的加载，并将加载请求委派给父类加载器，只有在父类加载器找不到类的情况下，才会由子类加载器进行加载。</p>
<p><strong>双亲委派模型的优点</strong></p>
<ol>
<li>避免类的重复加载：由于类加载器会先委派给父类加载器进行加载，所以可以避免同一个类被多个类加载器重复加载，从而节省内存和提高性能。</li>
<li>安全性：核心类库通常由启动类加载器加载，而自定义类通常由应用程序类加载器加载，这样可以保证核心类库的安全性，防止被恶意代码替代。</li>
<li>模块化：通过使用不同的类加载器，可以实现类的模块化和隔离，从而在复杂的应用程序中实现类的共享和复用。</li>
</ol>
<p><strong>双亲委派模型的缺点</strong></p>
<ol>
<li>灵活性受限：双亲委派模型限制了类加载器的灵活性，可能导致在某些特定的场景中无法实现自定义的类加载行为。例如，在某些需要在运行时动态生成类或加载非标准格式的类文件的场景中，双亲委派模型可能会受限。</li>
<li>不适合某些类加载场景：在某些场景中，双亲委派模型可能并不适合，例如在OSGi（Open Service Gateway Initiative）等动态模块化系统中，需要实现更为复杂的类加载策略，而双亲委派模型可能不足以满足需求。</li>
<li>类冲突：在某些情况下，由于双亲委派模型的存在，可能会导致类的冲突问题。例如，如果应用程序中存在多个版本的同一个类，并且使用了不同的类加载器加载，可能会导致类加载冲突，从而导致程序出现错误或异常。</li>
<li>性能开销：由于每次类加载都会委派给父类加载器，这可能导致多层级的类加载链，从而增加了类加载的时间和性能开销。特别是在某些大型复杂的应用程序中，可能会出现类加载性能瓶颈。</li>
</ol>
<p><strong>如何打破双亲委派模型</strong></p>
<p>在Java中，可以通过以下几种方式来打破双亲委派模型，实现自定义的类加载行为：</p>
<ol>
<li>自定义类加载器：可以继承java.lang.ClassLoader类，并实现自定义的类加载逻辑，从而绕过双亲委派模型。<strong>通过重写ClassLoader的loadClass()方法，可以在类加载过程中自定义加载规则</strong>，例如先尝试自定义加载，如果失败再委派给父类加载器。</li>
<li>使用Java的扩展类加载器：<strong>Java的扩展类加载器（Extension ClassLoader）并不遵循双亲委派模型，它在加载Java扩展库时不会委派给父类加载器</strong>。因此，可以将自定义的类放置在Java扩展库中，并使用扩展类加载器加载这些类，从而实现对双亲委派模型的绕过。</li>
<li>使用线程上下文类加载器：Java中的线程上下文类加载器（Thread Context ClassLoader）是一种特殊的类加载器，可以在程序运行时动态设置，从而在某个特定线程中绕过双亲委派模型。通过设置线程上下文类加载器，可以使特定线程加载指定的类，而不受双亲委派模型的限制。</li>
</ol>
<h4 id="loadClass-和-findClass-有什么区别"><a href="#loadClass-和-findClass-有什么区别" class="headerlink" title="loadClass 和 findClass() 有什么区别"></a><code>loadClass</code> 和 <code>findClass()</code> 有什么区别</h4><table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><code>loadClass()</code></th>
<th align="left"><code>findClass()</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>职责</strong></td>
<td align="left">控制加载流程（委派机制）</td>
<td align="left">实现具体加载逻辑</td>
</tr>
<tr>
<td align="left"><strong>重写必要性</strong></td>
<td align="left">通常不重写（保持委派模型）</td>
<td align="left">自定义类加载器时<strong>必须重写</strong></td>
</tr>
<tr>
<td align="left"><strong>双亲委派角色</strong></td>
<td align="left">实现委派逻辑</td>
<td align="left">被委派机制调用</td>
</tr>
<tr>
<td align="left"><strong>典型用途</strong></td>
<td align="left">类加载入口（<code>ClassLoader.loadClass()</code>）</td>
<td align="left">自定义类加载器时扩展资源获取方式</td>
</tr>
</tbody></table>
<p><strong>最佳实践</strong></p>
<ol>
<li><p><strong>自定义类加载器</strong>：<br>只需重写 <code>findClass()</code>（保持双亲委派），<strong>无需</strong>重写 <code>loadClass()</code>。</p>
<p>java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class CustomLoader extends ClassLoader &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) &#123;</span><br><span class="line">        // 自定义加载逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>破坏双亲委派</strong>：<br>需重写 <code>loadClass()</code>（谨慎使用，如 JDBC&#x2F;JNDI 等场景）。</p>
</li>
</ol>
<img src="/post/7992e236/image-20250725203542235.png" class="" title="image-20250725203542235">

<p><code>loadClass()</code> 是框架流程控制者，<code>findClass()</code> 是实际加载逻辑的实现者。自定义类加载优先扩展 <code>findClass()</code>。</p>
<h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><h4 id="JVM-的新生代划为什么分为一个-Eden-区和两个-Survivor-区"><a href="#JVM-的新生代划为什么分为一个-Eden-区和两个-Survivor-区" class="headerlink" title="JVM 的新生代划为什么分为一个 Eden 区和两个 Survivor 区"></a>JVM 的新生代划为什么分为一个 Eden 区和两个 Survivor 区</h4><p>JVM 的新生代划分为一个 Eden 区和两个 Survivor 区（通常称为 S0 和 S1，或者 From Survivor 和 To Survivor），主要是为了<strong>高效地管理短暂存活的对象，并优化垃圾回收（尤其是 Minor GC）的性能</strong>。这种设计核心在于利用了<strong>复制算法</strong>的优势，同时解决了复制算法在单块 Survivor 空间下的主要问题。</p>
<p>以下是详细的原因分析：</p>
<ol>
<li><strong>利用分代假说（Generational Hypothesis）</strong>：<ul>
<li>绝大多数对象都是“朝生夕死”的，在分配后很快变得不可达。</li>
<li>Eden 区是对象<strong>诞生</strong>的地方。几乎所有新对象都在 Eden 区分配。</li>
<li>将新生代的大部分空间分配给 Eden 区（默认比例通常是 8:1:1），可以容纳大量新创建的对象，减少频繁触发 Minor GC。</li>
</ul>
</li>
<li><strong>高效实施复制算法（Copying Algorithm）</strong>：<ul>
<li>新生代垃圾回收（Minor GC）主要使用<strong>复制算法</strong>。该算法的核心思想是：将存活的对象从一个内存区域复制到另一个空的内存区域，然后一次性清理掉原区域的整个空间。</li>
<li><strong>优点</strong>：简单高效，没有内存碎片，回收速度快（只需要移动存活对象，不需要扫描和标记死亡对象）。</li>
<li><strong>关键需求</strong>：复制算法需要一个<strong>完全空闲的目标区域</strong>来接收存活对象。</li>
</ul>
</li>
<li><strong>解决单块 Survivor 空间的问题（核心原因）</strong>：<ul>
<li>假设只有一个 Survivor 区（S）。一次 Minor GC 后：<ol>
<li>Eden 区存活的对象需要复制到 S 区。</li>
<li>此时 S 区可能已经存放了上次 GC 存活下来的对象（年龄小于晋升阈值的）。</li>
<li>现在需要将 Eden + S 区的所有存活对象都复制到一个地方。如果只有一个 S 区，那么<strong>这个 S 区既是源又是目标</strong>，这显然是不可能的（源数据会被覆盖）。</li>
</ol>
</li>
<li>即使忽略上面的逻辑矛盾，如果只有一个较大的 Survivor 区，每次 GC 时都需要将其中的存活对象和 Eden 的存活对象一起复制到另一个地方（比如老年代），这会：<ul>
<li><strong>导致对象过早晋升</strong>：很多本应在新生代经历几次 GC 才死亡的对象，因为 Survivor 空间不足（或设计限制）被直接提升到老年代，增加了老年代 GC 的压力。</li>
<li><strong>降低复制算法效率</strong>：无法利用 Survivor 区来暂存存活对象进行多次筛选。</li>
<li><strong>增加内存碎片</strong>：如果复制到老年代，老年代使用的通常是标记-清除或标记-整理算法，更容易产生碎片。</li>
</ul>
</li>
</ul>
</li>
<li><strong>双 Survivor 区的解决方案（轮转复制）</strong>：<ul>
<li>设计两个较小的 Survivor 区（S0 和 S1，通常各占新生代的 10%，与 Eden 的 80% 构成 8:1:1）。</li>
<li>在任何时候，<strong>总有一个 Survivor 区是空的（To Survivor）</strong>。</li>
<li><strong>Minor GC 过程</strong>：<ol>
<li><strong>标记</strong>：标记 Eden 区和当前非空的 Survivor 区（From Survivor，假设是 S0）中所有存活的对象。</li>
<li><strong>复制</strong>：将所有存活的对象<strong>复制</strong>到空的 Survivor 区（To Survivor，假设是 S1）。在复制过程中：<ul>
<li>对象的<strong>年龄（Age）</strong> 会增加 1。</li>
<li>如果某个对象的年龄达到了设定的阈值（默认为 15，可通过 <code>-XX:MaxTenuringThreshold</code> 调整），或者 To Survivor 区空间不足以容纳所有存活对象，这些对象会被直接<strong>晋升（Promote）</strong> 到老年代。</li>
</ul>
</li>
<li><strong>清空</strong>：一次性清空 Eden 区和刚刚作为来源的 Survivor 区（S0）。</li>
<li><strong>角色互换</strong>：现在 S1 成为了存放存活对象的 From Survivor，而清空的 S0 则成为下一次 GC 的 To Survivor（即空的 Survivor）。</li>
</ol>
</li>
<li><strong>关键优势</strong>：<ul>
<li><strong>始终有空的 To Survivor</strong>：为复制算法提供了必需的目标空间。</li>
<li><strong>对象年龄增长</strong>：在两个 Survivor 区之间多次复制（Minor GC）的过程，自然地实现了对象年龄的增长，为基于年龄的晋升策略提供了基础。</li>
<li><strong>延迟晋升</strong>：大部分对象会在 Eden 和 Survivor 区之间经历几次 GC 后被回收掉，只有真正“长寿”的对象才会晋升到老年代，减少了老年代 GC 的压力。</li>
<li><strong>避免碎片</strong>：复制算法保证了 Survivor 区内总是紧凑排列的存活对象，没有内存碎片。</li>
<li><strong>高效回收 Eden</strong>：只需简单地清空整个 Eden 区，回收速度极快。</li>
</ul>
</li>
</ul>
</li>
<li><strong>空间利用率与权衡</strong>：<ul>
<li>两个较小的 Survivor 区（各 10%）相比一个较大的 Survivor 区（比如 20%），在空间利用率上似乎有损失（总有 10% 是空的）。</li>
<li>但这种牺牲是值得的：<ul>
<li>它换来了复制算法的核心优势（无碎片、高效回收 Eden）。</li>
<li>它有效实现了基于年龄的对象筛选，大大减少了不必要的晋升。</li>
<li>空着的那个 Survivor 区是算法运行的必要条件，不能算浪费。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>总结：</strong></p>
<p>将新生代划分为一个较大的 Eden 区和两个较小的 Survivor 区（S0 和 S1），是为了完美适配<strong>复制算法</strong>进行高效的 Minor GC：</p>
<ol>
<li><strong>Eden 区</strong>：容纳大量新创建的对象，利用“对象朝生夕死”的特性。</li>
<li><strong>双 Survivor 区（S0 &amp; S1）</strong>：提供轮转机制。<ul>
<li>确保<strong>始终有一个空的 Survivor（To）</strong> 作为复制算法的目标区域。</li>
<li>在 Eden 和 From Survivor 的存活对象复制到 To Survivor 的过程中：<ul>
<li>实现<strong>对象年龄增长</strong>。</li>
<li>筛选出达到年龄阈值或空间不足的对象<strong>晋升到老年代</strong>。</li>
</ul>
</li>
<li>复制完成后，一次性清空 Eden 和 From Survivor，交换 From&#x2F;To 角色。</li>
<li>避免了单 Survivor 区的逻辑矛盾、过早晋升和碎片问题。</li>
</ul>
</li>
</ol>
<p>这种设计是 HotSpot JVM（以及其他许多 JVM）实现高效新生代垃圾回收的基石。虽然现代垃圾收集器（如 G1, ZGC, Shenandoah）在内存布局上有所不同，但它们解决新生代对象管理的核心思想（快速分配、高效回收短暂对象、延迟晋升）仍然是相通的，双 Survivor 区的设计很好地体现了这些原则。</p>
<h4 id="运行时常量池和字符串常量池有什么区别"><a href="#运行时常量池和字符串常量池有什么区别" class="headerlink" title="运行时常量池和字符串常量池有什么区别"></a>运行时常量池和字符串常量池有什么区别</h4><p>在JVM中，常量池分为两部分：<strong>运行时常量池</strong>和<strong>字符串常量池</strong>（String Pool，也称为String Table）。</p>
<ul>
<li><p><strong>运行时常量池</strong>：属于方法区的一部分。在JDK1.7之前，方法区位于永久代（PermGen）中；从JDK1.7开始，字符串常量池被移动到堆中；而到了JDK1.8，永久代被元空间（Metaspace）取代，运行时常量池也随之移到了元空间。但是，元空间并不在虚拟机内存中，而是使用本地内存。</p>
</li>
<li><p><strong>字符串常量池</strong>：在JDK1.7之前位于方法区（永久代），从JDK1.7开始被移动到堆中（Heap）。所以，在JDK1.7及之后的版本中，字符串常量池位于堆内存中。</p>
</li>
</ul>
<p>因此，针对不同版本的JDK，常量池的位置有所不同：</p>
<ul>
<li><p>JDK1.6及之前：运行时常量池（包括字符串常量池）在方法区（永久代）。</p>
</li>
<li><p>JDK1.7：运行时常量池仍在方法区（但方法区开始逐步移除永久代，使用元空间的前身），而字符串常量池被移动到堆中。</p>
</li>
<li><p>JDK1.8及之后：运行时常量池在元空间（Metaspace，使用本地内存），字符串常量池在堆中。</p>
</li>
</ul>
<p>StringTable 在 jdk1.6 之前，是方法区中运行时常量池的一部分， jdk1.7 之后移到了堆中。</p>
<p>在 jdk1.6 之前，full GC 才会触发永久代的垃圾回收，回收效率很低，如果有大量字符串放入 StringTable，容易导致永久代内存溢出。</p>
<p>StringTable 放入堆中之后，只要有 minor GC，就会触发 StringTable 的垃圾回收，减少了无用字符串常量对内存的占用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk8</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringPool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>); <span class="comment">// s1 指向堆中的 &quot;ab&quot;</span></span><br><span class="line">        s1.intern(); <span class="comment">// 在 StringTable 中放入堆中 &quot;ab&quot; 的地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// s2 存的地址就是 StringTable 中指向堆中 &quot;ab&quot; 的地址，即 s2 也指向堆中的 &quot;ab&quot;</span></span><br><span class="line">        System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jdk6</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringPool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>); <span class="comment">// s1 指向堆中的 &quot;ab&quot;</span></span><br><span class="line">        s1.intern(); <span class="comment">// 在 StringTable 创建 &quot;ab&quot;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// s2 指向 StringTable 中的 &quot;ab&quot;</span></span><br><span class="line">        System.out.println(s1 == s2); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="String-s-new-String-a-new-String-a-一共创建几个对象"><a href="#String-s-new-String-a-new-String-a-一共创建几个对象" class="headerlink" title="String s = new String(&quot;a&quot;) + new String(&quot;a&quot;) 一共创建几个对象"></a><code>String s = new String(&quot;a&quot;) + new String(&quot;a&quot;)</code> 一共创建几个对象</h4><h4 id="什么情况下会触发StackOverflowError和OutOfMemoryError"><a href="#什么情况下会触发StackOverflowError和OutOfMemoryError" class="headerlink" title="什么情况下会触发StackOverflowError和OutOfMemoryError"></a>什么情况下会触发StackOverflowError和OutOfMemoryError</h4><p><strong>触发StackOverflowError</strong></p>
<ul>
<li><p><strong>无限递归</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class StackOverflowExample &#123;</span><br><span class="line">    public static void recursiveMethod() &#123;</span><br><span class="line">        recursiveMethod(); // 无限递归调用</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        recursiveMethod(); // 触发StackOverflowError</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次方法调用都会在虚拟机栈中压入新栈帧，超出栈的最大深度限制（默认1MB，可通过<code>-Xss</code>调整）。</p>
</li>
<li><p>栈帧过大（局部变量过多或方法操作数栈过深）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void largeMethod() &#123;</span><br><span class="line">    int a1, a2, a3, ..., a10000; // 大量局部变量占用栈空间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单个栈帧占用的内存超过栈容量。</p>
</li>
</ul>
<p><strong>触发OutOfMemoryError</strong></p>
<ul>
<li><p><strong>堆内存溢出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 不断创建大对象，耗尽堆内存</span><br><span class="line">List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">while (true) &#123;</span><br><span class="line">    list.add(new byte[1024 * 1024]); // 每次分配1MB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原因</strong>：对象数量超过堆容量（可通过<code>-Xmx</code>和<code>-Xms</code>调整堆大小）。</p>
<p><strong>典型场景</strong>：内存泄漏（如静态集合未释放对象）或合理内存不足。</p>
</li>
<li><p><strong>方法区&#x2F;元空间溢出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 动态生成大量类（如使用CGLIB）</span><br><span class="line">public class MetaspaceOOM &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Enhancer enhancer = new Enhancer();</span><br><span class="line">        enhancer.setSuperclass(OOMObject.class);</span><br><span class="line">        enhancer.setCallback((MethodInterceptor) (obj, method, args1, proxy) -&gt; proxy.invokeSuper(obj, args1));</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            enhancer.create(); // 持续生成代理类</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static class OOMObject &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原因</strong>：加载的类数量或元数据量超过元空间容量（通过<code>-XX:MaxMetaspaceSize</code>设置上限）。</p>
<p><strong>典型场景</strong>：动态代理框架（如Spring AOP）、反射滥用。</p>
</li>
<li><p><strong>虚拟机栈或本地方法栈无法扩展</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 启动大量线程，每个线程的栈空间无法分配</span><br><span class="line">public class ThreadOOM &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                try &#123; Thread.sleep(1000000); &#125; catch (InterruptedException e) &#123;&#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原因</strong>：线程数量过多导致栈总内存超过系统限制（通过<code>-Xss</code>减少单个线程栈大小）。</p>
</li>
</ul>
<p><strong>总结</strong></p>
<table>
<thead>
<tr>
<th><strong>错误类型</strong></th>
<th><strong>触发场景</strong></th>
<th><strong>典型原因</strong></th>
<th><strong>解决方案</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>StackOverflowError</strong></td>
<td>递归调用未终止、栈帧过大</td>
<td>代码逻辑错误</td>
<td>修复递归终止条件，减少局部变量数量</td>
</tr>
<tr>
<td><strong>OutOfMemoryError</strong></td>
<td>堆内存不足、元空间溢出、线程数过多</td>
<td>内存泄漏、配置不当、资源耗尽</td>
<td>调整JVM参数，优化代码，增加物理内存</td>
</tr>
</tbody></table>
<h4 id="永久代和元空间的区别"><a href="#永久代和元空间的区别" class="headerlink" title="永久代和元空间的区别"></a>永久代和元空间的区别</h4><h4 id="堆内存是怎么细分的"><a href="#堆内存是怎么细分的" class="headerlink" title="堆内存是怎么细分的"></a>堆内存是怎么细分的</h4><h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><h4 id="如何定位内存溢出问题"><a href="#如何定位内存溢出问题" class="headerlink" title="如何定位内存溢出问题"></a>如何定位内存溢出问题</h4><p><strong>快速识别症状</strong></p>
<ol>
<li><strong>监控告警</strong>：<ul>
<li>JVM：<code>Heap usage &gt; 90%</code>，频繁Full GC但回收效果差。</li>
<li>系统级：<code>top</code>&#x2F;<code>htop</code> 显示进程内存持续增长不释放。</li>
</ul>
</li>
<li><strong>错误日志</strong>：<ul>
<li><code>java.lang.OutOfMemoryError: Java heap space</code>（堆溢出）</li>
<li><code>java.lang.OutOfMemoryError: Metaspace</code>（元空间溢出）</li>
<li><code>java.lang.OutOfMemoryError: Unable to create new native thread</code>（线程数超限）</li>
</ul>
</li>
</ol>
<p><strong>获取内存快照（Heap Dump）</strong></p>
<blockquote>
<p><strong>关键动作：在OOM发生时自动保存Dump，避免重启后丢失现场</strong></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># JVM启动参数添加</span></span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError </span><br><span class="line">-XX:HeapDumpPath=/path/to/dump.hprof</span><br></pre></td></tr></table></figure>

<p><strong>分析堆转储文件（关键步骤）</strong></p>
<ol>
<li><p><strong>Eclipse MAT (Memory Analyzer Tool)</strong></p>
<ul>
<li>优势：可视化分析，自动检测泄漏疑点。</li>
<li>步骤：<ul>
<li>打开 <code>dump.hprof</code> 文件。</li>
<li>查看 <strong>Leak Suspects Report</strong>（泄漏嫌疑对象）。</li>
<li>分析 <strong>Dominator Tree</strong> 找到占用最大的对象。</li>
<li>检查 <strong>Path to GC Roots</strong> 查看引用链。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>VisualVM</strong></p>
<ul>
<li>适用场景：实时监控+离线分析。</li>
<li>功能：堆转储的 <strong>Classes</strong> 视图按实例数排序，定位异常类。</li>
</ul>
</li>
<li><p><strong>命令行工具（快速排查）</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 检查堆内对象统计</span></span><br><span class="line">jmap -histo:live &lt;pid&gt; | <span class="built_in">head</span> -n 20</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 分析堆转储（文本模式）</span></span><br><span class="line">jhat dump.hprof  <span class="comment"># 访问 http://localhost:7000</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>排查常见内存泄漏场景</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>泄漏类型</strong></th>
<th align="left"><strong>典型代码案例</strong></th>
<th align="left"><strong>分析线索</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>集合类泄漏</strong></td>
<td align="left"><code>static Map</code> 缓存无清理逻辑</td>
<td align="left">HashMap&#x2F;ArrayList 占主导</td>
</tr>
<tr>
<td align="left"><strong>未关闭资源</strong></td>
<td align="left">未关闭的 <code>FileInputStream</code>、<code>Connection</code></td>
<td align="left">Finalizer 队列堆积</td>
</tr>
<tr>
<td align="left"><strong>线程局部变量</strong></td>
<td align="left"><code>ThreadLocal</code> 未调用 <code>remove()</code></td>
<td align="left">线程池中ThreadLocal对象累积</td>
</tr>
<tr>
<td align="left"><strong>监听器未注销</strong></td>
<td align="left">注册后未移除的事件监听器</td>
<td align="left">监听器对象持有外部引用</td>
</tr>
<tr>
<td align="left"><strong>元空间溢出</strong></td>
<td align="left">动态生成类（如CGLib）</td>
<td align="left">Metaspace 使用量持续增长</td>
</tr>
</tbody></table>
<p><strong>案例</strong></p>
<p>以下是一个高度真实的内存溢出案例，模拟了常见的<strong>缓存无限增长</strong>场景。该案例通过静态Map存储用户数据，并配合后台线程持续加载，同时缺乏过期机制，最终导致堆内存溢出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemoryLeakSimulator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态缓存Map - 典型的内存泄漏根源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Long, UserProfile&gt; USER_CACHE = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟后台缓存加载线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===== 内存泄漏模拟程序启动 =====&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 初始化定时任务：每秒添加100个用户到缓存</span></span><br><span class="line">        executor.scheduleAtFixedRate(() -&gt; loadUsersToCache(), <span class="number">0</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 模拟访问缓存（加速内存增长）</span></span><br><span class="line">        executor.scheduleAtFixedRate(() -&gt; accessCache(), <span class="number">0</span>, <span class="number">300</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 添加JVM关闭钩子（用于资源清理）</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            executor.shutdown();</span><br><span class="line">            System.out.println(<span class="string">&quot;===== 程序关闭 =====&quot;</span>);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟用户数据加载到缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loadUsersToCache</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">userId</span> <span class="operator">=</span> System.nanoTime(); <span class="comment">// 使用时间戳模拟用户ID</span></span><br><span class="line">            USER_CACHE.put(userId, <span class="keyword">new</span> <span class="title class_">UserProfile</span>(</span><br><span class="line">                userId,</span><br><span class="line">                <span class="string">&quot;user-&quot;</span> + UUID.randomUUID(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">50</span>] <span class="comment">// 每个用户分配50KB数据（模拟用户信息）</span></span><br><span class="line">            ));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;【缓存加载】当前缓存用户数: %,d 占用内存: ≈%,dMB\n&quot;</span>,</span><br><span class="line">            USER_CACHE.size(),</span><br><span class="line">            (USER_CACHE.size() * <span class="number">50</span>) / <span class="number">1024</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟缓存访问（增加对象引用复杂度）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">accessCache</span><span class="params">()</span> &#123;</span><br><span class="line">        USER_CACHE.forEach((id, profile) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 模拟业务处理（实际中可能包含复杂逻辑）</span></span><br><span class="line">            <span class="keyword">if</span> (id % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                profile.updateLastAccessTime();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户信息类（包含大对象）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserProfile</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">long</span> userId;</span><br><span class="line">        <span class="keyword">private</span> String userName;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span>[] userData; <span class="comment">// 大对象</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">long</span> lastAccessTime;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">UserProfile</span><span class="params">(<span class="type">long</span> userId, String userName, <span class="type">byte</span>[] userData)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.userId = userId;</span><br><span class="line">            <span class="built_in">this</span>.userName = userName;</span><br><span class="line">            <span class="built_in">this</span>.userData = userData;</span><br><span class="line">            <span class="built_in">this</span>.lastAccessTime = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateLastAccessTime</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.lastAccessTime = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键设计说明（真实漏洞点）</strong>：</p>
<ol>
<li><strong>静态Map缓存</strong>（<code>USER_CACHE</code>）<ul>
<li>生命周期与JVM相同，永远不会被回收</li>
<li>使用<code>ConcurrentHashMap</code>模拟真实高并发场景</li>
</ul>
</li>
<li><strong>定时加载线程</strong><ul>
<li>每秒添加100个新用户（约5MB&#x2F;秒）</li>
<li>每个用户对象包含50KB数据（模拟用户信息、图片等）</li>
</ul>
</li>
<li><strong>缓存访问模式</strong><ul>
<li>高频访问缓存（每300ms遍历一次）</li>
<li>更新对象字段（增加GC Roots引用链复杂度）</li>
</ul>
</li>
<li><strong>大对象设计</strong><ul>
<li><code>byte[1024 * 50]</code> 模拟用户上传的文件&#x2F;图片数据</li>
<li>对象大小可控（调整数组长度可改变OOM速度）</li>
</ul>
</li>
</ol>
<p><strong>运行参数配置（加速OOM出现）</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置小堆内存 + OOM时自动dump</span></span><br><span class="line">java -Xms128m -Xmx128m -XX:+HeapDumpOnOutOfMemoryError -jar MemoryLeakSimulator.jar</span><br></pre></td></tr></table></figure>

<p><strong>预期结果</strong>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">===== 内存泄漏模拟程序启动 =====</span><br><span class="line">【缓存加载】当前缓存用户数: 100 占用内存: ≈4MB</span><br><span class="line">【缓存加载】当前缓存用户数: 200 占用内存: ≈9MB</span><br><span class="line">...</span><br><span class="line">【缓存加载】当前缓存用户数: 2,500 占用内存: ≈122MB</span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid12345.hprof ...</span><br></pre></td></tr></table></figure>

<p><strong>漏洞分析（MAT工具验证）</strong>：</p>
<ol>
<li>打开生成的<code>java_pid12345.hprof</code>文件</li>
<li>执行 <strong>Leak Suspects Report</strong>：<ul>
<li>将显示<code>ConcurrentHashMap</code>占用 &gt;90% 内存</li>
</ul>
</li>
<li>查看 <strong>Dominator Tree</strong>：<ul>
<li>排名第一的是<code>java.util.concurrent.ConcurrentHashMap$Node[]</code></li>
<li>保留堆栈指向<code>USER_CACHE</code></li>
</ul>
</li>
<li>追踪 <strong>Path to GC Roots</strong>：<ul>
<li>显示<code>USER_CACHE</code>被<code>static</code>变量持有</li>
</ul>
</li>
</ol>
<p><strong>真实场景对应</strong>：</p>
<p>此案例模拟了：</p>
<ul>
<li>用户会话缓存未设置TTL</li>
<li>上传文件缓存未清理</li>
<li>静态配置中心数据无限累积</li>
<li>第三方API响应缓存未过期</li>
</ul>
<p><strong>修复方案</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用弱引用缓存（自动回收）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Long, WeakReference&lt;UserProfile&gt;&gt; USER_CACHE = </span><br><span class="line">    Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或使用Guava Cache（带过期策略）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Cache&lt;Long, UserProfile&gt; cache = CacheBuilder.newBuilder()</span><br><span class="line">    .maximumSize(<span class="number">1000</span>)</span><br><span class="line">    .expireAfterAccess(<span class="number">10</span>, TimeUnit.MINUTES)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>重要提示</strong>：在本地运行此代码前，请确保关闭其他重要应用！可通过调整<code>byte[1024 * 50]</code>中的乘数控制OOM速度（例如改为<code>*5</code>可降低内存占用）。</p>
</blockquote>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><h4 id="如何判断一个对象是否可回收"><a href="#如何判断一个对象是否可回收" class="headerlink" title="如何判断一个对象是否可回收"></a>如何判断一个对象是否可回收</h4><p><strong>引用计数法</strong></p>
<p><strong>可达性分析法</strong></p>
<p>在 Java 中 以下对象可作为 GC Roots：</p>
<ul>
<li>虚拟机栈中引用的对象</li>
<li>本地方法栈中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
</ul>
<p>需要注意的是，要宣告一个对象的真正死亡，需要经过两次标记。</p>
<ol>
<li><p>从 GC roots 出发，标记不可达的对象</p>
</li>
<li><p>对 F-Queue 对列中的对象进行二次标记</p>
<p>不可达对象如果重写且还未执行 finalize 方法，会被加入到一个名为 F-Queue 的队列中。在 F-Queue 队列中的对象可以重新被赋值给某个引用，这样二次标记时，这些对象将被移出 F-Queue 队列，从而实现自救。</p>
</li>
</ol>
<h4 id="4种引用类型"><a href="#4种引用类型" class="headerlink" title="4种引用类型"></a>4种引用类型</h4><p>JVM 的四种引用类型（强引用、软引用、弱引用、虚引用）决定了对象如何被垃圾回收器（GC）对待，主要服务于<strong>更精细地控制对象生命周期</strong>和<strong>管理内存</strong>的目的。它们的使用场景各有侧重：</p>
<ol>
<li><p><strong>强引用 (Strong Reference)</strong></p>
<ul>
<li><strong>定义：</strong> 最常见的引用类型。通过 <code>new</code> 关键字创建的对象默认就是强引用。只要强引用存在，垃圾回收器就<strong>绝对不会</strong>回收该对象，即使面临内存不足（OOM）的风险。</li>
<li><strong>语法：</strong> <code>Object obj = new Object(); // obj 就是一个指向新 Object 实例的强引用</code></li>
</ul>
</li>
<li><p><strong>软引用 (SoftReference)</strong></p>
<ul>
<li><p><strong>定义：</strong> 用来描述一些<strong>有用但非必需</strong>的对象。当内存充足时，软引用关联的对象不会被回收；当<strong>内存不足（即将发生 OOM 之前）</strong>，垃圾回收器会尝试回收这些软引用指向的对象。如果回收了软引用对象后内存仍然不足，才会抛出 <code>OutOfMemoryError</code>。</p>
</li>
<li><p><strong>语法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">importantObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 原始强引用</span></span><br><span class="line">SoftReference&lt;Object&gt; softRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(importantObj);</span><br><span class="line">importantObj = <span class="literal">null</span>; <span class="comment">// 解除强引用，只剩下软引用</span></span><br><span class="line"><span class="comment">// 稍后尝试获取</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">retrieved</span> <span class="operator">=</span> softRef.get(); <span class="comment">// 如果未被回收，retrieved != null; 如果被回收，retrieved == null</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用场景：</strong></p>
<ul>
<li><strong>内存敏感的高速缓存 (Memory-Sensitive Caches)：</strong> 软引用能保证在内存吃紧时自动释放缓存，避免 OOM，同时尽可能利用内存提高缓存命中率。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>弱引用 (WeakReference)</strong></p>
<ul>
<li><p><strong>定义：</strong> 用来描述<strong>非必需</strong>对象，比软引用更弱。无论当前内存是否充足，只要垃圾回收器开始工作（并且扫描到这个对象），就会回收掉<strong>仅被弱引用指向</strong>的对象。</p>
</li>
<li><p><strong>语法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">tempObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 原始强引用</span></span><br><span class="line">WeakReference&lt;Object&gt; weakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(tempObj);</span><br><span class="line">tempObj = <span class="literal">null</span>; <span class="comment">// 解除强引用，只剩下弱引用</span></span><br><span class="line"><span class="comment">// 强制触发一次 GC (仅示例，生产环境慎用 System.gc())</span></span><br><span class="line">System.gc();</span><br><span class="line"><span class="comment">// 尝试获取</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">retrieved</span> <span class="operator">=</span> weakRef.get(); <span class="comment">// 很大概率 retrieved == null，因为对象已被回收</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>虚引用 (PhantomReference)</strong></p>
<ul>
<li><p><strong>定义：</strong> 最弱的一种引用。<strong>无法通过虚引用获取对象实例</strong>（其 <code>get()</code> 方法总是返回 <code>null</code>）。虚引用<strong>必须</strong>与 <code>ReferenceQueue</code> 联合使用。设置虚引用的<strong>唯一目的</strong>是<strong>跟踪对象被垃圾回收的时机</strong>。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象<strong>之后</strong>（此时对象内存已被释放或即将被释放），将这个虚引用加入与之关联的 <code>ReferenceQueue</code> 中。</p>
</li>
<li><p><strong>语法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line"><span class="type">Object</span> <span class="variable">phantomObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 原始强引用</span></span><br><span class="line">PhantomReference&lt;Object&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(phantomObj, queue);</span><br><span class="line">phantomObj = <span class="literal">null</span>; <span class="comment">// 解除强引用</span></span><br><span class="line"><span class="comment">// ... 强制 GC 或等待 GC 发生 ...</span></span><br><span class="line"><span class="comment">// 检查队列</span></span><br><span class="line">Reference&lt;?&gt; refFromQueue = queue.poll();</span><br><span class="line"><span class="keyword">if</span> (refFromQueue != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 此时 refFromQueue 就是 phantomRef，表示 phantomObj 已被回收或处于 finalization 状态</span></span><br><span class="line">    <span class="comment">// 可以在这里执行一些资源清理动作（如关闭关联的文件描述符、释放堆外内存等）</span></span><br><span class="line">    <span class="comment">// 注意：此时原对象 phantomObj 已经不可达且内存可能已被回收</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用场景：</strong></p>
<ul>
<li><strong>管理堆外内存 (Off-Heap Memory)：</strong> 这是最主要的应用场景。Java NIO 的 <code>DirectByteBuffer</code> 分配堆外内存。<code>DirectByteBuffer</code> 对象本身很小（在堆上），但它关联着一块较大的堆外内存。当 <code>DirectByteBuffer</code> 对象被回收时，需要释放其关联的堆外内存。JVM 使用 <code>Cleaner</code> 类（内部基于 <code>PhantomReference</code>）来监控 <code>DirectByteBuffer</code> 对象。当 <code>DirectByteBuffer</code> 对象被 GC 回收后，<code>Cleaner</code> 的虚引用会被放入队列，触发一个清理线程调用 <code>unsafe.freeMemory</code> 来释放堆外内存。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="CMS收集器工作原理"><a href="#CMS收集器工作原理" class="headerlink" title="CMS收集器工作原理"></a>CMS收集器工作原理</h4><h4 id="G1收集器工作原理"><a href="#G1收集器工作原理" class="headerlink" title="G1收集器工作原理"></a>G1收集器工作原理</h4><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/7c4f87d.html" rel="prev" title="问题库">
                  <i class="fa fa-angle-left"></i> 问题库
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/32511a71.html" rel="next" title="学习&面试-数据存储">
                  学习&面试-数据存储 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa-regular fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder"></span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Word count total">100k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">6:03</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>

  <script class="next-config" data-name="wavedrom" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/wavedrom.min.js","integrity":"sha256-INLAoJc6quTNfiMWkGZniYO2cxE8mHpddnLow1m6RFs="}}</script>
  <script class="next-config" data-name="wavedrom_skin" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/skins/default.js","integrity":"sha256-fduc/Zszk5ezWws2uInY/ALWVmIrmV6VTgXbsYSReFI="}}</script>
  <script src="/js/third-party/tags/wavedrom.js"></script>




  





</body>
</html>
