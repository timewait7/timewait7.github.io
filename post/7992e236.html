<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"timewait7.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":true,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="新特性Java 8Lambda 表达式作用：简化匿名内部类，实现函数式编程 12345678910111213&#x2F;&#x2F; 传统方式Runnable r1 &#x3D; new Runnable() &#123;    @Override    public void run() &#123;        System.out.println(&quot;Runnable 1&quot;);    &#125;&amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="学习&amp;面试-Java">
<meta property="og:url" content="http://timewait7.github.io/post/7992e236.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="新特性Java 8Lambda 表达式作用：简化匿名内部类，实现函数式编程 12345678910111213&#x2F;&#x2F; 传统方式Runnable r1 &#x3D; new Runnable() &#123;    @Override    public void run() &#123;        System.out.println(&quot;Runnable 1&quot;);    &#125;&amp;">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://timewait7.github.io/post/7992e236/image-20250720163023390.png">
<meta property="og:image" content="http://timewait7.github.io/post/7992e236/image-20250725195316321.png">
<meta property="og:image" content="http://timewait7.github.io/post/7992e236/image-20250725210437363.png">
<meta property="og:image" content="http://timewait7.github.io/post/7992e236/image-20250725203542235.png">
<meta property="article:published_time" content="2025-07-26T11:19:10.000Z">
<meta property="article:modified_time" content="2025-07-28T16:11:42.028Z">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://timewait7.github.io/post/7992e236/image-20250720163023390.png">


<link rel="canonical" href="http://timewait7.github.io/post/7992e236.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://timewait7.github.io/post/7992e236.html","path":"post/7992e236.html","title":"学习&面试-Java"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>学习&面试-Java | Hexo</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-archives"><a href="/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="Searching..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.</span> <span class="nav-text">新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-8"><span class="nav-number">1.1.</span> <span class="nav-text">Java 8</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.1.1.</span> <span class="nav-text">Lambda 表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.1.2.</span> <span class="nav-text">函数式接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="nav-number">1.1.3.</span> <span class="nav-text">方法引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.4.</span> <span class="nav-text">默认方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Stream-API"><span class="nav-number">1.1.5.</span> <span class="nav-text">Stream API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Optional-%E7%B1%BB"><span class="nav-number">1.1.6.</span> <span class="nav-text">Optional 类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4-API"><span class="nav-number">1.1.7.</span> <span class="nav-text">新的日期时间 API</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-11"><span class="nav-number">1.2.</span> <span class="nav-text">Java 11</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%E5%A2%9E%E5%BC%BA"><span class="nav-number">1.2.1.</span> <span class="nav-text">局部变量类型推断增强</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B0%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.2.</span> <span class="nav-text">新的字符串方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%87%86HTTP%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">1.2.3.</span> <span class="nav-text">标准HTTP客户端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E7%AE%80%E5%8C%96"><span class="nav-number">1.2.4.</span> <span class="nav-text">文件读写简化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E4%BE%BF%E6%8D%B7%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.5.</span> <span class="nav-text">集合转数组的便捷方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-17"><span class="nav-number">1.3.</span> <span class="nav-text">Java 17</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D-instanceof"><span class="nav-number">1.3.1.</span> <span class="nav-text">模式匹配 instanceof</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E5%9D%97"><span class="nav-number">1.3.2.</span> <span class="nav-text">文本块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8-API"><span class="nav-number">1.3.3.</span> <span class="nav-text">伪随机数生成器 API</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-21"><span class="nav-number">1.4.</span> <span class="nav-text">Java 21</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.4.1.</span> <span class="nav-text">虚拟线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91"><span class="nav-number">1.4.2.</span> <span class="nav-text">结构化并发</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="nav-number">2.</span> <span class="nav-text">Java基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80"><span class="nav-number">2.1.</span> <span class="nav-text">语法基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.1.1.</span> <span class="nav-text">&#x3D;&#x3D;和equals的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#equals%E5%92%8ChashCode%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%90%8C%E6%97%B6%E9%87%8D%E5%86%99"><span class="nav-number">2.1.2.</span> <span class="nav-text">equals和hashCode为什么要同时重写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.3.</span> <span class="nav-text">异常的层次结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">2.2.</span> <span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B3%9B%E5%9E%8B"><span class="nav-number">2.2.1.</span> <span class="nav-text">为什么需要泛型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="nav-number">2.2.2.</span> <span class="nav-text">什么是泛型擦除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E9%99%90%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.2.3.</span> <span class="nav-text">泛型的上下限及应用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">2.3.</span> <span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84"><span class="nav-number">2.3.1.</span> <span class="nav-text">什么是反射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">2.3.2.</span> <span class="nav-text">反射的优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84-Class-%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.3.3.</span> <span class="nav-text">如何获取一个类的 Class 对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="nav-number">2.3.4.</span> <span class="nav-text">如何通过反射创建一个类的实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.3.5.</span> <span class="nav-text">反射有哪些实际应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Class-forName-%E5%92%8C-ClassLoader-loadClass-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">2.3.6.</span> <span class="nav-text">Class.forName() 和 ClassLoader.loadClass() 有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%B0%84%E7%A0%B4%E5%9D%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.3.7.</span> <span class="nav-text">如何防止反射破坏单例模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">2.3.8.</span> <span class="nav-text">动态代理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3"><span class="nav-number">2.4.</span> <span class="nav-text">注解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E4%B8%AD%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="nav-number">2.4.1.</span> <span class="nav-text">Java中都有哪些元注解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SPI"><span class="nav-number">2.5.</span> <span class="nav-text">SPI</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E9%9B%86%E5%90%88"><span class="nav-number">3.</span> <span class="nav-text">Java集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80"><span class="nav-number">3.1.</span> <span class="nav-text">集合基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Iterator-%E5%92%8C-ListIterator-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.1.1.</span> <span class="nav-text">Iterator 和 ListIterator 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-fail-fast-%E6%9C%BA%E5%88%B6"><span class="nav-number">3.1.2.</span> <span class="nav-text">什么是 fail-fast 机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fail-fast-%E5%92%8C-fail-safe-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.1.3.</span> <span class="nav-text">fail-fast 和 fail-safe 的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List"><span class="nav-number">3.2.</span> <span class="nav-text">List</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="nav-number">3.2.1.</span> <span class="nav-text">ArrayList的扩容机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Vector-%E5%92%8C-ArrayList-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.2.2.</span> <span class="nav-text">Vector 和 ArrayList 的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set"><span class="nav-number">3.3.</span> <span class="nav-text">Set</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HashSet%E3%80%81LinkedHashSet-%E5%92%8C-TreeSet-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.3.1.</span> <span class="nav-text">HashSet、LinkedHashSet 和 TreeSet 的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map"><span class="nav-number">3.4.</span> <span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">3.4.1.</span> <span class="nav-text">HashMap 的底层实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap-%E5%92%8C-HashTable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.4.2.</span> <span class="nav-text">HashMap 和 HashTable 的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-IO"><span class="nav-number">4.</span> <span class="nav-text">Java IO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.1.</span> <span class="nav-text">字节流与字符流的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BIO%E3%80%81NIO%E3%80%81AIO%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.</span> <span class="nav-text">BIO、NIO、AIO的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NIO-%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="nav-number">4.3.</span> <span class="nav-text">NIO 三大核心组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="nav-number">4.4.</span> <span class="nav-text">什么是零拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9BIO%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.5.</span> <span class="nav-text">有哪些IO模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E4%B8%AD%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">4.6.</span> <span class="nav-text">IO中阻塞与非阻塞、同步与异步的区别是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFReactor%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.7.</span> <span class="nav-text">什么是Reactor模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%B9%B6%E5%8F%91"><span class="nav-number">5.</span> <span class="nav-text">Java并发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">5.1.</span> <span class="nav-text">synchronized 的实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%B4%E4%B8%8E-Mark-Word"><span class="nav-number">5.1.1.</span> <span class="nav-text">对象头与 Mark Word</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Monitor-%E7%9B%91%E8%A7%86%E5%99%A8%E9%94%81"><span class="nav-number">5.1.2.</span> <span class="nav-text">Monitor 监视器锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7%E6%9C%BA%E5%88%B6"><span class="nav-number">5.1.3.</span> <span class="nav-text">锁升级机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">5.2.</span> <span class="nav-text">ThreadLocal</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">5.2.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-number">5.2.2.</span> <span class="nav-text">使用示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JUC%E9%9B%86%E5%90%88"><span class="nav-number">5.3.</span> <span class="nav-text">JUC集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentHashMap-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">5.3.1.</span> <span class="nav-text">ConcurrentHashMap 的实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-ConcurrentHashMap-%E6%AF%94-Hashtable-%E6%95%88%E7%8E%87%E9%AB%98"><span class="nav-number">5.3.2.</span> <span class="nav-text">为什么 ConcurrentHashMap 比 Hashtable 效率高</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="nav-number">6.</span> <span class="nav-text">异步编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CompletableFuture%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="nav-number">6.1.</span> <span class="nav-text">CompletableFuture的原理与应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CompletableFuture-%E5%92%8C%E4%BC%A0%E7%BB%9F%E7%9A%84-Future-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">6.2.</span> <span class="nav-text">CompletableFuture 和传统的 Future 有什么区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM"><span class="nav-number">7.</span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="nav-number">7.1.</span> <span class="nav-text">类加载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%E4%BC%9A%E8%A7%A6%E5%8F%91%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="nav-number">7.1.1.</span> <span class="nav-text">哪些场景会触发类的加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Class-forName-%E5%92%8CClassLoader-loadClass-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">7.1.2.</span> <span class="nav-text">Class.forName()和ClassLoader.loadClass()有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">7.1.3.</span> <span class="nav-text">类加载器的层次结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="nav-number">7.1.4.</span> <span class="nav-text">什么是双亲委派模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#loadClass-%E5%92%8C-findClass-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">7.1.5.</span> <span class="nav-text">loadClass 和 findClass() 有什么区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-number">7.2.</span> <span class="nav-text">内存结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-number">7.2.1.</span> <span class="nav-text">JVM内存结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">7.2.2.</span> <span class="nav-text">运行时常量池和字符串常量池有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E8%A7%A6%E5%8F%91StackOverflowError%E5%92%8COutOfMemoryError"><span class="nav-number">7.2.3.</span> <span class="nav-text">什么情况下会触发StackOverflowError和OutOfMemoryError</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B0%B8%E4%B9%85%E4%BB%A3%E5%92%8C%E5%85%83%E7%A9%BA%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.2.4.</span> <span class="nav-text">永久代和元空间的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E6%98%AF%E6%80%8E%E4%B9%88%E7%BB%86%E5%88%86%E7%9A%84"><span class="nav-number">7.2.5.</span> <span class="nav-text">堆内存是怎么细分的</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">7.3.</span> <span class="nav-text">垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E5%9B%9E%E6%94%B6"><span class="nav-number">7.3.1.</span> <span class="nav-text">如何判断一个对象是否可回收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.3.2.</span> <span class="nav-text">4种引用类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-number">7.3.3.</span> <span class="nav-text">有哪些垃圾回收算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CMS%E6%94%B6%E9%9B%86%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">7.3.4.</span> <span class="nav-text">CMS收集器工作原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#G1%E6%94%B6%E9%9B%86%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">7.3.5.</span> <span class="nav-text">G1收集器工作原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E8%B0%83%E4%BC%98"><span class="nav-number">7.4.</span> <span class="nav-text">JVM调优</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0"><span class="nav-number">7.4.1.</span> <span class="nav-text">常用调优参数</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/">
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="Back to top">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://timewait7.github.io/post/7992e236.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="学习&面试-Java | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          学习&面试-Java
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-07-26 19:19:10" itemprop="dateCreated datePublished" datetime="2025-07-26T19:19:10+08:00">2025-07-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>21k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>1:16</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><h3 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8"></a>Java 8</h3><h4 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h4><p><strong>作用</strong>：简化匿名内部类，实现函数式编程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统方式</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Runnable 1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda 方式</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">r2</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Runnable 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">r1.run();  <span class="comment">// 输出: Runnable 1</span></span><br><span class="line">r2.run();  <span class="comment">// 输出: Runnable 2</span></span><br></pre></td></tr></table></figure>

<h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p><strong>作用</strong>：只有一个抽象方法的接口，可用 <code>@FunctionalInterface</code> 注解标记</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MathOperation</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">operate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MathOperation</span> <span class="variable">add</span> <span class="operator">=</span> (a, b) -&gt; a + b;</span><br><span class="line">        System.out.println(add.operate(<span class="number">5</span>, <span class="number">3</span>));  <span class="comment">// 输出: 8</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p><strong>作用</strong>：简化 Lambda 表达式，直接引用已有方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda 表达式</span></span><br><span class="line">names.forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法引用</span></span><br><span class="line">names.forEach(System.out::println);  <span class="comment">// 输出所有元素</span></span><br></pre></td></tr></table></figure>

<h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><p><strong>作用</strong>：在接口中提供默认实现，避免破坏现有实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一辆车!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">Vehicle</span> &#123;&#125;  <span class="comment">// 无需实现print方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Car</span>().print();  <span class="comment">// 输出: 我是一辆车!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h4><p><strong>作用</strong>：函数式处理集合数据（过滤、映射、归约等）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求所有偶数的平方和</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers.stream()</span><br><span class="line">        .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        .map(n -&gt; n * n)</span><br><span class="line">        .reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"></span><br><span class="line">System.out.println(sum);  <span class="comment">// 输出: 20 (2^2 + 4^2)</span></span><br></pre></td></tr></table></figure>

<h4 id="Optional-类"><a href="#Optional-类" class="headerlink" title="Optional 类"></a>Optional 类</h4><p><strong>作用</strong>：优雅处理 <code>null</code> 值，避免 <code>NullPointerException</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; name = Optional.ofNullable(getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存在时输出，不存在输出默认值</span></span><br><span class="line">System.out.println(name.orElse(<span class="string">&quot;Unknown&quot;</span>));  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全使用方法引用</span></span><br><span class="line">name.ifPresent(System.out::println);  </span><br><span class="line"></span><br><span class="line">String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Math.random() &gt; <span class="number">0.5</span> ? <span class="string">&quot;Alice&quot;</span> : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="新的日期时间-API"><a href="#新的日期时间-API" class="headerlink" title="新的日期时间 API"></a>新的日期时间 API</h4><p><strong>作用</strong>：解决旧 <code>java.util.Date</code> 线程安全问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前日期和时间</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">System.out.println(<span class="string">&quot;当前时间: &quot;</span> + now);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日期操作</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.of(<span class="number">2023</span>, Month.JANUARY, <span class="number">1</span>);</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">nextWeek</span> <span class="operator">=</span> date.plusWeeks(<span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;下周日期: &quot;</span> + nextWeek);  <span class="comment">// 2023-01-08</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算时间差</span></span><br><span class="line"><span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(LocalTime.NOON, LocalTime.now());</span><br><span class="line">System.out.println(<span class="string">&quot;距中午过去秒数: &quot;</span> + duration.getSeconds());</span><br></pre></td></tr></table></figure>



<h3 id="Java-11"><a href="#Java-11" class="headerlink" title="Java 11"></a>Java 11</h3><h4 id="局部变量类型推断增强"><a href="#局部变量类型推断增强" class="headerlink" title="局部变量类型推断增强"></a>局部变量类型推断增强</h4><p>允许在Lambda表达式中使用<code>var</code>声明参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaVarExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; names = List.of(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在Lambda中使用var声明参数</span></span><br><span class="line">        names.forEach((<span class="keyword">var</span> name) -&gt; System.out.println(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="新的字符串方法"><a href="#新的字符串方法" class="headerlink" title="新的字符串方法"></a>新的字符串方法</h4><p>新增<code>isBlank()</code>、<code>lines()</code>、<code>strip()</code>、<code>repeat()</code>等方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringMethodsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// isBlank(): 检查空或空白</span></span><br><span class="line">        System.out.println(<span class="string">&quot; &quot;</span>.isBlank()); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// lines(): 分割为行流</span></span><br><span class="line">        <span class="string">&quot;Line1\nLine2&quot;</span>.lines().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// strip(): 去除首尾空白（比trim()更智能）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;  Hello  &quot;</span>.strip()); <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// repeat(): 重复字符串</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Java&quot;</span>.repeat(<span class="number">3</span>)); <span class="comment">// &quot;JavaJavaJava&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="标准HTTP客户端"><a href="#标准HTTP客户端" class="headerlink" title="标准HTTP客户端"></a>标准HTTP客户端</h4><p>替代旧<code>HttpURLConnection</code>，支持HTTP&#x2F;2和WebSocket。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.http.HttpClient;</span><br><span class="line"><span class="keyword">import</span> java.net.http.HttpRequest;</span><br><span class="line"><span class="keyword">import</span> java.net.http.HttpResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpClientDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClient.newHttpClient();</span><br><span class="line">        <span class="type">HttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> HttpRequest.newBuilder()</span><br><span class="line">                .uri(URI.create(<span class="string">&quot;https://httpbin.org/get&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送同步请求</span></span><br><span class="line">        HttpResponse&lt;String&gt; response = </span><br><span class="line">            client.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;Status: &quot;</span> + response.statusCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;Body: &quot;</span> + response.body());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="文件读写简化"><a href="#文件读写简化" class="headerlink" title="文件读写简化"></a>文件读写简化</h4><p>新增<code>readString()</code>和<code>writeString()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReadWriteDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 写入文件</span></span><br><span class="line">        Files.writeString(path, <span class="string">&quot;Hello Java 11!&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读取文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> Files.readString(path);</span><br><span class="line">        System.out.println(content); <span class="comment">// &quot;Hello Java 11!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="集合转数组的便捷方法"><a href="#集合转数组的便捷方法" class="headerlink" title="集合转数组的便捷方法"></a>集合转数组的便捷方法</h4><p><code>Collection.toArray(IntFunction)</code>简化数组转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionToArrayDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 直接传入数组构造函数引用</span></span><br><span class="line">        String[] array = list.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (String s : array) &#123;</span><br><span class="line">            System.out.println(s); <span class="comment">// 输出A, B, C</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java-17"><a href="#Java-17" class="headerlink" title="Java 17"></a>Java 17</h3><h4 id="模式匹配-instanceof"><a href="#模式匹配-instanceof" class="headerlink" title="模式匹配 instanceof"></a>模式匹配 <code>instanceof</code></h4><p>简化类型检查和转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="string">&quot;Hello Java 17&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) obj;</span><br><span class="line">    System.out.println(s.toLowerCase());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法：自动类型转换</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">    System.out.println(s.toLowerCase()); <span class="comment">// 直接使用变量 s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="文本块"><a href="#文本块" class="headerlink" title="文本块"></a>文本块</h4><p>简化多行字符串处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧写法（需手动换行和转义）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">oldHtml</span> <span class="operator">=</span> <span class="string">&quot;&lt;html&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;  &lt;body&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;     &lt;p&gt;Hello&lt;/p&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;  &lt;/body&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;/html&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法：文本块（自动保留格式）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">newHtml</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                &lt;html&gt;</span></span><br><span class="line"><span class="string">                  &lt;body&gt;</span></span><br><span class="line"><span class="string">                    &lt;p&gt;Hello Java 17&lt;/p&gt;</span></span><br><span class="line"><span class="string">                  &lt;/body&gt;</span></span><br><span class="line"><span class="string">                &lt;/html&gt;</span></span><br><span class="line"><span class="string">                &quot;&quot;&quot;</span>;</span><br><span class="line">System.out.println(newHtml);</span><br></pre></td></tr></table></figure>

<h4 id="伪随机数生成器-API"><a href="#伪随机数生成器-API" class="headerlink" title="伪随机数生成器 API"></a>伪随机数生成器 API</h4><p>统一随机数生成器接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.random.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 选择算法（如 L32X64MixRandom）</span></span><br><span class="line">        <span class="type">RandomGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> RandomGeneratorFactory.of(<span class="string">&quot;L32X64MixRandom&quot;</span>).create();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成随机数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">randomNum</span> <span class="operator">=</span> generator.nextInt(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Random: &quot;</span> + randomNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java-21"><a href="#Java-21" class="headerlink" title="Java 21"></a>Java 21</h3><h4 id="虚拟线程"><a href="#虚拟线程" class="headerlink" title="虚拟线程"></a>虚拟线程</h4><p>轻量级线程，显著提升并发性能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">var</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;</span><br><span class="line">    IntStream.range(<span class="number">0</span>, <span class="number">10_000</span>).forEach(i -&gt; </span><br><span class="line">        executor.submit(() -&gt; &#123;</span><br><span class="line">            Thread.sleep(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125; <span class="comment">// 自动等待所有线程结束</span></span><br></pre></td></tr></table></figure>

<h4 id="结构化并发"><a href="#结构化并发" class="headerlink" title="结构化并发"></a>结构化并发</h4><p>简化多线程任务管理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">var</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;</span><br><span class="line">    Future&lt;String&gt; user  = scope.fork(() -&gt; fetchUser());</span><br><span class="line">    Future&lt;Integer&gt; order = scope.fork(() -&gt; fetchOrder());</span><br><span class="line"></span><br><span class="line">    scope.join();          <span class="comment">// 等待所有任务</span></span><br><span class="line">    scope.throwIfFailed(); <span class="comment">// 异常传播</span></span><br><span class="line"></span><br><span class="line">    System.out.println(user.resultNow() + <span class="string">&quot;: &quot;</span> + order.resultNow());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h3><h4 id="和equals的区别"><a href="#和equals的区别" class="headerlink" title="==和equals的区别"></a><code>==</code>和<code>equals</code>的区别</h4><p><code>==</code> 用于比较基本数据类型的值或对象引用的内存地址，<code>equals</code> 用户比较对象内容。</p>
<h4 id="equals和hashCode为什么要同时重写"><a href="#equals和hashCode为什么要同时重写" class="headerlink" title="equals和hashCode为什么要同时重写"></a><code>equals</code>和<code>hashCode</code>为什么要同时重写</h4><ol>
<li>契约要求：对象相等性的一致性</li>
</ol>
<ul>
<li><p><strong><code>Object</code>类的规范</strong>明确规定：</p>
<blockquote>
<p>如果两个对象通过<code>equals()</code>方法比较是相等的，那么它们的<code>hashCode()</code><strong>必须</strong>返回相同的值。</p>
</blockquote>
</li>
<li><p>如果违反此契约，对象在基于哈希的集合中会出现不可预测的行为（如<code>HashMap</code>无法正确查找对象）。</p>
</li>
</ul>
<ol start="2">
<li>基于哈希的集合（如<code>HashMap</code>, <code>HashSet</code>）依赖<code>hashCode()</code>和<code>equals()</code>协同工作：</li>
</ol>
<ul>
<li><p><strong><code>hashCode()</code>定位桶（Bucket）</strong>：<br>集合首先调用<code>hashCode()</code>确定对象存储在哪个哈希桶中。</p>
</li>
<li><p><strong><code>equals()</code>确认唯一性</strong>：<br>在同一个桶内，再调用<code>equals()</code>检查对象是否真正相等（解决哈希冲突）。</p>
</li>
</ul>
<ol start="3">
<li><p>假设只重写了<code>equals()</code>但未重写<code>hashCode()</code>：</p>
<ul>
<li><p><strong>场景</strong>：两个对象<code>a</code>和<code>b</code>满足<code>a.equals(b) == true</code>，但<code>a.hashCode() != b.hashCode()</code>。</p>
</li>
<li><p><strong>问题</strong>：</p>
<ul>
<li>它们会被存入<code>HashMap</code>的<strong>不同桶</strong>中（因为哈希值不同，未重写的<code>hasoCode()</code>默认返回内存地址）。</li>
<li><code>map.put(a, val1)</code>和<code>map.put(b, val2)</code>会同时存在，违反<code>Map</code>的键唯一性。</li>
</ul>
</li>
<li><p>示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">// 重写equals但未重写hashCode</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    Set&lt;Person&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    set.add(p1);</span><br><span class="line">    set.add(p2);  <span class="comment">// p1.equals(p2)=true，但Set会存储两个对象！</span></span><br><span class="line">    System.out.println(set.size()); <span class="comment">// 输出2（错误，应为1）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>重写<code>hashCode()</code>需满足：</p>
<ul>
<li><strong>一致性</strong>：如果<code>a.equals(b)</code>，则<code>a.hashCode() == b.hashCode()</code>。</li>
<li><strong>稳定性</strong>：在对象状态不变时，多次调用<code>hashCode()</code>应返回相同值。</li>
<li><strong>高效性</strong>：尽量减少哈希冲突（不同对象尽量返回不同哈希值）。</li>
</ul>
<p><strong>推荐方法</strong>（使用<code>Objects.hash()</code>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(name, age); <span class="comment">// 包含所有equals中使用的字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="异常的层次结构"><a href="#异常的层次结构" class="headerlink" title="异常的层次结构"></a>异常的层次结构</h4><p><code>Throwable</code>：所有异常和错误的父类</p>
<p><code>Error</code>：</p>
<ul>
<li><strong>系统级严重问题</strong>，应用程序通常无法恢复</li>
<li>示例：<ul>
<li><code>OutOfMemoryError</code>：内存耗尽</li>
<li><code>StackOverflowError</code>：栈溢出</li>
<li><code>VirtualMachineError</code>：JVM致命错误</li>
</ul>
</li>
<li>❗ <strong>无需捕获处理</strong>（即使捕获也难以恢复）</li>
</ul>
<p><code>Exception</code>：</p>
<ol>
<li><ul>
<li><p><strong>程序可处理的异常</strong>，分为两类：</p>
<ul>
<li><p><strong>Checked Exceptions（受检异常）</strong><br>编译器强制要求处理（必须<code>try-catch</code>或<code>throws</code>）<br>✅ <strong>典型代表</strong>：<code>IOException</code>、<code>SQLException</code>、<code>ClassNotFoundException</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须处理IOException的示例</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Files.readString(Path.of(<span class="string">&quot;file.txt&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123; <span class="comment">// 必须捕获</span></span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>RuntimeException</code>（运行时异常&#x2F;非受检异常）</strong><br>编译器不强制处理，通常由<strong>编程逻辑错误</strong>引起<br>⚠️ <strong>典型代表</strong>：<code>NullPointerException</code>、<code>IndexOutOfBoundsException</code>、<code>IllegalArgumentException</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可选的运行时异常处理</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  System.out.println(str.length()); <span class="comment">// 抛出NullPointerException</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// 非强制捕获</span></span><br><span class="line">  System.out.println(<span class="string">&quot;逻辑错误！&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ol>
<img src="/post/7992e236/image-20250720163023390.png" class="" title="image-20250720163023390">



<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="为什么需要泛型"><a href="#为什么需要泛型" class="headerlink" title="为什么需要泛型"></a>为什么需要泛型</h4><p>泛型（Generics）是现代编程语言（如 Java、C#、C++、TypeScript 等）中一项极其重要的特性，它的出现主要是为了解决<strong>代码复用</strong>、<strong>类型安全</strong>和<strong>可读性</strong>这三大核心问题。</p>
<p>📍 1. <strong>类型安全（Type Safety）</strong></p>
<ul>
<li><strong>问题：</strong> 在没有泛型之前（例如使用 Java 的 <code>Object</code> 或 C# 的 <code>object</code>），容器类（如集合 <code>List</code>、<code>Array</code>）可以存放任何类型的对象。当你从容器中取出对象时，你需要进行强制类型转换 (<code>(String) myList.get(0)</code>)。</li>
<li><strong>风险：</strong> 如果容器里不小心放入了错误的类型（比如你期望是 <code>String</code>，但实际放入了 <code>Integer</code>），这个错误在<strong>编译时不会被发现</strong>，只有在<strong>运行时进行强制转换时</strong>才会抛出 <code>ClassCastException</code>，导致程序崩溃。</li>
<li><strong>泛型解决方案：</strong> 泛型允许你在<strong>声明</strong>容器时就指定它只能存放特定类型（如 <code>List&lt;String&gt;</code>）。编译器会在<strong>编译时</strong>严格检查你放入容器的对象类型是否匹配。如果尝试放入错误类型，编译器会直接报错，阻止潜在的类型错误运行到生产环境。</li>
</ul>
<p>🔁 2. <strong>消除强制类型转换（Eliminating Casts）</strong></p>
<ul>
<li><strong>问题：</strong> 使用原始类型（非泛型）容器时，每次取出元素都需要进行显式的、冗长的、容易出错的强制类型转换。 *   <strong>泛型解决方案：</strong> 使用泛型容器（如 <code>List&lt;String&gt;</code>）后，当你从容器中获取元素时（如 <code>String s = myList.get(0);</code>），<strong>编译器会自动知道返回的是 <code>String</code> 类型，不需要任何强制转换</strong>。代码更简洁，更安全。</li>
</ul>
<p>♻ 3. <strong>代码复用（Code Reuse）</strong></p>
<ul>
<li><strong>问题：</strong> 编写一个算法（比如排序、搜索、比较），你希望它能作用于多种不同类型的对象（整数、字符串、自定义对象等）。没有泛型时，你需要为每种类型重写算法，或者使用 <code>Object</code> 并伴随类型检查和转换。</li>
<li><strong>泛型解决方案：</strong> 泛型允许你编写<strong>类型无关的算法</strong>。你可以定义一个操作在类型参数 <code>T</code> 上的方法或类（例如 <code>public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code>）。只要类型 <code>T</code> 满足算法所需的基本条件（比如实现了 <code>Comparable</code> 接口），同一个算法代码就可以安全地应用于各种不同的数据类型。</li>
</ul>
<p>📖 4. <strong>提高代码可读性和可维护性（Improved Readability &amp; Maintainability）</strong></p>
<ul>
<li><strong>问题：</strong> 使用原始类型或 <code>Object</code>，代码的意图变得模糊。阅读代码的人需要仔细查看上下文（或者注释）才能理解某个容器预期存放什么类型的数据。</li>
<li><strong>泛型解决方案：</strong> 泛型声明（如 <code>Map&lt;String, Customer&gt;</code>）本身就是<strong>清晰、自文档化的代码</strong>。它明确地告诉开发者和编译器：这个容器是做什么用的（存储键为 <code>String</code>、值为 <code>Customer</code> 的映射）。这使得代码更容易理解、维护和调试。</li>
</ul>
<h4 id="什么是泛型擦除"><a href="#什么是泛型擦除" class="headerlink" title="什么是泛型擦除"></a>什么是泛型擦除</h4><p>泛型擦除（Type Erasure）是 <strong>Java 泛型实现的核心机制</strong>，它指编译器在编译阶段<strong>移除所有泛型类型信息</strong>，将其替换为原始类型（Raw Type）或边界类型（Bound Type），并在必要时插入强制类型转换。这一设计主要是为了<strong>兼容旧版本的 Java（JDK 5 之前）</strong>，确保泛型代码能与非泛型遗留代码互操作。</p>
<p><strong>一、泛型擦除的核心规则</strong></p>
<ol>
<li><p><strong>类型参数替换为边界类型</strong></p>
<ul>
<li>若类型参数有上限（如 <code>&lt;T extends Number&gt;</code>），<code>T</code> 被替换为<strong>边界类型</strong>（<code>Number</code>）。</li>
<li>若无明确上限（如 <code>&lt;T&gt;</code>），<code>T</code> 被替换为 <code>Object</code>。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123; <span class="built_in">this</span>.value = value; &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后（擦除后）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object value;         <span class="comment">// T → Object</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Object value)</span> &#123; <span class="built_in">this</span>.value = value; &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> value; &#125; <span class="comment">// 返回 Object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在调用处插入强制类型转换</strong><br>编译器在<strong>使用泛型的地方</strong>自动添加类型转换代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line">Box&lt;String&gt; box = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();</span><br><span class="line">box.set(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> box.get(); <span class="comment">// 无需显式转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后（擦除后）</span></span><br><span class="line"><span class="type">Box</span> <span class="variable">box</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Box</span>();</span><br><span class="line">box.set(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) box.get(); <span class="comment">// 编译器插入 (String) 强制转换</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>保证类型安全的桥接方法（Bridge Methods）</strong><br>当泛型类继承或实现接口时，编译器会生成<strong>合成方法</strong>确保多态性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T other)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String other)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后（擦除后）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="comment">// 编译器生成的桥接方法（保持多态）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object other)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> compareTo((String) other); <span class="comment">// 调用实际方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际编写的泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String other)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>二、泛型擦除导致的关键限制</strong></p>
<ol>
<li><p><strong>无法使用基本类型作为类型参数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 编译错误！不能使用 int</span></span><br><span class="line">List&lt;<span class="type">int</span>&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br><span class="line"><span class="comment">// 必须使用包装类</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>无法获取泛型具体类型的 <code>Class</code> 对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// ❌ 编译错误！List&lt;String&gt;.class 不存在</span></span><br><span class="line">Class&lt;?&gt; clazz = list.getClass(); </span><br><span class="line"><span class="comment">// 输出：java.util.ArrayList（无法得知是 List&lt;String&gt;）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>无法使用 <code>instanceof</code> 检查泛型类型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (list <span class="keyword">instanceof</span> List&lt;String&gt;) &#123; ... &#125; <span class="comment">// ❌ 编译错误！</span></span><br><span class="line"><span class="keyword">if</span> (list <span class="keyword">instanceof</span> List&lt;?&gt;) &#123; ... &#125;      <span class="comment">// ✅ 允许（但无具体类型信息）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>无法创建泛型数组</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 编译错误！</span></span><br><span class="line">T[] array = <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">10</span>]; </span><br><span class="line"><span class="comment">// 替代方案：使用反射或 ArrayList</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>方法签名冲突（重载失效）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 编译错误！擦除后都是 void print(List list)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;String&gt; list)</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;Integer&gt; list)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>三、为什么 Java 选择泛型擦除？</strong></p>
<ol>
<li><strong>向后兼容性（Backward Compatibility）</strong><ul>
<li>确保 JDK 5+ 的泛型代码能运行在旧 JVM（1.4 或更早）上。</li>
<li>非泛型集合（如 <code>ArrayList</code>）和泛型集合（<code>ArrayList&lt;String&gt;</code>）在 JVM 层面都是同一个类。</li>
</ul>
</li>
<li><strong>运行时效率（Runtime Efficiency）</strong><ul>
<li>不需要为每种泛型组合生成新的类（如 C# 的泛型实现），节省内存。</li>
<li>JVM 无需修改即可支持泛型（仅编译器层处理）。</li>
</ul>
</li>
</ol>
<p><strong>四、如何绕过擦除的限制？</strong></p>
<ol>
<li><p><strong>类型令牌（Type Token）</strong><br>通过传递 <code>Class&lt;T&gt;</code> 对象保留类型信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Box</span><span class="params">(Class&lt;T&gt; type)</span> &#123; <span class="built_in">this</span>.type = type; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInstance</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type.isInstance(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>反射 API（Reflection）</strong><br>运行时获取泛型参数（需接口&#x2F;父类保留信息）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> myList.getClass().getGenericSuperclass();</span><br><span class="line"><span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">    <span class="type">Type</span> <span class="variable">actualType</span> <span class="operator">=</span> ((ParameterizedType)type).getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">    System.out.println(actualType); <span class="comment">// 输出如 String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>五、与其他语言泛型实现的对比</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>语言</strong></th>
<th align="left"><strong>泛型实现</strong></th>
<th align="left"><strong>运行时类型保留</strong></th>
<th align="left"><strong>特点</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">Java</td>
<td align="left">类型擦除</td>
<td align="left">❌</td>
<td align="left">兼容旧版，效率高</td>
</tr>
<tr>
<td align="left">C#</td>
<td align="left">具现化（Reified）</td>
<td align="left">✅</td>
<td align="left">运行时保留类型，支持泛型数组</td>
</tr>
<tr>
<td align="left">Kotlin</td>
<td align="left">擦除（JVM上）</td>
<td align="left">❌</td>
<td align="left">通过 <code>inline</code> + <code>reified</code> 绕过限制</td>
</tr>
<tr>
<td align="left">TypeScript</td>
<td align="left">编译时擦除</td>
<td align="left">❌</td>
<td align="left">仅静态类型检查</td>
</tr>
</tbody></table>
<p><strong>总结</strong></p>
<ul>
<li><strong>泛型擦除的本质</strong>：编译器移除泛型类型信息，替换为原始类型（<code>Object</code> 或边界类型），并在使用点插入强制转换。</li>
<li><strong>优点</strong>：无缝兼容旧代码，运行时效率高。</li>
<li><strong>代价</strong>：运行时无法获取泛型类型信息，导致部分操作受限（如 <code>instanceof</code>、泛型数组）。</li>
<li><strong>应对</strong>：通过类型令牌、反射或设计模式（如工厂）绕过限制。</li>
</ul>
<p>泛型擦除是 Java 在兼容性与类型安全之间的折衷方案，理解其原理能帮助你写出更健壮的泛型代码！</p>
<h4 id="泛型的上下限及应用场景"><a href="#泛型的上下限及应用场景" class="headerlink" title="泛型的上下限及应用场景"></a>泛型的上下限及应用场景</h4><p>泛型的<strong>上限（Upper Bound）</strong> 和<strong>下限（Lower Bound）</strong> 是用于<strong>约束类型参数范围</strong>的关键机制，主要解决泛型代码需要<strong>限制可接受的类型</strong>或<strong>支持更灵活的子类型关系</strong>的问题。以下是详细解释：</p>
<p><strong>一、泛型的上限（Upper Bound）</strong></p>
<p>定义：限制类型参数必须是<strong>某个类&#x2F;接口本身或其子类</strong>。<br>语法：<code>&lt;T extends 类/接口&gt;</code> 或 <code>&lt;? extends 类/接口&gt;</code>（通配符形式）。</p>
<p><strong>核心作用</strong></p>
<ol>
<li><p><strong>确保类型具备某些能力</strong><br>要求类型 <code>T</code> 必须实现特定接口（如 <code>Comparable</code>）或继承特定类，从而在泛型代码中安全调用其方法。<br><strong>示例</strong>：要求类型必须可比较</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T 必须是实现了 Comparable 接口的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; T <span class="title function_">max</span><span class="params">(T a, T b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.compareTo(b) &gt; <span class="number">0</span> ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可安全调用 a.compareTo(b)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安全访问数据（只读不写）</strong><br>在通配符 <code>? extends T</code> 中，表示“某个 <code>T</code> 的子类型”，此时容器<strong>只能读取数据</strong>（返回 <code>T</code> 类型），<strong>不能写入数据</strong>（除 <code>null</code> 外）。<br><strong>示例</strong>：安全读取数字集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">printNumbers</span><span class="params">(List&lt;? extends Number&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Number n : list) &#123;</span><br><span class="line">        System.out.println(n);  <span class="comment">// ✅ 可读</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// list.add(10); ❌ 编译错误！无法写入（除 null 外）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>典型场景</strong></p>
<ul>
<li>定义泛型类&#x2F;方法时，约束类型参数的能力（如 <code>T extends Runnable</code>）。</li>
<li>作为方法参数时，安全接收<strong>某种子类型的集合</strong>（生产者场景）。</li>
</ul>
<p><strong>二、泛型的下限（Lower Bound）</strong></p>
<p>定义：限制类型参数必须是<strong>某个类&#x2F;接口本身或其父类</strong>。<br>语法：<code>&lt;? super 类/接口&gt;</code>（仅通配符形式）。</p>
<p><strong>核心作用</strong></p>
<ol>
<li><p><strong>支持安全写入数据</strong><br>表示“某个 <code>T</code> 的父类型”，此时容器<strong>可以写入 <code>T</code> 及其子类型对象</strong>，但读取时只能视为 <code>Object</code>。<br><strong>示例</strong>：向集合添加元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addNumbers</span><span class="params">(List&lt;? <span class="built_in">super</span> Integer&gt; list)</span> &#123;</span><br><span class="line">    list.add(<span class="number">10</span>);     <span class="comment">// ✅ 可写入 Integer</span></span><br><span class="line">    list.add(<span class="number">1000L</span>);  <span class="comment">// ❌ 错误！Long 不是 Integer 的子类</span></span><br><span class="line">    <span class="comment">// Object obj = list.get(0);  // 读取时只能视为 Object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>实现灵活的子类型兼容</strong><br>允许方法接收比预期更宽泛的容器（如需要 <code>List&lt;Number&gt;</code> 时，也可传入 <code>List&lt;Object&gt;</code>）。</p>
</li>
</ol>
<p><strong>典型场景</strong></p>
<ul>
<li><p>向泛型容器<strong>写入数据</strong>（消费者场景）。</p>
</li>
<li><p>配合 <code>Comparator</code> 等接口实现类型灵活的API：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可接收 Person 或其父类的 Comparator</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;Person&gt; list, Comparator&lt;? <span class="built_in">super</span> Person&gt; comparator)</span> &#123;</span><br><span class="line">    Collections.sort(list, comparator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>三、关键对比：<code>extends</code> vs <code>super</code></strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>上限 (<code>? extends T</code>)</strong></th>
<th align="left"><strong>下限 (<code>? super T</code>)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>类型范围</strong></td>
<td align="left"><code>T</code> 或其<strong>子类型</strong></td>
<td align="left"><code>T</code> 或其<strong>父类型</strong></td>
</tr>
<tr>
<td align="left"><strong>数据读取</strong></td>
<td align="left">✅ 返回 <code>T</code> 类型</td>
<td align="left">❌ 只能视为 <code>Object</code></td>
</tr>
<tr>
<td align="left"><strong>数据写入</strong></td>
<td align="left">❌ 禁止（除 <code>null</code>）</td>
<td align="left">✅ 可写入 <code>T</code> <strong>及其子类</strong></td>
</tr>
<tr>
<td align="left"><strong>设计意图</strong></td>
<td align="left"><strong>生产者</strong>（Producer）只提供数据</td>
<td align="left"><strong>消费者</strong>（Consumer）只消费数据</td>
</tr>
<tr>
<td align="left"><strong>经典口诀</strong></td>
<td align="left"><strong>PECS</strong> (Producer-Extends, Consumer-Super)</td>
<td align="left"></td>
</tr>
</tbody></table>
<p><strong>四、实际应用：PECS 原则</strong></p>
<p>在泛型编程中，遵循 <strong>PECS（Producer-Extends, Consumer-Super）</strong> 原则：</p>
<ul>
<li><strong>生产者（Producer）</strong>：产生 <code>T</code> 的对象 → 用 <code>&lt;? extends T&gt;</code></li>
<li><strong>消费者（Consumer）</strong>：消费 <code>T</code> 的对象 → 用 <code>&lt;? super T&gt;</code></li>
</ul>
<p><strong>示例</strong>：Java 集合工具类 <code>Collections.copy()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(</span></span><br><span class="line"><span class="params">    List&lt;? <span class="built_in">super</span> T&gt; dest,    // 消费者：写入目标集合</span></span><br><span class="line"><span class="params">    List&lt;? extends T&gt; src    // 生产者：读取源集合</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; src.size(); i++) &#123;</span><br><span class="line">        dest.set(i, src.get(i));  <span class="comment">// ✅ 安全读写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>五、使用场景总结</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>场景</strong></th>
<th align="left"><strong>推荐语法</strong></th>
<th align="left"><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">需要调用类型特定方法</td>
<td align="left"><code>&lt;T extends Interface&gt;</code></td>
<td align="left"><code>T</code> 必须实现某个接口</td>
</tr>
<tr>
<td align="left">安全读取泛型集合内容</td>
<td align="left"><code>&lt;? extends T&gt;</code></td>
<td align="left">遍历 <code>List&lt;? extends Number&gt;</code></td>
</tr>
<tr>
<td align="left">安全写入泛型集合</td>
<td align="left"><code>&lt;? super T&gt;</code></td>
<td align="left">向 <code>List&lt;? super Integer&gt;</code> 添加值</td>
</tr>
<tr>
<td align="left">同时支持读写</td>
<td align="left">使用确定的类型参数 <code>T</code></td>
<td align="left"><code>List&lt;T&gt;</code></td>
</tr>
</tbody></table>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h4 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h4><p>在程序运行期间，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 Java 的反射机制。</p>
<h4 id="反射的优缺点"><a href="#反射的优缺点" class="headerlink" title="反射的优缺点"></a>反射的优缺点</h4><ul>
<li><strong>优点：</strong><ul>
<li><strong>动态性：</strong> 运行时才确定类型、绑定对象，极大提高了程序的灵活性和扩展性。是框架设计的基石（如 Spring 的 IOC）。</li>
<li><strong>灵活性：</strong> 可以访问和操作私有成员（通过 <code>setAccessible(true)</code>），突破封装限制（需谨慎）。</li>
<li><strong>通用性：</strong> 可以编写非常通用的代码（如通用序列化&#x2F;反序列化工具、对象比较工具、动态代理等）。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li><strong>性能开销：</strong> 反射操作比直接调用慢很多。因为涉及动态类型解析、方法查找、安全检查等。JVM 难以对其优化。</li>
<li><strong>安全隐患：</strong> 可以破坏封装性（访问 private 成员），可能引发安全问题。需要额外的安全管理策略。</li>
<li><strong>代码复杂性：</strong> 反射代码通常比直接代码更复杂、可读性更差、更难维护。</li>
<li><strong>内部暴露：</strong> 可能暴露类的内部实现细节，破坏抽象。</li>
</ul>
</li>
</ul>
<h4 id="如何获取一个类的-Class-对象"><a href="#如何获取一个类的-Class-对象" class="headerlink" title="如何获取一个类的 Class 对象"></a>如何获取一个类的 <code>Class</code> 对象</h4><ol>
<li><code>Class clazz = Object.getClass();</code> (通过对象实例获取)</li>
<li><code>Class clazz = ClassName.class;</code> (通过类字面常量 <code>.class</code> 获取)</li>
<li><code>Class clazz = Class.forName(&quot;fully.qualified.ClassName&quot;);</code> (通过完整类名字符串获取，常用，可能抛出 <code>ClassNotFoundException</code>)</li>
<li>(对于基本类型和数组) <code>Class clazz = int.class;</code> &#x2F; <code>Class clazz = String[].class;</code></li>
</ol>
<h4 id="如何通过反射创建一个类的实例"><a href="#如何通过反射创建一个类的实例" class="headerlink" title="如何通过反射创建一个类的实例"></a>如何通过反射创建一个类的实例</h4><ol>
<li><p><strong>使用 <code>Class.newInstance()</code>（已过时）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) clazz.newInstance(); <span class="comment">// 调用无参构造器</span></span><br></pre></td></tr></table></figure>

<p>只能调用无参构造器；在 Java 9 开始被标记为 <code>@Deprecated(since=&quot;9&quot;)</code>，推荐使用 <code>Constructor.newInstance()</code>。</p>
</li>
<li><p><strong>使用 <code>Constructor.newInstance()</code> (推荐)：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getConstructor(String.class, <span class="type">int</span>.class); <span class="comment">// 获取特定参数类型的构造器</span></span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) constructor.newInstance(<span class="string">&quot;arg1&quot;</span>, <span class="number">42</span>); <span class="comment">// 传入参数创建实例</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="反射有哪些实际应用场景"><a href="#反射有哪些实际应用场景" class="headerlink" title="反射有哪些实际应用场景"></a>反射有哪些实际应用场景</h4><ul>
<li><strong>框架开发：</strong> 是几乎所有 Java 框架的核心（如 Spring, Hibernate, MyBatis, JUnit）。<ul>
<li><strong>Spring IOC：</strong> 通过反射读取配置（XML 或注解），动态创建 Bean 实例，注入依赖。</li>
<li><strong>Spring AOP：</strong> 动态代理（JDK Proxy 或 CGLIB）底层依赖反射调用目标方法。</li>
<li><strong>Hibernate&#x2F;MyBatis：</strong> 将数据库结果集映射到 Java 对象时，通过反射设置对象的属性值。</li>
</ul>
</li>
<li><strong>注解处理：</strong> 在运行时通过反射读取类、方法、字段上的注解信息，并根据注解执行特定逻辑（如 JUnit 查找 <code>@Test</code> 方法）。</li>
<li><strong>动态代理：</strong> JDK 动态代理 (<code>java.lang.reflect.Proxy</code>) 的核心就是利用反射调用被代理对象的方法。</li>
<li><strong>通用工具库：</strong> 如 Apache Commons BeanUtils, Jackson&#x2F;Gson (JSON 序列化&#x2F;反序列化)，通过反射操作对象的属性。</li>
<li><strong>IDE 和开发工具：</strong> 代码提示、调试器、反编译工具等利用反射获取类的结构信息。</li>
</ul>
<h4 id="Class-forName-和-ClassLoader-loadClass-有什么区别"><a href="#Class-forName-和-ClassLoader-loadClass-有什么区别" class="headerlink" title="Class.forName() 和 ClassLoader.loadClass() 有什么区别"></a><strong><code>Class.forName()</code> 和 <code>ClassLoader.loadClass()</code> 有什么区别</strong></h4><ul>
<li><code>Class.forName(String name)</code>：<ul>
<li>默认会触发类的<strong>加载、链接（验证、准备）、初始化</strong>（执行 <code>&lt;clinit&gt;</code> 静态初始化块）。</li>
<li>有一个重载方法 <code>Class.forName(String name, boolean initialize, ClassLoader loader)</code> 可以控制是否初始化 (<code>initialize</code>) 和指定类加载器 (<code>loader</code>)。</li>
</ul>
</li>
<li><code>ClassLoader.loadClass(String name)</code>：<ul>
<li>只触发类的<strong>加载</strong>和<strong>链接（验证、准备）</strong> 阶段，<strong>不会执行初始化</strong> (<code>&lt;clinit&gt;</code>)。只有首次主动使用时（如创建实例、访问静态字段&#x2F;方法）才会初始化。</li>
</ul>
</li>
<li><strong>考察点：</strong> 理解类加载过程的阶段（加载 -&gt; 链接（验证、准备、解析） -&gt; 初始化），以及这两个关键方法在触发类加载行为上的差异。知道 <code>forName</code> 默认会初始化类，而 <code>loadClass</code> 不会。</li>
</ul>
<h4 id="如何防止反射破坏单例模式"><a href="#如何防止反射破坏单例模式" class="headerlink" title="如何防止反射破坏单例模式"></a><strong>如何防止反射破坏单例模式</strong></h4><ul>
<li><p><strong>问题：</strong> 标准的饿汉式或懒汉式（非枚举）单例，其私有构造器可以通过反射的 <code>setAccessible(true)</code> 被访问，从而创建多个实例。</p>
</li>
<li><p><strong>防御方法：</strong></p>
<ul>
<li><p><strong>在构造器中检查：</strong> 如果实例已存在，则在私有构造器中抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Singleton instance already created&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用枚举实现单例 (推荐)：</strong> 枚举的单例实现是《Effective Java》作者 Josh Bloch 强烈推荐的方式。JVM 从根本上保证了枚举类型的构造器只会被调用一次，且反射 API 被设计为<strong>不能通过反射创建枚举实例</strong>（<code>Constructor.newInstance()</code> 方法内部会检查并阻止）。这是最安全、简洁的方式。</p>
</li>
</ul>
</li>
</ul>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>动态代理是一种在运行时生成代理对象的机制，它可以在不改变原有代码的情况下，通过代理对象对原有对象进行增强、扩展或限制等操作。</p>
<p>在 Java 中，动态代理主要有两种实现方式：<strong>基于接口的动态代理</strong>和基于<strong>类的动态代理</strong>。其中，基于接口的动态代理使用 Java 自带的 java.lang.reflect.Proxy 类实现，而基于类的动态代理则需要使用第三方库，如 CGLIB 或 ByteBuddy 等。</p>
<p><strong>基于接口的动态代理</strong></p>
<p>基于接口的动态代理要求目标对象必须实现一个或多个接口，动态代理对象会实现这些接口，并将对这些接口方法的调用委托给目标对象。在创建动态代理对象时，需要提供一个实现了 InvocationHandler 接口的代理处理器对象，它会在代理对象方法调用时被回调。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloImpl</span> <span class="keyword">implements</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HelloProxy</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before method invocation&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;After method invocation&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloImpl</span>();</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">proxy</span> <span class="operator">=</span> (Hello) Proxy.newProxyInstance(</span><br><span class="line">            hello.getClass().getClassLoader(),</span><br><span class="line">            hello.getClass().getInterfaces(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">HelloProxy</span>(hello)</span><br><span class="line">        );</span><br><span class="line">        proxy.sayHello(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>基于类的动态代理</strong></p>
<p>基于类的动态代理则不要求目标对象必须实现接口，而是通过创建目标对象的子类来实现代理。在创建动态代理对象时，需要提供一个实现了 MethodInterceptor 接口的拦截器对象，它会在代理对象方法调用时被回调。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before method invocation&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;After method invocation&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(Hello.class);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">HelloInterceptor</span>());</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> (Hello) enhancer.create();</span><br><span class="line">        hello.sayHello(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><h4 id="Java中都有哪些元注解"><a href="#Java中都有哪些元注解" class="headerlink" title="Java中都有哪些元注解"></a>Java中都有哪些元注解</h4><table>
<thead>
<tr>
<th align="left">元注解</th>
<th align="left">作用域</th>
<th align="left">主要用途</th>
<th align="left">Java 版本</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>@Target</code></strong></td>
<td align="left">注解</td>
<td align="left">指定注解可应用的程序元素（类、方法、字段等）</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left"><strong><code>@Retention</code></strong></td>
<td align="left">注解</td>
<td align="left">指定注解的保留策略（源码、类文件、运行时）</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left"><strong><code>@Documented</code></strong></td>
<td align="left">注解</td>
<td align="left">指示注解应包含在 Javadoc 中</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left"><strong><code>@Inherited</code></strong></td>
<td align="left">注解</td>
<td align="left">指示注解具有继承性（仅对类注解有效）</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left"><strong><code>@Repeatable</code></strong></td>
<td align="left">注解</td>
<td align="left">允许同一注解在单个元素上重复使用（需配合容器注解）</td>
<td align="left"><strong>8</strong></td>
</tr>
<tr>
<td align="left"><strong><code>@Native</code></strong></td>
<td align="left">字段</td>
<td align="left">标记可能被本机代码引用的常量字段（主要在 JDK 内部使用）</td>
<td align="left"><strong>8</strong></td>
</tr>
</tbody></table>
<h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><p><strong>SPI</strong> 是 Java 提供的一种<strong>服务发现机制</strong>，通过<strong>接口与实现解耦</strong>实现动态扩展。核心流程如下：</p>
<ol>
<li><strong>定义服务接口</strong>（如 <code>PaymentService</code>）</li>
<li><strong>提供实现类</strong>（如 <code>AlipayService</code>, <code>WechatPayService</code>）</li>
<li><strong>注册实现</strong>：在 <code>META-INF/services/</code> 下创建以接口全限定名命名的文件，写入实现类全限定名</li>
<li><strong>动态加载</strong>：通过 <code>ServiceLoader</code> 加载所有注册的实现</li>
</ol>
<p><strong>优势：</strong></p>
<ul>
<li><strong>开闭原则</strong>：新增实现无需修改核心代码</li>
<li><strong>解耦</strong>：接口与实现分离</li>
<li><strong>可插拔</strong>：通过配置文件动态替换实现</li>
</ul>
<p><strong>Java SPI 完整 Demo</strong></p>
<ol>
<li>定义服务接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PaymentService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">double</span> amount)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>实现服务接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AlipayService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AlipayService</span> <span class="keyword">implements</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[支付宝] 支付: ¥&quot;</span> + amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WechatPayService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WechatPayService</span> <span class="keyword">implements</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[微信支付] 支付: ¥&quot;</span> + amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>注册服务实现</li>
</ol>
<p>创建资源文件：<br><code>src/main/resources/META-INF/services/com.example.PaymentService</code><br>内容：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.example.AlipayService</span><br><span class="line">com.example.WechatPayService</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用 SPI 加载服务</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPIDemo.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.ServiceLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SPIDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 加载所有 PaymentService 实现</span></span><br><span class="line">        ServiceLoader&lt;PaymentService&gt; services = </span><br><span class="line">            ServiceLoader.load(PaymentService.class);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;=== 发现 &quot;</span> + getServiceCount(services) + <span class="string">&quot; 个支付服务 ===&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用所有实现</span></span><br><span class="line">        <span class="keyword">for</span> (PaymentService service : services) &#123;</span><br><span class="line">            service.pay(<span class="number">100.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getServiceCount</span><span class="params">(ServiceLoader&lt;PaymentService&gt; services)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (PaymentService ignored : services) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>项目结构</li>
</ol>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">├── main/</span><br><span class="line">│   ├── java/</span><br><span class="line">│   │   ├── com/example/</span><br><span class="line">│   │   │   ├── PaymentService.java</span><br><span class="line">│   │   │   ├── AlipayService.java</span><br><span class="line">│   │   │   ├── WechatPayService.java</span><br><span class="line">│   │   │   └── SPIDemo.java</span><br><span class="line">│   │</span><br><span class="line">│   └── resources/</span><br><span class="line">│       └── META-INF/services/</span><br><span class="line">│           └── com.example.PaymentService  &lt;-- 关键配置文件</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>运行结果</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">=== 发现 2 个支付服务 ===</span><br><span class="line">[支付宝] 支付: ¥100.0</span><br><span class="line">[微信支付] 支付: ¥100.0</span><br></pre></td></tr></table></figure>

<p><strong>关键点解析：</strong></p>
<ol>
<li><strong>配置文件路径</strong>：<code>META-INF/services/接口全限定名</code></li>
<li><strong>文件内容</strong>：实现类的全限定名（每行一个）</li>
<li><strong>ServiceLoader</strong>：核心加载工具，实现懒加载</li>
<li><strong>迭代顺序</strong>：按配置文件中定义的顺序加载</li>
</ol>
<p><strong>实际应用场景：</strong></p>
<ul>
<li>JDBC 驱动加载（<code>DriverManager</code>）</li>
<li>日志门面（SLF4J）</li>
<li>序列化框架（Jackson）</li>
<li>Spring Boot 自动配置</li>
</ul>
<blockquote>
<p>通过 SPI 机制，Java 实现了真正的面向接口编程，使系统具备高度可扩展性，符合「开闭原则」。</p>
</blockquote>
<h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><h3 id="集合基础"><a href="#集合基础" class="headerlink" title="集合基础"></a>集合基础</h3><p>Java 集合框架主要包括 <code>Collection</code> 和 <code>Map</code> 两大接口体系。<code>Collection</code> 主要有 <code>List</code>、<code>Set</code>、<code>Queue</code> 几个核心子接口。</p>
<h4 id="Iterator-和-ListIterator-的区别"><a href="#Iterator-和-ListIterator-的区别" class="headerlink" title="Iterator 和 ListIterator 的区别"></a><strong><code>Iterator</code> 和 <code>ListIterator</code> 的区别</strong></h4><ul>
<li><code>Iterator</code>：通用迭代器接口。提供 <code>hasNext()</code>, <code>next()</code>, <code>remove()</code> 方法。只能<strong>单向</strong>遍历 (<code>Collection</code> 接口使用)。</li>
<li><code>ListIterator</code>：继承 <code>Iterator</code>。专门用于 <code>List</code>。额外提供：<ul>
<li><strong>双向遍历</strong>：<code>hasPrevious()</code>, <code>previous()</code>。</li>
<li><strong>获取索引</strong>：<code>nextIndex()</code>, <code>previousIndex()</code>。</li>
<li><strong>修改元素</strong>：<code>set(E e)</code> (替换上次调用 <code>next()</code> 或 <code>previous()</code> 返回的元素)。</li>
<li><strong>添加元素</strong>：<code>add(E e)</code> (在当前游标位置插入元素)。</li>
</ul>
</li>
<li><code>ListIterator</code> 功能更强大，但只能用于 <code>List</code> 及其实现类。</li>
</ul>
<h4 id="什么是-fail-fast-机制"><a href="#什么是-fail-fast-机制" class="headerlink" title="什么是 fail-fast 机制"></a><strong>什么是 <code>fail-fast</code> 机制</strong></h4><ul>
<li>一种<strong>错误检测机制</strong>。当使用迭代器 (<code>Iterator</code>) 遍历集合时，如果<strong>在遍历过程中（除了通过迭代器自身的 <code>remove()</code> 方法外）对集合结构进行了修改</strong>（添加、删除元素），则会立即抛出 <code>ConcurrentModificationException</code>。</li>
<li><strong>实现原理</strong>：集合内部维护一个 <code>modCount</code> (修改计数器)。创建迭代器时，会将当前的 <code>modCount</code> 记录为 <code>expectedModCount</code>。在迭代过程中，每次调用 <code>next()</code>、<code>remove()</code> 等方法前都会检查 <code>modCount == expectedModCount</code>。如果不相等，说明有其他线程或本线程其他操作修改了集合结构，抛出异常。</li>
<li><strong>目的</strong>：快速失败，避免在不确定状态下继续操作导致更难以预料的结果。<strong>它不能保证并发修改一定被检测到，主要用于单线程环境下的错误检测</strong>。</li>
</ul>
<h4 id="fail-fast-和-fail-safe-的区别"><a href="#fail-fast-和-fail-safe-的区别" class="headerlink" title="fail-fast 和 fail-safe 的区别"></a><strong><code>fail-fast</code> 和 <code>fail-safe</code> 的区别</strong></h4><ul>
<li><strong><code>fail-fast</code><strong>：直接在原集合上操作。迭代时检测到并发修改就</strong>立即抛异常</strong>。代表：<code>ArrayList</code>, <code>HashMap</code> 等非并发集合的迭代器。</li>
<li><strong><code>fail-safe</code> (Concurrent Modification Tolerance)<strong>：</strong>不在原集合上操作</strong>，而是基于原集合的<strong>快照 (snapshot)</strong> 或 <strong>只读视图</strong> 进行迭代。迭代过程中原集合的修改不会影响迭代器，不会抛异常。代表：<code>ConcurrentHashMap</code>, <code>CopyOnWriteArrayList</code> 的迭代器。</li>
<li><strong>注意</strong>：<code>java.util.concurrent</code> 包下的集合通常采用 <strong>弱一致性 (Weakly Consistent)</strong> 迭代器，它提供 <code>fail-safe</code> 行为，但不保证迭代器看到所有修改。</li>
</ul>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a><code>List</code></h3><h4 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a><code>ArrayList</code>的扩容机制</h4><ul>
<li>使用 <code>Object[] elementData</code> 存储元素。</li>
<li>创建时如果未指定大小，初始容量为 <strong>0</strong> (JDK 1.8+) 或 <strong>10</strong> (旧版本，需确认具体版本)，第一次添加元素时扩容到 <strong>10</strong>。</li>
<li>当添加元素时发现容量不足（<code>size + 1 &gt; elementData.length</code>），触发扩容。</li>
<li>新容量 &#x3D; <code>ArraysSupport.newLength(oldCapacity, minCapacity - oldCapacity, oldCapacity &gt;&gt; 1)</code>，即计算新容量为 <code>oldCapacity + max(需要的最小增量, oldCapacity / 2)</code>，简单理解通常是 <strong>原容量的1.5倍</strong>。</li>
<li>创建一个新的更大的数组，将旧数组元素<strong>复制</strong>到新数组。</li>
</ul>
<h4 id="Vector-和-ArrayList-的区别"><a href="#Vector-和-ArrayList-的区别" class="headerlink" title="Vector 和 ArrayList 的区别"></a><code>Vector</code> 和 <code>ArrayList</code> 的区别</h4><ul>
<li><strong>线程安全</strong>：<ul>
<li><code>Vector</code>：<strong>线程安全</strong>。关键方法使用 <code>synchronized</code> 修饰，性能较低。</li>
<li><code>ArrayList</code>：<strong>非线程安全</strong>。性能更高。</li>
</ul>
</li>
<li><strong>扩容机制</strong>：<ul>
<li><code>Vector</code>：默认扩容为原来的 <strong>2倍</strong>，可通过构造函数指定扩容增量。</li>
<li><code>ArrayList</code>：默认扩容为原来的 <strong>1.5倍</strong> (<code>(oldCapacity * 3)/2 + 1</code>)。</li>
</ul>
</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a><code>Set</code></h3><h4 id="HashSet、LinkedHashSet-和-TreeSet-的区别"><a href="#HashSet、LinkedHashSet-和-TreeSet-的区别" class="headerlink" title="HashSet、LinkedHashSet 和 TreeSet 的区别"></a><strong><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的区别</strong></h4><ul>
<li><strong>底层实现</strong>：<ul>
<li><code>HashSet</code>：基于 <code>HashMap</code> (只需 Key，Value 用常量 <code>PRESENT</code> 填充)。</li>
<li><code>LinkedHashSet</code>：继承自 <code>HashSet</code>，基于 <code>LinkedHashMap</code>。</li>
<li><code>TreeSet</code>：基于 <code>TreeMap</code> (红黑树)。</li>
</ul>
</li>
<li><strong>元素顺序</strong>：<ul>
<li><code>HashSet</code>：<strong>无序</strong> (不保证插入顺序或恒久不变)。</li>
<li><code>LinkedHashSet</code>：<strong>按元素插入顺序排序</strong> (双向链表维护插入次序)。</li>
<li><code>TreeSet</code>：<strong>按元素的自然顺序 (<code>Comparable</code>) 或指定的 <code>Comparator</code> 排序</strong>。</li>
</ul>
</li>
<li><strong>性能</strong>：<ul>
<li><code>HashSet</code>&#x2F;<code>LinkedHashSet</code>：添加、删除、查找 O(1) (平均情况)。</li>
<li><code>TreeSet</code>：添加、删除、查找 O(log n)。</li>
</ul>
</li>
<li><strong>元素要求</strong>：<ul>
<li><code>HashSet</code>&#x2F;<code>LinkedHashSet</code>：元素必须正确实现 <code>equals()</code> 和 <code>hashCode()</code>。</li>
<li><code>TreeSet</code>：元素必须实现 <code>Comparable</code> 接口或在构造时传入 <code>Comparator</code>。</li>
</ul>
</li>
<li><strong>线程安全</strong>：三者都<strong>非线程安全</strong>。</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a><code>Map</code></h3><h4 id="HashMap-的底层实现原理"><a href="#HashMap-的底层实现原理" class="headerlink" title="HashMap 的底层实现原理"></a><strong><code>HashMap</code> 的底层实现原理</strong></h4><p><strong>JDK7：数组 + 链表</strong></p>
<ul>
<li><strong>扩容</strong>：创建新数组 (通常是原数组长度的 <strong>2倍</strong>)，遍历所有元素，<strong>重新计算每个元素在新数组中的位置</strong> (<code>rehash</code>)，将元素转移到新数组。<strong>头插法会导致扩容时链表元素顺序反转</strong>。</li>
</ul>
<p><strong>JDK8：数组 + 链表 &#x2F; 红黑树</strong></p>
<p><strong>主要改进</strong>：</p>
<ul>
<li><strong>尾插法</strong>：解决 JDK7 头插法多线程下可能导致死循环的问题（未解决线程安全问题）。</li>
<li><strong>链表转红黑树</strong>：当链表长度 <strong>&gt;&#x3D; 8 (TREEIFY_THRESHOLD)</strong> 且 <strong>数组长度 &gt;&#x3D; 64 (MIN_TREEIFY_CAPACITY)</strong> 时，链表转换为红黑树，提高长链表的查找效率 (O(n) -&gt; O(log n))。</li>
<li><strong>优化哈希算法</strong>：<code>(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，高位参与运算，减少哈希冲突。</li>
<li><strong>扩容</strong>：根据 <code>(e.hash &amp; oldCap) == 0</code> 将链表拆分成两个子链表，结果为 0 的节点保持原索引位置 <code>i</code>，结果不为 0 的节点放到新位置 <code>i + oldCap</code>，避免全量 <code>rehash</code>，提升了效率。</li>
</ul>
<h4 id="HashMap-和-HashTable-的区别"><a href="#HashMap-和-HashTable-的区别" class="headerlink" title="HashMap 和 HashTable 的区别"></a><strong><code>HashMap</code> 和 <code>HashTable</code> 的区别</strong></h4><ul>
<li><strong>线程安全</strong>：<ul>
<li><code>HashMap</code>：<strong>非线程安全</strong>。性能更高。</li>
<li><code>Hashtable</code>：<strong>线程安全</strong>。几乎所有公共方法都用 <code>synchronized</code> 修饰，性能较低。</li>
</ul>
</li>
<li><strong><code>null</code> 值</strong>：<ul>
<li><code>HashMap</code>：允许 <code>key</code> 和 <code>value</code> 为 <code>null</code>。</li>
<li><code>Hashtable</code>：不允许 <code>key</code> 或 <code>value</code> 为 <code>null</code>。</li>
</ul>
</li>
<li><strong>继承体系</strong>：<ul>
<li><code>HashMap</code>：继承 <code>AbstractMap</code>。</li>
<li><code>Hashtable</code>：继承 <code>Dictionary</code> (一个古老的类)。</li>
</ul>
</li>
<li><strong>迭代器</strong>：<ul>
<li><code>HashMap</code> 的 <code>Iterator</code> 是 <strong>fail-fast</strong> 的。</li>
<li><code>Hashtable</code> 的 <code>Enumerator</code> 不是 fail-fast 的。</li>
</ul>
</li>
<li><strong>初始容量与扩容</strong>：<ul>
<li><code>HashMap</code>：默认 16，扩容为 2 倍。</li>
<li><code>Hashtable</code>：默认 11，扩容为 2 倍 + 1 (<code>oldCapacity * 2 + 1</code>)。</li>
</ul>
</li>
<li><strong>哈希计算</strong>：<ul>
<li><code>HashMap</code>：优化了哈希函数 (<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>)。</li>
<li><code>Hashtable</code>：直接使用 <code>key.hashCode()</code>。</li>
</ul>
</li>
<li><strong>推荐使用</strong>：<code>HashMap</code> + <code>ConcurrentHashMap</code> 或 <code>Collections.synchronizedMap()</code> 代替 <code>Hashtable</code>。</li>
</ul>
<h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h2><h3 id="字节流与字符流的区别"><a href="#字节流与字符流的区别" class="headerlink" title="字节流与字符流的区别"></a>字节流与字符流的区别</h3><ul>
<li><strong>字节流</strong>：<code>InputStream</code>&#x2F;<code>OutputStream</code>，处理二进制数据（如图片、视频），核心类如 <code>FileInputStream</code>。</li>
<li><strong>字符流</strong>：<code>Reader</code>&#x2F;<code>Writer</code>，处理文本数据（自动处理编码），核心类如 <code>FileReader</code>、<code>InputStreamReader</code>。</li>
<li><strong>关键点</strong>：字符流底层依赖字节流 + 编码转换（如 <code>InputStreamReader</code> 是字节到字符的桥梁）。</li>
</ul>
<p><strong>为什么要有字符流？</strong></p>
<ul>
<li>直接操作字符更高效，避免手动处理编码（如 UTF-8 转码），解决乱码问题。</li>
</ul>
<h3 id="BIO、NIO、AIO的区别"><a href="#BIO、NIO、AIO的区别" class="headerlink" title="BIO、NIO、AIO的区别"></a>BIO、NIO、AIO的区别</h3><table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left">传统 IO</th>
<th align="left">NIO</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>模型</strong></td>
<td align="left">阻塞式（Blocking）</td>
<td align="left">非阻塞式（Non-blocking）</td>
</tr>
<tr>
<td align="left"><strong>数据单位</strong></td>
<td align="left">流（Stream）</td>
<td align="left">缓冲区（Buffer） + 通道（Channel）</td>
</tr>
<tr>
<td align="left"><strong>多路复用</strong></td>
<td align="left">不支持</td>
<td align="left">Selector 轮询机制</td>
</tr>
</tbody></table>
<h3 id="NIO-三大核心组件"><a href="#NIO-三大核心组件" class="headerlink" title="NIO 三大核心组件"></a>NIO 三大核心组件</h3><ul>
<li><strong>Buffer</strong>：数据容器（如 <code>ByteBuffer</code>），支持 <code>flip()</code>、<code>clear()</code> 等操作。</li>
<li><strong>Channel</strong>：双向数据传输通道（如 <code>FileChannel</code>、<code>SocketChannel</code>）。</li>
<li><strong>Selector</strong>：单线程监听多个 Channel 事件（OP_READ&#x2F;OP_WRITE）。</li>
</ul>
<h3 id="什么是零拷贝"><a href="#什么是零拷贝" class="headerlink" title="什么是零拷贝"></a>什么是零拷贝</h3><h3 id="有哪些IO模型"><a href="#有哪些IO模型" class="headerlink" title="有哪些IO模型"></a>有哪些IO模型</h3><p>在计算机 I&#x2F;O 操作中，主要有五种 I&#x2F;O 模型。</p>
<p><strong>1. 阻塞 I&#x2F;O 模型 (Blocking I&#x2F;O)</strong></p>
<p><strong>特点</strong>：线程发起 I&#x2F;O 操作后会被挂起，直到操作完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器端</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>)) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 阻塞直到客户端连接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">clientSocket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> clientSocket.getInputStream()) &#123;</span><br><span class="line">                <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="comment">// 阻塞直到数据到达</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> in.read(buffer);</span><br><span class="line">                <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">                System.out.println(<span class="string">&quot;Received: &quot;</span> + data);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 非阻塞 I&#x2F;O 模型 (Non-blocking I&#x2F;O)</strong></p>
<p><strong>特点</strong>：线程立即返回结果，通过轮询检查就绪状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器端</span></span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">serverChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">serverChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">serverChannel.configureBlocking(<span class="literal">false</span>); <span class="comment">// 设置为非阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 立即返回，可能为 null</span></span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> serverChannel.accept();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (clientChannel != <span class="literal">null</span>) &#123;</span><br><span class="line">        clientChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 非阻塞读取</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> clientChannel.read(buffer);</span><br><span class="line">        <span class="keyword">if</span> (bytesRead &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[buffer.limit()];</span><br><span class="line">            buffer.get(data);</span><br><span class="line">            System.out.println(<span class="string">&quot;Received: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 可执行其他任务</span></span><br><span class="line">        Thread.sleep(<span class="number">100</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. I&#x2F;O 多路复用模型 (I&#x2F;O Multiplexing)</strong></p>
<p><strong>特点</strong>：使用单个线程管理多个 I&#x2F;O 通道</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器端</span></span><br><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">serverChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">serverChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">serverChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 阻塞直到有就绪事件</span></span><br><span class="line">    selector.select();</span><br><span class="line">    </span><br><span class="line">    Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; iter = selectedKeys.iterator();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            <span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> server.accept();</span><br><span class="line">            client.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            client.read(buffer);</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">// 处理数据...</span></span><br><span class="line">        &#125;</span><br><span class="line">        iter.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 信号驱动 I&#x2F;O 模型 (Signal-driven I&#x2F;O)</strong></p>
<p><strong>特点</strong>：通过信号通知 I&#x2F;O 就绪状态（Java 不直接支持）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* C语言示例（Java无直接对应API） */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigio_handler</span><span class="params">(<span class="type">int</span> signo)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理I/O就绪事件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    signal(SIGIO, sigio_handler);</span><br><span class="line">    fcntl(sockfd, F_SETOWN, getpid());</span><br><span class="line">    fcntl(sockfd, F_SETFL, O_ASYNC | O_NONBLOCK);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5. 异步 I&#x2F;O 模型 (Asynchronous I&#x2F;O)</strong></p>
<p><strong>特点</strong>：I&#x2F;O 操作完成后自动通知，无需等待</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器端</span></span><br><span class="line"><span class="type">AsynchronousServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> </span><br><span class="line">    AsynchronousServerSocketChannel.open().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步接受连接</span></span><br><span class="line">server.accept(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, Void&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(AsynchronousSocketChannel client, Void attachment)</span> &#123;</span><br><span class="line">        server.accept(<span class="literal">null</span>, <span class="built_in">this</span>); <span class="comment">// 继续接受新连接</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 异步读取数据</span></span><br><span class="line">        client.read(buffer, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, Void&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer bytesRead, Void attachment)</span> &#123;</span><br><span class="line">                buffer.flip();</span><br><span class="line">                <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[buffer.limit()];</span><br><span class="line">                buffer.get(data);</span><br><span class="line">                System.out.println(<span class="string">&quot;Async received: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, Void attachment)</span> &#123;</span><br><span class="line">                exc.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, Void attachment)</span> &#123;</span><br><span class="line">        exc.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>各模型对比总结：</strong></p>
<table>
<thead>
<tr>
<th align="left">模型</th>
<th align="left">阻塞阶段</th>
<th align="left">Java 实现</th>
<th align="left">优点</th>
<th align="left">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>阻塞 I&#x2F;O</strong></td>
<td align="left">等待数据到达和复制</td>
<td align="left"><code>Socket</code>, <code>ServerSocket</code></td>
<td align="left">编程简单</td>
<td align="left">线程资源浪费</td>
</tr>
<tr>
<td align="left"><strong>非阻塞 I&#x2F;O</strong></td>
<td align="left">无（但需轮询）</td>
<td align="left">NIO <code>configureBlocking(false)</code></td>
<td align="left">单线程管理多连接</td>
<td align="left">轮询消耗 CPU</td>
</tr>
<tr>
<td align="left"><strong>I&#x2F;O 多路复用</strong></td>
<td align="left">等待事件通知</td>
<td align="left">NIO <code>Selector</code></td>
<td align="left">高效管理大量连接</td>
<td align="left">编程较复杂</td>
</tr>
<tr>
<td align="left"><strong>信号驱动 I&#x2F;O</strong></td>
<td align="left">无（但需处理信号）</td>
<td align="left">Java 不支持</td>
<td align="left">减少轮询开销</td>
<td align="left">编程复杂，信号队列溢出</td>
</tr>
<tr>
<td align="left"><strong>异步 I&#x2F;O</strong></td>
<td align="left">无（完全异步）</td>
<td align="left">NIO.2 <code>AsynchronousChannel</code></td>
<td align="left">真正非阻塞，资源利用率高</td>
<td align="left">编程模型复杂</td>
</tr>
</tbody></table>
<h3 id="IO中阻塞与非阻塞、同步与异步的区别是什么"><a href="#IO中阻塞与非阻塞、同步与异步的区别是什么" class="headerlink" title="IO中阻塞与非阻塞、同步与异步的区别是什么"></a>IO中阻塞与非阻塞、同步与异步的区别是什么</h3><p><strong>1. 阻塞 I&#x2F;O（Blocking I&#x2F;O）</strong></p>
<p>线程会一直等待操作完成，期间无法执行其他任务。</p>
<p><strong>示例：阻塞 Socket 服务器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主线程在 accept() 和 read() 时阻塞</span></span><br><span class="line"><span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>);</span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept(); <span class="comment">// 阻塞直到有客户端连接</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> in.read(); <span class="comment">// 阻塞直到数据到达</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 非阻塞 I&#x2F;O（Non-blocking I&#x2F;O）</strong></p>
<p>线程立即返回结果（无论是否就绪），通过轮询或事件通知机制处理就绪状态。</p>
<p><strong>示例：NIO 非阻塞 Selector</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">serverChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">serverChannel.configureBlocking(<span class="literal">false</span>); <span class="comment">// 非阻塞模式</span></span><br><span class="line">serverChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    selector.select(); <span class="comment">// 阻塞直到有事件就绪（可设置超时）</span></span><br><span class="line">    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">    <span class="keyword">for</span> (SelectionKey key : keys) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> serverChannel.accept();</span><br><span class="line">            clientChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            clientChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            client.read(buffer); <span class="comment">// 非阻塞读取，可能返回0字节</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">// 处理数据...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    keys.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 同步（Synchronous）</strong></p>
<p>调用者主动等待结果返回，线程可能阻塞（同步阻塞）或轮询（同步非阻塞）。</p>
<p><strong>示例：同步阻塞的 Future</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">Future&lt;String&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟耗时任务</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Result&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get(); <span class="comment">// 同步阻塞，直到结果返回</span></span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>

<p><strong>4. 异步（Asynchronous）</strong></p>
<p>调用者发起操作后立即返回，通过回调或事件通知获取结果。</p>
<p><strong>示例：CompletableFuture 异步回调</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟耗时任务</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Result&quot;</span>;</span><br><span class="line">&#125;).thenAccept(result -&gt; &#123; <span class="comment">// 异步回调处理结果</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Async result: &quot;</span> + result);</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;主线程继续执行...&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>示例：NIO.2 异步文件读取</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AsynchronousFileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> </span><br><span class="line">    AsynchronousFileChannel.open(Paths.get(<span class="string">&quot;test.txt&quot;</span>));</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">fileChannel.read(buffer, <span class="number">0</span>, buffer, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer bytesRead, ByteBuffer buffer)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;读取完成，字节数: &quot;</span> + bytesRead);</span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="comment">// 处理数据...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer buffer)</span> &#123;</span><br><span class="line">        exc.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>同步阻塞</strong>：线程直接等待结果（如 <code>InputStream.read()</code>）。</li>
<li><strong>同步非阻塞</strong>：线程轮询检查状态（如 NIO 的 <code>Selector</code>）。</li>
<li><strong>异步非阻塞</strong>：操作完成后自动触发回调（如 <code>CompletableFuture</code>）。</li>
</ul>
<h3 id="什么是Reactor模型"><a href="#什么是Reactor模型" class="headerlink" title="什么是Reactor模型"></a>什么是Reactor模型</h3><h2 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h2><h3 id="synchronized-的实现原理"><a href="#synchronized-的实现原理" class="headerlink" title="synchronized 的实现原理"></a><code>synchronized</code> 的实现原理</h3><p><code>synchronized</code> 关键字在 Java 中的底层实现依赖于 <strong>JVM 对象头、Monitor 监视器锁以及锁升级机制</strong>。</p>
<h4 id="对象头与-Mark-Word"><a href="#对象头与-Mark-Word" class="headerlink" title="对象头与 Mark Word"></a><strong>对象头与 Mark Word</strong></h4><ul>
<li><p>每个 Java 对象在内存中分为三部分：</p>
<ul>
<li><strong>对象头（Header）</strong>：存储锁状态、GC 年龄等元数据。</li>
<li><strong>实例数据（Instance Data）</strong>：对象字段值。</li>
<li><strong>对齐填充（Padding）</strong>：保证内存对齐。</li>
</ul>
</li>
<li><p><strong>Mark Word</strong>（对象头的核心部分）存储以下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">| 锁状态       | 存储内容                       |</span><br><span class="line">|-------------|-------------------------------|</span><br><span class="line">| 无锁         | 对象哈希码、分代年龄             |</span><br><span class="line">| 偏向锁       | 偏向线程ID、偏向时间戳           |</span><br><span class="line">| 轻量级锁      | 指向栈中锁记录的指针             |</span><br><span class="line">| 重量级锁      | 指向 Monitor 的指针            |</span><br><span class="line">| GC 标记      | 与垃圾回收相关                  |</span><br></pre></td></tr></table></figure>

<p><strong>锁状态的变化直接体现在 Mark Word 的比特位组合上。</strong></p>
</li>
</ul>
<h4 id="Monitor-监视器锁"><a href="#Monitor-监视器锁" class="headerlink" title="Monitor 监视器锁"></a><strong>Monitor 监视器锁</strong></h4><ul>
<li><p>当 <code>synchronized</code> 升级为重量级锁时，Mark Word 指向一个 <strong>Monitor 对象</strong>（由 C++ 实现的 <code>ObjectMonitor</code>）。</p>
</li>
<li><p>Monitor 的核心结构：</p>
<p>cpp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class ObjectMonitor &#123;</span><br><span class="line">    void*     _header;      // 存储 Mark Word 的备份</span><br><span class="line">    void*     _owner;       // 持有锁的线程（如：Thread*）</span><br><span class="line">    intptr_t  _count;       // 重入次数</span><br><span class="line">    ObjectWaiter* _WaitSet; // 调用 wait() 后进入等待队列</span><br><span class="line">    ObjectWaiter* _EntryList; // 阻塞等待锁的线程队列</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>工作流程</strong>：</p>
<ol>
<li>线程尝试通过 CAS 操作将 Mark Word 替换为指向 Monitor 的指针。</li>
<li>成功则成为 <code>_owner</code>，失败则进入 <code>_EntryList</code> 阻塞（通过操作系统 mutex 实现）。</li>
<li>当 <code>_owner</code> 释放锁时，唤醒 <code>_EntryList</code> 中的线程竞争锁。</li>
</ol>
</li>
</ul>
<h4 id="锁升级机制"><a href="#锁升级机制" class="headerlink" title="锁升级机制"></a><strong>锁升级机制</strong></h4><p>为提高性能，从 java1.6 开始采用渐进式锁升级策略：</p>
<p>(1) <strong>偏向锁（Biased Locking）</strong></p>
<ul>
<li><strong>目标</strong>：减少无竞争时的开销。</li>
<li><strong>流程</strong>：<ul>
<li>首次加锁时，通过 CAS 将 Mark Word 的锁标志置为 <code>101</code>（偏向锁），并写入当前线程 ID。</li>
<li>后续同一线程进入同步块时，只需检查线程 ID 匹配即可直接执行（零开销）。</li>
</ul>
</li>
<li><strong>撤销</strong>：当其他线程尝试获取锁时，撤销偏向锁（Stop-The-World 操作）。</li>
</ul>
<p>(2) <strong>轻量级锁（Lightweight Locking）</strong></p>
<ul>
<li><strong>目标</strong>：避免短时阻塞的线程切换开销。</li>
<li><strong>流程</strong>：<ol>
<li>在栈帧中创建 <strong>锁记录（Lock Record）</strong>。</li>
<li>通过 CAS 将 Mark Word 复制到锁记录，并尝试将 Mark Word 替换为指向锁记录的指针。</li>
<li>成功则获得锁；失败则自旋（循环尝试）一定次数。</li>
</ol>
</li>
<li><strong>自旋失败后升级为重量级锁</strong>。</li>
</ul>
<p>(3) <strong>重量级锁（Heavyweight Locking）</strong></p>
<ul>
<li>当竞争激烈时，最终升级为重量级锁。</li>
<li>线程通过操作系统互斥量（mutex）阻塞，进入内核态，性能开销最大。</li>
</ul>
<img src="/post/7992e236/image-20250725195316321.png" class="" title="image-20250725195316321">

<p><code>synchronized</code> 和 <code>ReentrantLock</code> 有什么区别</p>
<ul>
<li>synchronized 是 JVM 实现的，ReentrantLock 是 JDK 实现的</li>
<li>synchronized 不可中断，ReentrantLock 可中断</li>
<li>synchronized 非公平，ReentrantLock 默认也是非公平，可设置为公平</li>
<li>synchronized 只能锁定一个对象，ReentrantLock 可以锁定多个对象</li>
</ul>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a><code>ThreadLocal</code></h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>ThreadLocal 是 Java 中一个用于实现<strong>线程局部变量</strong>的工具类。它为每个使用该变量的线程提供了一个独立的变量副本，从而实现了线程间的数据隔离。这意味着每个线程都可以独立地改变自己的副本，而不会影响其他线程的副本。</p>
<p><strong>核心原理：</strong></p>
<ol>
<li><strong>Thread 类中的 ThreadLocalMap：</strong><ul>
<li>每个 <code>Thread</code> 对象内部都有一个私有成员变量 <code>threadLocals</code> (在 JDK 源码中是 <code>java.lang.Thread.threadLocals</code>)，它的类型是 <code>ThreadLocal.ThreadLocalMap</code>。</li>
<li><code>ThreadLocalMap</code> 是一个定制的、类似 <code>HashMap</code> 的结构，专门用于存储线程局部变量。它的键是 <code>ThreadLocal</code> 对象本身（使用弱引用），值是该线程对应的变量副本。</li>
</ul>
</li>
<li><strong>ThreadLocal 的操作机制：</strong><ul>
<li><strong><code>set(T value)</code>：</strong> 当调用 <code>threadLocal.set(value)</code> 时：<ol>
<li>获取当前正在执行的线程 (<code>Thread.currentThread()</code>)。</li>
<li>获取该线程的 <code>threadLocals</code> 成员（一个 <code>ThreadLocalMap</code>）。</li>
<li>如果 <code>threadLocals</code> 为 <code>null</code>，则创建一个新的 <code>ThreadLocalMap</code> 并赋值给线程的 <code>threadLocals</code>。</li>
<li>以当前的 <code>ThreadLocal</code> 实例 (<code>this</code>) 作为键，传入的 <code>value</code> 作为值，存储到这个线程的 <code>ThreadLocalMap</code> 中。</li>
</ol>
</li>
<li><strong><code>get()</code>：</strong> 当调用 <code>threadLocal.get()</code> 时：<ol>
<li>获取当前线程。</li>
<li>获取该线程的 <code>threadLocals</code>。</li>
<li>如果 <code>threadLocals</code> 不为 <code>null</code>，则以当前 <code>ThreadLocal</code> 实例为键，查找 <code>ThreadLocalMap</code> 中对应的条目 (<code>Entry</code>)。</li>
<li>如果找到条目且条目不为 <code>null</code>，则返回其值。</li>
<li>如果没找到或找到的条目值为 <code>null</code>，则调用 <code>initialValue()</code> 方法（如果用户重写了）或 <code>setInitialValue()</code> 方法来初始化并设置一个值（通常默认返回 <code>null</code>），然后返回这个初始值。</li>
</ol>
</li>
<li><strong><code>remove()</code>：</strong> 当调用 <code>threadLocal.remove()</code> 时：<ol>
<li>获取当前线程的 <code>threadLocals</code>。</li>
<li>如果 <code>threadLocals</code> 不为 <code>null</code>，则从中移除以当前 <code>ThreadLocal</code> 实例为键的条目。<strong>这是一个非常重要的操作，用于避免内存泄漏！</strong></li>
</ol>
</li>
</ul>
</li>
<li><strong>关键点：</strong><ul>
<li><strong>数据存储位置：</strong> 变量副本实际存储在<strong>线程对象</strong>内部的 <code>ThreadLocalMap</code> 里，而不是存储在 <code>ThreadLocal</code> 对象本身。<code>ThreadLocal</code> 只是一个访问这些副本的工具和键。</li>
<li><strong>键的引用：</strong> <code>ThreadLocalMap</code> 中的键 (<code>ThreadLocal</code> 对象) 是<strong>弱引用</strong>。这是为了在 <code>ThreadLocal</code> 实例本身不再被强引用时（比如被 GC 回收了），<code>ThreadLocalMap</code> 中的键能自动被 GC 回收，避免内存泄漏（键部分）。</li>
<li><strong>值的引用：</strong> <code>ThreadLocalMap</code> 中的值是<strong>强引用</strong>。这就是为什么如果 <code>ThreadLocal</code> 被回收了（键变 <code>null</code>），但线程（尤其是线程池中的线程）长期存活，且没有调用 <code>remove()</code> 方法，那么值对象会一直被 <code>ThreadLocalMap</code> 的条目强引用着，导致值对象无法被回收，造成<strong>内存泄漏</strong>（值部分）。</li>
<li><strong>内存泄漏风险：</strong> 这是使用 <code>ThreadLocal</code> 最大的隐患。主要发生在：<ul>
<li>使用了<strong>线程池</strong>（线程复用，生命周期长）。</li>
<li>在 <code>ThreadLocal</code> 中存储了<strong>大对象</strong>。</li>
<li>在任务执行完毕后，<strong>没有调用 <code>threadLocal.remove()</code></strong> 来清理当前线程的副本。</li>
</ul>
</li>
<li><strong>继承性：</strong> <code>ThreadLocal</code> 本身不支持变量从父线程传递给子线程。如果需要这种能力，可以使用 <code>InheritableThreadLocal</code>。</li>
</ul>
</li>
</ol>
<img src="/post/7992e236/image-20250725210437363.png" class="" title="image-20250725210437363">

<p><strong>实际应用场景：</strong></p>
<p><code>ThreadLocal</code> 主要用于需要将状态（如用户 ID、事务上下文、Locale 信息）与单个线程关联的场景，避免在方法参数中显式传递这些上下文信息，尤其是在调用链很深的情况下。常见应用包括：</p>
<ol>
<li><strong>上下文信息传递：</strong><ul>
<li><strong>用户会话 (Session&#x2F;User ID)：</strong> 在 Web 应用中，一个请求通常由一个线程处理。将当前登录用户的信息存储在 <code>ThreadLocal</code> 中，可以在请求处理的任何地方（Controller, Service, DAO）方便地获取，无需在每个方法参数中传递。</li>
<li><strong>事务管理：</strong> Spring 框架等使用 <code>ThreadLocal</code> 来保存当前线程的事务上下文（如数据库连接 Connection 对象），确保同一个事务内的所有数据库操作使用同一个连接。</li>
<li><strong>全局请求信息：</strong> 如请求 ID、Trace ID（用于分布式链路追踪）、时区、语言 (Locale) 等。</li>
<li><strong>权限信息：</strong> 当前用户的角色、权限列表等。</li>
</ul>
</li>
<li><strong>线程专有对象：</strong><ul>
<li><strong>非线程安全对象的线程安全使用：</strong> 例如 <code>SimpleDateFormat</code> 是线程不安全的。为每个线程创建一个独立的 <code>SimpleDateFormat</code> 实例存储在 <code>ThreadLocal</code> 中，可以避免同步开销和线程安全问题。</li>
<li><strong>避免重复创建开销大的对象：</strong> 如果一个对象创建成本高（如复杂的解析器、大缓冲区），且仅在线程内部多次使用，可以将其存储在 <code>ThreadLocal</code> 中作为线程的“缓存”，避免每次使用都创建新实例。</li>
<li><strong>数据库连接（特定场景）：</strong> 虽然通常由连接池管理，但在一些特殊设计或小型应用中，<code>ThreadLocal</code> 可用于确保一个线程内多次数据库操作复用同一个连接（需谨慎管理生命周期）。</li>
</ul>
</li>
<li><strong>跨方法参数传递：</strong><ul>
<li>当一个参数需要在调用栈中很深层次的方法中使用，但中间层方法不需要它时，显式传递会污染中间方法的签名。将其放入 <code>ThreadLocal</code> 可以避免这种显式传递。</li>
</ul>
</li>
<li><strong>替代显式同步：</strong><ul>
<li>当多个线程需要操作不同实例（非共享）的数据时，使用 <code>ThreadLocal</code> 让每个线程操作自己的副本，可以完全避免同步（锁）带来的性能开销和复杂性。</li>
</ul>
</li>
</ol>
<p><strong>使用 ThreadLocal 的最佳实践与注意事项：</strong></p>
<ol>
<li><p><strong><code>private static final</code>：</strong> 通常将 <code>ThreadLocal</code> 变量声明为 <code>private static final</code>。<code>static</code> 确保每个类只有一个 <code>ThreadLocal</code> 实例（作为键），<code>final</code> 防止意外修改引用。<code>private</code> 控制访问。</p>
</li>
<li><p><strong>务必清理：</strong> 这是最重要的！<strong>尤其是在使用线程池时</strong>。在任务执行完毕、线程被归还给线程池之前，必须调用 <code>threadLocal.remove()</code> 来显式清除当前线程的副本。否则会导致严重的内存泄漏和潜在的数据错乱（线程池中下一个任务可能读到前一个任务遗留的数据）。</p>
<ul>
<li><p>使用 <code>try-finally</code> 块确保 <code>remove()</code> 被执行：</p>
<p>java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    threadLocal.set(someValue);</span><br><span class="line">    // ... 执行业务逻辑 ...</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    threadLocal.remove(); // 无论如何都清理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>避免存储大对象：</strong> 谨慎存储占用内存大的对象，因为线程长期存活（尤其是线程池）会导致这些对象长期无法释放。</p>
</li>
<li><p><strong>理解内存泄漏：</strong> 深刻理解弱引用键和强引用值导致的内存泄漏机制，并严格遵守 <code>remove()</code> 的规范。</p>
</li>
<li><p><strong>考虑 InheritableThreadLocal：</strong> 如果需要父线程的局部变量被子线程继承，使用 <code>InheritableThreadLocal</code>。但要注意线程池场景下，线程是复用的，子任务可能不是由创建 <code>InheritableThreadLocal</code> 的父线程执行的，继承可能不符合预期。</p>
</li>
<li><p><strong>初始值：</strong> 可以通过覆盖 <code>initialValue()</code> 方法（在第一次 <code>get()</code> 时调用）或在 Java 8 之后使用 <code>ThreadLocal.withInitial(Supplier)</code> 来设置初始值。</p>
</li>
</ol>
<p><strong>总结：</strong></p>
<p><code>ThreadLocal</code> 通过在每个线程内部维护一个专属的变量存储空间 (<code>ThreadLocalMap</code>)，实现了高效的线程局部变量。它是解决线程间数据隔离、上下文传递、线程专有对象管理等问题的强大工具。然而，其伴随的<strong>内存泄漏风险</strong>要求开发者必须严格遵守 <code>remove()</code> 的最佳实践，尤其是在线程池环境下。合理使用 <code>ThreadLocal</code> 可以简化代码、提高性能，但滥用或疏忽清理则可能带来难以排查的问题。</p>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><p><strong>示例1：存储用户信息</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserContextHolder</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个ThreadLocal变量，用于存储用户ID。通常声明为private static final</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; currentUser = ThreadLocal.withInitial(() -&gt; <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 设置当前线程的用户ID</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setCurrentUser</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">        currentUser.set(userId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前线程的用户ID</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getCurrentUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currentUser.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清除当前线程的用户ID（重要！避免内存泄漏）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        currentUser.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在拦截器或过滤器中设置和清除</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> &#123;</span><br><span class="line">        <span class="comment">// 从请求中获取用户信息（比如token解析）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> ...; </span><br><span class="line">        UserContextHolder.setCurrentUser(userId);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> &#123;</span><br><span class="line">        <span class="comment">// 请求处理完成后，清除ThreadLocal，防止内存泄漏</span></span><br><span class="line">        UserContextHolder.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例2：事务管理</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionContextHolder</span> &#123;</span><br><span class="line">    <span class="comment">// 存储当前线程的事务连接</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Connection&gt; currentConnection = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> currentConnection.get();</span><br><span class="line">        <span class="keyword">if</span> (conn == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果没有，则从连接池获取一个新的连接，并设置到ThreadLocal</span></span><br><span class="line">            conn = DataSourceUtils.getConnection(); <span class="comment">// 假设的工具类</span></span><br><span class="line">            currentConnection.set(conn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bindConnection</span><span class="params">(Connection conn)</span> &#123;</span><br><span class="line">        currentConnection.set(conn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unbindConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        currentConnection.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionManager</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> TransactionContextHolder.getConnection();</span><br><span class="line">        conn.setAutoCommit(<span class="literal">false</span>); <span class="comment">// 开启事务</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> TransactionContextHolder.getConnection();</span><br><span class="line">        conn.commit();</span><br><span class="line">        TransactionContextHolder.unbindConnection(); <span class="comment">// 提交后移除连接，并释放到连接池</span></span><br><span class="line">        DataSourceUtils.releaseConnection(conn); <span class="comment">// 假设的工具类，将连接归还连接池</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...类似commit，回滚事务并清理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> TransactionContextHolder.getConnection();</span><br><span class="line">        <span class="comment">// 使用conn执行更新...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="JUC集合"><a href="#JUC集合" class="headerlink" title="JUC集合"></a>JUC集合</h3><h4 id="ConcurrentHashMap-的实现原理"><a href="#ConcurrentHashMap-的实现原理" class="headerlink" title="ConcurrentHashMap 的实现原理"></a><code>ConcurrentHashMap</code> 的实现原理</h4><ul>
<li><strong>JDK7：分段锁 (Segment Locking)</strong><ul>
<li>将数据分成多个段 (<code>Segment</code> 数组，默认 16 个段)。</li>
<li>每个 <code>Segment</code> 本身是一个类似 <code>ReentrantLock</code> 的锁，并管理一个独立的 <code>HashEntry</code> 数组 (相当于一个小型的 <code>HashMap</code>)。</li>
<li><strong>锁粒度</strong>：锁住的是<strong>整个段</strong>。不同段上的操作可以并发进行。并发度等于 <code>Segment</code> 的数量。</li>
<li><strong>PUT</strong>：先定位到哪个 <code>Segment</code>，然后对该 <code>Segment</code> <strong>加锁</strong>，再在该 <code>Segment</code> 内部的哈希表上进行操作（类似 <code>HashMap</code> JDK7）。</li>
<li><strong>GET</strong>：<strong>无锁</strong> (volatile 读)。定位到 <code>Segment</code> 和 <code>HashEntry</code> 后直接读取 <code>value</code> (value 是 volatile 的)。</li>
</ul>
</li>
<li><strong>JDK8：<code>synchronized</code> + <code>CAS</code> + 红黑树</strong><ul>
<li>摒弃分段锁，采用 <code>Node</code> 数组 + 链表 &#x2F; 红黑树 (结构类似 <code>HashMap</code> JDK8)。</li>
<li><strong>锁粒度</strong>：<strong>锁单个链表头节点或树根节点</strong> (桶级别)。并发度大大提高。</li>
<li><strong>关键机制</strong>：<ul>
<li><code>CAS</code> (Compare-And-Swap)：用于无锁化的初始化数组、插入新节点 (<code>tabAt</code>, <code>casTabAt</code>, <code>setTabAt</code> 使用 <code>Unsafe</code> 操作)。</li>
<li><code>synchronized</code>：当发生哈希冲突（桶不为空）时，对链表的头节点或树的根节点加 <code>synchronized</code> 锁。锁对象是头节点本身。</li>
<li><code>volatile</code>：<code>Node</code> 的 <code>val</code> 和 <code>next</code> 字段用 <code>volatile</code> 修饰，保证可见性。</li>
</ul>
</li>
<li><strong>PUT</strong>：<ol>
<li>计算哈希值，定位桶位置。</li>
<li>如果桶为空，尝试用 <code>CAS</code> 插入新节点。</li>
<li>如果桶不为空（可能有锁竞争）：<ul>
<li>如果该桶节点正在扩容 (<code>MOVED</code>)，当前线程协助扩容 (<code>helpTransfer</code>)。</li>
<li>否则，<strong>对桶的头节点加 <code>synchronized</code> 锁</strong>。</li>
<li>在锁内，根据是链表还是树，执行类似 <code>HashMap</code> JDK8 的插入逻辑（尾插法，树化）。</li>
</ul>
</li>
<li>检查是否需要扩容（链表长度达到 8 且数组长度 &lt; 64 时优先扩容）。</li>
</ol>
</li>
<li><strong>GET</strong>：<strong>完全无锁</strong>。定位到桶后，根据链表或树遍历查找。依赖 <code>volatile</code> 读保证可见性。</li>
<li><strong>扩容</strong>：支持<strong>多线程协同扩容</strong> (<code>transfer</code>)。当一个线程触发扩容时，它负责分配迁移任务区间。其他线程在 PUT 操作时如果发现正在扩容，会协助迁移一部分数据。使用 <code>ForwardingNode</code> 节点标记迁移完成的桶。</li>
</ul>
</li>
</ul>
<h4 id="为什么-ConcurrentHashMap-比-Hashtable-效率高"><a href="#为什么-ConcurrentHashMap-比-Hashtable-效率高" class="headerlink" title="为什么 ConcurrentHashMap 比 Hashtable 效率高"></a><strong>为什么 <code>ConcurrentHashMap</code> 比 <code>Hashtable</code> 效率高</strong></h4><ul>
<li><strong>锁粒度</strong>：<ul>
<li><code>Hashtable</code>：<strong>全局锁</strong>。锁住整个表，一次只允许一个线程操作。</li>
<li><code>ConcurrentHashMap</code> (JDK7)：分段锁。锁住一个段，不同段操作可并发。</li>
<li><code>ConcurrentHashMap</code> (JDK8)：桶锁 (头节点锁)。锁粒度更细，冲突概率更低，并发度更高。</li>
</ul>
</li>
<li><strong>无锁读</strong>：<ul>
<li><code>Hashtable</code>：读操作也需要获取锁。</li>
<li><code>ConcurrentHashMap</code> (JDK7 &amp; JDK8)：<strong>读操作完全无锁</strong> (JDK7 利用 volatile value，JDK8 利用 volatile val&#x2F;next 和 Unsafe 的原子读)，极大提升读性能。</li>
</ul>
</li>
</ul>
<h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><h3 id="CompletableFuture的原理与应用"><a href="#CompletableFuture的原理与应用" class="headerlink" title="CompletableFuture的原理与应用"></a><code>CompletableFuture</code>的原理与应用</h3><p><code>CompletableFuture</code> 是 Java 8 引入的核心并发工具类（位于 <code>java.util.concurrent</code> 包），它代表一个<strong>异步计算的结果</strong>。它不仅是对传统 <code>Future</code> 接口的增强，更是一个强大的<strong>异步编程框架</strong>，支持显式地完成计算、链式组合多个异步任务、处理结果和异常，是实现响应式、非阻塞编程的关键组件。</p>
<p><strong>一、核心原理</strong></p>
<ol>
<li><strong>异步执行与结果容器：</strong><ul>
<li>它本质上是一个<strong>容器</strong>，用于承载将来某个时刻计算完成的结果（或异常）。</li>
<li>计算任务通常被提交给 <code>Executor</code>（线程池）在后台线程中执行，避免阻塞调用线程。</li>
<li>创建时结果未知，计算完成后结果被设置（<code>complete(result)</code> 或 <code>completeExceptionally(throwable)</code>）。</li>
</ul>
</li>
<li><strong>显式完成：</strong><ul>
<li>与传统 <code>Future</code> 只能被动等待不同，<code>CompletableFuture</code> 可以被<strong>主动完成</strong>。</li>
<li>任何拥有该对象引用的线程都可以调用 <code>complete()</code> 或 <code>completeExceptionally()</code> 手动设置结果或异常。这是实现超时控制、外部事件触发完成等场景的基础。</li>
</ul>
</li>
<li><strong>链式组合与回调 (CompletionStage)：</strong><ul>
<li><code>CompletableFuture</code> 实现了 <code>CompletionStage</code> 接口，这是其强大能力的核心。</li>
<li><code>CompletionStage</code> 定义了丰富的链式方法（<code>thenApply</code>, <code>thenAccept</code>, <code>thenRun</code>, <code>thenCompose</code>, <code>thenCombine</code>, <code>handle</code>, <code>whenComplete</code>, <code>exceptionally</code> 等）。</li>
<li>这些方法允许你<strong>声明式地</strong>描述：“<strong>当当前阶段完成时，接下来应该做什么</strong>”。回调函数（lambda 表达式或方法引用）会被挂接到当前阶段的完成事件上。</li>
<li>每个链式调用都会返回一个<strong>新的 <code>CompletionStage</code>（通常是另一个 <code>CompletableFuture</code>）</strong>，代表下一个异步步骤。这形成了<strong>异步任务流水线</strong>。</li>
</ul>
</li>
<li><strong>依赖关系与内部状态机：</strong><ul>
<li>当多个 <code>CompletableFuture</code> 通过 <code>thenXxx</code> 方法链接起来时，后续阶段依赖于前驱阶段的完成。</li>
<li><code>CompletableFuture</code> 内部维护一个<strong>状态机</strong>（如 <code>NEW</code>, <code>COMPLETING</code>, <code>NORMAL</code>, <code>EXCEPTIONAL</code>, <code>CANCELLED</code>）和一个<strong>依赖栈</strong>（指向所有依赖于它完成的后续阶段）。</li>
<li>当一个阶段完成时，它会遍历其依赖栈，<strong>尝试触发所有后续阶段</strong>的执行（可能立即执行，也可能提交到线程池）。</li>
</ul>
</li>
<li><strong>非阻塞与事件驱动：</strong><ul>
<li>整个流程是<strong>非阻塞</strong>的。调用 <code>thenXxx</code> 只是注册回调，并不等待前驱完成。主线程可以继续执行其他任务。</li>
<li>执行由<strong>完成事件驱动</strong>：前驱完成 -&gt; 触发回调 -&gt; 执行回调逻辑 -&gt; 完成后继 -&gt; 触发后继的回调…。</li>
</ul>
</li>
<li><strong>组合多个 Future：</strong><ul>
<li>提供 <code>allOf()</code>, <code>anyOf()</code> 等静态方法，用于组合多个独立的 <code>CompletableFuture</code>：<ul>
<li><code>allOf(futures...)</code>: 创建一个新的 Future，当<strong>所有</strong>输入 Future 完成时（无论成功失败），它才完成（本身无结果，需手动获取各Future结果）。</li>
<li><code>anyOf(futures...)</code>: 创建一个新的 Future，当<strong>任意一个</strong>输入 Future 完成时（无论成功失败），它就完成（结果是最先完成的那个Future的结果）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>线程池控制：</strong><ul>
<li>默认情况下，链式调用中后续任务的执行线程由前驱任务的完成线程执行（通常是执行前驱任务的线程或调用 <code>complete</code> 的线程）。</li>
<li>可以使用带有 <code>Executor</code> 参数的变体方法（如 <code>thenApplyAsync(func, executor)</code>）<strong>显式指定</strong>后续任务在特定的线程池中执行，避免线程饥饿或控制资源。</li>
</ul>
</li>
</ol>
<p><strong>二、主要应用场景</strong></p>
<ol>
<li><p><strong>异步任务编排与流水线：</strong> 将复杂的业务逻辑拆分成多个异步步骤，按顺序或条件链式执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; fetchUserData(userId), ioPool) <span class="comment">// 步骤1：IO操作</span></span><br><span class="line">    .thenApply(userData -&gt; processData(userData))              <span class="comment">// 步骤2：CPU密集型处理（默认同线程或ForkJoinPool）</span></span><br><span class="line">    .thenApplyAsync(processedData -&gt; saveToDB(processedData), dbPool) <span class="comment">// 步骤3：另一个IO操作，指定DB线程池</span></span><br><span class="line">    .thenAccept(savedResult -&gt; sendNotification(savedResult))  <span class="comment">// 步骤4：最终处理</span></span><br><span class="line">    .exceptionally(ex -&gt; &#123;                                     <span class="comment">// 统一异常处理</span></span><br><span class="line">        log.error(<span class="string">&quot;Pipeline failed&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> handleFailure(ex);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>并行执行与结果聚合：</strong> 同时发起多个独立任务，等所有&#x2F;任意一个完成后再处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;ResultA&gt; futureA = CompletableFuture.supplyAsync(() -&gt; serviceA.call());</span><br><span class="line">CompletableFuture&lt;ResultB&gt; futureB = CompletableFuture.supplyAsync(() -&gt; serviceB.call());</span><br><span class="line">CompletableFuture&lt;ResultC&gt; futureC = CompletableFuture.supplyAsync(() -&gt; serviceC.call());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等所有任务完成</span></span><br><span class="line">CompletableFuture&lt;Void&gt; allFutures = CompletableFuture.allOf(futureA, futureB, futureC);</span><br><span class="line">allFutures.thenRun(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 手动获取各个结果（此时肯定已完成）</span></span><br><span class="line">    <span class="type">ResultA</span> <span class="variable">a</span> <span class="operator">=</span> futureA.join(); <span class="comment">// 或 get() (需处理异常)</span></span><br><span class="line">    <span class="type">ResultB</span> <span class="variable">b</span> <span class="operator">=</span> futureB.join();</span><br><span class="line">    <span class="type">ResultC</span> <span class="variable">c</span> <span class="operator">=</span> futureC.join();</span><br><span class="line">    aggregateResults(a, b, c);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等任意一个任务完成</span></span><br><span class="line">CompletableFuture&lt;Object&gt; anyFuture = CompletableFuture.anyOf(futureA, futureB, futureC);</span><br><span class="line">anyFuture.thenAccept(result -&gt; handleFirstResult(result));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>结果转换与处理：</strong> 使用 <code>thenApply</code> 将上一步的结果转换成另一种形式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;123&quot;</span>);</span><br><span class="line">CompletableFuture&lt;Integer&gt; intFuture = future.thenApply(Integer::parseInt);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>副作用操作：</strong> 使用 <code>thenAccept</code> 消费结果但不产生新结果（如日志、发送消息），或使用 <code>thenRun</code> 执行不依赖结果的动作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">future.thenAccept(result -&gt; System.out.println(<span class="string">&quot;Result: &quot;</span> + result));</span><br><span class="line">future.thenRun(() -&gt; cleanupResources());</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>组合异步任务：</strong></p>
<ul>
<li><code>thenCompose(Function&lt;T, CompletionStage&lt;U&gt;&gt;)</code>: <strong>扁平化</strong>组合。当前 Future 完成后，用其结果作为输入，<strong>启动并返回另一个 Future</strong> (避免嵌套 <code>CompletableFuture&lt;CompletableFuture&lt;U&gt;&gt;</code>)。</li>
<li><code>thenCombine(CompletionStage&lt;U&gt;, BiFunction&lt;T, U, V&gt;)</code>: 等待<strong>当前 Future 和另一个 Future</strong> 都完成，然后用两者的结果执行一个函数，返回新的 Future。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thenCompose 示例 (获取用户后获取订单)</span></span><br><span class="line">CompletableFuture&lt;User&gt; userFuture = getUserAsync(userId);</span><br><span class="line">CompletableFuture&lt;Order&gt; orderFuture = userFuture.thenCompose(user -&gt; getOrdersAsync(user));</span><br><span class="line"></span><br><span class="line"><span class="comment">// thenCombine 示例 (并行计算价格和库存，然后组合)</span></span><br><span class="line">CompletableFuture&lt;Price&gt; priceFuture = getPriceAsync(productId);</span><br><span class="line">CompletableFuture&lt;Inventory&gt; inventoryFuture = getInventoryAsync(productId);</span><br><span class="line">CompletableFuture&lt;ProductInfo&gt; productInfoFuture = priceFuture.thenCombine(inventoryFuture,</span><br><span class="line">    (price, inventory) -&gt; <span class="keyword">new</span> <span class="title class_">ProductInfo</span>(price, inventory));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>异常处理：</strong></p>
<ul>
<li><code>exceptionally(Function&lt;Throwable, T&gt;)</code>: 捕获异常并提供一个<strong>恢复值</strong>，返回一个正常完成的 Future。</li>
<li><code>handle(BiFunction&lt;T, Throwable, U&gt;)</code>: 无论正常完成还是异常，都会被调用。可以检查结果或异常，并返回一个新结果（或抛出新异常）。</li>
<li><code>whenComplete(BiConsumer&lt;T, Throwable&gt;)</code>: 类似 <code>handle</code>，但它是消费者（不改变结果），用于记录日志、清理等，返回一个结果类型相同的 Future（异常会传播）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">future.exceptionally(ex -&gt; defaultValue) <span class="comment">// 异常时提供默认值</span></span><br><span class="line">     .handle((result, ex) -&gt; &#123;</span><br><span class="line">         <span class="keyword">if</span> (ex != <span class="literal">null</span>) &#123; <span class="keyword">return</span> fallback; &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123; <span class="keyword">return</span> transform(result); &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">     .whenComplete((result, ex) -&gt; &#123;</span><br><span class="line">         <span class="keyword">if</span> (ex != <span class="literal">null</span>) log.error(<span class="string">&quot;Oops&quot;</span>, ex);</span><br><span class="line">         <span class="keyword">else</span> metrics.recordSuccess();</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>超时控制 (Java 9+):</strong> 使用 <code>orTimeout(timeout, timeUnit)</code> 或 <code>completeOnTimeout(value, timeout, timeUnit)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = someLongRunningTask()</span><br><span class="line">    .orTimeout(<span class="number">5</span>, TimeUnit.SECONDS) <span class="comment">// 超时抛出 TimeoutException</span></span><br><span class="line">    .exceptionally(ex -&gt; (ex <span class="keyword">instanceof</span> TimeoutException) ? <span class="string">&quot;Timed out&quot;</span> : <span class="string">&quot;Other error&quot;</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;String&gt; future = someLongRunningTask()</span><br><span class="line">    .completeOnTimeout(<span class="string">&quot;Fallback Value&quot;</span>, <span class="number">5</span>, TimeUnit.SECONDS); <span class="comment">// 超时提供默认值</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>三、关键优势</strong></p>
<ol>
<li><strong>非阻塞异步：</strong> 提高系统吞吐量和响应性。</li>
<li><strong>声明式 &amp; 链式编程：</strong> 代码更简洁、易读、易维护，接近同步代码的风格（避免回调地狱）。</li>
<li><strong>强大的组合能力：</strong> 轻松编排复杂异步工作流（顺序、并行、聚合、条件）。</li>
<li><strong>灵活的异常处理：</strong> 提供多种方式处理异步管道中的错误。</li>
<li><strong>显式完成控制：</strong> 支持手动设置结果，适应更多场景（如超时、外部事件）。</li>
<li><strong>线程池集成：</strong> 可精细控制任务执行位置。</li>
</ol>
<p><strong>四、注意事项与最佳实践</strong></p>
<ol>
<li><strong>避免阻塞：</strong> 不要在 <code>CompletableFuture</code> 的回调方法（如 <code>thenApply</code>, <code>thenAccept</code> 内部）执行长时间阻塞操作，这会卡住执行线程（可能是公共的 ForkJoinPool 线程）。使用 <code>thenApplyAsync</code> 等带 <code>Executor</code> 的方法将阻塞操作提交到专用线程池。</li>
<li><strong>线程池选择：</strong><ul>
<li>CPU 密集型任务：考虑使用 <code>ForkJoinPool.commonPool()</code> (默认) 或固定大小线程池（线程数 ≈ CPU 核心数）。</li>
<li>IO 密集型任务：<strong>务必使用</strong> 足够大的缓存线程池（如 <code>Executors.newCachedThreadPool()</code>）或专门配置的线程池，避免线程饥饿。<strong>强烈推荐为不同资源（如DB、HTTP）使用独立线程池。</strong></li>
</ul>
</li>
<li><strong>异常传播：</strong> 理解异常在链式调用中的传播机制。如果某个阶段抛出异常且未被捕获（如 <code>exceptionally</code>），后续依赖它的 <code>thenApply</code>&#x2F;<code>thenAccept</code> 等<strong>不会被执行</strong>，异常会传递到链的末端或等待 <code>get()</code>&#x2F;<code>join()</code> 时抛出。使用 <code>handle</code>&#x2F;<code>whenComplete</code>&#x2F;<code>exceptionally</code> 妥善处理。</li>
<li><strong>结果获取：</strong><ul>
<li><code>get()</code>: 阻塞等待结果，需处理 <code>InterruptedException</code> 和 <code>ExecutionException</code>（封装了原始异常）。</li>
<li><code>join()</code>: 类似 <code>get()</code>，但抛出未经检查的 <code>CompletionException</code>（其 <code>getCause()</code> 是原始异常）。通常在链的末端或明确知道会很快完成时使用。</li>
<li><strong>尽量使用回调</strong>（<code>thenAccept</code>, <code>thenApply</code>, <code>whenComplete</code>）而非阻塞获取，以保持非阻塞性。</li>
</ul>
</li>
<li><strong>资源清理：</strong> 使用 <code>whenComplete</code> 或 <code>handle</code> 确保资源（如文件句柄、网络连接）在任务完成（无论成功失败）后被正确关闭。</li>
<li><strong>避免过度嵌套：</strong> 虽然链式调用避免回调地狱，但深度嵌套仍可能降低可读性。考虑将复杂步骤抽取成独立方法。</li>
<li><strong>取消传播：</strong> <code>CompletableFuture.cancel(true)</code> 会尝试中断当前正在执行的任务，但<strong>不会自动取消它依赖的或依赖它的其他 Future</strong>。需要手动设计取消逻辑。</li>
</ol>
<p><strong>总结</strong></p>
<p><code>CompletableFuture</code> 是 Java 现代异步编程的基石。它通过<strong>链式组合</strong>、<strong>非阻塞回调</strong>和<strong>显式完成</strong>机制，提供了强大而优雅的方式来构建复杂、高效的异步应用程序。深入理解其原理（状态机、依赖管理）和熟练掌握其 API（<code>supplyAsync</code>, <code>thenXxx</code>, <code>handle</code>, <code>allOf</code>, <code>anyOf</code>, <code>thenCompose</code>, <code>thenCombine</code>, 异常处理）是编写高性能、高响应性 Java 服务的关键。合理使用线程池和遵循最佳实践（避免阻塞回调、妥善处理异常、管理资源）至关重要。</p>
<h3 id="CompletableFuture-和传统的-Future-有什么区别"><a href="#CompletableFuture-和传统的-Future-有什么区别" class="headerlink" title="CompletableFuture 和传统的 Future 有什么区别"></a><strong><code>CompletableFuture</code> 和传统的 <code>Future</code> 有什么区别</strong></h3><ul>
<li>考察点：理解其核心优势（链式编程、组合能力、手动完成、异常处理）。</li>
<li>期望回答：<code>Future</code> 仅支持阻塞获取结果或轮询，无法组合；<code>CompletableFuture</code> 实现了 <code>CompletionStage</code>，支持非阻塞回调、任务链式组合、手动设置结果&#x2F;异常、更强大的异常处理。</li>
</ul>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><p>类加载的过程包括了<strong>加载、验证、准备、解析、初始化</strong>五个阶段。</p>
<h4 id="哪些场景会触发类的加载"><a href="#哪些场景会触发类的加载" class="headerlink" title="哪些场景会触发类的加载"></a>哪些场景会触发类的加载</h4><ul>
<li>类的实例化</li>
<li>访问类的静态成员</li>
<li>调用类的静态方法</li>
<li><code>Class.forName()</code>、<code>ClassLoader.loadClass()</code>等反射方法</li>
<li>加载子类时会加载父类</li>
</ul>
<h4 id="Class-forName-和ClassLoader-loadClass-有什么区别"><a href="#Class-forName-和ClassLoader-loadClass-有什么区别" class="headerlink" title="Class.forName()和ClassLoader.loadClass()有什么区别"></a><code>Class.forName()</code>和<code>ClassLoader.loadClass()</code>有什么区别</h4><ul>
<li><code>Class.forName()</code>: 将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li>
<li><code>ClassLoader.loadClass()</code>: 只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li>
<li><code>Class.forName(name, initialize, loader)</code>带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。</li>
</ul>
<h4 id="类加载器的层次结构"><a href="#类加载器的层次结构" class="headerlink" title="类加载器的层次结构"></a>类加载器的层次结构</h4><p>类加载器层级结构：</p>
<table>
<thead>
<tr>
<th><strong>类加载器</strong></th>
<th><strong>加载路径</strong></th>
<th><strong>父加载器</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Bootstrap ClassLoader</strong></td>
<td><code>JRE/lib/rt.jar</code>等核心库</td>
<td>无（顶级加载器）</td>
</tr>
<tr>
<td><strong>Extension ClassLoader</strong></td>
<td><code>JRE/lib/ext</code>目录下扩展库</td>
<td>Bootstrap</td>
</tr>
<tr>
<td><strong>Application ClassLoader</strong></td>
<td>应用类路径（ClassPath）</td>
<td>Extension</td>
</tr>
<tr>
<td><strong>自定义ClassLoader</strong></td>
<td>用户自定义路径</td>
<td>Application</td>
</tr>
</tbody></table>
<h4 id="什么是双亲委派模型"><a href="#什么是双亲委派模型" class="headerlink" title="什么是双亲委派模型"></a>什么是双亲委派模型</h4><p>双亲委派模型（Parent Delegation Model）是Java类加载机制中的一种设计模式，用于控制类的加载顺序和避免类的重复加载。在双亲委派模型中，类加载器会按照一定的顺序进行类的加载，并将加载请求委派给父类加载器，只有在父类加载器找不到类的情况下，才会由子类加载器进行加载。</p>
<p><strong>双亲委派模型的优点</strong></p>
<ol>
<li>避免类的重复加载：由于类加载器会先委派给父类加载器进行加载，所以可以避免同一个类被多个类加载器重复加载，从而节省内存和提高性能。</li>
<li>安全性：核心类库通常由启动类加载器加载，而自定义类通常由应用程序类加载器加载，这样可以保证核心类库的安全性，防止被恶意代码替代。</li>
<li>模块化：通过使用不同的类加载器，可以实现类的模块化和隔离，从而在复杂的应用程序中实现类的共享和复用。</li>
</ol>
<p><strong>双亲委派模型的缺点</strong></p>
<ol>
<li>灵活性受限：双亲委派模型限制了类加载器的灵活性，可能导致在某些特定的场景中无法实现自定义的类加载行为。例如，在某些需要在运行时动态生成类或加载非标准格式的类文件的场景中，双亲委派模型可能会受限。</li>
<li>不适合某些类加载场景：在某些场景中，双亲委派模型可能并不适合，例如在OSGi（Open Service Gateway Initiative）等动态模块化系统中，需要实现更为复杂的类加载策略，而双亲委派模型可能不足以满足需求。</li>
<li>类冲突：在某些情况下，由于双亲委派模型的存在，可能会导致类的冲突问题。例如，如果应用程序中存在多个版本的同一个类，并且使用了不同的类加载器加载，可能会导致类加载冲突，从而导致程序出现错误或异常。</li>
<li>性能开销：由于每次类加载都会委派给父类加载器，这可能导致多层级的类加载链，从而增加了类加载的时间和性能开销。特别是在某些大型复杂的应用程序中，可能会出现类加载性能瓶颈。</li>
</ol>
<p><strong>如何打破双亲委派模型</strong></p>
<p>在Java中，可以通过以下几种方式来打破双亲委派模型，实现自定义的类加载行为：</p>
<ol>
<li>自定义类加载器：可以继承java.lang.ClassLoader类，并实现自定义的类加载逻辑，从而绕过双亲委派模型。<strong>通过重写ClassLoader的loadClass()方法，可以在类加载过程中自定义加载规则</strong>，例如先尝试自定义加载，如果失败再委派给父类加载器。</li>
<li>使用Java的扩展类加载器：<strong>Java的扩展类加载器（Extension ClassLoader）并不遵循双亲委派模型，它在加载Java扩展库时不会委派给父类加载器</strong>。因此，可以将自定义的类放置在Java扩展库中，并使用扩展类加载器加载这些类，从而实现对双亲委派模型的绕过。</li>
<li>使用线程上下文类加载器：Java中的线程上下文类加载器（Thread Context ClassLoader）是一种特殊的类加载器，可以在程序运行时动态设置，从而在某个特定线程中绕过双亲委派模型。通过设置线程上下文类加载器，可以使特定线程加载指定的类，而不受双亲委派模型的限制。</li>
</ol>
<h4 id="loadClass-和-findClass-有什么区别"><a href="#loadClass-和-findClass-有什么区别" class="headerlink" title="loadClass 和 findClass() 有什么区别"></a><code>loadClass</code> 和 <code>findClass()</code> 有什么区别</h4><table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><code>loadClass()</code></th>
<th align="left"><code>findClass()</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>职责</strong></td>
<td align="left">控制加载流程（委派机制）</td>
<td align="left">实现具体加载逻辑</td>
</tr>
<tr>
<td align="left"><strong>重写必要性</strong></td>
<td align="left">通常不重写（保持委派模型）</td>
<td align="left">自定义类加载器时<strong>必须重写</strong></td>
</tr>
<tr>
<td align="left"><strong>双亲委派角色</strong></td>
<td align="left">实现委派逻辑</td>
<td align="left">被委派机制调用</td>
</tr>
<tr>
<td align="left"><strong>典型用途</strong></td>
<td align="left">类加载入口（<code>ClassLoader.loadClass()</code>）</td>
<td align="left">自定义类加载器时扩展资源获取方式</td>
</tr>
</tbody></table>
<p><strong>最佳实践</strong></p>
<ol>
<li><p><strong>自定义类加载器</strong>：<br>只需重写 <code>findClass()</code>（保持双亲委派），<strong>无需</strong>重写 <code>loadClass()</code>。</p>
<p>java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class CustomLoader extends ClassLoader &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) &#123;</span><br><span class="line">        // 自定义加载逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>破坏双亲委派</strong>：<br>需重写 <code>loadClass()</code>（谨慎使用，如 JDBC&#x2F;JNDI 等场景）。</p>
</li>
</ol>
<img src="/post/7992e236/image-20250725203542235.png" class="" title="image-20250725203542235">

<p><code>loadClass()</code> 是框架流程控制者，<code>findClass()</code> 是实际加载逻辑的实现者。自定义类加载优先扩展 <code>findClass()</code>。</p>
<h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><h4 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h4><table>
<thead>
<tr>
<th><strong>内存区域</strong></th>
<th><strong>描述</strong></th>
<th><strong>线程共享性</strong></th>
<th><strong>异常触发条件</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>程序计数器（PC）</strong></td>
<td>记录当前线程执行的字节码指令地址，线程私有，唯一无OOM的区域。</td>
<td>线程私有</td>
<td>无（不会抛出内存相关异常）</td>
</tr>
<tr>
<td><strong>虚拟机栈（Java Stack）</strong></td>
<td>存储方法调用的栈帧（局部变量表、操作数栈、动态链接、方法出口等），线程私有。</td>
<td>线程私有</td>
<td><code>StackOverflowError</code>（栈深度溢出） <code>OutOfMemoryError</code>（无法扩展栈空间）</td>
</tr>
<tr>
<td><strong>本地方法栈（Native Stack）</strong></td>
<td>为Native方法（如C&#x2F;C++实现的方法）提供栈空间，线程私有。</td>
<td>线程私有</td>
<td>同虚拟机栈</td>
</tr>
<tr>
<td><strong>堆（Heap）</strong></td>
<td>存放对象实例和数组，所有线程共享，是垃圾回收的主要区域。</td>
<td>线程共享</td>
<td><code>OutOfMemoryError</code>（堆内存不足）</td>
</tr>
<tr>
<td><strong>方法区（Method Area）</strong></td>
<td>存储类信息、常量、静态变量、即时编译器代码等数据。JDK 8后由元空间（Metaspace）实现。</td>
<td>线程共享</td>
<td><code>OutOfMemoryError</code>（元空间&#x2F;方法区内存不足）</td>
</tr>
</tbody></table>
<h4 id="运行时常量池和字符串常量池有什么区别"><a href="#运行时常量池和字符串常量池有什么区别" class="headerlink" title="运行时常量池和字符串常量池有什么区别"></a>运行时常量池和字符串常量池有什么区别</h4><p>在JVM中，常量池分为两部分：<strong>运行时常量池</strong>和<strong>字符串常量池</strong>（String Pool，也称为String Table）。</p>
<ul>
<li><p><strong>运行时常量池</strong>：属于方法区的一部分。在JDK1.7之前，方法区位于永久代（PermGen）中；从JDK1.7开始，字符串常量池被移动到堆中；而到了JDK1.8，永久代被元空间（Metaspace）取代，运行时常量池也随之移到了元空间。但是，元空间并不在虚拟机内存中，而是使用本地内存。</p>
</li>
<li><p><strong>字符串常量池</strong>：在JDK1.7之前位于方法区（永久代），从JDK1.7开始被移动到堆中（Heap）。所以，在JDK1.7及之后的版本中，字符串常量池位于堆内存中。</p>
</li>
</ul>
<p>因此，针对不同版本的JDK，常量池的位置有所不同：</p>
<ul>
<li><p>JDK1.6及之前：运行时常量池（包括字符串常量池）在方法区（永久代）。</p>
</li>
<li><p>JDK1.7：运行时常量池仍在方法区（但方法区开始逐步移除永久代，使用元空间的前身），而字符串常量池被移动到堆中。</p>
</li>
<li><p>JDK1.8及之后：运行时常量池在元空间（Metaspace，使用本地内存），字符串常量池在堆中。</p>
</li>
</ul>
<p>StringTable 在 jdk1.6 之前，是方法区中运行时常量池的一部分， jdk1.7 之后移到了堆中。</p>
<p>在 jdk1.6 之前，full GC 才会触发永久代的垃圾回收，回收效率很低，如果有大量字符串放入 StringTable，容易导致永久代内存溢出。</p>
<p>StringTable 放入堆中之后，只要有 minor GC，就会触发 StringTable 的垃圾回收，减少了无用字符串常量对内存的占用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk8</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringPool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>); <span class="comment">// s1 指向堆中的 &quot;ab&quot;</span></span><br><span class="line">        s1.intern(); <span class="comment">// 在 StringTable 中放入堆中 &quot;ab&quot; 的地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// s2 存的地址就是 StringTable 中指向堆中 &quot;ab&quot; 的地址，即 s2 也指向堆中的 &quot;ab&quot;</span></span><br><span class="line">        System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jdk6</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringPool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>); <span class="comment">// s1 指向堆中的 &quot;ab&quot;</span></span><br><span class="line">        s1.intern(); <span class="comment">// 在 StringTable 创建 &quot;ab&quot;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// s2 指向 StringTable 中的 &quot;ab&quot;</span></span><br><span class="line">        System.out.println(s1 == s2); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="什么情况下会触发StackOverflowError和OutOfMemoryError"><a href="#什么情况下会触发StackOverflowError和OutOfMemoryError" class="headerlink" title="什么情况下会触发StackOverflowError和OutOfMemoryError"></a>什么情况下会触发StackOverflowError和OutOfMemoryError</h4><p><strong>触发StackOverflowError</strong></p>
<ul>
<li><p><strong>无限递归</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class StackOverflowExample &#123;</span><br><span class="line">    public static void recursiveMethod() &#123;</span><br><span class="line">        recursiveMethod(); // 无限递归调用</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        recursiveMethod(); // 触发StackOverflowError</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次方法调用都会在虚拟机栈中压入新栈帧，超出栈的最大深度限制（默认1MB，可通过<code>-Xss</code>调整）。</p>
</li>
<li><p>栈帧过大（局部变量过多或方法操作数栈过深）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void largeMethod() &#123;</span><br><span class="line">    int a1, a2, a3, ..., a10000; // 大量局部变量占用栈空间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单个栈帧占用的内存超过栈容量。</p>
</li>
</ul>
<p><strong>触发OutOfMemoryError</strong></p>
<ul>
<li><p><strong>堆内存溢出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 不断创建大对象，耗尽堆内存</span><br><span class="line">List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">while (true) &#123;</span><br><span class="line">    list.add(new byte[1024 * 1024]); // 每次分配1MB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原因</strong>：对象数量超过堆容量（可通过<code>-Xmx</code>和<code>-Xms</code>调整堆大小）。</p>
<p><strong>典型场景</strong>：内存泄漏（如静态集合未释放对象）或合理内存不足。</p>
</li>
<li><p><strong>方法区&#x2F;元空间溢出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 动态生成大量类（如使用CGLIB）</span><br><span class="line">public class MetaspaceOOM &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Enhancer enhancer = new Enhancer();</span><br><span class="line">        enhancer.setSuperclass(OOMObject.class);</span><br><span class="line">        enhancer.setCallback((MethodInterceptor) (obj, method, args1, proxy) -&gt; proxy.invokeSuper(obj, args1));</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            enhancer.create(); // 持续生成代理类</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static class OOMObject &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原因</strong>：加载的类数量或元数据量超过元空间容量（通过<code>-XX:MaxMetaspaceSize</code>设置上限）。</p>
<p><strong>典型场景</strong>：动态代理框架（如Spring AOP）、反射滥用。</p>
</li>
<li><p><strong>虚拟机栈或本地方法栈无法扩展</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 启动大量线程，每个线程的栈空间无法分配</span><br><span class="line">public class ThreadOOM &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                try &#123; Thread.sleep(1000000); &#125; catch (InterruptedException e) &#123;&#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原因</strong>：线程数量过多导致栈总内存超过系统限制（通过<code>-Xss</code>减少单个线程栈大小）。</p>
</li>
</ul>
<p><strong>总结</strong></p>
<table>
<thead>
<tr>
<th><strong>错误类型</strong></th>
<th><strong>触发场景</strong></th>
<th><strong>典型原因</strong></th>
<th><strong>解决方案</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>StackOverflowError</strong></td>
<td>递归调用未终止、栈帧过大</td>
<td>代码逻辑错误</td>
<td>修复递归终止条件，减少局部变量数量</td>
</tr>
<tr>
<td><strong>OutOfMemoryError</strong></td>
<td>堆内存不足、元空间溢出、线程数过多</td>
<td>内存泄漏、配置不当、资源耗尽</td>
<td>调整JVM参数，优化代码，增加物理内存</td>
</tr>
</tbody></table>
<h4 id="永久代和元空间的区别"><a href="#永久代和元空间的区别" class="headerlink" title="永久代和元空间的区别"></a>永久代和元空间的区别</h4><h4 id="堆内存是怎么细分的"><a href="#堆内存是怎么细分的" class="headerlink" title="堆内存是怎么细分的"></a>堆内存是怎么细分的</h4><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><h4 id="如何判断一个对象是否可回收"><a href="#如何判断一个对象是否可回收" class="headerlink" title="如何判断一个对象是否可回收"></a>如何判断一个对象是否可回收</h4><p><strong>引用计数法</strong></p>
<p><strong>可达性分析法</strong></p>
<p>在 Java 中 以下对象可作为 GC Roots：</p>
<ul>
<li>虚拟机栈中引用的对象</li>
<li>本地方法栈中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
</ul>
<p>需要注意的是，要宣告一个对象的真正死亡，需要经过两次标记。</p>
<ol>
<li><p>从 GC roots 出发，标记不可达的对象</p>
</li>
<li><p>对 F-Queue 对列中的对象进行二次标记</p>
<p>不可达对象如果重写且还未执行 finalize 方法，会被加入到一个名为 F-Queue 的队列中。在 F-Queue 队列中的对象可以重新被赋值给某个引用，这样二次标记时，这些对象将被移出 F-Queue 队列，从而实现自救。</p>
</li>
</ol>
<h4 id="4种引用类型"><a href="#4种引用类型" class="headerlink" title="4种引用类型"></a>4种引用类型</h4><p>JVM 的四种引用类型（强引用、软引用、弱引用、虚引用）决定了对象如何被垃圾回收器（GC）对待，主要服务于<strong>更精细地控制对象生命周期</strong>和<strong>管理内存</strong>的目的。它们的使用场景各有侧重：</p>
<ol>
<li><p><strong>强引用 (Strong Reference)</strong></p>
<ul>
<li><strong>定义：</strong> 最常见的引用类型。通过 <code>new</code> 关键字创建的对象默认就是强引用。只要强引用存在，垃圾回收器就<strong>绝对不会</strong>回收该对象，即使面临内存不足（OOM）的风险。</li>
<li><strong>语法：</strong> <code>Object obj = new Object(); // obj 就是一个指向新 Object 实例的强引用</code></li>
<li><strong>使用场景：</strong><ul>
<li><strong>绝大多数对象引用。</strong> 日常编程中创建的对象引用几乎都是强引用。</li>
<li><strong>需要对象长期存在直到显式解除引用 (<code>obj = null;</code>) 的场景。</strong></li>
</ul>
</li>
<li><strong>GC 行为：</strong> 对象可达性判断的基准。从 GC Roots（如线程栈中的局部变量、静态变量、JNI 引用等）出发，通过强引用链可达的对象是存活的，不会被回收。只有当一个对象<strong>不再被任何强引用链可达</strong>时，它才成为潜在的回收候选对象。</li>
</ul>
</li>
<li><p><strong>软引用 (SoftReference)</strong></p>
<ul>
<li><p><strong>定义：</strong> 用来描述一些<strong>有用但非必需</strong>的对象。当内存充足时，软引用关联的对象不会被回收；当<strong>内存不足（即将发生 OOM 之前）</strong>，垃圾回收器会尝试回收这些软引用指向的对象。如果回收了软引用对象后内存仍然不足，才会抛出 <code>OutOfMemoryError</code>。</p>
</li>
<li><p><strong>语法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">importantObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 原始强引用</span></span><br><span class="line">SoftReference&lt;Object&gt; softRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(importantObj);</span><br><span class="line">importantObj = <span class="literal">null</span>; <span class="comment">// 解除强引用，只剩下软引用</span></span><br><span class="line"><span class="comment">// 稍后尝试获取</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">retrieved</span> <span class="operator">=</span> softRef.get(); <span class="comment">// 如果未被回收，retrieved != null; 如果被回收，retrieved == null</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用场景：</strong></p>
<ul>
<li><strong>内存敏感的高速缓存 (Memory-Sensitive Caches)：</strong> 这是最经典的场景。缓存的对象如果被回收，通常可以重新加载或计算。软引用能保证在内存吃紧时自动释放缓存，避免 OOM，同时尽可能利用内存提高缓存命中率。例如：<ul>
<li>图片缓存</li>
<li>数据库查询结果缓存</li>
<li>大型计算结果的缓存</li>
</ul>
</li>
<li><strong>需要临时保留但可牺牲的数据。</strong></li>
</ul>
</li>
<li><p><strong>GC 行为：</strong> 在 JVM 判断内存不足（通常是在 Full GC 之后）时，会回收仅被软引用指向的对象。</p>
</li>
</ul>
</li>
<li><p><strong>弱引用 (WeakReference)</strong></p>
<ul>
<li><p><strong>定义：</strong> 用来描述<strong>非必需</strong>对象，比软引用更弱。弱引用关联的对象<strong>只能生存到下一次垃圾回收发生之前</strong>。无论当前内存是否充足，只要垃圾回收器开始工作（并且扫描到这个对象），就会回收掉<strong>仅被弱引用指向</strong>的对象。</p>
</li>
<li><p><strong>语法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">tempObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 原始强引用</span></span><br><span class="line">WeakReference&lt;Object&gt; weakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(tempObj);</span><br><span class="line">tempObj = <span class="literal">null</span>; <span class="comment">// 解除强引用，只剩下弱引用</span></span><br><span class="line"><span class="comment">// 强制触发一次 GC (仅示例，生产环境慎用 System.gc())</span></span><br><span class="line">System.gc();</span><br><span class="line"><span class="comment">// 尝试获取</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">retrieved</span> <span class="operator">=</span> weakRef.get(); <span class="comment">// 很大概率 retrieved == null，因为对象已被回收</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用场景：</strong></p>
<ul>
<li><strong>规范化映射 (Canonicalizing Mappings)：</strong> <code>WeakHashMap</code> 是其典型应用。它使用弱引用作为键（Key）。当键对象<strong>在 WeakHashMap 外部不再有任何强引用</strong>时，下次 GC 后，该键值对会自动从 WeakHashMap 中被移除。适用于存储对象的元信息、附加属性等，这些信息在对象本身不再被使用时也应自动消失。</li>
<li><strong>监听器模式 (Listener Patterns)：</strong> 避免因注册监听器后忘记注销而导致监听器对象（通常是实现了监听接口的对象）和发布者对象都无法回收（内存泄漏）。使用弱引用持有监听器，当监听器对象在其他地方没有强引用时，GC 会自动回收它，发布者持有的弱引用会自动失效（get() 返回 null），发布者可以清理这些无效引用。</li>
<li><strong>临时性的、辅助性的数据结构。</strong></li>
</ul>
</li>
<li><p><strong>GC 行为：</strong> 在<strong>下一次 GC 运行时</strong>（无论是 Minor GC 还是 Full GC），只要对象<strong>仅被弱引用指向</strong>（没有强引用或软引用），就会被回收。</p>
</li>
</ul>
</li>
<li><p><strong>虚引用 (PhantomReference)</strong></p>
<ul>
<li><p><strong>定义：</strong> 最弱的一种引用。<strong>无法通过虚引用获取对象实例</strong>（其 <code>get()</code> 方法总是返回 <code>null</code>）。虚引用<strong>必须</strong>与 <code>ReferenceQueue</code> 联合使用。设置虚引用的<strong>唯一目的</strong>是<strong>跟踪对象被垃圾回收的时机</strong>。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象<strong>之后</strong>（此时对象内存已被释放或即将被释放），将这个虚引用加入与之关联的 <code>ReferenceQueue</code> 中。</p>
</li>
<li><p><strong>语法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line"><span class="type">Object</span> <span class="variable">phantomObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 原始强引用</span></span><br><span class="line">PhantomReference&lt;Object&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(phantomObj, queue);</span><br><span class="line">phantomObj = <span class="literal">null</span>; <span class="comment">// 解除强引用</span></span><br><span class="line"><span class="comment">// ... 强制 GC 或等待 GC 发生 ...</span></span><br><span class="line"><span class="comment">// 检查队列</span></span><br><span class="line">Reference&lt;?&gt; refFromQueue = queue.poll();</span><br><span class="line"><span class="keyword">if</span> (refFromQueue != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 此时 refFromQueue 就是 phantomRef，表示 phantomObj 已被回收或处于 finalization 状态</span></span><br><span class="line">    <span class="comment">// 可以在这里执行一些资源清理动作（如关闭关联的文件描述符、释放堆外内存等）</span></span><br><span class="line">    <span class="comment">// 注意：此时原对象 phantomObj 已经不可达且内存可能已被回收</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用场景：</strong></p>
<ul>
<li><strong>管理堆外内存 (Off-Heap Memory)：</strong> 这是最主要的应用场景。Java NIO 的 <code>DirectByteBuffer</code> 分配堆外内存。<code>DirectByteBuffer</code> 对象本身很小（在堆上），但它关联着一块较大的堆外内存。当 <code>DirectByteBuffer</code> 对象被回收时，需要释放其关联的堆外内存。JVM 使用 <code>Cleaner</code> 类（内部基于 <code>PhantomReference</code>）来监控 <code>DirectByteBuffer</code> 对象。当 <code>DirectByteBuffer</code> 对象被 GC 回收后，<code>Cleaner</code> 的虚引用会被放入队列，触发一个清理线程调用 <code>unsafe.freeMemory</code> 来释放堆外内存。</li>
<li><strong>精确的对象回收后处理 (Post-Mortem Cleanup Actions)：</strong> 需要在确切知道对象<strong>已经被 GC 回收</strong>（或者至少处于 finalization 完成状态）之后执行某些特定的清理操作，且这些操作不适合放在 <code>finalize()</code> 方法中时（<code>finalize()</code> 有性能问题、执行时机不确定、可能复活对象）。</li>
</ul>
</li>
<li><p><strong>GC 行为：</strong> 对象是否被虚引用指向<strong>完全不影响</strong>其被垃圾回收的资格（只要不可达就会被回收）。虚引用的存在是为了在对象被回收<strong>之后</strong>提供一个通知机制（通过 <code>ReferenceQueue</code>）。对象回收后，其关联的虚引用会被加入队列。</p>
</li>
</ul>
</li>
</ol>
<p><strong>总结对比表：</strong></p>
<table>
<thead>
<tr>
<th align="left">引用类型</th>
<th align="left">强度</th>
<th align="left">被 GC 回收的时机</th>
<th align="left"><code>get()</code> 行为</th>
<th align="left">是否影响对象生命周期</th>
<th align="left">主要用途</th>
<th align="left">是否关联 ReferenceQueue</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>强引用</strong></td>
<td align="left">最强</td>
<td align="left"><strong>永不</strong>（只要可达）</td>
<td align="left">返回对象本身</td>
<td align="left"><strong>是</strong></td>
<td align="left">默认引用，保持对象长期存在</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left"><strong>软引用</strong></td>
<td align="left">次强</td>
<td align="left"><strong>内存不足时</strong>（在 OOM 之前）</td>
<td align="left">内存足时返回对象；内存不足返回<code>null</code></td>
<td align="left">间接是（通过内存压力）</td>
<td align="left">内存敏感缓存</td>
<td align="left">可选</td>
</tr>
<tr>
<td align="left"><strong>弱引用</strong></td>
<td align="left">较弱</td>
<td align="left"><strong>下一次 GC 运行时</strong>（无论内存是否充足）</td>
<td align="left">GC 前返回对象；GC 后返回 <code>null</code></td>
<td align="left"><strong>否</strong></td>
<td align="left">规范化映射（WeakHashMap）、监听器、临时数据</td>
<td align="left">可选</td>
</tr>
<tr>
<td align="left"><strong>虚引用</strong></td>
<td align="left">最弱</td>
<td align="left"><strong>对象被回收之后</strong>通知</td>
<td align="left"><strong>总是返回 <code>null</code></strong></td>
<td align="left"><strong>否</strong></td>
<td align="left">对象回收跟踪、堆外内存清理、回收后处理</td>
<td align="left"><strong>必须</strong></td>
</tr>
</tbody></table>
<p>理解并正确使用这四种引用类型，特别是软、弱、虚引用，对于编写高效、内存友好的 Java 程序（尤其是需要管理缓存、监听器或堆外资源时）至关重要。它们提供了一种机制，让程序能在不影响核心功能的前提下，更优雅地处理内存资源。</p>
<h4 id="有哪些垃圾回收算法"><a href="#有哪些垃圾回收算法" class="headerlink" title="有哪些垃圾回收算法"></a>有哪些垃圾回收算法</h4><table>
<thead>
<tr>
<th>算法</th>
<th>步骤</th>
<th>特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>标记-清除（Mark-Sweep）</strong></td>
<td>1. <strong>标记</strong>：遍历所有对象，标记存活对象。 2. <strong>清除</strong>：回收未被标记的对象（垃圾）。</td>
<td><strong>优点</strong>：实现简单，不需要移动对象。 <strong>缺点</strong>：产生内存碎片，可能触发频繁的 Full GC。</td>
<td>1. 老年代回收（如 CMS 收集器的初始阶段）。 2. 对内存碎片不敏感的场景，或短期运行的应用程序。</td>
</tr>
<tr>
<td><strong>复制算法（Copying）</strong></td>
<td>1. 将内存分为两块（From 和 To），对象分配在 From 区。 2. 标记存活对象，将其复制到 To 区。 3. 清空 From 区，交换 From 和 To 的角色。</td>
<td><strong>优点</strong>：无内存碎片，回收高效。 <strong>缺点</strong>：内存利用率低（需预留一半空间）。</td>
<td>1. 新生代回收（如 Serial、ParNew、Parallel Scavenge 等收集器）。 2. 适用于对象存活率低的场景（如新生代 Eden 区）。</td>
</tr>
<tr>
<td><strong>标记-整理（Mark-Compact）</strong></td>
<td><strong>标记</strong>：遍历所有对象，标记存活对象。 <strong>整理</strong>：将存活对象向内存一端移动，清理边界外的空间。</td>
<td><strong>优点</strong>：避免内存碎片，适合长期运行的系统。 <strong>缺点</strong>：移动对象需要时间，导致停顿较长（STW）。</td>
<td>1. 老年代回收（如 Serial Old、Parallel Old 收集器）。 2. 对内存敏感且需要避免碎片的场景（如大数据应用）。</td>
</tr>
</tbody></table>
<h4 id="CMS收集器工作原理"><a href="#CMS收集器工作原理" class="headerlink" title="CMS收集器工作原理"></a>CMS收集器工作原理</h4><h4 id="G1收集器工作原理"><a href="#G1收集器工作原理" class="headerlink" title="G1收集器工作原理"></a>G1收集器工作原理</h4><h3 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h3><h4 id="常用调优参数"><a href="#常用调优参数" class="headerlink" title="常用调优参数"></a>常用调优参数</h4><ol>
<li>-Xmx: 设置Java堆的最大内存大小。</li>
<li>-Xms: 设置Java堆的初始内存大小。</li>
<li>-Xmn: 设置新生代的大小。</li>
<li>-XX:NewRatio: 设置新生代和老年代的比例。</li>
<li>-XX:SurvivorRatio: 设置Eden区和Survivor区的比例。</li>
<li>-XX:MaxPermSize (Java 8之前) &#x2F; -XX:MaxMetaspaceSize (Java 8及之后): 设置永久代（Java 8之前）或元空间（Java 8及之后）的最大内存大小。</li>
<li>-XX:ParallelGCThreads: 设置并行垃圾回收的线程数。</li>
<li>-XX:+UseConcMarkSweepGC: 启用CMS垃圾回收器。</li>
<li>-XX:+UseG1GC: 启用G1（Garbage-First）垃圾回收器。</li>
<li>-XX:G1HeapRegionSize：设置 Region 的大小。</li>
<li>-XX:+HeapDumpOnOutOfMemoryError: 当发生OutOfMemoryError错误时，自动生成堆内存转储文件。</li>
<li>-XX:HeapDumpPath&#x3D;&lt;路径&gt;: 设置堆内存转储文件的保存路径。</li>
<li>-XX:+DisableExplicitGC: 禁用显式的垃圾回收操作。</li>
<li>-XX:CMSInitiatingOccupancyFraction：设置老年代的使用比例。</li>
<li>-XX:PretenureSizeThreshold：设置大对象阈值，超过这个大小直接在老年代分配。</li>
<li>-XX:MaxTenuringThreshold：设置晋升到老年代的年龄</li>
</ol>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/5cb37524.html" rel="prev" title="参考代码">
                  <i class="fa fa-angle-left"></i> 参考代码
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/32511a71.html" rel="next" title="学习&面试-数据存储">
                  学习&面试-数据存储 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa-regular fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder"></span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Word count total">94k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">5:43</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>

  <script class="next-config" data-name="wavedrom" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/wavedrom.min.js","integrity":"sha256-INLAoJc6quTNfiMWkGZniYO2cxE8mHpddnLow1m6RFs="}}</script>
  <script class="next-config" data-name="wavedrom_skin" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/skins/default.js","integrity":"sha256-fduc/Zszk5ezWws2uInY/ALWVmIrmV6VTgXbsYSReFI="}}</script>
  <script src="/js/third-party/tags/wavedrom.js"></script>




  





</body>
</html>
