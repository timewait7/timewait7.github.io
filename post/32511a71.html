<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"timewait7.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":true,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="SQL 优化: 深入理解执行计划（EXPLAIN）、索引原理（B+树, 哈希, 覆盖索引, 最左前缀）、锁机制（行锁、表锁、间隙锁、MVCC）、事务隔离级别实现原理。 分库分表: 理解分片策略（水平&#x2F;垂直）、路由算法、分布式 ID 生成方案（Snowflake 等）、面临的挑战（跨库查询、事务）。 NoSQL 选型: 了解 MongoDB, Elasticsearch, Cassand">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL">
<meta property="og:url" content="http://timewait7.github.io/post/32511a71.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="SQL 优化: 深入理解执行计划（EXPLAIN）、索引原理（B+树, 哈希, 覆盖索引, 最左前缀）、锁机制（行锁、表锁、间隙锁、MVCC）、事务隔离级别实现原理。 分库分表: 理解分片策略（水平&#x2F;垂直）、路由算法、分布式 ID 生成方案（Snowflake 等）、面临的挑战（跨库查询、事务）。 NoSQL 选型: 了解 MongoDB, Elasticsearch, Cassand">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://timewait7.github.io/post/32511a71/1726212535664-4bb3f3ff-704a-4706-84c8-a046a8486657.webp">
<meta property="article:published_time" content="2025-07-26T11:19:32.000Z">
<meta property="article:modified_time" content="2025-11-10T14:52:44.159Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://timewait7.github.io/post/32511a71/1726212535664-4bb3f3ff-704a-4706-84c8-a046a8486657.webp">


<link rel="canonical" href="http://timewait7.github.io/post/32511a71.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://timewait7.github.io/post/32511a71.html","path":"post/32511a71.html","title":"MySQL"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>MySQL | Hexo</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-archives"><a href="/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="Searching..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL"><span class="nav-number">1.</span> <span class="nav-text">SQL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.1.</span> <span class="nav-text">查询语句的执行顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EXPLAIN-%E5%AD%97%E6%AE%B5%E8%AF%B4%E6%98%8E"><span class="nav-number">1.2.</span> <span class="nav-text">EXPLAIN 字段说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E6%9D%A1%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.3.</span> <span class="nav-text">一条查询语句的执行流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E6%9D%A1%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.4.</span> <span class="nav-text">一条更新语句的执行流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#count-%E3%80%81count-1-%E3%80%81count-id-%E3%80%81count-%E5%AD%97%E6%AE%B5-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">1.5.</span> <span class="nav-text">count(*)、count(1)、count(id)、count(字段)有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%93OFFSET%E5%80%BC%E5%BE%88%E5%A4%A7%E6%97%B6%EF%BC%88%E5%A6%82LIMIT-100000-10%EF%BC%89%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9F%A5%E8%AF%A2%E4%BC%9A%E5%8F%98%E6%85%A2"><span class="nav-number">1.6.</span> <span class="nav-text">当OFFSET值很大时（如LIMIT 100000, 10），为什么查询会变慢</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E6%90%AD%E9%85%8DORDER-BY"><span class="nav-number">1.7.</span> <span class="nav-text">分页时为什么必须搭配ORDER BY</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IN-%E5%92%8C-EXISTS-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.8.</span> <span class="nav-text">IN 和 EXISTS 的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95"><span class="nav-number">2.</span> <span class="nav-text">索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%A1%A8%E3%80%81%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E3%80%81%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99%E5%92%8C%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8"><span class="nav-number">2.1.</span> <span class="nav-text">什么是回表、覆盖索引、最左前缀原则和索引下推</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84"><span class="nav-number">2.2.</span> <span class="nav-text">InnoDB索引结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">2.3.</span> <span class="nav-text">索引设计原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E7%B4%A2%E5%BC%95%E4%BC%9A%E5%A4%B1%E6%95%88%E6%88%96%E9%80%89%E9%94%99%E7%B4%A2%E5%BC%95"><span class="nav-number">2.4.</span> <span class="nav-text">为什么有时索引会失效或选错索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WHERE-b-1-AND-c-2-ORDER-BY-a-%E8%83%BD%E5%90%A6%E7%94%A8%E4%B8%8A%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95-a-b-c"><span class="nav-number">2.5.</span> <span class="nav-text">WHERE b&#x3D;1 AND c&#x3D;2 ORDER BY a 能否用上组合索引 (a, b, c)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">3.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB%E6%9C%89%E5%93%AA%E5%87%A0%E7%B1%BB%E9%94%81"><span class="nav-number">3.1.</span> <span class="nav-text">InnoDB有哪几类锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-number">4.</span> <span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7%E5%92%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">4.1.</span> <span class="nav-text">事务的基本特性和隔离级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E7%85%A7%E8%AF%BB%E5%92%8C%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="nav-number">4.2.</span> <span class="nav-text">快照读和当前读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MVCC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">4.3.</span> <span class="nav-text">MVCC实现原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A5%E5%BF%97"><span class="nav-number">5.</span> <span class="nav-text">日志</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFredo-log"><span class="nav-number">5.1.</span> <span class="nav-text">什么是redo log</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFbinlog"><span class="nav-number">5.2.</span> <span class="nav-text">什么是binlog</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redo-log-vs-binlog"><span class="nav-number">5.3.</span> <span class="nav-text">redo log vs binlog</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="nav-number">5.4.</span> <span class="nav-text">什么是两阶段提交</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB"><span class="nav-number">6.</span> <span class="nav-text">InnoDB</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB%E5%92%8C%E5%85%B6%E4%BB%96%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">6.1.</span> <span class="nav-text">InnoDB和其他存储引擎的比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFbuffer-pool"><span class="nav-number">6.2.</span> <span class="nav-text">什么是buffer pool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFchange-buffer"><span class="nav-number">6.3.</span> <span class="nav-text">什么是change buffer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.</span> <span class="nav-text">字段类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#char-100-%E5%92%8C-varchar-100-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.1.</span> <span class="nav-text">char(100) 和 varchar(100) 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8text%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.2.</span> <span class="nav-text">为什么不建议使用text类型</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/">
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="Back to top">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>

    
        <div class="sidebar-inner sidebar-post-related">
          <div class="animated">
              <div class="links-of-blogroll-title"><i class="fa fa-signs-post fa-fw"></i>
    Related Posts
  </div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <a class="popular-posts-link" href="/post/1aa6cbcd.html" rel="bookmark">
        <time class="popular-posts-time">2025-10-04</time>
        <br>
      命令速查表
      </a>
    </li>
  </ul>

          </div>
        </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://timewait7.github.io/post/32511a71.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="MySQL | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-07-26 19:19:32" itemprop="dateCreated datePublished" datetime="2025-07-26T19:19:32+08:00">2025-07-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>7k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>25 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><ul>
<li><strong>SQL 优化:</strong> 深入理解执行计划（EXPLAIN）、索引原理（B+树, 哈希, 覆盖索引, 最左前缀）、锁机制（行锁、表锁、间隙锁、MVCC）、事务隔离级别实现原理。</li>
<li><strong>分库分表:</strong> 理解分片策略（水平&#x2F;垂直）、路由算法、分布式 ID 生成方案（Snowflake 等）、面临的挑战（跨库查询、事务）。</li>
<li><strong>NoSQL 选型:</strong> 了解 MongoDB, Elasticsearch, Cassandra 等适用场景和核心特性。</li>
</ul>
<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="查询语句的执行顺序"><a href="#查询语句的执行顺序" class="headerlink" title="查询语句的执行顺序"></a>查询语句的执行顺序</h3><p>MySQL 分为 server 层和存储引擎层。</p>
<p>server 层涵盖 MySQL 大多数核心功能（如存储过程、触发器、视图等）和所有内置函数（如日期、时间、数学函数等）。</p>
<p>存储引擎层负责数据的存储和提取。</p>
<p><code>from</code> -&gt; <code>where</code> -&gt; <code>group by</code> -&gt; <code>having</code> -&gt; <code>select</code> -&gt; <code>distinct</code> -&gt; <code>order by</code> -&gt; <code>limit</code></p>
<img src="/post/32511a71/1726212535664-4bb3f3ff-704a-4706-84c8-a046a8486657.webp" class="" title="img">

<h3 id="EXPLAIN-字段说明"><a href="#EXPLAIN-字段说明" class="headerlink" title="EXPLAIN 字段说明"></a><code>EXPLAIN</code> 字段说明</h3><p>通常<code>EXPALIN</code>查询语句的输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;id&quot;: 1, // 每个select语句对应一个唯一的id</span><br><span class="line">    /**</span><br><span class="line">     * 查询类型：</span><br><span class="line">     * SIMPLE：不包含UNION或子查询的select（连接查询的每个查询都是simple查询）</span><br><span class="line">     * PRIMARY：最外层查询</span><br><span class="line">     * UNION</span><br><span class="line">     * ...</span><br><span class="line">     */</span><br><span class="line">    &quot;select_type&quot;: &quot;SIMPLE&quot;,</span><br><span class="line">    &quot;table&quot;: &quot;users&quot;, // 要查询的表</span><br><span class="line">    &quot;partitions&quot;: null, // 分区信息</span><br><span class="line">    /**</span><br><span class="line">     * 针对单表的访问方法：</span><br><span class="line">     * system：当表中只有一条记录，并且该表使用的存储引擎的统计数据是精确的，访问方法就是system</span><br><span class="line">     * constant：根据主键或唯一索引列与常数进行等值匹配时，访问方法就是const</span><br><span class="line">     * eq_ref：连接查询中对被驱动表的主键或不允许为NULL的唯一索引进行等值查询时，访问方法就是eq_ref</span><br><span class="line">     * ref：通过普通二级索引列与常量进行等值匹配时，对该表的访问方法就是 ref</span><br><span class="line">     * ref_or_null：select * from single_table where key1 = &#x27;abc&#x27; or key1 is NULL;</span><br><span class="line">     * index_merge：使用多个索引进行等值匹配</span><br><span class="line">     * unique_subquery：在子查询中使用主键或不允许存储NULL值的唯一二级索引进行等值匹配</span><br><span class="line">     * index_subquery：在子查询中使用普通二级索引进行等值匹</span><br><span class="line">     * range：利用索引进行范围查询</span><br><span class="line">     * index：当可以使用索引覆盖，但需要扫描全部索引记录</span><br><span class="line">     * all：全表扫描</span><br><span class="line">     * </span><br><span class="line">     */</span><br><span class="line">    &quot;type&quot;: &quot;ref&quot;, </span><br><span class="line">    &quot;possible_keys&quot;: &quot;idx_composite&quot;, // 可能使用的索引</span><br><span class="line">    &quot;key&quot;: &quot;idx_composite&quot;, // 实际使用的索引</span><br><span class="line">    &quot;key_len&quot;: &quot;208&quot;, // 实际使用的索引长度</span><br><span class="line">    &quot;ref&quot;: &quot;const&quot;, // 使用索引列等值查询时，与索引列进行等值匹配的对象信息</span><br><span class="line">    &quot;rows&quot;: 1, // 预估需要读取的记录行数</span><br><span class="line">    &quot;filtered&quot;: 100.0, // 过滤后剩余记录行数百分比</span><br><span class="line">    /**</span><br><span class="line">     * 额外信息：</span><br><span class="line">     * Using index：使用覆盖索引</span><br><span class="line">     * Using index condition：使用索引条件下推</span><br><span class="line">     * Using where：需要在server层判断条件是否成立</span><br><span class="line">     * Using join buffer：执行连接查询时，被驱动表不能有效利用索引加快访问速度时，会分配一块内存用来保存被驱动表的查询结果，</span><br><span class="line">     					  利用join buffer可以减少访问被驱动表的次数</span><br><span class="line">     * Using filesort：</span><br><span class="line">     * Using temporary</span><br><span class="line">     */</span><br><span class="line">    &quot;Extra&quot;: &quot;Using index&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="一条查询语句的执行流程"><a href="#一条查询语句的执行流程" class="headerlink" title="一条查询语句的执行流程"></a>一条查询语句的执行流程</h3><h3 id="一条更新语句的执行流程"><a href="#一条更新语句的执行流程" class="headerlink" title="一条更新语句的执行流程"></a>一条更新语句的执行流程</h3><p>一条 <code>UPDATE</code> 语句在 MySQL（尤其是 InnoDB 存储引擎）中的执行过程是一个涉及多个组件（解析器、优化器、执行引擎、存储引擎、缓冲池、日志系统、锁机制等）协同工作的复杂过程。下面是其核心步骤的详细分解：</p>
<ol>
<li><strong>连接与请求接收</strong></li>
</ol>
<ul>
<li>客户端应用程序（如 Java 程序、MySQL CLI）通过连接器建立与 MySQL 服务器的连接。</li>
<li>服务器验证用户身份和权限。</li>
<li>客户端发送 <code>UPDATE</code> SQL 语句到服务器。</li>
</ul>
<ol start="2">
<li><strong>解析与优化（Server 层）</strong></li>
</ol>
<ul>
<li><strong>解析器：</strong><ul>
<li>进行词法分析：识别 <code>UPDATE</code>、表名、<code>SET</code>、列名、<code>=</code>、值、<code>WHERE</code> 等关键字和标识符。</li>
<li>进行语法分析：检查语句是否符合 SQL 语法规则，构建抽象语法树。</li>
</ul>
</li>
<li><strong>预处理器：</strong><ul>
<li>检查表和列是否存在。</li>
<li>解析名称和别名。</li>
<li>检查用户是否有执行 <code>UPDATE</code> 的权限。</li>
</ul>
</li>
<li><strong>优化器：</strong><ul>
<li><strong>关键步骤！</strong> 基于统计信息（表大小、索引分布、基数等）选择它认为最高效的执行计划。</li>
<li>决定：<ul>
<li>使用哪个索引（主键索引、二级索引）来定位需要更新的行。这是影响速度的关键因素。</li>
<li>是否可以使用索引条件下推。</li>
<li>是否需要进行全表扫描（如果 <code>WHERE</code> 条件无法有效利用索引）。</li>
</ul>
</li>
<li>生成具体的执行计划。</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>执行引擎调用存储引擎（Server 层 -&gt; 存储引擎层）</strong></li>
</ol>
<ul>
<li>执行引擎根据优化器选择的执行计划，调用存储引擎（InnoDB）提供的接口来执行实际的数据查找和修改操作。</li>
</ul>
<ol start="4">
<li><strong>InnoDB 存储引擎内部处理</strong></li>
</ol>
<ul>
<li><strong>缓冲池查找：</strong><ul>
<li>执行引擎告知 InnoDB 要更新哪些行（通过 <code>WHERE</code> 条件定位）。</li>
<li>InnoDB 首先在 <strong>Buffer Pool（缓冲池）</strong> 中查找这些行所在的数据页。</li>
<li>如果数据页不在 Buffer Pool 中，则从磁盘上的 <code>.ibd</code> 数据文件中将其加载到 Buffer Pool。</li>
</ul>
</li>
<li><strong>写 Undo Log：</strong><ul>
<li><strong>关键步骤！</strong> 在修改 Buffer Pool 中的数据页<strong>之前</strong>，InnoDB 会先将这行数据的旧版本（修改前的状态）写入 <strong>Undo Log（回滚日志）</strong>。</li>
<li><strong>目的：</strong><ul>
<li>支持事务回滚：如果事务需要回滚，可以用 Undo Log 中的旧数据覆盖修改。</li>
<li>实现 MVCC：其他并发事务如果需要读取这行数据的旧版本（基于它们的 Read View），可以通过 Undo Log 链找到。</li>
</ul>
</li>
<li>Undo Log 存储在 Undo Tablespaces 中。</li>
</ul>
</li>
<li><strong>修改 Buffer Pool：</strong><ul>
<li>将 Buffer Pool 中对应的数据页中的行数据更新为新值。</li>
<li>此时数据页变成<strong>脏页</strong>（内存中的数据与磁盘数据不一致）。</li>
</ul>
</li>
<li><strong>写 Redo Log Buffer：</strong><ul>
<li><strong>关键步骤！</strong> 在脏页刷盘<strong>之前</strong>，InnoDB 会先把对数据页所做的物理修改（字节级别的变化）记录到内存中的 <strong>Redo Log Buffer（重做日志缓冲区）</strong>。</li>
<li><strong>目的：</strong> 保证事务的持久性。即使系统崩溃，重启后也能根据 Redo Log 重做未持久化的修改。</li>
</ul>
</li>
</ul>
<ol start="5">
<li><strong>事务提交（关键步骤！）</strong></li>
</ol>
<ul>
<li>当用户显式执行 <code>COMMIT</code> 或自动提交开启时，事务进入提交阶段。</li>
<li><strong>Write Redo Log：</strong><ul>
<li><strong>两阶段提交的核心第一步：</strong> 将 Redo Log Buffer 中与该事务相关的所有日志记录<strong>顺序、快速</strong>地写入磁盘上的 <strong>Redo Log File（通常是 <code>ib_logfile0</code>, <code>ib_logfile1</code>）</strong>。</li>
<li><strong><code>fsync()</code>：</strong> 为了确保日志真正落盘（防止操作系统缓存丢失），通常需要调用 <code>fsync()</code>（或配置决定的类似机制）强制将文件系统缓存中的日志数据刷到物理磁盘。<strong>这是保证持久性（D）的关键点，也是相对耗时的操作。</strong></li>
</ul>
</li>
<li><strong>写 Binlog（如果启用）：</strong><ul>
<li>在写入 Redo Log <strong>之后</strong>，Server 层会将更新操作的逻辑语句或行变更写入 <strong>Binlog（二进制日志）</strong>。Binlog 用于主从复制和数据恢复。</li>
<li>同样需要 <code>fsync()</code> 确保 Binlog 落盘（取决于 <code>sync_binlog</code> 配置）。</li>
</ul>
</li>
<li><strong>Redo Log Commit：</strong><ul>
<li><strong>两阶段提交的核心第二步：</strong> 在 Binlog 成功写入并 <code>fsync()</code> 后，InnoDB 在 Redo Log 中写入一个特殊的 <strong>Commit Record</strong>，标记该事务<strong>已提交</strong>。</li>
<li>再次 <code>fsync()</code> Redo Log（如果配置需要）。</li>
</ul>
</li>
<li><strong>释放锁：</strong> 事务提交后，InnoDB 释放该事务持有的所有锁（行锁、间隙锁等）。</li>
<li><strong>返回成功：</strong> 向客户端返回执行成功的消息。</li>
</ul>
<ol start="6">
<li><strong>后台刷脏页</strong></li>
</ol>
<ul>
<li><strong>非同步操作！</strong> 提交成功<strong>并不保证</strong>脏页立即写入磁盘数据文件（<code>.ibd</code>）。写入 Redo Log 已经保证了持久性。</li>
<li>InnoDB 有后台线程（Page Cleaner Thread）负责在以下时机将脏页异步刷新回磁盘：<ul>
<li>当 Buffer Pool 中脏页比例过高时（由 <code>innodb_max_dirty_pages_pct</code> 等参数控制）。</li>
<li>当系统空闲时。</li>
<li>当 Redo Log 空间即将用完时（需要回收旧的 Redo Log 空间，这要求对应的脏页必须先刷盘）。</li>
<li>关闭数据库时。</li>
</ul>
</li>
</ul>
<p><strong>关键点与注意事项</strong></p>
<ol>
<li><strong>Buffer Pool 核心作用：</strong> 所有数据读写都发生在内存（Buffer Pool），极大提升性能。</li>
<li><strong>WAL 机制：</strong> Write-Ahead Logging (Redo Log) 是保证持久性和崩溃恢复的核心。先写日志（顺序写，快），后刷脏页（随机写，慢）。</li>
<li><strong>两阶段提交：</strong> 协调 Redo Log 和 Binlog 的写入，保证这两个关键日志在崩溃时状态一致，是数据一致性和主从复制的基石。</li>
<li><strong>Undo Log 与 MVCC：</strong> Undo Log 支持回滚和实现非锁定读（MVCC），是多版本并发控制的关键。</li>
<li><strong>异步刷盘：</strong> 数据文件（.ibd）的写入是异步的，依赖于 Redo Log 保证持久性。</li>
</ol>
<h3 id="count-、count-1-、count-id-、count-字段-有什么区别"><a href="#count-、count-1-、count-id-、count-字段-有什么区别" class="headerlink" title="count(*)、count(1)、count(id)、count(字段)有什么区别"></a><code>count(*)、count(1)、count(id)、count(字段)</code>有什么区别</h3><table>
<thead>
<tr>
<th><strong>语法</strong></th>
<th><strong>统计逻辑</strong></th>
<th><strong>是否包含 NULL</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>COUNT(*)</code></td>
<td>统计所有行（包括所有列），即使所有字段都为 <code>NULL</code> 也会计数</td>
<td><strong>包含</strong></td>
</tr>
<tr>
<td><code>COUNT(1)</code></td>
<td>统计所有行（<code>1</code> 是常量表达式，与列无关）</td>
<td><strong>包含</strong></td>
</tr>
<tr>
<td><code>COUNT(id)</code></td>
<td>统计 <code>id</code> 列中 <strong>非 NULL</strong> 的行数（<code>id</code> 是主键或普通列）</td>
<td><strong>不包含 NULL</strong></td>
</tr>
<tr>
<td><code>COUNT(某个字段)</code></td>
<td>统计该字段中 <strong>非 NULL</strong> 的行数（如果字段允许 <code>NULL</code>）</td>
<td><strong>不包含 NULL</strong></td>
</tr>
</tbody></table>
<p>性能：<code>count(字段)</code> &lt; <code>count(主键)</code> &lt; <code>count(1)</code> ≈ <code>count(*)</code></p>
<p><code>count(主键/字段)</code> 的效率更低的原因是需要解析数据行，并拷贝要返回的字段值。</p>
<h3 id="当OFFSET值很大时（如LIMIT-100000-10），为什么查询会变慢"><a href="#当OFFSET值很大时（如LIMIT-100000-10），为什么查询会变慢" class="headerlink" title="当OFFSET值很大时（如LIMIT 100000, 10），为什么查询会变慢"></a>当<code>OFFSET</code>值很大时（如<code>LIMIT 100000, 10</code>），为什么查询会变慢</h3><ul>
<li><p><strong>原因</strong>：MySQL需先扫描并跳过<code>offset + limit</code>行，再返回结果。</p>
</li>
<li><p><strong>优化方案</strong>：</p>
<ol>
<li><p><strong>记录上一页最后一条数据的ID</strong>（推荐）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">&gt;</span> last_seen_id  <span class="comment">-- 上一页最后一条记录的ID</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>子查询</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> orders </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">&gt;=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> id <span class="keyword">FROM</span> orders <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">10000</span>, <span class="number">1</span></span><br><span class="line">) </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id </span><br><span class="line">LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h3 id="分页时为什么必须搭配ORDER-BY"><a href="#分页时为什么必须搭配ORDER-BY" class="headerlink" title="分页时为什么必须搭配ORDER BY"></a>分页时为什么必须搭配<code>ORDER BY</code></h3><ul>
<li><p>缺少<code>ORDER BY</code>时，MySQL返回结果的顺序不确定，导致分页结果混乱。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span> LIMIT <span class="number">0</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="IN-和-EXISTS-的区别"><a href="#IN-和-EXISTS-的区别" class="headerlink" title="IN 和 EXISTS 的区别"></a><code>IN</code> 和 <code>EXISTS</code> 的区别</h3><p>当使用 <code>IN</code> 时，MySQL 会首先执行子查询，然后将子查询的结果集用于外部查询的条件。这意味着子查询的结果集要全部加载到内存。</p>
<p>而 <code>EXISTS</code> 会对外部查询的每一行，执行一次子查询。如果子查询返回任何行，则 <code>EXISTS</code> 条件为真。<code>EXISTS</code> 关注的是子查询是否返回行，而不是返回的具体值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- IN 的临时表可能成为性能瓶颈</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> user_id <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> amount <span class="operator">&gt;</span> <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- EXISTS 可以利用关联索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users u</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> orders o </span><br><span class="line">            <span class="keyword">WHERE</span> o.user_id <span class="operator">=</span> u.id <span class="keyword">AND</span> o.amount <span class="operator">&gt;</span> <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p><code>IN</code> 适用于子查询结果集较小的情况。如果子查询返回大量数据，<code>IN</code> 的性能可能会下降，因为它需要将整个结果集加载到内存。</p>
<p>而 EXISTS 适用于子查询结果集可能很大的情况。由于 <code>EXISTS</code> 只需要判断子查询是否返回行，而不需要加载整个结果集，因此在某些情况下性能更好，特别是当子查询可以使用索引时。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="什么是回表、覆盖索引、最左前缀原则和索引下推"><a href="#什么是回表、覆盖索引、最左前缀原则和索引下推" class="headerlink" title="什么是回表、覆盖索引、最左前缀原则和索引下推"></a>什么是回表、覆盖索引、最左前缀原则和索引下推</h3><p><strong>回表</strong>：要查询的字段没有全部包含在索引中，需要根据索引找到主键，再从主键索引中找到所需字段 。</p>
<p><strong>覆盖索引</strong>：查询所需的字段都包含在索引中，无需回表操作。</p>
<p><strong>最左前缀原则</strong>：复合索引 <code>(a, b, c)</code> 的查询条件必须从最左列开始，且不能跳过中间列才能命中索引。</p>
<p><strong>索引下推</strong>：将WHERE条件中的过滤操作”下推”到存储引擎层执行，减少不必要的回表操作。</p>
<h3 id="InnoDB索引结构"><a href="#InnoDB索引结构" class="headerlink" title="InnoDB索引结构"></a>InnoDB索引结构</h3><p><strong>InnoDB选择B+树的7大关键原因</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>对比维度</strong></th>
<th align="left"><strong>B树</strong></th>
<th align="left"><strong>B+树</strong></th>
<th align="left"><strong>InnoDB优势体现</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>数据存储位置</strong></td>
<td align="left">所有节点存储数据</td>
<td align="left">仅叶子节点存储数据</td>
<td align="left">减少磁盘IO次数</td>
</tr>
<tr>
<td align="left"><strong>树高度</strong></td>
<td align="left">较高（数据分散存储）</td>
<td align="left">较低（内部节点纯索引）</td>
<td align="left">3层B+树可支撑千万级数据</td>
</tr>
<tr>
<td align="left"><strong>范围查询</strong></td>
<td align="left">需要回溯父节点</td>
<td align="left">通过叶子链表顺序扫描</td>
<td align="left"><code>WHERE id &gt; 100</code> 效率提升10倍+</td>
</tr>
<tr>
<td align="left"><strong>全表扫描</strong></td>
<td align="left">需遍历整棵树</td>
<td align="left">直接顺序遍历叶子节点链表</td>
<td align="left">全表扫描速度接近顺序读</td>
</tr>
<tr>
<td align="left"><strong>磁盘利用率</strong></td>
<td align="left">节点包含数据导致存储键值数少</td>
<td align="left">单页可存储更多键值（高分支因子）</td>
<td align="left">相同数据量减少30%-50%树高度</td>
</tr>
<tr>
<td align="left"><strong>数据更新代价</strong></td>
<td align="left">可能引起复杂结构调整</td>
<td align="left">插入删除多数情况只需局部调整</td>
<td align="left">支持更高并发写入</td>
</tr>
<tr>
<td align="left"><strong>缓存命中率</strong></td>
<td align="left">热点数据分散在不同层级</td>
<td align="left">叶子节点集中存储所有数据</td>
<td align="left">Buffer Pool利用率提升40%+</td>
</tr>
</tbody></table>
<h3 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h3><h3 id="为什么有时索引会失效或选错索引"><a href="#为什么有时索引会失效或选错索引" class="headerlink" title="为什么有时索引会失效或选错索引"></a>为什么有时索引会失效或选错索引</h3><p>索引失效的常见场景：</p>
<ul>
<li>统计信息不准确，误判索引效率（手动更新统计信息：<code>ANALYZE TABLE users;</code> ）</li>
<li>需要大量回表操作</li>
<li>违反最左前缀原则</li>
<li>对索引列进行运算或函数操作</li>
<li>使用 <code>or</code> 连接非索引列</li>
<li>使用 <code>like &#39;%地址&#39;</code></li>
</ul>
<h3 id="WHERE-b-1-AND-c-2-ORDER-BY-a-能否用上组合索引-a-b-c"><a href="#WHERE-b-1-AND-c-2-ORDER-BY-a-能否用上组合索引-a-b-c" class="headerlink" title="WHERE b=1 AND c=2 ORDER BY a 能否用上组合索引 (a, b, c)"></a><code>WHERE b=1 AND c=2 ORDER BY a</code> 能否用上组合索引 <code>(a, b, c)</code></h3><p><strong>可以，但是效率不高，需要扫描全索引</strong>。</p>
<p>使用索引 <code>(a, b, c)</code> 的执行过程：</p>
<ol>
<li><strong>索引扫描</strong>：由于 <code>WHERE</code> 条件缺少最左列 <code>a</code>，无法使用索引<strong>查找</strong>，只能进行<strong>索引全扫描</strong></li>
<li><strong>过滤条件</strong>：扫描过程中对每行索引记录检查 <code>b=1 AND c=2</code></li>
<li><strong>排序天然满足</strong>：由于索引本身就是按 <code>a</code> 排序的，所以 <code>ORDER BY a</code> 天然满足，无需额外排序</li>
</ol>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="InnoDB有哪几类锁"><a href="#InnoDB有哪几类锁" class="headerlink" title="InnoDB有哪几类锁"></a>InnoDB有哪几类锁</h3><ul>
<li><p><strong>记录锁（Record Lock）</strong>：单行记录上的锁。</p>
</li>
<li><p><strong>间隙锁（Gap Lock）</strong>：锁定记录之间的间隙，不锁定记录本身。防止幻读。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 表数据：5, 10, 15</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">10</span> <span class="keyword">AND</span> id <span class="operator">&lt;</span> <span class="number">20</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>这条语句会锁定区间 <code>(10,15)</code>、<code>(15,+∞)</code>，在事务执行期间，其他事务无法在这两个区间插入数据</p>
<ul>
<li><strong>临键锁（Next-Key Lock）</strong>：锁定记录本身及之前的间隙。防止幻读和不可重复读。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 事务A执行：</span><br><span class="line">SELECT * FROM users WHERE id &gt; 15 AND id &lt; 25 FOR UPDATE;</span><br><span class="line">-- 假设存在id=20的记录，临键锁会锁定：(15,20],(20,+∞)</span><br></pre></td></tr></table></figure>

<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务的基本特性和隔离级别"><a href="#事务的基本特性和隔离级别" class="headerlink" title="事务的基本特性和隔离级别"></a>事务的基本特性和隔离级别</h3><p>事务保证一组操作要么全都执行，要么都不执行。在 MySQL 中，事务支持是在引擎层实现的。</p>
<table>
<thead>
<tr>
<th>基本特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>原子性（<code>atomicity</code>）</td>
<td>事务中的操作要么全都执行，要么都不执行</td>
</tr>
<tr>
<td>一致性（<code>consistency</code>）</td>
<td>事务的执行要保证数据的完整性和一致性</td>
</tr>
<tr>
<td>隔离性（<code>isolation</code>）</td>
<td>事务的执行互不干扰</td>
</tr>
<tr>
<td>持久性（<code>durability</code>）</td>
<td>事务一旦提交，对数据的修改就永久保存到数据库中，不可撤销</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>事务可能引发的问题</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>脏读</td>
<td>A 事务读取 B 事务尚未提交的修改</td>
</tr>
<tr>
<td>不可重复读</td>
<td>A 事务多次读取同一数据，结果前后不一致</td>
</tr>
<tr>
<td>幻读</td>
<td>A 事务多次读取，数据总量前后不一致</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>说明</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td><code>read uncommitted</code></td>
<td>一个事务执行过程中，能看到其他未提交事务做的修改</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td><code>read committed</code></td>
<td>一个事务执行过程中，能看到其他已提交事务做的修改（MySQL 会在每个 SQL 语句开始执行时创建一个视图）</td>
<td></td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td><code>repeatable read</code></td>
<td>一个事务执行过程中，其他事务的修改对它不可见（MySQL 会在事务启动时创建一个视图，整个事务执行期间都使用这个视图）</td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td><code>serializable</code></td>
<td>事务串行执行，隔离级别最高，不会出现上面所说的问题，但相应的效率也最低</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a>快照读和当前读</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">快照读</th>
<th align="left">当前读</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>数据版本</strong></td>
<td align="left">历史快照版本</td>
<td align="left">最新提交版本</td>
</tr>
<tr>
<td align="left"><strong>加锁</strong></td>
<td align="left">不加锁</td>
<td align="left">加锁（共享锁&#x2F;排他锁）</td>
</tr>
<tr>
<td align="left"><strong>一致性</strong></td>
<td align="left">一致性非锁定读</td>
<td align="left">当前数据一致性</td>
</tr>
<tr>
<td align="left"><strong>并发性</strong></td>
<td align="left">高，读写不冲突</td>
<td align="left">低，可能阻塞写操作</td>
</tr>
<tr>
<td align="left"><strong>触发语句</strong></td>
<td align="left">普通SELECT</td>
<td align="left">SELECT FOR UPDATE, UPDATE, DELETE等</td>
</tr>
<tr>
<td align="left"><strong>隔离级别</strong></td>
<td align="left">RC, RR</td>
<td align="left">所有级别，特别是SERIALIZABLE</td>
</tr>
</tbody></table>
<h3 id="MVCC实现原理"><a href="#MVCC实现原理" class="headerlink" title="MVCC实现原理"></a><code>MVCC</code>实现原理</h3><ul>
<li><code>Undo log</code>：每条数据维护多个历史版本</li>
<li><code>ReadView</code>：快照</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ReadView结构：</span><br><span class="line">&#123;</span><br><span class="line">  creator_trx_id: 150,      -- 当前事务ID</span><br><span class="line">  m_ids: [100, 120, 140],   -- 活跃事务ID列表</span><br><span class="line">  min_trx_id: 100,          -- 最小活跃事务ID</span><br><span class="line">  max_trx_id: 150           -- 预分配最大事务ID</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可见性判断规则</strong>：</p>
<ol>
<li>数据版本<code>trx_id</code> &lt; <code>min_trx_id</code> → 可见</li>
<li><code>trx_id</code>在<code>m_ids</code>中 → 不可见</li>
<li><code>trx_id</code> &gt;&#x3D; <code>max_trx_id</code> → 不可见</li>
</ol>
<p>InnoDB默认会为每行数据生成两个隐藏列：</p>
<ul>
<li><code>DB_TRX_ID</code>：最后修改该行的事务ID</li>
<li><code>DB_ROLL_PTR</code>：指向<code>Undo Log</code>的回滚指针</li>
</ul>
<p>不同隔离级别下<code>ReadView</code>的生成时机：</p>
<ul>
<li><code>READ COMMITTED(RC)</code>：每次<code>SELECT</code>都会创建新的<code>ReadView</code></li>
<li><code>REPEATABLE READ(RR)</code>：事务中第一次<code>SELECT</code>时创建<code>ReadView</code></li>
</ul>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="什么是redo-log"><a href="#什么是redo-log" class="headerlink" title="什么是redo log"></a>什么是redo log</h3><p><strong>Redo Log (物理日志):</strong> 记录的是物理级别的更改。它描述的是“在某个数据页 (Page) 上的某个偏移量处做了什么修改”。例如：“在表空间 ID 为 X，页号 Y 的数据页上，偏移量 Z 开始的 4 个字节被修改为值 0x12345678”。它不关心具体的 SQL 语句是什么，只关心数据页的物理变化。这种日志体积通常较小且高效。</p>
<h3 id="什么是binlog"><a href="#什么是binlog" class="headerlink" title="什么是binlog"></a>什么是binlog</h3><p><strong>Binlog (逻辑日志):</strong> 记录的是逻辑级别的操作。根据 binlog 格式 (<code>STATEMENT</code>, <code>ROW</code>, <code>MIXED</code>) 的不同，它记录的内容也不同：</p>
<ul>
<li><code>STATEMENT</code>: 记录原始的 SQL 语句本身（如 <code>UPDATE users SET balance=100 WHERE id=5;</code>）。</li>
<li><code>ROW</code>: 记录被修改的行在修改前和修改后的数据（或仅修改后的数据，取决于配置）。例如，记录 <code>id=5</code> 的这行数据，<code>balance</code> 字段从 <code>50</code> 改成了 <code>100</code>。</li>
<li><code>MIXED</code>: 混合模式，默认使用 <code>STATEMENT</code>，但在某些可能引起主从不一致（如使用非确定性函数 <code>UUID()</code>, <code>NOW()</code>）的情况下自动切换到 <code>ROW</code>。逻辑日志更易于人类理解和用于复制，但 <code>ROW</code> 模式在批量操作时可能产生大量日志。</li>
</ul>
<h3 id="redo-log-vs-binlog"><a href="#redo-log-vs-binlog" class="headerlink" title="redo log vs binlog"></a>redo log vs binlog</h3><table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>Redo Log (重做日志)</strong></th>
<th align="left"><strong>Binlog (二进制日志)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>所属层级</strong></td>
<td align="left"><strong>InnoDB 存储引擎层</strong></td>
<td align="left"><strong>MySQL Server 层</strong></td>
</tr>
<tr>
<td align="left"><strong>主要作用</strong></td>
<td align="left"><strong>崩溃恢复</strong>：确保事务的持久性 (Durability)</td>
<td align="left"><strong>数据备份与恢复</strong>：主从复制、时间点恢复</td>
</tr>
<tr>
<td align="left"><strong>日志类型</strong></td>
<td align="left"><strong>物理日志</strong>：记录页面的物理修改</td>
<td align="left"><strong>逻辑日志</strong>：记录导致数据变化的 SQL 语句或行变化</td>
</tr>
<tr>
<td align="left"><strong>内容</strong></td>
<td align="left">在某个数据页上做了什么修改 (物理操作)</td>
<td align="left">执行了什么 SQL 语句 (Statement) 或哪些行被修改 (Row)</td>
</tr>
<tr>
<td align="left"><strong>写入时机</strong></td>
<td align="left"><strong>持续写入</strong>：事务进行中</td>
<td align="left"><strong>事务提交后</strong>：事务完成时才写入</td>
</tr>
<tr>
<td align="left"><strong>写入方式</strong></td>
<td align="left"><strong>顺序写入</strong> (循环文件)</td>
<td align="left"><strong>追加写入</strong> (文件序列)</td>
</tr>
<tr>
<td align="left"><strong>生命周期</strong></td>
<td align="left">数据刷盘后可覆盖 (循环使用)</td>
<td align="left">可长期保存 (需手动或策略清理)</td>
</tr>
<tr>
<td align="left"><strong>刷盘策略</strong></td>
<td align="left"><code>innodb_flush_log_at_trx_commit</code></td>
<td align="left"><code>sync_binlog</code></td>
</tr>
<tr>
<td align="left"><strong>格式</strong></td>
<td align="left">InnoDB 私有格式</td>
<td align="left"><code>STATEMENT</code>, <code>ROW</code>, <code>MIXED</code></td>
</tr>
<tr>
<td align="left"><strong>使用场景</strong></td>
<td align="left">数据库崩溃后自动恢复未刷盘的数据</td>
<td align="left">主从复制、增量备份、时间点恢复、数据审计</td>
</tr>
</tbody></table>
<p><strong>写入时机：</strong></p>
<ul>
<li><strong>Redo Log:</strong> 在事务执行过程中 <strong>持续写入</strong>。当事务修改数据时，首先会在内存中的 Buffer Pool 修改数据页（产生脏页），同时会生成对应的 redo log 记录并 <strong>顺序、近乎实时地写入 redo log buffer</strong>，然后根据策略（<code>innodb_flush_log_at_trx_commit</code>）刷写到磁盘上的 redo log 文件。<strong>事务提交时，必须确保其对应的 redo log 已按策略持久化到磁盘</strong>，这是保证持久性的关键。</li>
<li><strong>Binlog:</strong> 是在事务 <strong>提交完成之前</strong>，但在确保 redo log 已持久化之后（见两阶段提交）<strong>一次性写入</strong>。事务提交时，MySQL Server 层将事务涉及的所有 binlog 事件按顺序写入 binlog cache，然后根据策略 (<code>sync_binlog</code>) 刷写到磁盘上的 binlog 文件。<strong>只有 binlog 成功写入并持久化（根据策略），事务才被认为最终提交成功</strong>。</li>
</ul>
<p><strong>刷盘策略</strong></p>
<ul>
<li><strong>Redo Log:</strong> 由参数 <code>innodb_flush_log_at_trx_commit</code> 控制：<ul>
<li><code>0</code>: 每秒写入并刷盘一次（可能丢失最多1秒的事务）。</li>
<li><code>1</code>: <strong>默认且最安全</strong>。每次事务提交时写入并刷盘（保证崩溃后不丢数据）。</li>
<li><code>2</code>: 每次事务提交时写入 OS 缓存，每秒刷盘一次（MySQL 进程崩溃不丢数据，OS 崩溃可能丢失最多1秒的事务）。</li>
</ul>
</li>
<li><strong>Binlog:</strong> 由参数 <code>sync_binlog</code> 控制：<ul>
<li><code>0</code>: 依赖 OS 刷新，MySQL 不主动刷盘（性能最好，风险最高）。</li>
<li><code>1</code>: <strong>默认且安全</strong>。每次事务提交后都刷盘（保证 binlog 不丢失）。</li>
<li><code>N</code> (N&gt;1): 每 N 个事务提交后刷盘一次（折中方案）。</li>
</ul>
</li>
</ul>
<h3 id="什么是两阶段提交"><a href="#什么是两阶段提交" class="headerlink" title="什么是两阶段提交"></a>什么是两阶段提交</h3><p>两阶段提交的核心目的之一，就是为了协调 <strong>redo log (InnoDB 引擎层)</strong> 和 <strong>binlog (Server 层)</strong> 这两种位于不同层次、有各自内存 buffer 和刷盘策略的日志，在 <strong>刷盘时机</strong> 上保持一致，确保崩溃恢复后数据状态一致。</p>
<ol>
<li><strong>Prepare 阶段 (InnoDB):</strong> 将事务的 redo log 写入 redo log buffer <strong>并刷盘</strong>（根据 <code>innodb_flush_log_at_trx_commit</code>，通常此时已强制刷盘），标记状态为 <code>PREPARE</code>。<strong>此时 redo log 在磁盘上持久化了“这个事务在哪些位置修改了什么”。</strong></li>
<li><strong>Write &amp; Sync Binlog 阶段 (Server):</strong> 将事务的 binlog 事件写入 binlog cache <strong>并刷盘</strong>（根据 <code>sync_binlog</code>，通常此时也强制刷盘）。<strong>此时 binlog 在磁盘上持久化了“这个事务执行了什么操作”。</strong></li>
<li><strong>Commit 阶段 (InnoDB):</strong> 在 redo log 中写入一个 <code>COMMIT</code> 标记（通常只需写 redo log buffer，不一定立刻刷盘，因为前两步已保证关键信息持久化）。<strong>标记事务在引擎层正式提交。</strong></li>
</ol>
<h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><h3 id="InnoDB和其他存储引擎的比较"><a href="#InnoDB和其他存储引擎的比较" class="headerlink" title="InnoDB和其他存储引擎的比较"></a>InnoDB和其他存储引擎的比较</h3><table>
<thead>
<tr>
<th></th>
<th>MyISAM</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td>锁</td>
<td>表级锁</td>
<td>行级锁</td>
</tr>
<tr>
<td>事务支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>索引结构</td>
<td>B树</td>
<td>B+树</td>
</tr>
<tr>
<td>全文检索</td>
<td>支持</td>
<td>5.5版本后支持</td>
</tr>
</tbody></table>
<p>总体来说，如果需要支持事务、外键约束和高并发访问，那么InnoDB是更好的选择。如果需要进行全文检索，那么MyISAM是更好的选择。但是需要注意的是，MySQL 5.5版本之后，InnoDB已经支持了全文检索。</p>
<h3 id="什么是buffer-pool"><a href="#什么是buffer-pool" class="headerlink" title="什么是buffer pool"></a>什么是buffer pool</h3><p>在 MySQL 的 InnoDB 存储引擎中，<strong>Change Buffer</strong> 和 <strong>Buffer Pool</strong> 都是核心的内存结构，用于优化性能，但它们解决的问题和运作方式截然不同：</p>
<ul>
<li><strong>本质：</strong> <strong>数据库的内存缓存区域</strong>。用于缓存从磁盘读取的<strong>数据页（Data Pages）和索引页（Index Pages）</strong>。</li>
<li><strong>目的：</strong> <strong>减少磁盘 I&#x2F;O</strong>。</li>
<li><strong>作用对象：</strong> <strong>所有类型的数据页</strong>。包括：<ul>
<li>包含表行数据的页（数据页）。</li>
<li>包含索引（主键索引、二级索引）条目的页（索引页）。</li>
<li>系统页、Undo 页等。</li>
</ul>
</li>
<li><strong>工作原理：</strong><ul>
<li><strong>读操作：</strong> 优先从 Buffer Pool 读取，未命中则读磁盘并加载。</li>
<li><strong>写操作 (DML: INSERT, UPDATE, DELETE)：</strong><ol>
<li>修改发生在 Buffer Pool 中的<strong>脏页（Dirty Page）</strong>（已被修改但尚未写回磁盘的页）。</li>
<li>修改会写入 Redo Log 以保证持久性。</li>
<li><strong>不是立即写回磁盘！</strong> Buffer Pool 中的脏页会在后台由专门的线程或根据特定策略（如 LRU 淘汰、检查点触发、Buffer Pool 空间不足时）<strong>异步刷新（Flush）</strong> 到磁盘的数据文件（.ibd 文件）。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="什么是change-buffer"><a href="#什么是change-buffer" class="headerlink" title="什么是change buffer"></a>什么是change buffer</h3><ul>
<li><strong>本质：</strong> <strong>用于优化对非唯一二级索引的写操作（INSERT, UPDATE, DELETE）</strong>。物理上<strong>是 Buffer Pool 的一部分</strong>，但逻辑功能独立。</li>
<li><strong>目的：</strong> <strong>减少对非唯一二级索引的随机磁盘 I&#x2F;O。</strong> 当修改操作（尤其是 INSERT 和 UPDATE）涉及到非唯一的二级索引时，如果对应的索引页<strong>不在 Buffer Pool</strong> 中，传统的做法是必须先将该索引页从磁盘读入 Buffer Pool 才能修改。Change Buffer 允许 InnoDB <strong>将这次修改“缓冲”下来</strong>，而不是立即去磁盘加载那个索引页。</li>
<li><strong>作用对象：</strong> <strong>仅限于非唯一二级索引（Non-Unique Secondary Index）</strong> 的修改操作。它不处理：<ul>
<li>主键索引（聚簇索引）的修改（直接在 Buffer Pool 中的页上修改）。</li>
<li>唯一索引的修改（需要立即检查唯一性约束，必须加载索引页）。</li>
<li>数据页本身的修改（在 Buffer Pool 中进行）。</li>
</ul>
</li>
<li><strong>工作原理：</strong><ul>
<li>当发生影响非唯一二级索引的 DML 操作时：<ol>
<li>检查目标索引页是否已在 Buffer Pool 中。</li>
<li><strong>如果在：</strong> 直接在内存中的索引页上进行修改。</li>
<li><strong>如果不在：</strong> <strong>将这次修改操作（包含索引列值、行标识等信息）记录到 Change Buffer 中</strong>，而不是去磁盘加载索引页。修改操作本身也会记录到 Redo Log。</li>
</ol>
</li>
<li><strong>后续操作（Merge 合并）：</strong><ul>
<li>当<strong>稍后</strong>需要读取这个被修改的索引页（例如通过 SELECT 使用该索引、后台 Purge 线程、Checkpoint 检查点、Server 空闲、Change Buffer 满、关闭数据库时），InnoDB 会先将该索引页从磁盘加载到 Buffer Pool。</li>
<li>加载完成后，InnoDB 会查找 Change Buffer 中所有针对这个<strong>已加载页</strong>的待处理修改记录。</li>
<li>将这些修改记录<strong>应用（Merge）</strong> 到新加载到内存的索引页上，使该索引页在内存中达到最新状态。</li>
<li>此时，被 Merge 的索引页变成了脏页，之后会由 Buffer Pool 的刷新机制写回磁盘。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h2><h3 id="char-100-和-varchar-100-的区别"><a href="#char-100-和-varchar-100-的区别" class="headerlink" title="char(100) 和 varchar(100) 的区别"></a>char(100) 和 varchar(100) 的区别</h3><p><strong>核心区别总结</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><code>CHAR(100)</code></th>
<th align="left"><code>VARCHAR(100)</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>类型名称</strong></td>
<td align="left">定长字符串</td>
<td align="left">变长字符串</td>
</tr>
<tr>
<td align="left"><strong>存储方式</strong></td>
<td align="left">始终占用 100 字符空间（不足补空格）</td>
<td align="left">按实际字符数存储 + 额外长度开销</td>
</tr>
<tr>
<td align="left"><strong>存储 “abc” 的占用</strong></td>
<td align="left">100 字节（固定）</td>
<td align="left">3 字节 + 1~2 字节长度开销 ≈ 4 字节</td>
</tr>
<tr>
<td align="left"><strong>空格处理</strong></td>
<td align="left">插入时会自动补空格，查询时自动去除</td>
<td align="left">保留原始空格，不自动补齐</td>
</tr>
<tr>
<td align="left"><strong>查询速度</strong></td>
<td align="left">更快（定长，直接定位）</td>
<td align="left">稍慢（需计算位置）</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">长度固定的数据（如国家代码、MD5）</td>
<td align="left">长度不固定的数据（如用户名、地址）</td>
</tr>
</tbody></table>
<h3 id="为什么不建议使用text类型"><a href="#为什么不建议使用text类型" class="headerlink" title="为什么不建议使用text类型"></a>为什么不建议使用<code>text</code>类型</h3><p>在数据库设计中，文本类型字段（如MySQL中的TEXT，PostgreSQL中的TEXT等）通常用于存储大量文本数据。虽然它们可以存储大量数据，但在某些情况下不建议使用，原因如下：</p>
<ol>
<li><strong>性能问题</strong>：在InnoDB中，TEXT和BLOB类型在记录较大时可能存储在溢出页，这可能导致额外的磁盘I&#x2F;O。</li>
<li><strong>内存使用</strong>：在处理查询时，数据库可能会为TEXT字段分配大量内存，这可能导致内存使用过高，影响数据库性能。</li>
<li><strong>索引限制</strong>：在MySQL中，对TEXT列建立索引必须指定前缀长度，这可能导致索引效率不高。</li>
<li><strong>复制和恢复</strong>：由于TEXT字段可能包含大量数据，在数据库复制（如主从复制）和备份恢复过程中，可能会增加网络传输和I&#x2F;O负担，导致延迟。</li>
<li><strong>查询优化</strong>：优化器在处理包含TEXT字段的查询时可能会选择效率较低的执行计划，因为无法准确估计TEXT字段的大小。</li>
<li><strong>排序和分组</strong>：如果查询需要对TEXT字段进行排序或分组，由于数据量大，可能会使用磁盘临时表，导致性能下降。</li>
</ol>
<p><strong>总结</strong>：在不需要存储大文本时，使用TEXT类型可能会带来性能、存储和功能上的限制，因此建议仅在必要时使用。</p>
<table>
<thead>
<tr>
<th align="left"><strong>场景</strong></th>
<th align="left"><strong>推荐类型</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">短文本（&lt; 255 字符）</td>
<td align="left"><code>VARCHAR(n)</code></td>
</tr>
<tr>
<td align="left">中等文本（&lt; 64KB）</td>
<td align="left"><code>VARCHAR(65535)</code></td>
</tr>
<tr>
<td align="left">超大文本（&gt; 64KB）</td>
<td align="left"><code>TEXT</code>（或分表存储）</td>
</tr>
</tbody></table>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/7992e236.html" rel="prev" title="学习&面试-Java">
                  <i class="fa fa-angle-left"></i> 学习&面试-Java
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/688e2513.html" rel="next" title="消息队列之Kafka">
                  消息队列之Kafka <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa-regular fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder"></span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Word count total">392k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">23:47</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>

  <script class="next-config" data-name="wavedrom" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/wavedrom.min.js","integrity":"sha256-INLAoJc6quTNfiMWkGZniYO2cxE8mHpddnLow1m6RFs="}}</script>
  <script class="next-config" data-name="wavedrom_skin" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/skins/default.js","integrity":"sha256-fduc/Zszk5ezWws2uInY/ALWVmIrmV6VTgXbsYSReFI="}}</script>
  <script src="/js/third-party/tags/wavedrom.js"></script>




  





</body>
</html>
