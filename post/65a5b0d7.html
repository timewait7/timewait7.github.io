<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"timewait7.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":true,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Java新特性Java 8Java 11Java 17Java 21Java基础语法基础&#x3D;&#x3D;和equals的区别&#x3D;&#x3D; 用于比较基本数据类型的值或对象引用的内存地址，equals 用户比较对象内容。 equals和hashCode为什么要同时重写 契约要求：对象相等性的一致性   Object类的规范明确规定：  如果两个对象通过equals()方法比较是相等的，那么它们的hashCode()必须返">
<meta property="og:type" content="article">
<meta property="og:title" content="Java学习&amp;面试">
<meta property="og:url" content="http://timewait7.github.io/post/65a5b0d7.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Java新特性Java 8Java 11Java 17Java 21Java基础语法基础&#x3D;&#x3D;和equals的区别&#x3D;&#x3D; 用于比较基本数据类型的值或对象引用的内存地址，equals 用户比较对象内容。 equals和hashCode为什么要同时重写 契约要求：对象相等性的一致性   Object类的规范明确规定：  如果两个对象通过equals()方法比较是相等的，那么它们的hashCode()必须返">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://timewait7.github.io/post/65a5b0d7/image-20250720163023390.png">
<meta property="og:image" content="http://timewait7.github.io/post/65a5b0d7/1726212535664-4bb3f3ff-704a-4706-84c8-a046a8486657.webp">
<meta property="og:image" content="http://timewait7.github.io/post/65a5b0d7/image-20250302111116621.png">
<meta property="og:image" content="http://timewait7.github.io/post/65a5b0d7/image-20250302111551681.png">
<meta property="og:image" content="http://timewait7.github.io/post/65a5b0d7/image-20250302112330725.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/stutymore/redis-20240918114125.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-b7b24e25-d2dc-4457-994f-95bdb3674b8e.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-942a927a-86e4-4a01-8f52-9addd89642ff.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-df77ee15-2ff0-4ec7-8e65-e4ebb8ba88f1.png">
<meta property="og:image" content="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-e29a122b-db07-48b8-8289-7251032e87a1.png">
<meta property="og:image" content="http://timewait7.github.io/post/65a5b0d7/image-20250505093121422.png">
<meta property="article:published_time" content="2025-07-19T05:58:30.000Z">
<meta property="article:modified_time" content="2025-07-20T08:31:37.624Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://timewait7.github.io/post/65a5b0d7/image-20250720163023390.png">


<link rel="canonical" href="http://timewait7.github.io/post/65a5b0d7.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://timewait7.github.io/post/65a5b0d7.html","path":"post/65a5b0d7.html","title":"Java学习&面试"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java学习&面试 | Hexo</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-archives"><a href="/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="Searching..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java"><span class="nav-number">1.</span> <span class="nav-text">Java</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.1.</span> <span class="nav-text">新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-8"><span class="nav-number">1.1.1.</span> <span class="nav-text">Java 8</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-11"><span class="nav-number">1.1.2.</span> <span class="nav-text">Java 11</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-17"><span class="nav-number">1.1.3.</span> <span class="nav-text">Java 17</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-21"><span class="nav-number">1.1.4.</span> <span class="nav-text">Java 21</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="nav-number">1.2.</span> <span class="nav-text">Java基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80"><span class="nav-number">1.2.1.</span> <span class="nav-text">语法基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">&#x3D;&#x3D;和equals的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#equals%E5%92%8ChashCode%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%90%8C%E6%97%B6%E9%87%8D%E5%86%99"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">equals和hashCode为什么要同时重写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">异常的层次结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">1.2.2.</span> <span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B3%9B%E5%9E%8B"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">为什么需要泛型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">什么是泛型擦除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E9%99%90%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">泛型的上下限及应用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">1.2.3.</span> <span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">什么是反射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">反射的优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84-Class-%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">如何获取一个类的 Class 对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.2.3.4.</span> <span class="nav-text">如何通过反射创建一个类的实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.2.3.5.</span> <span class="nav-text">反射有哪些实际应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Class-forName-%E5%92%8C-ClassLoader-loadClass-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.3.6.</span> <span class="nav-text">Class.forName() 和 ClassLoader.loadClass() 有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%B0%84%E7%A0%B4%E5%9D%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.2.3.7.</span> <span class="nav-text">如何防止反射破坏单例模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.2.4.</span> <span class="nav-text">注解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E4%B8%AD%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">Java中都有哪些元注解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SPI"><span class="nav-number">1.2.5.</span> <span class="nav-text">SPI</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E9%9B%86%E5%90%88"><span class="nav-number">1.3.</span> <span class="nav-text">Java集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80"><span class="nav-number">1.3.1.</span> <span class="nav-text">集合基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Iterator-%E5%92%8C-ListIterator-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">Iterator 和 ListIterator 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-fail-fast-%E6%9C%BA%E5%88%B6"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">什么是 fail-fast 机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fail-fast-%E5%92%8C-fail-safe-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">fail-fast 和 fail-safe 的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List"><span class="nav-number">1.3.2.</span> <span class="nav-text">List</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">ArrayList的扩容机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Vector-%E5%92%8C-ArrayList-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">Vector 和 ArrayList 的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set"><span class="nav-number">1.3.3.</span> <span class="nav-text">Set</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HashSet%E3%80%81LinkedHashSet-%E5%92%8C-TreeSet-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">HashSet、LinkedHashSet 和 TreeSet 的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map"><span class="nav-number">1.3.4.</span> <span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">HashMap 的底层实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap-%E5%92%8C-HashTable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">HashMap 和 HashTable 的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-IO"><span class="nav-number">1.4.</span> <span class="nav-text">Java IO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.1.</span> <span class="nav-text">字节流与字符流的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BIO%E3%80%81NIO%E3%80%81AIO%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.2.</span> <span class="nav-text">BIO、NIO、AIO的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NIO-%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="nav-number">1.4.3.</span> <span class="nav-text">NIO 三大核心组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.4.4.</span> <span class="nav-text">什么是零拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E7%A7%8DIO%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.4.5.</span> <span class="nav-text">5种IO模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFReactor%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.4.6.</span> <span class="nav-text">什么是Reactor模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%B9%B6%E5%8F%91"><span class="nav-number">1.5.</span> <span class="nav-text">Java并发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JUC%E9%9B%86%E5%90%88"><span class="nav-number">1.5.1.</span> <span class="nav-text">JUC集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentHashMap-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">ConcurrentHashMap 的实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-ConcurrentHashMap-%E6%AF%94-Hashtable-%E6%95%88%E7%8E%87%E9%AB%98"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">为什么 ConcurrentHashMap 比 Hashtable 效率高</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="nav-number">1.6.</span> <span class="nav-text">异步编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CompletableFuture%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="nav-number">1.6.1.</span> <span class="nav-text">CompletableFuture的原理与应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CompletableFuture-%E5%92%8C%E4%BC%A0%E7%BB%9F%E7%9A%84-Future-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">1.6.2.</span> <span class="nav-text">CompletableFuture 和传统的 Future 有什么区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM"><span class="nav-number">1.7.</span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="nav-number">1.7.1.</span> <span class="nav-text">类加载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">类加载器的层次结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Class-forName-%E5%92%8CClassLoader-loadClass-%E5%8C%BA%E5%88%AB"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">Class.forName()和ClassLoader.loadClass()区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-number">1.7.2.</span> <span class="nav-text">内存结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">JVM内存结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E8%A7%A6%E5%8F%91StackOverflowError%E5%92%8COutOfMemoryError"><span class="nav-number">1.7.2.2.</span> <span class="nav-text">什么情况下会触发StackOverflowError和OutOfMemoryError</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B0%B8%E4%B9%85%E4%BB%A3%E5%92%8C%E5%85%83%E7%A9%BA%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.7.2.3.</span> <span class="nav-text">永久代和元空间的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E6%98%AF%E6%80%8E%E4%B9%88%E7%BB%86%E5%88%86%E7%9A%84"><span class="nav-number">1.7.2.4.</span> <span class="nav-text">堆内存是怎么细分的</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">1.7.3.</span> <span class="nav-text">垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E5%9B%9E%E6%94%B6"><span class="nav-number">1.7.3.1.</span> <span class="nav-text">如何判断一个对象是否可回收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-number">1.7.3.2.</span> <span class="nav-text">有哪些垃圾回收算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CMS%E6%94%B6%E9%9B%86%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.7.3.3.</span> <span class="nav-text">CMS收集器工作原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#G1%E6%94%B6%E9%9B%86%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.7.3.4.</span> <span class="nav-text">G1收集器工作原理</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="nav-number">2.</span> <span class="nav-text">数据存储</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL"><span class="nav-number">2.1.</span> <span class="nav-text">MySQL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">2.1.1.</span> <span class="nav-text">查询语句的执行顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.2.</span> <span class="nav-text">InnoDB索引结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88MongoDB%E4%BD%BF%E7%94%A8B%E6%A0%91%E8%80%8CMySQL%E7%94%A8B-%E6%A0%91"><span class="nav-number">2.1.3.</span> <span class="nav-text">为什么MongoDB使用B树而MySQL用B+树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-%E6%A0%91%E8%8A%82%E7%82%B9%E5%88%86%E8%A3%82%E7%9A%84%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B"><span class="nav-number">2.1.4.</span> <span class="nav-text">B+树节点分裂的具体过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EXPLAIN-%E5%AD%97%E6%AE%B5%E8%AF%B4%E6%98%8E"><span class="nav-number">2.1.5.</span> <span class="nav-text">EXPLAIN 字段说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B"><span class="nav-number">2.1.6.</span> <span class="nav-text">覆盖索引与最左前缀原则实战案例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="nav-number">2.1.7.</span> <span class="nav-text">慢查询优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88InnoDB%E4%B8%8D%E4%BF%9D%E5%AD%98%E8%A1%A8%E7%9A%84%E6%80%BB%E8%A1%8C%E6%95%B0"><span class="nav-number">2.1.8.</span> <span class="nav-text">为什么InnoDB不保存表的总行数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7%E5%92%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">2.1.9.</span> <span class="nav-text">解释一下事务的基本特性和隔离级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB"><span class="nav-number">2.1.10.</span> <span class="nav-text">InnoDB如何解决幻读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB%E5%92%8CMyISAM%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.1.11.</span> <span class="nav-text">InnoDB和MyISAM的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E7%B4%A2%E5%BC%95%E4%BC%9A%E5%A4%B1%E6%95%88%E6%88%96%E9%80%89%E9%94%99%E7%B4%A2%E5%BC%95"><span class="nav-number">2.1.12.</span> <span class="nav-text">为什么有时索引会失效或选错索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2"><span class="nav-number">2.1.13.</span> <span class="nav-text">如何优化查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E5%8F%AA%E6%9F%A5%E8%AF%A2%E4%B8%80%E8%A1%8C%E4%BD%86%E6%98%AF%E5%BE%88%E6%85%A2"><span class="nav-number">2.1.14.</span> <span class="nav-text">为什么有时只查询一行但是很慢</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%85%A2SQL%E4%BC%98%E5%8C%96%E5%85%A8%E6%B5%81%E7%A8%8B"><span class="nav-number">2.1.15.</span> <span class="nav-text">慢SQL优化全流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis"><span class="nav-number">2.2.</span> <span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB%EF%BC%9F%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E9%AB%98%E5%B9%B6%E5%8F%91%EF%BC%9F"><span class="nav-number">2.2.1.</span> <span class="nav-text">Redis为什么快？单线程如何处理高并发？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-%E9%9B%AA%E5%B4%A9-%E5%87%BB%E7%A9%BF%EF%BC%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.2.2.</span> <span class="nav-text">解释一下缓存穿透&#x2F;雪崩&#x2F;击穿，对应的解决方案是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB%E5%92%8CAOF%E6%8C%81%E4%B9%85%E5%8C%96%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8A%A3%E5%AF%B9%E6%AF%94"><span class="nav-number">2.2.3.</span> <span class="nav-text">RDB和AOF持久化原理及优劣对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%83%ADKey%E9%97%AE%E9%A2%98"><span class="nav-number">2.2.4.</span> <span class="nav-text">什么是热Key问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E4%BA%8B%E5%8A%A1%E4%B8%8EMySQL%E4%BA%8B%E5%8A%A1%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">2.2.5.</span> <span class="nav-text">Redis事务与MySQL事务有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E6%BC%94%E8%BF%9B%E8%BF%87%E7%A8%8B"><span class="nav-number">2.2.6.</span> <span class="nav-text">使用Redis实现分布式锁的演进过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5%E5%92%8C%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.2.7.</span> <span class="nav-text">全量同步和增量同步的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E4%B8%8ELRU%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.8.</span> <span class="nav-text">内存淘汰策略与LRU实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E5%92%8CMySQL%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.2.9.</span> <span class="nav-text">Redis和MySQL的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E5%92%8Cmemchahed%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.2.10.</span> <span class="nav-text">Redis和memchahed的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">2.2.11.</span> <span class="nav-text">Redis IO多路复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-6-0-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.2.12.</span> <span class="nav-text">Redis 6.0 多线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ElasticSearch"><span class="nav-number">2.3.</span> <span class="nav-text">ElasticSearch</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Elasticsearch-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-number">2.3.1.</span> <span class="nav-text">Elasticsearch 的核心概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%83%E5%AF%B9%E6%90%9C%E7%B4%A2%E5%BE%88%E9%87%8D%E8%A6%81%EF%BC%9F"><span class="nav-number">2.3.2.</span> <span class="nav-text">什么是倒排索引？为什么它对搜索很重要？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MongoDB"><span class="nav-number">2.4.</span> <span class="nav-text">MongoDB</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">3.</span> <span class="nav-text">消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka"><span class="nav-number">3.1.</span> <span class="nav-text">Kafka</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Kafka-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%90%9E%E5%90%90%E9%87%8F%EF%BC%9F"><span class="nav-number">3.1.1.</span> <span class="nav-text">Kafka 为什么能实现高吞吐量？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A-Kafka-%E4%B8%AD-Topic%E3%80%81Partition%E3%80%81Replica-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">3.1.2.</span> <span class="nav-text">解释 Kafka 中 Topic、Partition、Replica 的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Producer-%E7%9A%84-acks-%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F%E5%88%86%E5%88%AB%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%E5%90%AB%E4%B9%89%EF%BC%9F"><span class="nav-number">3.1.3.</span> <span class="nav-text">Producer 的 acks 参数有哪几种？分别代表什么含义？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A-Consumer-Group-%E5%92%8C-Rebalance-%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%82"><span class="nav-number">3.1.4.</span> <span class="nav-text">解释 Consumer Group 和 Rebalance 的概念。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kafka-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1%EF%BC%9F"><span class="nav-number">3.1.5.</span> <span class="nav-text">Kafka 如何保证消息不丢失？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A-Kafka-%E7%9A%84-ISR-%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%9C%A8-Leader-%E9%80%89%E4%B8%BE%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%82"><span class="nav-number">3.1.6.</span> <span class="nav-text">解释 Kafka 的 ISR 机制及其在 Leader 选举中的作用。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kafka-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-Exactly-Once-%E8%AF%AD%E4%B9%89%EF%BC%9F"><span class="nav-number">3.1.7.</span> <span class="nav-text">Kafka 如何实现 Exactly-Once 语义？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kafka-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7%EF%BC%9F"><span class="nav-number">3.1.8.</span> <span class="nav-text">Kafka 如何保证消息的顺序性？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kafka-%E4%B8%AD-Zookeeper-%E5%92%8C-KRaft-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88-Kafka-%E8%A6%81%E5%8E%BB-Zookeeper-%E5%8C%96%EF%BC%9F"><span class="nav-number">3.1.9.</span> <span class="nav-text">Kafka 中 Zookeeper 和 KRaft 的区别？为什么 Kafka 要去 Zookeeper 化？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Consumer-Lag%EF%BC%9F%E5%A6%82%E4%BD%95%E7%9B%91%E6%8E%A7%E5%92%8C%E5%A4%84%E7%90%86-Lag%EF%BC%9F"><span class="nav-number">3.1.10.</span> <span class="nav-text">什么是 Consumer Lag？如何监控和处理 Lag？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kafka%E4%B8%BB%E8%A6%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A%E5%BC%82%E6%AD%A5%E3%80%81%E5%89%8A%E5%B3%B0%E3%80%81%E8%A7%A3%E8%80%A6"><span class="nav-number">3.1.11.</span> <span class="nav-text">kafka主要应用场景：异步、削峰、解耦</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RabbitMQ"><span class="nav-number">3.2.</span> <span class="nav-text">RabbitMQ</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RocketMQ"><span class="nav-number">3.3.</span> <span class="nav-text">RocketMQ</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6"><span class="nav-number">4.</span> <span class="nav-text">开发框架</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring"><span class="nav-number">4.1.</span> <span class="nav-text">Spring</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E8%A7%A3%E5%86%B3%E5%8E%9F%E7%90%86"><span class="nav-number">4.1.1.</span> <span class="nav-text">循环依赖解决原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FactoryBean-%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="nav-number">4.1.2.</span> <span class="nav-text">FactoryBean 的作用与应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BeanFactoryPostProcessor-%E5%92%8C-BeanPostProcessor-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.1.3.</span> <span class="nav-text">BeanFactoryPostProcessor 和 BeanPostProcessor 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%89%A9%E5%B1%95%E7%82%B9%E5%AE%9E%E6%88%98"><span class="nav-number">4.1.4.</span> <span class="nav-text">Bean生命周期扩展点实战</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86"><span class="nav-number">4.1.5.</span> <span class="nav-text">SpringBoot自动配置原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89Starter%E5%BC%80%E5%8F%91%E8%A6%81%E7%82%B9"><span class="nav-number">4.1.6.</span> <span class="nav-text">自定义Starter开发要点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">4.1.7.</span> <span class="nav-text">统一异常处理的最佳实践</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%89"><span class="nav-number">4.1.8.</span> <span class="nav-text">配置加载优先级（命令行&gt;环境变量）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-AOP-%E5%92%8C-AspectJ-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">4.1.9.</span> <span class="nav-text">Spring AOP 和 AspectJ 有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8%E3%80%81%E6%8B%A6%E6%88%AA%E5%99%A8%E3%80%81AOP%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%AE%9E%E8%B7%B5"><span class="nav-number">4.1.10.</span> <span class="nav-text">过滤器、拦截器、AOP的区别与实践</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">4.1.11.</span> <span class="nav-text">注解的实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MapperScan-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">4.1.12.</span> <span class="nav-text">@MapperScan 的实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Autowired-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">4.1.13.</span> <span class="nav-text">@Autowired 的实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringMVC-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">4.1.14.</span> <span class="nav-text">SpringMVC 工作流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringBoot"><span class="nav-number">4.2.</span> <span class="nav-text">SpringBoot</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86"><span class="nav-number">4.2.1.</span> <span class="nav-text">SpringBoot自动装配原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tomcat"><span class="nav-number">4.3.</span> <span class="nav-text">Tomcat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MyBatis"><span class="nav-number">4.4.</span> <span class="nav-text">MyBatis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JPA"><span class="nav-number">4.5.</span> <span class="nav-text">JPA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6"><span class="nav-number">4.6.</span> <span class="nav-text">日志框架</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F"><span class="nav-number">5.</span> <span class="nav-text">分布式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%90%86%E8%AE%BA"><span class="nav-number">5.1.</span> <span class="nav-text">基本理论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFCAP"><span class="nav-number">5.1.1.</span> <span class="nav-text">什么是CAP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFBASE"><span class="nav-number">5.1.2.</span> <span class="nav-text">什么是BASE</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE"><span class="nav-number">5.2.</span> <span class="nav-text">一致性协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Paxos"><span class="nav-number">5.2.1.</span> <span class="nav-text">Paxos</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Raft"><span class="nav-number">5.2.2.</span> <span class="nav-text">Raft</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">5.3.</span> <span class="nav-text">分布式锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90"><span class="nav-number">5.4.</span> <span class="nav-text">分布式ID生成</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1"><span class="nav-number">6.</span> <span class="nav-text">系统设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83"><span class="nav-number">6.1.</span> <span class="nav-text">认证授权</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8"><span class="nav-number">6.2.</span> <span class="nav-text">数据安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E6%80%A7%E8%83%BD"><span class="nav-number">6.3.</span> <span class="nav-text">高性能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="nav-number">6.4.</span> <span class="nav-text">高可用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%90%E6%B5%81"><span class="nav-number">6.4.1.</span> <span class="nav-text">限流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">6.4.1.1.</span> <span class="nav-text">常见的限流算法有哪些</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%8D%E7%BA%A7-%E7%86%94%E6%96%AD"><span class="nav-number">6.4.2.</span> <span class="nav-text">降级&amp;熔断</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DevOps"><span class="nav-number">7.</span> <span class="nav-text">DevOps</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux"><span class="nav-number">7.1.</span> <span class="nav-text">Linux</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker"><span class="nav-number">7.2.</span> <span class="nav-text">Docker</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CI-CD"><span class="nav-number">7.3.</span> <span class="nav-text">CI&#x2F;CD</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%BA%93"><span class="nav-number">8.</span> <span class="nav-text">工具类库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Git"><span class="nav-number">8.1.</span> <span class="nav-text">Git</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Maven"><span class="nav-number">8.2.</span> <span class="nav-text">Maven</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80"><span class="nav-number">9.</span> <span class="nav-text">计算机基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">9.1.</span> <span class="nav-text">操作系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="nav-number">9.2.</span> <span class="nav-text">计算机网络</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%9D%E7%BB%B4%E9%80%BB%E8%BE%91"><span class="nav-number">10.</span> <span class="nav-text">思维逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%99%BD%E9%BC%A0%E8%AF%95%E6%AF%92%E8%8D%AF"><span class="nav-number">10.1.</span> <span class="nav-text">小白鼠试毒药</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#100%E4%B8%AA%E4%BA%BA%E6%8C%89%E7%81%AF"><span class="nav-number">10.2.</span> <span class="nav-text">100个人按灯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#100%E7%9A%84%E9%98%B6%E4%B9%98%E6%9C%89%E5%87%A0%E4%B8%AA0"><span class="nav-number">10.3.</span> <span class="nav-text">100的阶乘有几个0</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E5%A4%A9%E5%B9%B3%E6%89%BE%E6%9C%80%E8%BD%BB-%E9%87%8D%E7%9A%84%E7%90%83"><span class="nav-number">10.4.</span> <span class="nav-text">用天平找最轻&#x2F;重的球</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2017%E7%9A%842017-%E6%AC%A1%E6%96%B9%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%BD%8D%E6%95%B0"><span class="nav-number">10.5.</span> <span class="nav-text">2017的2017 次方的最后一位数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25%E5%8C%B9%E9%A9%AC%EF%BC%8C5%E4%B8%AA%E8%B7%91%E9%81%93%EF%BC%8C%E6%9C%80%E5%B0%91%E6%AF%94%E5%A4%9A%E5%B0%91%E6%AC%A1%E8%83%BD%E6%AF%94%E5%87%BA%E5%89%8D3%E5%90%8D"><span class="nav-number">10.6.</span> <span class="nav-text">25匹马，5个跑道，最少比多少次能比出前3名</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/">
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="Back to top">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://timewait7.github.io/post/65a5b0d7.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java学习&面试 | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java学习&面试
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-07-19 13:58:30" itemprop="dateCreated datePublished" datetime="2025-07-19T13:58:30+08:00">2025-07-19</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>34k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>2:05</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><h3 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8"></a>Java 8</h3><h3 id="Java-11"><a href="#Java-11" class="headerlink" title="Java 11"></a>Java 11</h3><h3 id="Java-17"><a href="#Java-17" class="headerlink" title="Java 17"></a>Java 17</h3><h3 id="Java-21"><a href="#Java-21" class="headerlink" title="Java 21"></a>Java 21</h3><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h3><h4 id="和equals的区别"><a href="#和equals的区别" class="headerlink" title="==和equals的区别"></a><code>==</code>和<code>equals</code>的区别</h4><p><code>==</code> 用于比较基本数据类型的值或对象引用的内存地址，<code>equals</code> 用户比较对象内容。</p>
<h4 id="equals和hashCode为什么要同时重写"><a href="#equals和hashCode为什么要同时重写" class="headerlink" title="equals和hashCode为什么要同时重写"></a><code>equals</code>和<code>hashCode</code>为什么要同时重写</h4><ol>
<li>契约要求：对象相等性的一致性</li>
</ol>
<ul>
<li><p><strong><code>Object</code>类的规范</strong>明确规定：</p>
<blockquote>
<p>如果两个对象通过<code>equals()</code>方法比较是相等的，那么它们的<code>hashCode()</code><strong>必须</strong>返回相同的值。</p>
</blockquote>
</li>
<li><p>如果违反此契约，对象在基于哈希的集合中会出现不可预测的行为（如<code>HashMap</code>无法正确查找对象）。</p>
</li>
</ul>
<ol start="2">
<li>基于哈希的集合（如<code>HashMap</code>, <code>HashSet</code>）依赖<code>hashCode()</code>和<code>equals()</code>协同工作：</li>
</ol>
<ul>
<li><p><strong><code>hashCode()</code>定位桶（Bucket）</strong>：<br>集合首先调用<code>hashCode()</code>确定对象存储在哪个哈希桶中。</p>
</li>
<li><p><strong><code>equals()</code>确认唯一性</strong>：<br>在同一个桶内，再调用<code>equals()</code>检查对象是否真正相等（解决哈希冲突）。</p>
</li>
</ul>
<ol start="3">
<li><p>假设只重写了<code>equals()</code>但未重写<code>hashCode()</code>：</p>
<ul>
<li><p><strong>场景</strong>：两个对象<code>a</code>和<code>b</code>满足<code>a.equals(b) == true</code>，但<code>a.hashCode() != b.hashCode()</code>。</p>
</li>
<li><p><strong>问题</strong>：</p>
<ul>
<li>它们会被存入<code>HashMap</code>的<strong>不同桶</strong>中（因为哈希值不同，未重写的<code>hasoCode()</code>默认返回内存地址）。</li>
<li><code>map.put(a, val1)</code>和<code>map.put(b, val2)</code>会同时存在，违反<code>Map</code>的键唯一性。</li>
</ul>
</li>
<li><p>示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">// 重写equals但未重写hashCode</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    Set&lt;Person&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    set.add(p1);</span><br><span class="line">    set.add(p2);  <span class="comment">// p1.equals(p2)=true，但Set会存储两个对象！</span></span><br><span class="line">    System.out.println(set.size()); <span class="comment">// 输出2（错误，应为1）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>重写<code>hashCode()</code>需满足：</p>
<ul>
<li><strong>一致性</strong>：如果<code>a.equals(b)</code>，则<code>a.hashCode() == b.hashCode()</code>。</li>
<li><strong>稳定性</strong>：在对象状态不变时，多次调用<code>hashCode()</code>应返回相同值。</li>
<li><strong>高效性</strong>：尽量减少哈希冲突（不同对象尽量返回不同哈希值）。</li>
</ul>
<p><strong>推荐方法</strong>（使用<code>Objects.hash()</code>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(name, age); <span class="comment">// 包含所有equals中使用的字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="异常的层次结构"><a href="#异常的层次结构" class="headerlink" title="异常的层次结构"></a>异常的层次结构</h4><p><code>Throwable</code>：所有异常和错误的父类</p>
<p><code>Error</code>：</p>
<ul>
<li><strong>系统级严重问题</strong>，应用程序通常无法恢复</li>
<li>示例：<ul>
<li><code>OutOfMemoryError</code>：内存耗尽</li>
<li><code>StackOverflowError</code>：栈溢出</li>
<li><code>VirtualMachineError</code>：JVM致命错误</li>
</ul>
</li>
<li>❗ <strong>无需捕获处理</strong>（即使捕获也难以恢复）</li>
</ul>
<p><code>Exception</code>：</p>
<ol>
<li><ul>
<li><p><strong>程序可处理的异常</strong>，分为两类：</p>
<ul>
<li><p><strong>Checked Exceptions（受检异常）</strong><br>编译器强制要求处理（必须<code>try-catch</code>或<code>throws</code>）<br>✅ <strong>典型代表</strong>：<code>IOException</code>、<code>SQLException</code>、<code>ClassNotFoundException</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须处理IOException的示例</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Files.readString(Path.of(<span class="string">&quot;file.txt&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123; <span class="comment">// 必须捕获</span></span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>RuntimeException</code>（运行时异常&#x2F;非受检异常）</strong><br>编译器不强制处理，通常由<strong>编程逻辑错误</strong>引起<br>⚠️ <strong>典型代表</strong>：<code>NullPointerException</code>、<code>IndexOutOfBoundsException</code>、<code>IllegalArgumentException</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可选的运行时异常处理</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  System.out.println(str.length()); <span class="comment">// 抛出NullPointerException</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// 非强制捕获</span></span><br><span class="line">  System.out.println(<span class="string">&quot;逻辑错误！&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ol>
<img src="/post/65a5b0d7/image-20250720163023390.png" class="" title="image-20250720163023390">



<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="为什么需要泛型"><a href="#为什么需要泛型" class="headerlink" title="为什么需要泛型"></a>为什么需要泛型</h4><p>泛型（Generics）是现代编程语言（如 Java、C#、C++、TypeScript 等）中一项极其重要的特性，它的出现主要是为了解决<strong>代码复用</strong>、<strong>类型安全</strong>和<strong>可读性</strong>这三大核心问题。</p>
<p>📍 1. <strong>类型安全（Type Safety）</strong></p>
<ul>
<li><strong>问题：</strong> 在没有泛型之前（例如使用 Java 的 <code>Object</code> 或 C# 的 <code>object</code>），容器类（如集合 <code>List</code>、<code>Array</code>）可以存放任何类型的对象。当你从容器中取出对象时，你需要进行强制类型转换 (<code>(String) myList.get(0)</code>)。</li>
<li><strong>风险：</strong> 如果容器里不小心放入了错误的类型（比如你期望是 <code>String</code>，但实际放入了 <code>Integer</code>），这个错误在<strong>编译时不会被发现</strong>，只有在**运行时进行强制转换时才会抛出 <code>ClassCastException</code>**，导致程序崩溃。</li>
<li><strong>泛型解决方案：</strong> 泛型允许你在<strong>声明</strong>容器时就指定它只能存放特定类型（如 <code>List&lt;String&gt;</code>）。编译器会在<strong>编译时</strong>严格检查你放入容器的对象类型是否匹配。如果尝试放入错误类型，编译器会直接报错，阻止潜在的类型错误运行到生产环境。</li>
</ul>
<p>🔁 2. <strong>消除强制类型转换（Eliminating Casts）</strong></p>
<ul>
<li><strong>问题：</strong> 使用原始类型（非泛型）容器时，每次取出元素都需要进行显式的、冗长的、容易出错的强制类型转换。 *   <strong>泛型解决方案：</strong> 使用泛型容器（如 <code>List&lt;String&gt;</code>）后，当你从容器中获取元素时（如 <code>String s = myList.get(0);</code>），<strong>编译器会自动知道返回的是 <code>String</code> 类型，不需要任何强制转换</strong>。代码更简洁，更安全。</li>
</ul>
<p>♻ 3. <strong>代码复用（Code Reuse）</strong></p>
<ul>
<li><strong>问题：</strong> 编写一个算法（比如排序、搜索、比较），你希望它能作用于多种不同类型的对象（整数、字符串、自定义对象等）。没有泛型时，你需要为每种类型重写算法，或者使用 <code>Object</code> 并伴随类型检查和转换。</li>
<li><strong>泛型解决方案：</strong> 泛型允许你编写<strong>类型无关的算法</strong>。你可以定义一个操作在类型参数 <code>T</code> 上的方法或类（例如 <code>public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code>）。只要类型 <code>T</code> 满足算法所需的基本条件（比如实现了 <code>Comparable</code> 接口），同一个算法代码就可以安全地应用于各种不同的数据类型。</li>
</ul>
<p>📖 4. <strong>提高代码可读性和可维护性（Improved Readability &amp; Maintainability）</strong></p>
<ul>
<li><strong>问题：</strong> 使用原始类型或 <code>Object</code>，代码的意图变得模糊。阅读代码的人需要仔细查看上下文（或者注释）才能理解某个容器预期存放什么类型的数据。</li>
<li><strong>泛型解决方案：</strong> 泛型声明（如 <code>Map&lt;String, Customer&gt;</code>）本身就是<strong>清晰、自文档化的代码</strong>。它明确地告诉开发者和编译器：这个容器是做什么用的（存储键为 <code>String</code>、值为 <code>Customer</code> 的映射）。这使得代码更容易理解、维护和调试。</li>
</ul>
<h4 id="什么是泛型擦除"><a href="#什么是泛型擦除" class="headerlink" title="什么是泛型擦除"></a>什么是泛型擦除</h4><p>泛型擦除（Type Erasure）是 <strong>Java 泛型实现的核心机制</strong>，它指编译器在编译阶段<strong>移除所有泛型类型信息</strong>，将其替换为原始类型（Raw Type）或边界类型（Bound Type），并在必要时插入强制类型转换。这一设计主要是为了<strong>兼容旧版本的 Java（JDK 5 之前）</strong>，确保泛型代码能与非泛型遗留代码互操作。</p>
<p><strong>一、泛型擦除的核心规则</strong></p>
<ol>
<li><p><strong>类型参数替换为边界类型</strong></p>
<ul>
<li>若类型参数有上限（如 <code>&lt;T extends Number&gt;</code>），<code>T</code> 被替换为<strong>边界类型</strong>（<code>Number</code>）。</li>
<li>若无明确上限（如 <code>&lt;T&gt;</code>），<code>T</code> 被替换为 **<code>Object</code>**。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123; <span class="built_in">this</span>.value = value; &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后（擦除后）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object value;         <span class="comment">// T → Object</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Object value)</span> &#123; <span class="built_in">this</span>.value = value; &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> value; &#125; <span class="comment">// 返回 Object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在调用处插入强制类型转换</strong><br>编译器在<strong>使用泛型的地方</strong>自动添加类型转换代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line">Box&lt;String&gt; box = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();</span><br><span class="line">box.set(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> box.get(); <span class="comment">// 无需显式转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后（擦除后）</span></span><br><span class="line"><span class="type">Box</span> <span class="variable">box</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Box</span>();</span><br><span class="line">box.set(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) box.get(); <span class="comment">// 编译器插入 (String) 强制转换</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>保证类型安全的桥接方法（Bridge Methods）</strong><br>当泛型类继承或实现接口时，编译器会生成<strong>合成方法</strong>确保多态性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T other)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String other)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后（擦除后）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="comment">// 编译器生成的桥接方法（保持多态）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object other)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> compareTo((String) other); <span class="comment">// 调用实际方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际编写的泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String other)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>二、泛型擦除导致的关键限制</strong></p>
<ol>
<li><p><strong>无法使用基本类型作为类型参数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 编译错误！不能使用 int</span></span><br><span class="line">List&lt;<span class="type">int</span>&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br><span class="line"><span class="comment">// 必须使用包装类</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>无法获取泛型具体类型的 <code>Class</code> 对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// ❌ 编译错误！List&lt;String&gt;.class 不存在</span></span><br><span class="line">Class&lt;?&gt; clazz = list.getClass(); </span><br><span class="line"><span class="comment">// 输出：java.util.ArrayList（无法得知是 List&lt;String&gt;）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>无法使用 <code>instanceof</code> 检查泛型类型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (list <span class="keyword">instanceof</span> List&lt;String&gt;) &#123; ... &#125; <span class="comment">// ❌ 编译错误！</span></span><br><span class="line"><span class="keyword">if</span> (list <span class="keyword">instanceof</span> List&lt;?&gt;) &#123; ... &#125;      <span class="comment">// ✅ 允许（但无具体类型信息）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>无法创建泛型数组</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 编译错误！</span></span><br><span class="line">T[] array = <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">10</span>]; </span><br><span class="line"><span class="comment">// 替代方案：使用反射或 ArrayList</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>方法签名冲突（重载失效）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 编译错误！擦除后都是 void print(List list)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;String&gt; list)</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;Integer&gt; list)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>三、为什么 Java 选择泛型擦除？</strong></p>
<ol>
<li><strong>向后兼容性（Backward Compatibility）</strong><ul>
<li>确保 JDK 5+ 的泛型代码能运行在旧 JVM（1.4 或更早）上。</li>
<li>非泛型集合（如 <code>ArrayList</code>）和泛型集合（<code>ArrayList&lt;String&gt;</code>）在 JVM 层面都是同一个类。</li>
</ul>
</li>
<li><strong>运行时效率（Runtime Efficiency）</strong><ul>
<li>不需要为每种泛型组合生成新的类（如 C# 的泛型实现），节省内存。</li>
<li>JVM 无需修改即可支持泛型（仅编译器层处理）。</li>
</ul>
</li>
</ol>
<p><strong>四、如何绕过擦除的限制？</strong></p>
<ol>
<li><p><strong>类型令牌（Type Token）</strong><br>通过传递 <code>Class&lt;T&gt;</code> 对象保留类型信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Box</span><span class="params">(Class&lt;T&gt; type)</span> &#123; <span class="built_in">this</span>.type = type; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInstance</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type.isInstance(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>反射 API（Reflection）</strong><br>运行时获取泛型参数（需接口&#x2F;父类保留信息）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> myList.getClass().getGenericSuperclass();</span><br><span class="line"><span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">    <span class="type">Type</span> <span class="variable">actualType</span> <span class="operator">=</span> ((ParameterizedType)type).getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">    System.out.println(actualType); <span class="comment">// 输出如 String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>五、与其他语言泛型实现的对比</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>语言</strong></th>
<th align="left"><strong>泛型实现</strong></th>
<th align="left"><strong>运行时类型保留</strong></th>
<th align="left"><strong>特点</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">Java</td>
<td align="left">类型擦除</td>
<td align="left">❌</td>
<td align="left">兼容旧版，效率高</td>
</tr>
<tr>
<td align="left">C#</td>
<td align="left">具现化（Reified）</td>
<td align="left">✅</td>
<td align="left">运行时保留类型，支持泛型数组</td>
</tr>
<tr>
<td align="left">Kotlin</td>
<td align="left">擦除（JVM上）</td>
<td align="left">❌</td>
<td align="left">通过 <code>inline</code> + <code>reified</code> 绕过限制</td>
</tr>
<tr>
<td align="left">TypeScript</td>
<td align="left">编译时擦除</td>
<td align="left">❌</td>
<td align="left">仅静态类型检查</td>
</tr>
</tbody></table>
<p><strong>总结</strong></p>
<ul>
<li><strong>泛型擦除的本质</strong>：编译器移除泛型类型信息，替换为原始类型（<code>Object</code> 或边界类型），并在使用点插入强制转换。</li>
<li><strong>优点</strong>：无缝兼容旧代码，运行时效率高。</li>
<li><strong>代价</strong>：运行时无法获取泛型类型信息，导致部分操作受限（如 <code>instanceof</code>、泛型数组）。</li>
<li><strong>应对</strong>：通过类型令牌、反射或设计模式（如工厂）绕过限制。</li>
</ul>
<p>泛型擦除是 Java 在兼容性与类型安全之间的折衷方案，理解其原理能帮助你写出更健壮的泛型代码！</p>
<h4 id="泛型的上下限及应用场景"><a href="#泛型的上下限及应用场景" class="headerlink" title="泛型的上下限及应用场景"></a>泛型的上下限及应用场景</h4><p>泛型的<strong>上限（Upper Bound）</strong> 和<strong>下限（Lower Bound）</strong> 是用于<strong>约束类型参数范围</strong>的关键机制，主要解决泛型代码需要<strong>限制可接受的类型</strong>或<strong>支持更灵活的子类型关系</strong>的问题。以下是详细解释：</p>
<p><strong>一、泛型的上限（Upper Bound）</strong></p>
<p>定义：限制类型参数必须是<strong>某个类&#x2F;接口本身或其子类</strong>。<br>语法：<code>&lt;T extends 类/接口&gt;</code> 或 <code>&lt;? extends 类/接口&gt;</code>（通配符形式）。</p>
<p><strong>核心作用</strong></p>
<ol>
<li><p><strong>确保类型具备某些能力</strong><br>要求类型 <code>T</code> 必须实现特定接口（如 <code>Comparable</code>）或继承特定类，从而在泛型代码中安全调用其方法。<br><strong>示例</strong>：要求类型必须可比较</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T 必须是实现了 Comparable 接口的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; T <span class="title function_">max</span><span class="params">(T a, T b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.compareTo(b) &gt; <span class="number">0</span> ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可安全调用 a.compareTo(b)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安全访问数据（只读不写）</strong><br>在通配符 <code>? extends T</code> 中，表示“某个 <code>T</code> 的子类型”，此时容器<strong>只能读取数据</strong>（返回 <code>T</code> 类型），<strong>不能写入数据</strong>（除 <code>null</code> 外）。<br><strong>示例</strong>：安全读取数字集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">printNumbers</span><span class="params">(List&lt;? extends Number&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Number n : list) &#123;</span><br><span class="line">        System.out.println(n);  <span class="comment">// ✅ 可读</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// list.add(10); ❌ 编译错误！无法写入（除 null 外）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>典型场景</strong></p>
<ul>
<li>定义泛型类&#x2F;方法时，约束类型参数的能力（如 <code>T extends Runnable</code>）。</li>
<li>作为方法参数时，安全接收<strong>某种子类型的集合</strong>（生产者场景）。</li>
</ul>
<p><strong>二、泛型的下限（Lower Bound）</strong></p>
<p>定义：限制类型参数必须是<strong>某个类&#x2F;接口本身或其父类</strong>。<br>语法：<code>&lt;? super 类/接口&gt;</code>（仅通配符形式）。</p>
<p><strong>核心作用</strong></p>
<ol>
<li><p><strong>支持安全写入数据</strong><br>表示“某个 <code>T</code> 的父类型”，此时容器<strong>可以写入 <code>T</code> 及其子类型对象</strong>，但读取时只能视为 <code>Object</code>。<br><strong>示例</strong>：向集合添加元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addNumbers</span><span class="params">(List&lt;? <span class="built_in">super</span> Integer&gt; list)</span> &#123;</span><br><span class="line">    list.add(<span class="number">10</span>);     <span class="comment">// ✅ 可写入 Integer</span></span><br><span class="line">    list.add(<span class="number">1000L</span>);  <span class="comment">// ❌ 错误！Long 不是 Integer 的子类</span></span><br><span class="line">    <span class="comment">// Object obj = list.get(0);  // 读取时只能视为 Object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>实现灵活的子类型兼容</strong><br>允许方法接收比预期更宽泛的容器（如需要 <code>List&lt;Number&gt;</code> 时，也可传入 <code>List&lt;Object&gt;</code>）。</p>
</li>
</ol>
<p><strong>典型场景</strong></p>
<ul>
<li><p>向泛型容器<strong>写入数据</strong>（消费者场景）。</p>
</li>
<li><p>配合 <code>Comparator</code> 等接口实现类型灵活的API：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可接收 Person 或其父类的 Comparator</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;Person&gt; list, Comparator&lt;? <span class="built_in">super</span> Person&gt; comparator)</span> &#123;</span><br><span class="line">    Collections.sort(list, comparator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>三、关键对比：<code>extends</code> vs <code>super</code></strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>上限 (<code>? extends T</code>)</strong></th>
<th align="left"><strong>下限 (<code>? super T</code>)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>类型范围</strong></td>
<td align="left"><code>T</code> 或其<strong>子类型</strong></td>
<td align="left"><code>T</code> 或其<strong>父类型</strong></td>
</tr>
<tr>
<td align="left"><strong>数据读取</strong></td>
<td align="left">✅ 返回 <code>T</code> 类型</td>
<td align="left">❌ 只能视为 <code>Object</code></td>
</tr>
<tr>
<td align="left"><strong>数据写入</strong></td>
<td align="left">❌ 禁止（除 <code>null</code>）</td>
<td align="left">✅ 可写入 <code>T</code> <strong>及其子类</strong></td>
</tr>
<tr>
<td align="left"><strong>设计意图</strong></td>
<td align="left"><strong>生产者</strong>（Producer）只提供数据</td>
<td align="left"><strong>消费者</strong>（Consumer）只消费数据</td>
</tr>
<tr>
<td align="left"><strong>经典口诀</strong></td>
<td align="left"><strong>PECS</strong> (Producer-Extends, Consumer-Super)</td>
<td align="left"></td>
</tr>
</tbody></table>
<p><strong>四、实际应用：PECS 原则</strong></p>
<p>在泛型编程中，遵循 <strong>PECS（Producer-Extends, Consumer-Super）</strong> 原则：</p>
<ul>
<li><strong>生产者（Producer）</strong>：产生 <code>T</code> 的对象 → 用 <code>&lt;? extends T&gt;</code></li>
<li><strong>消费者（Consumer）</strong>：消费 <code>T</code> 的对象 → 用 <code>&lt;? super T&gt;</code></li>
</ul>
<p><strong>示例</strong>：Java 集合工具类 <code>Collections.copy()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(</span></span><br><span class="line"><span class="params">    List&lt;? <span class="built_in">super</span> T&gt; dest,    // 消费者：写入目标集合</span></span><br><span class="line"><span class="params">    List&lt;? extends T&gt; src    // 生产者：读取源集合</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; src.size(); i++) &#123;</span><br><span class="line">        dest.set(i, src.get(i));  <span class="comment">// ✅ 安全读写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>五、使用场景总结</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>场景</strong></th>
<th align="left"><strong>推荐语法</strong></th>
<th align="left"><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">需要调用类型特定方法</td>
<td align="left"><code>&lt;T extends Interface&gt;</code></td>
<td align="left"><code>T</code> 必须实现某个接口</td>
</tr>
<tr>
<td align="left">安全读取泛型集合内容</td>
<td align="left"><code>&lt;? extends T&gt;</code></td>
<td align="left">遍历 <code>List&lt;? extends Number&gt;</code></td>
</tr>
<tr>
<td align="left">安全写入泛型集合</td>
<td align="left"><code>&lt;? super T&gt;</code></td>
<td align="left">向 <code>List&lt;? super Integer&gt;</code> 添加值</td>
</tr>
<tr>
<td align="left">同时支持读写</td>
<td align="left">使用确定的类型参数 <code>T</code></td>
<td align="left"><code>List&lt;T&gt;</code></td>
</tr>
</tbody></table>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h4 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h4><p>在程序运行期间，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 Java 的反射机制。</p>
<h4 id="反射的优缺点"><a href="#反射的优缺点" class="headerlink" title="反射的优缺点"></a>反射的优缺点</h4><ul>
<li><strong>优点：</strong><ul>
<li><strong>动态性：</strong> 运行时才确定类型、绑定对象，极大提高了程序的灵活性和扩展性。是框架设计的基石（如 Spring 的 IOC）。</li>
<li><strong>灵活性：</strong> 可以访问和操作私有成员（通过 <code>setAccessible(true)</code>），突破封装限制（需谨慎）。</li>
<li><strong>通用性：</strong> 可以编写非常通用的代码（如通用序列化&#x2F;反序列化工具、对象比较工具、动态代理等）。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li><strong>性能开销：</strong> 反射操作比直接调用慢很多。因为涉及动态类型解析、方法查找、安全检查等。JVM 难以对其优化。</li>
<li><strong>安全隐患：</strong> 可以破坏封装性（访问 private 成员），可能引发安全问题。需要额外的安全管理策略。</li>
<li><strong>代码复杂性：</strong> 反射代码通常比直接代码更复杂、可读性更差、更难维护。</li>
<li><strong>内部暴露：</strong> 可能暴露类的内部实现细节，破坏抽象。</li>
</ul>
</li>
</ul>
<h4 id="如何获取一个类的-Class-对象"><a href="#如何获取一个类的-Class-对象" class="headerlink" title="如何获取一个类的 Class 对象"></a>如何获取一个类的 <code>Class</code> 对象</h4><ol>
<li><code>Class clazz = Object.getClass();</code> (通过对象实例获取)</li>
<li><code>Class clazz = ClassName.class;</code> (通过类字面常量 <code>.class</code> 获取)</li>
<li><code>Class clazz = Class.forName(&quot;fully.qualified.ClassName&quot;);</code> (通过完整类名字符串获取，常用，可能抛出 <code>ClassNotFoundException</code>)</li>
<li>(对于基本类型和数组) <code>Class clazz = int.class;</code> &#x2F; <code>Class clazz = String[].class;</code></li>
</ol>
<h4 id="如何通过反射创建一个类的实例"><a href="#如何通过反射创建一个类的实例" class="headerlink" title="如何通过反射创建一个类的实例"></a>如何通过反射创建一个类的实例</h4><ol>
<li><p><strong>使用 <code>Class.newInstance()</code>（已过时）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) clazz.newInstance(); <span class="comment">// 调用无参构造器</span></span><br></pre></td></tr></table></figure>

<p>只能调用无参构造器；在 Java 9 开始被标记为 <code>@Deprecated(since=&quot;9&quot;)</code>，推荐使用 <code>Constructor.newInstance()</code>。</p>
</li>
<li><p><strong>使用 <code>Constructor.newInstance()</code> (推荐)：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getConstructor(String.class, <span class="type">int</span>.class); <span class="comment">// 获取特定参数类型的构造器</span></span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) constructor.newInstance(<span class="string">&quot;arg1&quot;</span>, <span class="number">42</span>); <span class="comment">// 传入参数创建实例</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="反射有哪些实际应用场景"><a href="#反射有哪些实际应用场景" class="headerlink" title="反射有哪些实际应用场景"></a>反射有哪些实际应用场景</h4><ul>
<li><strong>框架开发：</strong> 是几乎所有 Java 框架的核心（如 Spring, Hibernate, MyBatis, JUnit）。<ul>
<li><strong>Spring IOC：</strong> 通过反射读取配置（XML 或注解），动态创建 Bean 实例，注入依赖。</li>
<li><strong>Spring AOP：</strong> 动态代理（JDK Proxy 或 CGLIB）底层依赖反射调用目标方法。</li>
<li><strong>Hibernate&#x2F;MyBatis：</strong> 将数据库结果集映射到 Java 对象时，通过反射设置对象的属性值。</li>
</ul>
</li>
<li><strong>注解处理：</strong> 在运行时通过反射读取类、方法、字段上的注解信息，并根据注解执行特定逻辑（如 JUnit 查找 <code>@Test</code> 方法）。</li>
<li><strong>动态代理：</strong> JDK 动态代理 (<code>java.lang.reflect.Proxy</code>) 的核心就是利用反射调用被代理对象的方法。</li>
<li><strong>通用工具库：</strong> 如 Apache Commons BeanUtils, Jackson&#x2F;Gson (JSON 序列化&#x2F;反序列化)，通过反射操作对象的属性。</li>
<li><strong>IDE 和开发工具：</strong> 代码提示、调试器、反编译工具等利用反射获取类的结构信息。</li>
</ul>
<h4 id="Class-forName-和-ClassLoader-loadClass-有什么区别"><a href="#Class-forName-和-ClassLoader-loadClass-有什么区别" class="headerlink" title="Class.forName() 和 ClassLoader.loadClass() 有什么区别"></a><strong><code>Class.forName()</code> 和 <code>ClassLoader.loadClass()</code> 有什么区别</strong></h4><ul>
<li>**<code>Class.forName(String name)</code>**：<ul>
<li>默认会触发类的<strong>加载、链接（验证、准备）、初始化</strong>（执行 <code>&lt;clinit&gt;</code> 静态初始化块）。</li>
<li>有一个重载方法 <code>Class.forName(String name, boolean initialize, ClassLoader loader)</code> 可以控制是否初始化 (<code>initialize</code>) 和指定类加载器 (<code>loader</code>)。</li>
</ul>
</li>
<li>**<code>ClassLoader.loadClass(String name)</code>**：<ul>
<li>只触发类的<strong>加载</strong>和<strong>链接（验证、准备）</strong> 阶段，<strong>不会执行初始化</strong> (<code>&lt;clinit&gt;</code>)。只有首次主动使用时（如创建实例、访问静态字段&#x2F;方法）才会初始化。</li>
</ul>
</li>
<li><strong>考察点：</strong> 理解类加载过程的阶段（加载 -&gt; 链接（验证、准备、解析） -&gt; 初始化），以及这两个关键方法在触发类加载行为上的差异。知道 <code>forName</code> 默认会初始化类，而 <code>loadClass</code> 不会。</li>
</ul>
<h4 id="如何防止反射破坏单例模式"><a href="#如何防止反射破坏单例模式" class="headerlink" title="如何防止反射破坏单例模式"></a><strong>如何防止反射破坏单例模式</strong></h4><ul>
<li><p><strong>问题：</strong> 标准的饿汉式或懒汉式（非枚举）单例，其私有构造器可以通过反射的 <code>setAccessible(true)</code> 被访问，从而创建多个实例。</p>
</li>
<li><p><strong>防御方法：</strong></p>
<ul>
<li><p><strong>在构造器中检查：</strong> 如果实例已存在，则在私有构造器中抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Singleton instance already created&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用枚举实现单例 (推荐)：</strong> 枚举的单例实现是《Effective Java》作者 Josh Bloch 强烈推荐的方式。JVM 从根本上保证了枚举类型的构造器只会被调用一次，且反射 API 被设计为<strong>不能通过反射创建枚举实例</strong>（<code>Constructor.newInstance()</code> 方法内部会检查并阻止）。这是最安全、简洁的方式。</p>
</li>
</ul>
</li>
</ul>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><h4 id="Java中都有哪些元注解"><a href="#Java中都有哪些元注解" class="headerlink" title="Java中都有哪些元注解"></a>Java中都有哪些元注解</h4><table>
<thead>
<tr>
<th align="left">元注解</th>
<th align="left">作用域</th>
<th align="left">主要用途</th>
<th align="left">Java 版本</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>@Target</code></strong></td>
<td align="left">注解</td>
<td align="left">指定注解可应用的程序元素（类、方法、字段等）</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left"><strong><code>@Retention</code></strong></td>
<td align="left">注解</td>
<td align="left">指定注解的保留策略（源码、类文件、运行时）</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left"><strong><code>@Documented</code></strong></td>
<td align="left">注解</td>
<td align="left">指示注解应包含在 Javadoc 中</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left"><strong><code>@Inherited</code></strong></td>
<td align="left">注解</td>
<td align="left">指示注解具有继承性（仅对类注解有效）</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left"><strong><code>@Repeatable</code></strong></td>
<td align="left">注解</td>
<td align="left">允许同一注解在单个元素上重复使用（需配合容器注解）</td>
<td align="left"><strong>8</strong></td>
</tr>
<tr>
<td align="left"><strong><code>@Native</code></strong></td>
<td align="left">字段</td>
<td align="left">标记可能被本机代码引用的常量字段（主要在 JDK 内部使用）</td>
<td align="left"><strong>8</strong></td>
</tr>
</tbody></table>
<h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><p><strong>SPI</strong> 是 Java 提供的一种<strong>服务发现机制</strong>，通过<strong>接口与实现解耦</strong>实现动态扩展。核心流程如下：</p>
<ol>
<li><strong>定义服务接口</strong>（如 <code>PaymentService</code>）</li>
<li><strong>提供实现类</strong>（如 <code>AlipayService</code>, <code>WechatPayService</code>）</li>
<li><strong>注册实现</strong>：在 <code>META-INF/services/</code> 下创建以接口全限定名命名的文件，写入实现类全限定名</li>
<li><strong>动态加载</strong>：通过 <code>ServiceLoader</code> 加载所有注册的实现</li>
</ol>
<p><strong>优势：</strong></p>
<ul>
<li><strong>开闭原则</strong>：新增实现无需修改核心代码</li>
<li><strong>解耦</strong>：接口与实现分离</li>
<li><strong>可插拔</strong>：通过配置文件动态替换实现</li>
</ul>
<p><strong>Java SPI 完整 Demo</strong></p>
<ol>
<li>定义服务接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PaymentService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">double</span> amount)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>实现服务接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AlipayService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AlipayService</span> <span class="keyword">implements</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[支付宝] 支付: ¥&quot;</span> + amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WechatPayService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WechatPayService</span> <span class="keyword">implements</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[微信支付] 支付: ¥&quot;</span> + amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>注册服务实现</li>
</ol>
<p>创建资源文件：<br><code>src/main/resources/META-INF/services/com.example.PaymentService</code><br>内容：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.example.AlipayService</span><br><span class="line">com.example.WechatPayService</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用 SPI 加载服务</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPIDemo.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.ServiceLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SPIDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 加载所有 PaymentService 实现</span></span><br><span class="line">        ServiceLoader&lt;PaymentService&gt; services = </span><br><span class="line">            ServiceLoader.load(PaymentService.class);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;=== 发现 &quot;</span> + getServiceCount(services) + <span class="string">&quot; 个支付服务 ===&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用所有实现</span></span><br><span class="line">        <span class="keyword">for</span> (PaymentService service : services) &#123;</span><br><span class="line">            service.pay(<span class="number">100.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getServiceCount</span><span class="params">(ServiceLoader&lt;PaymentService&gt; services)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (PaymentService ignored : services) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>项目结构</li>
</ol>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">├── main/</span><br><span class="line">│   ├── java/</span><br><span class="line">│   │   ├── com/example/</span><br><span class="line">│   │   │   ├── PaymentService.java</span><br><span class="line">│   │   │   ├── AlipayService.java</span><br><span class="line">│   │   │   ├── WechatPayService.java</span><br><span class="line">│   │   │   └── SPIDemo.java</span><br><span class="line">│   │</span><br><span class="line">│   └── resources/</span><br><span class="line">│       └── META-INF/services/</span><br><span class="line">│           └── com.example.PaymentService  &lt;-- 关键配置文件</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>运行结果</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">=== 发现 2 个支付服务 ===</span><br><span class="line">[支付宝] 支付: ¥100.0</span><br><span class="line">[微信支付] 支付: ¥100.0</span><br></pre></td></tr></table></figure>

<p><strong>关键点解析：</strong></p>
<ol>
<li><strong>配置文件路径</strong>：<code>META-INF/services/接口全限定名</code></li>
<li><strong>文件内容</strong>：实现类的全限定名（每行一个）</li>
<li><strong>ServiceLoader</strong>：核心加载工具，实现懒加载</li>
<li><strong>迭代顺序</strong>：按配置文件中定义的顺序加载</li>
</ol>
<p><strong>实际应用场景：</strong></p>
<ul>
<li>JDBC 驱动加载（<code>DriverManager</code>）</li>
<li>日志门面（SLF4J）</li>
<li>序列化框架（Jackson）</li>
<li>Spring Boot 自动配置</li>
</ul>
<blockquote>
<p>通过 SPI 机制，Java 实现了真正的面向接口编程，使系统具备高度可扩展性，符合「开闭原则」。</p>
</blockquote>
<h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><h3 id="集合基础"><a href="#集合基础" class="headerlink" title="集合基础"></a>集合基础</h3><p>Java 集合框架主要包括 <code>Collection</code> 和 <code>Map</code> 两大接口体系。<code>Collection</code> 主要有 <code>List</code>、<code>Set</code>、<code>Queue</code> 几个核心子接口。</p>
<h4 id="Iterator-和-ListIterator-的区别"><a href="#Iterator-和-ListIterator-的区别" class="headerlink" title="Iterator 和 ListIterator 的区别"></a><strong><code>Iterator</code> 和 <code>ListIterator</code> 的区别</strong></h4><ul>
<li><code>Iterator</code>：通用迭代器接口。提供 <code>hasNext()</code>, <code>next()</code>, <code>remove()</code> 方法。只能<strong>单向</strong>遍历 (<code>Collection</code> 接口使用)。</li>
<li><code>ListIterator</code>：继承 <code>Iterator</code>。专门用于 <code>List</code>。额外提供：<ul>
<li><strong>双向遍历</strong>：<code>hasPrevious()</code>, <code>previous()</code>。</li>
<li><strong>获取索引</strong>：<code>nextIndex()</code>, <code>previousIndex()</code>。</li>
<li><strong>修改元素</strong>：<code>set(E e)</code> (替换上次调用 <code>next()</code> 或 <code>previous()</code> 返回的元素)。</li>
<li><strong>添加元素</strong>：<code>add(E e)</code> (在当前游标位置插入元素)。</li>
</ul>
</li>
<li><code>ListIterator</code> 功能更强大，但只能用于 <code>List</code> 及其实现类。</li>
</ul>
<h4 id="什么是-fail-fast-机制"><a href="#什么是-fail-fast-机制" class="headerlink" title="什么是 fail-fast 机制"></a><strong>什么是 <code>fail-fast</code> 机制</strong></h4><ul>
<li>一种<strong>错误检测机制</strong>。当使用迭代器 (<code>Iterator</code>) 遍历集合时，如果<strong>在遍历过程中（除了通过迭代器自身的 <code>remove()</code> 方法外）对集合结构进行了修改</strong>（添加、删除元素），则会立即抛出 <code>ConcurrentModificationException</code>。</li>
<li><strong>实现原理</strong>：集合内部维护一个 <code>modCount</code> (修改计数器)。创建迭代器时，会将当前的 <code>modCount</code> 记录为 <code>expectedModCount</code>。在迭代过程中，每次调用 <code>next()</code>、<code>remove()</code> 等方法前都会检查 <code>modCount == expectedModCount</code>。如果不相等，说明有其他线程或本线程其他操作修改了集合结构，抛出异常。</li>
<li><strong>目的</strong>：快速失败，避免在不确定状态下继续操作导致更难以预料的结果。<strong>它不能保证并发修改一定被检测到，主要用于单线程环境下的错误检测</strong>。</li>
</ul>
<h4 id="fail-fast-和-fail-safe-的区别"><a href="#fail-fast-和-fail-safe-的区别" class="headerlink" title="fail-fast 和 fail-safe 的区别"></a><strong><code>fail-fast</code> 和 <code>fail-safe</code> 的区别</strong></h4><ul>
<li><strong><code>fail-fast</code><strong>：直接在原集合上操作。迭代时检测到并发修改就</strong>立即抛异常</strong>。代表：<code>ArrayList</code>, <code>HashMap</code> 等非并发集合的迭代器。</li>
<li><strong><code>fail-safe</code> (Concurrent Modification Tolerance)<strong>：</strong>不在原集合上操作</strong>，而是基于原集合的<strong>快照 (snapshot)</strong> 或 <strong>只读视图</strong> 进行迭代。迭代过程中原集合的修改不会影响迭代器，不会抛异常。代表：<code>ConcurrentHashMap</code>, <code>CopyOnWriteArrayList</code> 的迭代器。</li>
<li><strong>注意</strong>：<code>java.util.concurrent</code> 包下的集合通常采用 <strong>弱一致性 (Weakly Consistent)</strong> 迭代器，它提供 <code>fail-safe</code> 行为，但不保证迭代器看到所有修改。</li>
</ul>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a><code>List</code></h3><h4 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a><code>ArrayList</code>的扩容机制</h4><ul>
<li>使用 <code>Object[] elementData</code> 存储元素。</li>
<li>创建时如果未指定大小，初始容量为 <strong>0</strong> (JDK 1.8+) 或 <strong>10</strong> (旧版本，需确认具体版本)，第一次添加元素时扩容到 <strong>10</strong>。</li>
<li>当添加元素时发现容量不足（<code>size + 1 &gt; elementData.length</code>），触发扩容。</li>
<li>新容量 &#x3D; <code>ArraysSupport.newLength(oldCapacity, minCapacity - oldCapacity, oldCapacity &gt;&gt; 1)</code>，即计算新容量为 <code>oldCapacity + max(需要的最小增量, oldCapacity / 2)</code>，简单理解通常是 <strong>原容量的1.5倍</strong>。</li>
<li>创建一个新的更大的数组，将旧数组元素<strong>复制</strong>到新数组。</li>
</ul>
<h4 id="Vector-和-ArrayList-的区别"><a href="#Vector-和-ArrayList-的区别" class="headerlink" title="Vector 和 ArrayList 的区别"></a><code>Vector</code> 和 <code>ArrayList</code> 的区别</h4><ul>
<li><strong>线程安全</strong>：<ul>
<li><code>Vector</code>：<strong>线程安全</strong>。关键方法使用 <code>synchronized</code> 修饰，性能较低。</li>
<li><code>ArrayList</code>：<strong>非线程安全</strong>。性能更高。</li>
</ul>
</li>
<li><strong>扩容机制</strong>：<ul>
<li><code>Vector</code>：默认扩容为原来的 <strong>2倍</strong>，可通过构造函数指定扩容增量。</li>
<li><code>ArrayList</code>：默认扩容为原来的 <strong>1.5倍</strong> (<code>(oldCapacity * 3)/2 + 1</code>)。</li>
</ul>
</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a><code>Set</code></h3><h4 id="HashSet、LinkedHashSet-和-TreeSet-的区别"><a href="#HashSet、LinkedHashSet-和-TreeSet-的区别" class="headerlink" title="HashSet、LinkedHashSet 和 TreeSet 的区别"></a><strong><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的区别</strong></h4><ul>
<li><strong>底层实现</strong>：<ul>
<li><code>HashSet</code>：基于 <strong><code>HashMap</code></strong> (只需 Key，Value 用常量 <code>PRESENT</code> 填充)。</li>
<li><code>LinkedHashSet</code>：继承自 <code>HashSet</code>，基于 **<code>LinkedHashMap</code>**。</li>
<li><code>TreeSet</code>：基于 <strong><code>TreeMap</code></strong> (红黑树)。</li>
</ul>
</li>
<li><strong>元素顺序</strong>：<ul>
<li><code>HashSet</code>：<strong>无序</strong> (不保证插入顺序或恒久不变)。</li>
<li><code>LinkedHashSet</code>：<strong>按元素插入顺序排序</strong> (双向链表维护插入次序)。</li>
<li><code>TreeSet</code>：<strong>按元素的自然顺序 (<code>Comparable</code>) 或指定的 <code>Comparator</code> 排序</strong>。</li>
</ul>
</li>
<li><strong>性能</strong>：<ul>
<li><code>HashSet</code>&#x2F;<code>LinkedHashSet</code>：添加、删除、查找 <strong>O(1)</strong> (平均情况)。</li>
<li><code>TreeSet</code>：添加、删除、查找 **O(log n)**。</li>
</ul>
</li>
<li><strong>元素要求</strong>：<ul>
<li><code>HashSet</code>&#x2F;<code>LinkedHashSet</code>：元素必须正确实现 <code>equals()</code> 和 <code>hashCode()</code>。</li>
<li><code>TreeSet</code>：元素必须实现 <code>Comparable</code> 接口或在构造时传入 <code>Comparator</code>。</li>
</ul>
</li>
<li><strong>线程安全</strong>：三者都<strong>非线程安全</strong>。</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a><code>Map</code></h3><h4 id="HashMap-的底层实现原理"><a href="#HashMap-的底层实现原理" class="headerlink" title="HashMap 的底层实现原理"></a><strong><code>HashMap</code> 的底层实现原理</strong></h4><p><strong>JDK7：数组 + 链表</strong></p>
<ul>
<li><strong>扩容</strong>：创建新数组 (通常是原数组长度的 <strong>2倍</strong>)，遍历所有元素，<strong>重新计算每个元素在新数组中的位置</strong> (<code>rehash</code>)，将元素转移到新数组。<strong>头插法会导致扩容时链表元素顺序反转</strong>。</li>
</ul>
<p><strong>JDK8：数组 + 链表 &#x2F; 红黑树</strong></p>
<p><strong>主要改进</strong>：</p>
<ul>
<li><strong>尾插法</strong>：解决 JDK7 头插法多线程下可能导致死循环的问题（未解决线程安全问题）。</li>
<li><strong>链表转红黑树</strong>：当链表长度 <strong>&gt;&#x3D; 8 (TREEIFY_THRESHOLD)</strong> 且 <strong>数组长度 &gt;&#x3D; 64 (MIN_TREEIFY_CAPACITY)</strong> 时，链表转换为红黑树，提高长链表的查找效率 (O(n) -&gt; O(log n))。</li>
<li><strong>优化哈希算法</strong>：<code>(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，高位参与运算，减少哈希冲突。</li>
<li><strong>扩容</strong>：根据 <code>(e.hash &amp; oldCap) == 0</code> 将链表拆分成两个子链表，结果为 0 的节点保持原索引位置 <code>i</code>，结果不为 0 的节点放到新位置 <code>i + oldCap</code>，避免全量 <code>rehash</code>，提升了效率。</li>
</ul>
<h4 id="HashMap-和-HashTable-的区别"><a href="#HashMap-和-HashTable-的区别" class="headerlink" title="HashMap 和 HashTable 的区别"></a><strong><code>HashMap</code> 和 <code>HashTable</code> 的区别</strong></h4><ul>
<li><strong>线程安全</strong>：<ul>
<li><code>HashMap</code>：<strong>非线程安全</strong>。性能更高。</li>
<li><code>Hashtable</code>：<strong>线程安全</strong>。几乎所有公共方法都用 <code>synchronized</code> 修饰，性能较低。</li>
</ul>
</li>
<li><strong><code>null</code> 值</strong>：<ul>
<li><code>HashMap</code>：允许 <code>key</code> 和 <code>value</code> 为 <code>null</code>。</li>
<li><code>Hashtable</code>：不允许 <code>key</code> 或 <code>value</code> 为 <code>null</code>。</li>
</ul>
</li>
<li><strong>继承体系</strong>：<ul>
<li><code>HashMap</code>：继承 <code>AbstractMap</code>。</li>
<li><code>Hashtable</code>：继承 <code>Dictionary</code> (一个古老的类)。</li>
</ul>
</li>
<li><strong>迭代器</strong>：<ul>
<li><code>HashMap</code> 的 <code>Iterator</code> 是 <strong>fail-fast</strong> 的。</li>
<li><code>Hashtable</code> 的 <code>Enumerator</code> 不是 fail-fast 的。</li>
</ul>
</li>
<li><strong>初始容量与扩容</strong>：<ul>
<li><code>HashMap</code>：默认 16，扩容为 2 倍。</li>
<li><code>Hashtable</code>：默认 11，扩容为 2 倍 + 1 (<code>oldCapacity * 2 + 1</code>)。</li>
</ul>
</li>
<li><strong>哈希计算</strong>：<ul>
<li><code>HashMap</code>：优化了哈希函数 (<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>)。</li>
<li><code>Hashtable</code>：直接使用 <code>key.hashCode()</code>。</li>
</ul>
</li>
<li><strong>推荐使用</strong>：**<code>HashMap</code> + <code>ConcurrentHashMap</code> 或 <code>Collections.synchronizedMap()</code> 代替 <code>Hashtable</code>**。</li>
</ul>
<h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h2><h3 id="字节流与字符流的区别"><a href="#字节流与字符流的区别" class="headerlink" title="字节流与字符流的区别"></a>字节流与字符流的区别</h3><ul>
<li><strong>字节流</strong>：<code>InputStream</code>&#x2F;<code>OutputStream</code>，处理二进制数据（如图片、视频），核心类如 <code>FileInputStream</code>。</li>
<li><strong>字符流</strong>：<code>Reader</code>&#x2F;<code>Writer</code>，处理文本数据（自动处理编码），核心类如 <code>FileReader</code>、<code>InputStreamReader</code>。</li>
<li><strong>关键点</strong>：字符流底层依赖字节流 + 编码转换（如 <code>InputStreamReader</code> 是字节到字符的桥梁）。</li>
</ul>
<p><strong>为什么要有字符流？</strong></p>
<ul>
<li>直接操作字符更高效，避免手动处理编码（如 UTF-8 转码），解决乱码问题。</li>
</ul>
<h3 id="BIO、NIO、AIO的区别"><a href="#BIO、NIO、AIO的区别" class="headerlink" title="BIO、NIO、AIO的区别"></a>BIO、NIO、AIO的区别</h3><table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left">传统 IO</th>
<th align="left">NIO</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>模型</strong></td>
<td align="left">阻塞式（Blocking）</td>
<td align="left">非阻塞式（Non-blocking）</td>
</tr>
<tr>
<td align="left"><strong>数据单位</strong></td>
<td align="left">流（Stream）</td>
<td align="left">缓冲区（Buffer） + 通道（Channel）</td>
</tr>
<tr>
<td align="left"><strong>多路复用</strong></td>
<td align="left">不支持</td>
<td align="left">Selector 轮询机制</td>
</tr>
</tbody></table>
<h3 id="NIO-三大核心组件"><a href="#NIO-三大核心组件" class="headerlink" title="NIO 三大核心组件"></a>NIO 三大核心组件</h3><ul>
<li><strong>Buffer</strong>：数据容器（如 <code>ByteBuffer</code>），支持 <code>flip()</code>、<code>clear()</code> 等操作。</li>
<li><strong>Channel</strong>：双向数据传输通道（如 <code>FileChannel</code>、<code>SocketChannel</code>）。</li>
<li><strong>Selector</strong>：单线程监听多个 Channel 事件（OP_READ&#x2F;OP_WRITE）。</li>
</ul>
<h3 id="什么是零拷贝"><a href="#什么是零拷贝" class="headerlink" title="什么是零拷贝"></a>什么是零拷贝</h3><h3 id="5种IO模型"><a href="#5种IO模型" class="headerlink" title="5种IO模型"></a>5种IO模型</h3><h3 id="什么是Reactor模型"><a href="#什么是Reactor模型" class="headerlink" title="什么是Reactor模型"></a>什么是Reactor模型</h3><h2 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h2><h3 id="JUC集合"><a href="#JUC集合" class="headerlink" title="JUC集合"></a>JUC集合</h3><h4 id="ConcurrentHashMap-的实现原理"><a href="#ConcurrentHashMap-的实现原理" class="headerlink" title="ConcurrentHashMap 的实现原理"></a><code>ConcurrentHashMap</code> 的实现原理</h4><ul>
<li><strong>JDK7：分段锁 (Segment Locking)</strong><ul>
<li>将数据分成多个段 (<code>Segment</code> 数组，默认 16 个段)。</li>
<li>每个 <code>Segment</code> 本身是一个类似 <code>ReentrantLock</code> 的锁，并管理一个独立的 <code>HashEntry</code> 数组 (相当于一个小型的 <code>HashMap</code>)。</li>
<li><strong>锁粒度</strong>：锁住的是<strong>整个段</strong>。不同段上的操作可以并发进行。并发度等于 <code>Segment</code> 的数量。</li>
<li><strong>PUT</strong>：先定位到哪个 <code>Segment</code>，然后对该 <code>Segment</code> <strong>加锁</strong>，再在该 <code>Segment</code> 内部的哈希表上进行操作（类似 <code>HashMap</code> JDK7）。</li>
<li><strong>GET</strong>：<strong>无锁</strong> (volatile 读)。定位到 <code>Segment</code> 和 <code>HashEntry</code> 后直接读取 <code>value</code> (value 是 volatile 的)。</li>
</ul>
</li>
<li><strong>JDK8：<code>synchronized</code> + <code>CAS</code> + 红黑树</strong><ul>
<li>摒弃分段锁，采用 <code>Node</code> 数组 + 链表 &#x2F; 红黑树 (结构类似 <code>HashMap</code> JDK8)。</li>
<li><strong>锁粒度</strong>：<strong>锁单个链表头节点或树根节点</strong> (桶级别)。并发度大大提高。</li>
<li><strong>关键机制</strong>：<ul>
<li>**<code>CAS</code> (Compare-And-Swap)**：用于无锁化的初始化数组、插入新节点 (<code>tabAt</code>, <code>casTabAt</code>, <code>setTabAt</code> 使用 <code>Unsafe</code> 操作)。</li>
<li><strong><code>synchronized</code><strong>：当发生哈希冲突（桶不为空）时，对链表的头节点或树的根节点</strong>加 <code>synchronized</code> 锁</strong>。锁对象是头节点本身。</li>
<li>**<code>volatile</code>**：<code>Node</code> 的 <code>val</code> 和 <code>next</code> 字段用 <code>volatile</code> 修饰，保证可见性。</li>
</ul>
</li>
<li><strong>PUT</strong>：<ol>
<li>计算哈希值，定位桶位置。</li>
<li>如果桶为空，尝试用 <code>CAS</code> 插入新节点。</li>
<li>如果桶不为空（可能有锁竞争）：<ul>
<li>如果该桶节点正在扩容 (<code>MOVED</code>)，当前线程协助扩容 (<code>helpTransfer</code>)。</li>
<li>否则，<strong>对桶的头节点加 <code>synchronized</code> 锁</strong>。</li>
<li>在锁内，根据是链表还是树，执行类似 <code>HashMap</code> JDK8 的插入逻辑（尾插法，树化）。</li>
</ul>
</li>
<li>检查是否需要扩容（链表长度达到 8 且数组长度 &lt; 64 时优先扩容）。</li>
</ol>
</li>
<li><strong>GET</strong>：<strong>完全无锁</strong>。定位到桶后，根据链表或树遍历查找。依赖 <code>volatile</code> 读保证可见性。</li>
<li><strong>扩容</strong>：支持<strong>多线程协同扩容</strong> (<code>transfer</code>)。当一个线程触发扩容时，它负责分配迁移任务区间。其他线程在 PUT 操作时如果发现正在扩容，会协助迁移一部分数据。使用 <code>ForwardingNode</code> 节点标记迁移完成的桶。</li>
</ul>
</li>
</ul>
<h4 id="为什么-ConcurrentHashMap-比-Hashtable-效率高"><a href="#为什么-ConcurrentHashMap-比-Hashtable-效率高" class="headerlink" title="为什么 ConcurrentHashMap 比 Hashtable 效率高"></a><strong>为什么 <code>ConcurrentHashMap</code> 比 <code>Hashtable</code> 效率高</strong></h4><ul>
<li><strong>锁粒度</strong>：<ul>
<li><code>Hashtable</code>：<strong>全局锁</strong>。锁住整个表，一次只允许一个线程操作。</li>
<li><code>ConcurrentHashMap</code> (JDK7)：<strong>分段锁</strong>。锁住一个段，不同段操作可并发。</li>
<li><code>ConcurrentHashMap</code> (JDK8)：**桶锁 (头节点锁)**。锁粒度更细，冲突概率更低，并发度更高。</li>
</ul>
</li>
<li><strong>无锁读</strong>：<ul>
<li><code>Hashtable</code>：读操作也需要获取锁。</li>
<li><code>ConcurrentHashMap</code> (JDK7 &amp; JDK8)：<strong>读操作完全无锁</strong> (JDK7 利用 volatile value，JDK8 利用 volatile val&#x2F;next 和 Unsafe 的原子读)，极大提升读性能。</li>
</ul>
</li>
</ul>
<h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><h3 id="CompletableFuture的原理与应用"><a href="#CompletableFuture的原理与应用" class="headerlink" title="CompletableFuture的原理与应用"></a><code>CompletableFuture</code>的原理与应用</h3><p><code>CompletableFuture</code> 是 Java 8 引入的核心并发工具类（位于 <code>java.util.concurrent</code> 包），它代表一个<strong>异步计算的结果</strong>。它不仅是对传统 <code>Future</code> 接口的增强，更是一个强大的<strong>异步编程框架</strong>，支持显式地完成计算、链式组合多个异步任务、处理结果和异常，是实现响应式、非阻塞编程的关键组件。</p>
<p><strong>一、核心原理</strong></p>
<ol>
<li><strong>异步执行与结果容器：</strong><ul>
<li>它本质上是一个<strong>容器</strong>，用于承载将来某个时刻计算完成的结果（或异常）。</li>
<li>计算任务通常被提交给 <code>Executor</code>（线程池）在后台线程中执行，避免阻塞调用线程。</li>
<li>创建时结果未知，计算完成后结果被设置（<code>complete(result)</code> 或 <code>completeExceptionally(throwable)</code>）。</li>
</ul>
</li>
<li><strong>显式完成：</strong><ul>
<li>与传统 <code>Future</code> 只能被动等待不同，<code>CompletableFuture</code> 可以被<strong>主动完成</strong>。</li>
<li>任何拥有该对象引用的线程都可以调用 <code>complete()</code> 或 <code>completeExceptionally()</code> 手动设置结果或异常。这是实现超时控制、外部事件触发完成等场景的基础。</li>
</ul>
</li>
<li><strong>链式组合与回调 (CompletionStage)：</strong><ul>
<li><code>CompletableFuture</code> 实现了 <code>CompletionStage</code> 接口，这是其强大能力的核心。</li>
<li><code>CompletionStage</code> 定义了丰富的链式方法（<code>thenApply</code>, <code>thenAccept</code>, <code>thenRun</code>, <code>thenCompose</code>, <code>thenCombine</code>, <code>handle</code>, <code>whenComplete</code>, <code>exceptionally</code> 等）。</li>
<li>这些方法允许你<strong>声明式地</strong>描述：“<strong>当当前阶段完成时，接下来应该做什么</strong>”。回调函数（lambda 表达式或方法引用）会被挂接到当前阶段的完成事件上。</li>
<li>每个链式调用都会返回一个<strong>新的 <code>CompletionStage</code>（通常是另一个 <code>CompletableFuture</code>）</strong>，代表下一个异步步骤。这形成了<strong>异步任务流水线</strong>。</li>
</ul>
</li>
<li><strong>依赖关系与内部状态机：</strong><ul>
<li>当多个 <code>CompletableFuture</code> 通过 <code>thenXxx</code> 方法链接起来时，后续阶段依赖于前驱阶段的完成。</li>
<li><code>CompletableFuture</code> 内部维护一个<strong>状态机</strong>（如 <code>NEW</code>, <code>COMPLETING</code>, <code>NORMAL</code>, <code>EXCEPTIONAL</code>, <code>CANCELLED</code>）和一个<strong>依赖栈</strong>（指向所有依赖于它完成的后续阶段）。</li>
<li>当一个阶段完成时，它会遍历其依赖栈，<strong>尝试触发所有后续阶段</strong>的执行（可能立即执行，也可能提交到线程池）。</li>
</ul>
</li>
<li><strong>非阻塞与事件驱动：</strong><ul>
<li>整个流程是<strong>非阻塞</strong>的。调用 <code>thenXxx</code> 只是注册回调，并不等待前驱完成。主线程可以继续执行其他任务。</li>
<li>执行由<strong>完成事件驱动</strong>：前驱完成 -&gt; 触发回调 -&gt; 执行回调逻辑 -&gt; 完成后继 -&gt; 触发后继的回调…。</li>
</ul>
</li>
<li><strong>组合多个 Future：</strong><ul>
<li>提供 <code>allOf()</code>, <code>anyOf()</code> 等静态方法，用于组合多个独立的 <code>CompletableFuture</code>：<ul>
<li><code>allOf(futures...)</code>: 创建一个新的 Future，当<strong>所有</strong>输入 Future 完成时（无论成功失败），它才完成（本身无结果，需手动获取各Future结果）。</li>
<li><code>anyOf(futures...)</code>: 创建一个新的 Future，当<strong>任意一个</strong>输入 Future 完成时（无论成功失败），它就完成（结果是最先完成的那个Future的结果）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>线程池控制：</strong><ul>
<li>默认情况下，链式调用中后续任务的执行线程由前驱任务的完成线程执行（通常是执行前驱任务的线程或调用 <code>complete</code> 的线程）。</li>
<li>可以使用带有 <code>Executor</code> 参数的变体方法（如 <code>thenApplyAsync(func, executor)</code>）<strong>显式指定</strong>后续任务在特定的线程池中执行，避免线程饥饿或控制资源。</li>
</ul>
</li>
</ol>
<p><strong>二、主要应用场景</strong></p>
<ol>
<li><p><strong>异步任务编排与流水线：</strong> 将复杂的业务逻辑拆分成多个异步步骤，按顺序或条件链式执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; fetchUserData(userId), ioPool) <span class="comment">// 步骤1：IO操作</span></span><br><span class="line">    .thenApply(userData -&gt; processData(userData))              <span class="comment">// 步骤2：CPU密集型处理（默认同线程或ForkJoinPool）</span></span><br><span class="line">    .thenApplyAsync(processedData -&gt; saveToDB(processedData), dbPool) <span class="comment">// 步骤3：另一个IO操作，指定DB线程池</span></span><br><span class="line">    .thenAccept(savedResult -&gt; sendNotification(savedResult))  <span class="comment">// 步骤4：最终处理</span></span><br><span class="line">    .exceptionally(ex -&gt; &#123;                                     <span class="comment">// 统一异常处理</span></span><br><span class="line">        log.error(<span class="string">&quot;Pipeline failed&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> handleFailure(ex);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>并行执行与结果聚合：</strong> 同时发起多个独立任务，等所有&#x2F;任意一个完成后再处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;ResultA&gt; futureA = CompletableFuture.supplyAsync(() -&gt; serviceA.call());</span><br><span class="line">CompletableFuture&lt;ResultB&gt; futureB = CompletableFuture.supplyAsync(() -&gt; serviceB.call());</span><br><span class="line">CompletableFuture&lt;ResultC&gt; futureC = CompletableFuture.supplyAsync(() -&gt; serviceC.call());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等所有任务完成</span></span><br><span class="line">CompletableFuture&lt;Void&gt; allFutures = CompletableFuture.allOf(futureA, futureB, futureC);</span><br><span class="line">allFutures.thenRun(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 手动获取各个结果（此时肯定已完成）</span></span><br><span class="line">    <span class="type">ResultA</span> <span class="variable">a</span> <span class="operator">=</span> futureA.join(); <span class="comment">// 或 get() (需处理异常)</span></span><br><span class="line">    <span class="type">ResultB</span> <span class="variable">b</span> <span class="operator">=</span> futureB.join();</span><br><span class="line">    <span class="type">ResultC</span> <span class="variable">c</span> <span class="operator">=</span> futureC.join();</span><br><span class="line">    aggregateResults(a, b, c);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等任意一个任务完成</span></span><br><span class="line">CompletableFuture&lt;Object&gt; anyFuture = CompletableFuture.anyOf(futureA, futureB, futureC);</span><br><span class="line">anyFuture.thenAccept(result -&gt; handleFirstResult(result));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>结果转换与处理：</strong> 使用 <code>thenApply</code> 将上一步的结果转换成另一种形式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;123&quot;</span>);</span><br><span class="line">CompletableFuture&lt;Integer&gt; intFuture = future.thenApply(Integer::parseInt);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>副作用操作：</strong> 使用 <code>thenAccept</code> 消费结果但不产生新结果（如日志、发送消息），或使用 <code>thenRun</code> 执行不依赖结果的动作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">future.thenAccept(result -&gt; System.out.println(<span class="string">&quot;Result: &quot;</span> + result));</span><br><span class="line">future.thenRun(() -&gt; cleanupResources());</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>组合异步任务：</strong></p>
<ul>
<li><code>thenCompose(Function&lt;T, CompletionStage&lt;U&gt;&gt;)</code>: <strong>扁平化</strong>组合。当前 Future 完成后，用其结果作为输入，<strong>启动并返回另一个 Future</strong> (避免嵌套 <code>CompletableFuture&lt;CompletableFuture&lt;U&gt;&gt;</code>)。</li>
<li><code>thenCombine(CompletionStage&lt;U&gt;, BiFunction&lt;T, U, V&gt;)</code>: 等待<strong>当前 Future 和另一个 Future</strong> 都完成，然后用两者的结果执行一个函数，返回新的 Future。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thenCompose 示例 (获取用户后获取订单)</span></span><br><span class="line">CompletableFuture&lt;User&gt; userFuture = getUserAsync(userId);</span><br><span class="line">CompletableFuture&lt;Order&gt; orderFuture = userFuture.thenCompose(user -&gt; getOrdersAsync(user));</span><br><span class="line"></span><br><span class="line"><span class="comment">// thenCombine 示例 (并行计算价格和库存，然后组合)</span></span><br><span class="line">CompletableFuture&lt;Price&gt; priceFuture = getPriceAsync(productId);</span><br><span class="line">CompletableFuture&lt;Inventory&gt; inventoryFuture = getInventoryAsync(productId);</span><br><span class="line">CompletableFuture&lt;ProductInfo&gt; productInfoFuture = priceFuture.thenCombine(inventoryFuture,</span><br><span class="line">    (price, inventory) -&gt; <span class="keyword">new</span> <span class="title class_">ProductInfo</span>(price, inventory));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>异常处理：</strong></p>
<ul>
<li><code>exceptionally(Function&lt;Throwable, T&gt;)</code>: 捕获异常并提供一个<strong>恢复值</strong>，返回一个正常完成的 Future。</li>
<li><code>handle(BiFunction&lt;T, Throwable, U&gt;)</code>: 无论正常完成还是异常，都会被调用。可以检查结果或异常，并返回一个新结果（或抛出新异常）。</li>
<li><code>whenComplete(BiConsumer&lt;T, Throwable&gt;)</code>: 类似 <code>handle</code>，但它是消费者（不改变结果），用于记录日志、清理等，返回一个结果类型相同的 Future（异常会传播）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">future.exceptionally(ex -&gt; defaultValue) <span class="comment">// 异常时提供默认值</span></span><br><span class="line">     .handle((result, ex) -&gt; &#123;</span><br><span class="line">         <span class="keyword">if</span> (ex != <span class="literal">null</span>) &#123; <span class="keyword">return</span> fallback; &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123; <span class="keyword">return</span> transform(result); &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">     .whenComplete((result, ex) -&gt; &#123;</span><br><span class="line">         <span class="keyword">if</span> (ex != <span class="literal">null</span>) log.error(<span class="string">&quot;Oops&quot;</span>, ex);</span><br><span class="line">         <span class="keyword">else</span> metrics.recordSuccess();</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>超时控制 (Java 9+):</strong> 使用 <code>orTimeout(timeout, timeUnit)</code> 或 <code>completeOnTimeout(value, timeout, timeUnit)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = someLongRunningTask()</span><br><span class="line">    .orTimeout(<span class="number">5</span>, TimeUnit.SECONDS) <span class="comment">// 超时抛出 TimeoutException</span></span><br><span class="line">    .exceptionally(ex -&gt; (ex <span class="keyword">instanceof</span> TimeoutException) ? <span class="string">&quot;Timed out&quot;</span> : <span class="string">&quot;Other error&quot;</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;String&gt; future = someLongRunningTask()</span><br><span class="line">    .completeOnTimeout(<span class="string">&quot;Fallback Value&quot;</span>, <span class="number">5</span>, TimeUnit.SECONDS); <span class="comment">// 超时提供默认值</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>三、关键优势</strong></p>
<ol>
<li><strong>非阻塞异步：</strong> 提高系统吞吐量和响应性。</li>
<li><strong>声明式 &amp; 链式编程：</strong> 代码更简洁、易读、易维护，接近同步代码的风格（避免回调地狱）。</li>
<li><strong>强大的组合能力：</strong> 轻松编排复杂异步工作流（顺序、并行、聚合、条件）。</li>
<li><strong>灵活的异常处理：</strong> 提供多种方式处理异步管道中的错误。</li>
<li><strong>显式完成控制：</strong> 支持手动设置结果，适应更多场景（如超时、外部事件）。</li>
<li><strong>线程池集成：</strong> 可精细控制任务执行位置。</li>
</ol>
<p><strong>四、注意事项与最佳实践</strong></p>
<ol>
<li><strong>避免阻塞：</strong> 不要在 <code>CompletableFuture</code> 的回调方法（如 <code>thenApply</code>, <code>thenAccept</code> 内部）执行长时间阻塞操作，这会卡住执行线程（可能是公共的 ForkJoinPool 线程）。使用 <code>thenApplyAsync</code> 等带 <code>Executor</code> 的方法将阻塞操作提交到专用线程池。</li>
<li><strong>线程池选择：</strong><ul>
<li>CPU 密集型任务：考虑使用 <code>ForkJoinPool.commonPool()</code> (默认) 或固定大小线程池（线程数 ≈ CPU 核心数）。</li>
<li>IO 密集型任务：<strong>务必使用</strong> 足够大的缓存线程池（如 <code>Executors.newCachedThreadPool()</code>）或专门配置的线程池，避免线程饥饿。<strong>强烈推荐为不同资源（如DB、HTTP）使用独立线程池。</strong></li>
</ul>
</li>
<li><strong>异常传播：</strong> 理解异常在链式调用中的传播机制。如果某个阶段抛出异常且未被捕获（如 <code>exceptionally</code>），后续依赖它的 <code>thenApply</code>&#x2F;<code>thenAccept</code> 等<strong>不会被执行</strong>，异常会传递到链的末端或等待 <code>get()</code>&#x2F;<code>join()</code> 时抛出。使用 <code>handle</code>&#x2F;<code>whenComplete</code>&#x2F;<code>exceptionally</code> 妥善处理。</li>
<li><strong>结果获取：</strong><ul>
<li><code>get()</code>: 阻塞等待结果，需处理 <code>InterruptedException</code> 和 <code>ExecutionException</code>（封装了原始异常）。</li>
<li><code>join()</code>: 类似 <code>get()</code>，但抛出未经检查的 <code>CompletionException</code>（其 <code>getCause()</code> 是原始异常）。通常在链的末端或明确知道会很快完成时使用。</li>
<li><strong>尽量使用回调</strong>（<code>thenAccept</code>, <code>thenApply</code>, <code>whenComplete</code>）而非阻塞获取，以保持非阻塞性。</li>
</ul>
</li>
<li><strong>资源清理：</strong> 使用 <code>whenComplete</code> 或 <code>handle</code> 确保资源（如文件句柄、网络连接）在任务完成（无论成功失败）后被正确关闭。</li>
<li><strong>避免过度嵌套：</strong> 虽然链式调用避免回调地狱，但深度嵌套仍可能降低可读性。考虑将复杂步骤抽取成独立方法。</li>
<li><strong>取消传播：</strong> <code>CompletableFuture.cancel(true)</code> 会尝试中断当前正在执行的任务，但<strong>不会自动取消它依赖的或依赖它的其他 Future</strong>。需要手动设计取消逻辑。</li>
</ol>
<p><strong>总结</strong></p>
<p><code>CompletableFuture</code> 是 Java 现代异步编程的基石。它通过<strong>链式组合</strong>、<strong>非阻塞回调</strong>和<strong>显式完成</strong>机制，提供了强大而优雅的方式来构建复杂、高效的异步应用程序。深入理解其原理（状态机、依赖管理）和熟练掌握其 API（<code>supplyAsync</code>, <code>thenXxx</code>, <code>handle</code>, <code>allOf</code>, <code>anyOf</code>, <code>thenCompose</code>, <code>thenCombine</code>, 异常处理）是编写高性能、高响应性 Java 服务的关键。合理使用线程池和遵循最佳实践（避免阻塞回调、妥善处理异常、管理资源）至关重要。</p>
<h3 id="CompletableFuture-和传统的-Future-有什么区别"><a href="#CompletableFuture-和传统的-Future-有什么区别" class="headerlink" title="CompletableFuture 和传统的 Future 有什么区别"></a><strong><code>CompletableFuture</code> 和传统的 <code>Future</code> 有什么区别</strong></h3><ul>
<li>考察点：理解其核心优势（链式编程、组合能力、手动完成、异常处理）。</li>
<li>期望回答：<code>Future</code> 仅支持阻塞获取结果或轮询，无法组合；<code>CompletableFuture</code> 实现了 <code>CompletionStage</code>，支持非阻塞回调、任务链式组合、手动设置结果&#x2F;异常、更强大的异常处理。</li>
</ul>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><p>类加载的过程包括了<strong>加载、验证、准备、解析、初始化</strong>五个阶段。</p>
<h4 id="类加载器的层次结构"><a href="#类加载器的层次结构" class="headerlink" title="类加载器的层次结构"></a>类加载器的层次结构</h4><p>类加载器层级结构：</p>
<table>
<thead>
<tr>
<th><strong>类加载器</strong></th>
<th><strong>加载路径</strong></th>
<th><strong>父加载器</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Bootstrap ClassLoader</strong></td>
<td><code>JRE/lib/rt.jar</code>等核心库</td>
<td>无（顶级加载器）</td>
</tr>
<tr>
<td><strong>Extension ClassLoader</strong></td>
<td><code>JRE/lib/ext</code>目录下扩展库</td>
<td>Bootstrap</td>
</tr>
<tr>
<td><strong>Application ClassLoader</strong></td>
<td>应用类路径（ClassPath）</td>
<td>Extension</td>
</tr>
<tr>
<td><strong>自定义ClassLoader</strong></td>
<td>用户自定义路径</td>
<td>Application</td>
</tr>
</tbody></table>
<h4 id="Class-forName-和ClassLoader-loadClass-区别"><a href="#Class-forName-和ClassLoader-loadClass-区别" class="headerlink" title="Class.forName()和ClassLoader.loadClass()区别"></a>Class.forName()和ClassLoader.loadClass()区别</h4><ul>
<li><code>Class.forName()</code>: 将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li>
<li><code>ClassLoader.loadClass()</code>: 只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li>
<li><code>Class.forName(name, initialize, loader)</code>带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。</li>
</ul>
<h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><h4 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h4><table>
<thead>
<tr>
<th><strong>内存区域</strong></th>
<th><strong>描述</strong></th>
<th><strong>线程共享性</strong></th>
<th><strong>异常触发条件</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>程序计数器（PC）</strong></td>
<td>记录当前线程执行的字节码指令地址，线程私有，唯一无OOM的区域。</td>
<td>线程私有</td>
<td>无（不会抛出内存相关异常）</td>
</tr>
<tr>
<td><strong>虚拟机栈（Java Stack）</strong></td>
<td>存储方法调用的栈帧（局部变量表、操作数栈、动态链接、方法出口等），线程私有。</td>
<td>线程私有</td>
<td><code>StackOverflowError</code>（栈深度溢出） <code>OutOfMemoryError</code>（无法扩展栈空间）</td>
</tr>
<tr>
<td><strong>本地方法栈（Native Stack）</strong></td>
<td>为Native方法（如C&#x2F;C++实现的方法）提供栈空间，线程私有。</td>
<td>线程私有</td>
<td>同虚拟机栈</td>
</tr>
<tr>
<td><strong>堆（Heap）</strong></td>
<td>存放对象实例和数组，所有线程共享，是垃圾回收的主要区域。</td>
<td>线程共享</td>
<td><code>OutOfMemoryError</code>（堆内存不足）</td>
</tr>
<tr>
<td><strong>方法区（Method Area）</strong></td>
<td>存储类信息、常量、静态变量、即时编译器代码等数据。JDK 8后由元空间（Metaspace）实现。</td>
<td>线程共享</td>
<td><code>OutOfMemoryError</code>（元空间&#x2F;方法区内存不足）</td>
</tr>
</tbody></table>
<h4 id="什么情况下会触发StackOverflowError和OutOfMemoryError"><a href="#什么情况下会触发StackOverflowError和OutOfMemoryError" class="headerlink" title="什么情况下会触发StackOverflowError和OutOfMemoryError"></a>什么情况下会触发StackOverflowError和OutOfMemoryError</h4><p><strong>触发StackOverflowError</strong></p>
<ul>
<li><p><strong>无限递归</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class StackOverflowExample &#123;</span><br><span class="line">    public static void recursiveMethod() &#123;</span><br><span class="line">        recursiveMethod(); // 无限递归调用</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        recursiveMethod(); // 触发StackOverflowError</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次方法调用都会在虚拟机栈中压入新栈帧，超出栈的最大深度限制（默认1MB，可通过<code>-Xss</code>调整）。</p>
</li>
<li><p>栈帧过大（局部变量过多或方法操作数栈过深）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void largeMethod() &#123;</span><br><span class="line">    int a1, a2, a3, ..., a10000; // 大量局部变量占用栈空间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单个栈帧占用的内存超过栈容量。</p>
</li>
</ul>
<p><strong>触发OutOfMemoryError</strong></p>
<ul>
<li><p><strong>堆内存溢出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 不断创建大对象，耗尽堆内存</span><br><span class="line">List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">while (true) &#123;</span><br><span class="line">    list.add(new byte[1024 * 1024]); // 每次分配1MB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原因</strong>：对象数量超过堆容量（可通过<code>-Xmx</code>和<code>-Xms</code>调整堆大小）。</p>
<p><strong>典型场景</strong>：内存泄漏（如静态集合未释放对象）或合理内存不足。</p>
</li>
<li><p><strong>方法区&#x2F;元空间溢出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 动态生成大量类（如使用CGLIB）</span><br><span class="line">public class MetaspaceOOM &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Enhancer enhancer = new Enhancer();</span><br><span class="line">        enhancer.setSuperclass(OOMObject.class);</span><br><span class="line">        enhancer.setCallback((MethodInterceptor) (obj, method, args1, proxy) -&gt; proxy.invokeSuper(obj, args1));</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            enhancer.create(); // 持续生成代理类</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static class OOMObject &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原因</strong>：加载的类数量或元数据量超过元空间容量（通过<code>-XX:MaxMetaspaceSize</code>设置上限）。</p>
<p><strong>典型场景</strong>：动态代理框架（如Spring AOP）、反射滥用。</p>
</li>
<li><p><strong>虚拟机栈或本地方法栈无法扩展</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 启动大量线程，每个线程的栈空间无法分配</span><br><span class="line">public class ThreadOOM &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                try &#123; Thread.sleep(1000000); &#125; catch (InterruptedException e) &#123;&#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原因</strong>：线程数量过多导致栈总内存超过系统限制（通过<code>-Xss</code>减少单个线程栈大小）。</p>
</li>
</ul>
<p><strong>总结</strong></p>
<table>
<thead>
<tr>
<th><strong>错误类型</strong></th>
<th><strong>触发场景</strong></th>
<th><strong>典型原因</strong></th>
<th><strong>解决方案</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>StackOverflowError</strong></td>
<td>递归调用未终止、栈帧过大</td>
<td>代码逻辑错误</td>
<td>修复递归终止条件，减少局部变量数量</td>
</tr>
<tr>
<td><strong>OutOfMemoryError</strong></td>
<td>堆内存不足、元空间溢出、线程数过多</td>
<td>内存泄漏、配置不当、资源耗尽</td>
<td>调整JVM参数，优化代码，增加物理内存</td>
</tr>
</tbody></table>
<h4 id="永久代和元空间的区别"><a href="#永久代和元空间的区别" class="headerlink" title="永久代和元空间的区别"></a>永久代和元空间的区别</h4><h4 id="堆内存是怎么细分的"><a href="#堆内存是怎么细分的" class="headerlink" title="堆内存是怎么细分的"></a>堆内存是怎么细分的</h4><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><h4 id="如何判断一个对象是否可回收"><a href="#如何判断一个对象是否可回收" class="headerlink" title="如何判断一个对象是否可回收"></a>如何判断一个对象是否可回收</h4><p><strong>引用计数法</strong></p>
<p><strong>可达性分析法</strong></p>
<p>在 Java 中 以下对象可作为 GC Roots：</p>
<ul>
<li>虚拟机栈中引用的对象</li>
<li>本地方法栈中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
</ul>
<h4 id="有哪些垃圾回收算法"><a href="#有哪些垃圾回收算法" class="headerlink" title="有哪些垃圾回收算法"></a>有哪些垃圾回收算法</h4><table>
<thead>
<tr>
<th>算法</th>
<th>步骤</th>
<th>特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>标记-清除（Mark-Sweep）</strong></td>
<td>1. <strong>标记</strong>：遍历所有对象，标记存活对象。 2. <strong>清除</strong>：回收未被标记的对象（垃圾）。</td>
<td><strong>优点</strong>：实现简单，不需要移动对象。 <strong>缺点</strong>：产生内存碎片，可能触发频繁的 Full GC。</td>
<td>1. 老年代回收（如 CMS 收集器的初始阶段）。 2. 对内存碎片不敏感的场景，或短期运行的应用程序。</td>
</tr>
<tr>
<td><strong>复制算法（Copying）</strong></td>
<td>1. 将内存分为两块（From 和 To），对象分配在 From 区。 2. 标记存活对象，将其复制到 To 区。 3. 清空 From 区，交换 From 和 To 的角色。</td>
<td><strong>优点</strong>：无内存碎片，回收高效。 <strong>缺点</strong>：内存利用率低（需预留一半空间）。</td>
<td>1. 新生代回收（如 Serial、ParNew、Parallel Scavenge 等收集器）。 2. 适用于对象存活率低的场景（如新生代 Eden 区）。</td>
</tr>
<tr>
<td><strong>标记-整理（Mark-Compact）</strong></td>
<td><strong>标记</strong>：遍历所有对象，标记存活对象。 <strong>整理</strong>：将存活对象向内存一端移动，清理边界外的空间。</td>
<td><strong>优点</strong>：避免内存碎片，适合长期运行的系统。 <strong>缺点</strong>：移动对象需要时间，导致停顿较长（STW）。</td>
<td>1. 老年代回收（如 Serial Old、Parallel Old 收集器）。 2. 对内存敏感且需要避免碎片的场景（如大数据应用）。</td>
</tr>
</tbody></table>
<h4 id="CMS收集器工作原理"><a href="#CMS收集器工作原理" class="headerlink" title="CMS收集器工作原理"></a>CMS收集器工作原理</h4><h4 id="G1收集器工作原理"><a href="#G1收集器工作原理" class="headerlink" title="G1收集器工作原理"></a>G1收集器工作原理</h4><h1 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h1><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="查询语句的执行顺序"><a href="#查询语句的执行顺序" class="headerlink" title="查询语句的执行顺序"></a>查询语句的执行顺序</h3><p>MySQL 分为 server 层和存储引擎层。</p>
<p>server 层涵盖 MySQL 大多数核心功能（如存储过程、触发器、视图等）和所有内置函数（如日期、时间、数学函数等）。</p>
<p>存储引擎层负责数据的存储和提取。</p>
<p><code>from</code> -&gt; <code>where</code> -&gt; <code>group by</code> -&gt; <code>having</code> -&gt; <code>select</code> -&gt; <code>distinct</code> -&gt; <code>order by</code> -&gt; <code>limit</code></p>
<img src="/post/65a5b0d7/1726212535664-4bb3f3ff-704a-4706-84c8-a046a8486657.webp" class="" title="img">

<h3 id="InnoDB索引结构"><a href="#InnoDB索引结构" class="headerlink" title="InnoDB索引结构"></a>InnoDB索引结构</h3><p>B树结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">       [10 | 20]</span><br><span class="line">      /    |     \</span><br><span class="line">[5|8]  [12|15|18]  [25|30]</span><br></pre></td></tr></table></figure>

<p>特征：</p>
<ul>
<li>所有节点都存储完整数据</li>
<li>每个节点最多包涵 m-1 个键值和 m 个子节点</li>
</ul>
<p>B+树结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">               [15]</span><br><span class="line">              /    \</span><br><span class="line">     [10|15]          [20|25]</span><br><span class="line">     /     \          /     \ </span><br><span class="line">[10|...]→[15|...]→[20|...]→[25|...]（叶子节点链表）</span><br></pre></td></tr></table></figure>

<p>特征：</p>
<ul>
<li>只有叶子节点存储完整数据，内部节点只存储索引</li>
<li>叶子节点通过双向链表连接，支持高效范围查询</li>
<li>相同磁盘页可以存储更多索引，提高查询效率</li>
</ul>
<p><strong>InnoDB选择B+树的7大关键原因</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>对比维度</strong></th>
<th align="left"><strong>B树</strong></th>
<th align="left"><strong>B+树</strong></th>
<th align="left"><strong>InnoDB优势体现</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>数据存储位置</strong></td>
<td align="left">所有节点存储数据</td>
<td align="left">仅叶子节点存储数据</td>
<td align="left">减少磁盘IO次数</td>
</tr>
<tr>
<td align="left"><strong>树高度</strong></td>
<td align="left">较高（数据分散存储）</td>
<td align="left">较低（内部节点纯索引）</td>
<td align="left">3层B+树可支撑千万级数据</td>
</tr>
<tr>
<td align="left"><strong>范围查询</strong></td>
<td align="left">需要回溯父节点</td>
<td align="left">通过叶子链表顺序扫描</td>
<td align="left"><code>WHERE id &gt; 100</code> 效率提升10倍+</td>
</tr>
<tr>
<td align="left"><strong>全表扫描</strong></td>
<td align="left">需遍历整棵树</td>
<td align="left">直接顺序遍历叶子节点链表</td>
<td align="left">全表扫描速度接近顺序读</td>
</tr>
<tr>
<td align="left"><strong>磁盘利用率</strong></td>
<td align="left">节点包含数据导致存储键值数少</td>
<td align="left">单页可存储更多键值（高分支因子）</td>
<td align="left">相同数据量减少30%-50%树高度</td>
</tr>
<tr>
<td align="left"><strong>数据更新代价</strong></td>
<td align="left">可能引起复杂结构调整</td>
<td align="left">插入删除多数情况只需局部调整</td>
<td align="left">支持更高并发写入</td>
</tr>
<tr>
<td align="left"><strong>缓存命中率</strong></td>
<td align="left">热点数据分散在不同层级</td>
<td align="left">叶子节点集中存储所有数据</td>
<td align="left">Buffer Pool利用率提升40%+</td>
</tr>
</tbody></table>
<h3 id="为什么MongoDB使用B树而MySQL用B-树"><a href="#为什么MongoDB使用B树而MySQL用B-树" class="headerlink" title="为什么MongoDB使用B树而MySQL用B+树"></a>为什么MongoDB使用B树而MySQL用B+树</h3><p>MongoDB面向文档存储，需快速获取整个文档（B树的内部节点存储完整数据，可以减少寻址次数）</p>
<p>MySQL侧重范围查询和事务处理（B+树的顺序访问特性更优秀）</p>
<h3 id="B-树节点分裂的具体过程"><a href="#B-树节点分裂的具体过程" class="headerlink" title="B+树节点分裂的具体过程"></a>B+树节点分裂的具体过程</h3><p>InnoDB优化：预留1&#x2F;16页空间避免频繁分裂</p>
<p><strong>索引设计原则</strong></p>
<ul>
<li>前缀索引优化</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> <span class="keyword">ADD</span> INDEX (name(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>覆盖索引优化</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建包含所有查询字段的索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_cover <span class="keyword">ON</span> orders(user_id, status, create_time);</span><br></pre></td></tr></table></figure>



<p><strong>监控工具使用</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看索引使用情况</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.schema_index_statistics;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分析索引效率</span></span><br><span class="line">EXPLAIN ANALYZE <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> category_id<span class="operator">=</span><span class="number">5</span>;</span><br></pre></td></tr></table></figure>



<p><strong>维护策略</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 定期优化表（重建索引）</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 监控页分裂次数</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Innodb_page_splits%&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h3 id="EXPLAIN-字段说明"><a href="#EXPLAIN-字段说明" class="headerlink" title="EXPLAIN 字段说明"></a><code>EXPLAIN</code> 字段说明</h3><p>通常<code>EXPALIN</code>查询语句的输出如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="comment">// 每个select语句对应一个唯一的id</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询类型：</span></span><br><span class="line"><span class="comment">     * SIMPLE：不包含UNION或子查询的select（连接查询的每个查询都是simple查询）</span></span><br><span class="line"><span class="comment">     * PRIMARY：最外层查询</span></span><br><span class="line"><span class="comment">     * UNION</span></span><br><span class="line"><span class="comment">     * ...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="attr">&quot;select_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SIMPLE&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;users&quot;</span><span class="punctuation">,</span> <span class="comment">// 要查询的表</span></span><br><span class="line">    <span class="attr">&quot;partitions&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span> <span class="comment">// 分区信息</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 针对单表的访问方法：</span></span><br><span class="line"><span class="comment">     * system：当表中只有一条记录，并且该表使用的存储引擎的统计数据是精确的，访问方法就是system</span></span><br><span class="line"><span class="comment">     * constant：根据主键或唯一索引列与常数进行等值匹配时，访问方法就是const</span></span><br><span class="line"><span class="comment">     * eq_ref：连接查询中对被驱动表的主键或不允许为NULL的唯一索引进行等值查询时，访问方法就是eq_ref</span></span><br><span class="line"><span class="comment">     * ref：通过普通二级索引列与常量进行等值匹配时，对该表的访问方法就是 ref</span></span><br><span class="line"><span class="comment">     * ref_or_null：select * from single_table where key1 = &#x27;abc&#x27; or key1 is NULL;</span></span><br><span class="line"><span class="comment">     * index_merge：使用多个索引进行等值匹配</span></span><br><span class="line"><span class="comment">     * unique_subquery：在子查询中使用主键或不允许存储NULL值的唯一二级索引进行等值匹配</span></span><br><span class="line"><span class="comment">     * index_subquery：在子查询中使用普通二级索引进行等值匹</span></span><br><span class="line"><span class="comment">     * range：利用索引进行范围查询</span></span><br><span class="line"><span class="comment">     * index：当可以使用索引覆盖，但需要扫描全部索引记录</span></span><br><span class="line"><span class="comment">     * all：全表扫描</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ref&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;possible_keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;idx_composite&quot;</span><span class="punctuation">,</span> <span class="comment">// 可能使用的索引</span></span><br><span class="line">    <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;idx_composite&quot;</span><span class="punctuation">,</span> <span class="comment">// 实际使用的索引</span></span><br><span class="line">    <span class="attr">&quot;key_len&quot;</span><span class="punctuation">:</span> <span class="string">&quot;208&quot;</span><span class="punctuation">,</span> <span class="comment">// 实际使用的索引长度</span></span><br><span class="line">    <span class="attr">&quot;ref&quot;</span><span class="punctuation">:</span> <span class="string">&quot;const&quot;</span><span class="punctuation">,</span> <span class="comment">// 使用索引列等值查询时，与索引列进行等值匹配的对象信息</span></span><br><span class="line">    <span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="comment">// 预估需要读取的记录行数</span></span><br><span class="line">    <span class="attr">&quot;filtered&quot;</span><span class="punctuation">:</span> <span class="number">100.0</span><span class="punctuation">,</span> <span class="comment">// 过滤后剩余记录行数百分比</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 额外信息：</span></span><br><span class="line"><span class="comment">     * Using index：使用覆盖索引</span></span><br><span class="line"><span class="comment">     * Using index condition：使用索引条件下推</span></span><br><span class="line"><span class="comment">     * Using where：需要在server层判断条件是否成立</span></span><br><span class="line"><span class="comment">     * Using join buffer：执行连接查询时，被驱动表不能有效利用索引加快访问速度时，会分配一块内存用来保存被驱动表的查询结果，</span></span><br><span class="line"><span class="comment">     					  利用join buffer可以减少访问被驱动表的次数</span></span><br><span class="line"><span class="comment">     * Using filesort：</span></span><br><span class="line"><span class="comment">     * Using temporary</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="attr">&quot;Extra&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Using index&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h3 id="覆盖索引与最左前缀原则实战案例"><a href="#覆盖索引与最左前缀原则实战案例" class="headerlink" title="覆盖索引与最左前缀原则实战案例"></a>覆盖索引与最左前缀原则实战案例</h3><p><strong>回表</strong>：查询需要的字段没有全部包含在索引中，需要根据索引找到主键，再从主键索引中找到完整数据才能获取所需字段。</p>
<p><strong>覆盖索引</strong>：查询所需的字段都包含在索引中，无需回表操作。</p>
<p>优点：</p>
<ul>
<li>减少IO操作</li>
<li>避免回表（减少随机读）</li>
</ul>
<p><strong>最左前缀原则</strong>：复合索引 <code>(a, b, c)</code> 的查询条件必须从最左列开始，且不能跳过中间列才能命中索引。</p>
<p>具体规则：</p>
<ul>
<li>等值查询：<code>WHERE a = 1 and b = 2</code> → 命中索引</li>
<li>范围查询：<code>WHERE a &gt; 1 and b = 2</code> → 仅能命中 <code>a</code> 列</li>
<li>跳跃查询：<code>WHERE b = 2 and c = 3</code> → 不能能命中索引</li>
</ul>
<p>覆盖索引优化：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `users` (</span><br><span class="line">	`id` <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">	`name` <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">	`age` <span class="type">INT</span>,</span><br><span class="line">	`city` <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">	`created_at` DATETIME,</span><br><span class="line">	KEY `idx_composite` (`city`, `age`, `created_at`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>

<p>查询需求：统计北京25岁用户的数量</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> city<span class="operator">=</span><span class="string">&#x27;北京&#x27;</span> <span class="keyword">AND</span> age<span class="operator">=</span><span class="number">25</span>;</span><br></pre></td></tr></table></figure>

<img src="/post/65a5b0d7/image-20250302111116621.png" class="" title="image-20250302111116621">

<p>之前的版本<code>Extra</code>中应该是<code>Using where</code>，因为需要回表确认数据是否存在。</p>
<p>优化方案：添加覆盖索引覆盖统计需要的所有字段</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> users <span class="keyword">ADD</span> INDEX idx_covering(city, age, id);</span><br></pre></td></tr></table></figure>

<p>最左前缀索引优化</p>
<p>查询需求：查询北京地区年龄大于 30 岁的用户，并按注册时间排序</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> city<span class="operator">=</span><span class="string">&#x27;北京&#x27;</span> <span class="keyword">AND</span> age<span class="operator">&gt;</span> <span class="number">30</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> created_at LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<img src="/post/65a5b0d7/image-20250302111551681.png" class="" title="image-20250302111551681">

<p>从<code>EXPLAIN</code>结果可以看出，这条查询语句需要用到耗时的文件排序，这是因为查询条件中存在范围查询，导致不能完全利用上组合索引。</p>
<p>优化方案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> users <span class="keyword">ADD</span> INDEX idx_city_created_age(city, created_at, age);</span><br></pre></td></tr></table></figure>

<img src="/post/65a5b0d7/image-20250302112330725.png" class="" title="image-20250302112330725">



<p>索引设计规范：</p>
<ul>
<li>组合索引字段按区分度从高到低排序</li>
<li>索引列数≤5列，避免更新开销太大</li>
<li>禁止<code>SELECT *</code>，尽量查询索引能覆盖的字段</li>
</ul>
<h3 id="慢查询优化"><a href="#慢查询优化" class="headerlink" title="慢查询优化"></a>慢查询优化</h3><p>慢查询优化流程：</p>
<ol>
<li>抓取慢日志：<code>long_query_time=1s</code></li>
<li><code>EXPLAIN</code> 分析执行计划</li>
<li>检查索引使用情况<ul>
<li>是否触发覆盖索引</li>
<li>是否违反最左前缀原则</li>
</ul>
</li>
<li>使用<code>force index</code>验证索引有效性</li>
<li>调整索引或SQL写法</li>
</ol>
<ul>
<li>索引优化</li>
<li>使用覆盖索引，避免回表</li>
<li>最左前缀匹配，</li>
</ul>
<p>监控指标</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看索引使用频率</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.schema_index_statistics <span class="keyword">WHERE</span> table_name<span class="operator">=</span><span class="string">&#x27;users&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检查冗余索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.schema_redundant_indexes;</span><br></pre></td></tr></table></figure>



<h3 id="为什么InnoDB不保存表的总行数"><a href="#为什么InnoDB不保存表的总行数" class="headerlink" title="为什么InnoDB不保存表的总行数"></a>为什么InnoDB不保存表的总行数</h3><p>与MyISAM保存表的总行数不同，InnoDB统计行数需要扫描全表，因为MVCC，同一时刻多个查询返回的行数可能不一致。</p>
<p>对于需要经常统计表的行数的解决办法：</p>
<ul>
<li>在缓存（如 Redis）中保存计数</li>
<li>在 MySQL 中保存计数</li>
</ul>
<table>
<thead>
<tr>
<th><strong>语法</strong></th>
<th><strong>统计逻辑</strong></th>
<th><strong>是否包含 NULL</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>COUNT(*)</code></td>
<td>统计所有行（包括所有列），即使所有字段都为 <code>NULL</code> 也会计数</td>
<td><strong>包含</strong></td>
</tr>
<tr>
<td><code>COUNT(1)</code></td>
<td>统计所有行（<code>1</code> 是常量表达式，与列无关）</td>
<td><strong>包含</strong></td>
</tr>
<tr>
<td><code>COUNT(id)</code></td>
<td>统计 <code>id</code> 列中 <strong>非 NULL</strong> 的行数（<code>id</code> 是主键或普通列）</td>
<td><strong>不包含 NULL</strong></td>
</tr>
<tr>
<td><code>COUNT(某个字段)</code></td>
<td>统计该字段中 <strong>非 NULL</strong> 的行数（如果字段允许 <code>NULL</code>）</td>
<td><strong>不包含 NULL</strong></td>
</tr>
</tbody></table>
<p>性能：<code>count(字段)</code> &lt; <code>count(主键)</code> &lt; <code>count(1)</code> ≈ <code>count(*)</code></p>
<p><code>count(主键/字段)</code> 的效率更低的原因是需要解析数据行，并拷贝要返回的字段值。</p>
<h3 id="解释一下事务的基本特性和隔离级别"><a href="#解释一下事务的基本特性和隔离级别" class="headerlink" title="解释一下事务的基本特性和隔离级别"></a>解释一下事务的基本特性和隔离级别</h3><p>事务保证一组操作要么全部成功，要么全部失败。在 MySQL 中，事务支持是在引擎层实现的。</p>
<table>
<thead>
<tr>
<th>基本特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>原子性（<code>atomicity</code>）</td>
<td>事务中的操作要么全都执行，要么都不执行</td>
</tr>
<tr>
<td>一致性（<code>consistency</code>）</td>
<td>事务的执行要保证数据的完整性和一致性</td>
</tr>
<tr>
<td>隔离性（<code>isolation</code>）</td>
<td>事务的执行互不干扰</td>
</tr>
<tr>
<td>持久性（<code>durability</code>）</td>
<td>事务一旦提交，对数据的修改就永久保存到数据库中，不可撤销</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>事务可能引发的问题</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>脏读</td>
<td>A 事务读取 B 事务尚未提交的修改</td>
</tr>
<tr>
<td>不可重复读</td>
<td>A 事务多次读取同一数据，结果前后不一致</td>
</tr>
<tr>
<td>幻读</td>
<td>A 事务多次读取，数据总量前后不一致</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>说明</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td><code>read uncommitted</code></td>
<td>一个事务执行过程中，能看到其他未提交事务做的变更</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td><code>read committed</code></td>
<td>一个事务执行过程中，能看到其他已提交事务做的变更（MySQL 会在每个 SQL 语句开始执行时创建一个视图）</td>
<td></td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td><code>repeatable read</code></td>
<td>一个事务执行过程中，其他事务的变更对它不可见（MySQL 会在事务启动时创建一个视图，整个事务执行期间都使用这个视图）</td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td><code>serializable</code></td>
<td>事务串行执行，隔离级别最高，不会出现上面所说的问题，但相应的效率也最低</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="InnoDB如何解决幻读"><a href="#InnoDB如何解决幻读" class="headerlink" title="InnoDB如何解决幻读"></a>InnoDB如何解决幻读</h3><p>InnoDB解决幻读主要靠以下三大核心机制：</p>
<ul>
<li>多版本并发控制（<code>MVCC</code>）</li>
<li>间隙锁（<code>Gap Lock</code>）</li>
<li>临键锁（<code>Next-Key Lock</code>）</li>
</ul>
<p><strong><code>MVCC</code>实现原理：</strong></p>
<ul>
<li><code>Undo log</code>：每条数据维护多个历史版本</li>
<li><code>ReadView</code>：快照</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ReadView结构：</span><br><span class="line">&#123;</span><br><span class="line">  creator_trx_id: 150,      -- 当前事务ID</span><br><span class="line">  m_ids: [100, 120, 140],   -- 活跃事务ID列表</span><br><span class="line">  min_trx_id: 100,          -- 最小活跃事务ID</span><br><span class="line">  max_trx_id: 150           -- 预分配最大事务ID</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可见性判断规则</strong>：</p>
<ol>
<li>数据版本<code>trx_id</code> &lt; <code>min_trx_id</code> → 可见</li>
<li><code>trx_id</code>在<code>m_ids</code>中 → 不可见</li>
<li><code>trx_id</code> &gt;&#x3D; <code>max_trx_id</code> → 不可见</li>
</ol>
<p>InnoDB默认会为每行数据生成两个隐藏列：</p>
<ul>
<li><code>DB_TRX_ID</code>：最后修改该行的事务ID</li>
<li><code>DB_ROLL_PTR</code>：指向<code>Undo Log</code>的回滚指针</li>
</ul>
<p>不同隔离级别下<code>ReadView</code>的生成时机：</p>
<ul>
<li><code>READ COMMITTED(RC)</code>：每次<code>SELECT</code>都会创建新的<code>ReadView</code></li>
<li><code>REPEATABLE READ(RR)</code>：事务中第一次<code>SELECT</code>时创建<code>ReadView</code></li>
</ul>
<p><strong>间隙锁（<code>Gap Lock</code>）</strong></p>
<p>锁定记录之间的间隙，不锁定记录本身。防止幻读。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 表数据：5, 10, 15</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">10</span> <span class="keyword">AND</span> id <span class="operator">&lt;</span> <span class="number">20</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>这条语句会锁定区间 <code>(10,15)</code>、<code>(15,+∞)</code>，在事务执行期间，其他事务无法在这两个区间插入数据</p>
<p><strong>临键锁（<code>Next-Key Lock</code>）</strong></p>
<p>锁定记录本身及之前的间隙。同时防止幻读和不可重复读。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 事务A执行：</span><br><span class="line">SELECT * FROM users WHERE id &gt; 15 AND id &lt; 25 FOR UPDATE;</span><br><span class="line">-- 假设存在id=20的记录，临键锁会锁定：(15,20],(20,+∞)</span><br></pre></td></tr></table></figure>



<p><strong>Q1：RR隔离级别如何既使用MVCC又用锁？</strong></p>
<ul>
<li><strong>快照读</strong>（普通SELECT）：依赖MVCC保证一致性</li>
<li><strong>当前读</strong>（SELECT FOR UPDATE）：使用临键锁保证物理数据一致</li>
</ul>
<p><strong>Q2：Gap Lock是否会导致死锁？</strong></p>
<p>间隙锁是有可能导致死锁的，如：事务A锁(5,10)，事务B锁(10,15)，两者同时请求对方区间的插入</p>
<p>解决方案：设置<code>innodb_deadlock_detect=ON</code>（默认开启检测）</p>
<p><strong>Q3：Purge线程的作用是什么？</strong></p>
<p>清理不再被任何事务需要的<code>Undo Log</code>，回收版本链中的过期数据版本</p>
<h3 id="InnoDB和MyISAM的区别"><a href="#InnoDB和MyISAM的区别" class="headerlink" title="InnoDB和MyISAM的区别"></a>InnoDB和MyISAM的区别</h3><table>
<thead>
<tr>
<th></th>
<th>MyISAM</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td>锁</td>
<td>表级锁</td>
<td>行级锁</td>
</tr>
<tr>
<td>事务支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>索引结构</td>
<td>B树</td>
<td>B+树</td>
</tr>
<tr>
<td>全文检索</td>
<td>支持</td>
<td>5.5版本后支持</td>
</tr>
</tbody></table>
<p>总体来说，如果需要支持事务、外键约束和高并发访问，那么InnoDB是更好的选择。如果需要进行全文检索，那么MyISAM是更好的选择。但是需要注意的是，MySQL 5.5版本之后，InnoDB已经支持了全文检索。</p>
<h3 id="为什么有时索引会失效或选错索引"><a href="#为什么有时索引会失效或选错索引" class="headerlink" title="为什么有时索引会失效或选错索引"></a>为什么有时索引会失效或选错索引</h3><p>索引失效的常见场景：</p>
<ul>
<li>违反最左前缀原则</li>
<li>对索引列进行运算或函数操作</li>
<li>使用 <code>or</code> 连接非索引列</li>
<li>索引列存在大量重复值，如性别</li>
<li>使用 <code>like &#39;%地址&#39;</code></li>
</ul>
<p>选错索引的常见原因：</p>
<ul>
<li><p>统计信息不准确：优化器依赖的统计信息（如 <code>cardinality</code>）过时，误判索引效率。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 表数据分布已变化，但统计信息未更新</span><br><span class="line">ANALYZE TABLE users; -- 手动更新统计信息</span><br></pre></td></tr></table></figure>
</li>
<li><p>索引覆盖不足：索引未覆盖查询所需字段，导致回表成本过高。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 索引 (a) 无法覆盖 SELECT *</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用覆盖索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">table</span> <span class="keyword">ADD</span> INDEX idx_a_b_c (a, b, c);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="如何优化查询"><a href="#如何优化查询" class="headerlink" title="如何优化查询"></a>如何优化查询</h3><ol>
<li>编写高效的查询语句：合理编写查询语句是查询优化的基础。避免使用复杂的嵌套查询和子查询，尽量使用简单的查询语句；避免使用过多的通配符，尽量指定具体的查询条件；使用合适的连接方式，如INNER JOIN、LEFT JOIN、RIGHT JOIN等；避免使用不必要的排序和分组。</li>
<li>使用索引：合理使用索引可以显著提高查询性能。在查询条件中频繁使用的列上创建索引，避免在大表上进行全表扫描。</li>
<li>避免使用SELECT *：在查询时，避免使用SELECT *，而是只选择需要的列。这样可以减少数据库传输和处理的数据量，提高查询效率。</li>
<li>优化子查询和嵌套查询：子查询和嵌套查询可能导致查询性能下降，尽量避免在查询中多次嵌套子查询。可以考虑使用连接（JOIN）操作、临时表等替代子查询，从而优化查询性能。</li>
<li>使用合适的数据类型：在数据库设计和查询中，使用合适的数据类型可以避免数据类型转换和隐式转换，提高查询性能。例如，对于整数类型的列，使用整数类型的数据而不是字符类型的数据，可以提高查询效率。</li>
</ol>
<h3 id="为什么有时只查询一行但是很慢"><a href="#为什么有时只查询一行但是很慢" class="headerlink" title="为什么有时只查询一行但是很慢"></a>为什么有时只查询一行但是很慢</h3><ol>
<li>数据库表中数据量增加：随着表中数据量的增加，查询一行的时间可能会变得更长。</li>
<li>索引失效：如果查询条件中使用的列没有索引，或者索引失效（例如索引统计信息过期或者索引损坏），数据库可能会执行全表扫描或者其他低效的查询方法，从而导致查询一行的性能下降。</li>
<li>查询复杂度增加：如果查询的复杂度增加，例如涉及到多个表的联接、子查询、聚合函数等，查询一行的性能可能会受到影响。</li>
<li>数据库服务器负载增加：如果数据库服务器负载增加，例如同时有大量的查询和写入操作，数据库的性能可能会下降，从而导致查询一行变得很慢。</li>
</ol>
<h3 id="慢SQL优化全流程"><a href="#慢SQL优化全流程" class="headerlink" title="慢SQL优化全流程"></a>慢SQL优化全流程</h3><p><strong>阶段1：问题定位与数据采集</strong></p>
<ul>
<li>开启慢日志查询</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 动态开启（重启失效）</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log <span class="operator">=</span> <span class="string">&#x27;ON&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> long_query_time <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">-- 阈值设为1秒</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log_file <span class="operator">=</span> <span class="string">&#x27;/var/log/mysql/slow.log&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 永久配置（my.cnf）</span><br><span class="line">[mysqld]</span><br><span class="line">slow_query_log = 1</span><br><span class="line">long_query_time = 1</span><br><span class="line">log_queries_not_using_indexes = 1  -- 记录未走索引的查询</span><br></pre></td></tr></table></figure>

<ul>
<li>实时监测工具</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前运行中的慢查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.PROCESSLIST </span><br><span class="line"><span class="keyword">WHERE</span> <span class="type">TIME</span> <span class="operator">&gt;</span> <span class="number">2</span> <span class="keyword">AND</span> COMMAND <span class="operator">=</span> <span class="string">&#x27;Query&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用Percona Toolkit抓取问题SQL</span></span><br><span class="line">pt<span class="operator">-</span>query<span class="operator">-</span>digest <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysql<span class="operator">/</span>slow.log</span><br></pre></td></tr></table></figure>

<ul>
<li>关键性能指标</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">重点监控项：</span><br><span class="line">- QPS/TPS波动</span><br><span class="line">- CPU使用率（特别是%sys）</span><br><span class="line">- 锁等待时间(Innodb_row_lock_time_avg)</span><br><span class="line">- 缓冲池命中率(Innodb_buffer_pool_reads)</span><br></pre></td></tr></table></figure>



<p>Q：<code>IN</code> 和 <code>EXISTS</code> 的区别</p>
<p>当使用 <code>IN</code> 时，MySQL 会首先执行子查询，然后将子查询的结果集用于外部查询的条件。这意味着子查询的结果集需要全部加载到内存中。</p>
<p>而 <code>EXISTS</code> 会对外部查询的每一行，执行一次子查询。如果子查询返回任何行，则 <code>EXISTS</code> 条件为真。<code>EXISTS</code> 关注的是子查询是否返回行，而不是返回的具体值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- IN 的临时表可能成为性能瓶颈</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> user_id <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> amount <span class="operator">&gt;</span> <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- EXISTS 可以利用关联索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users u</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> orders o </span><br><span class="line">            <span class="keyword">WHERE</span> o.user_id <span class="operator">=</span> u.id <span class="keyword">AND</span> o.amount <span class="operator">&gt;</span> <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p><code>IN</code> 适用于子查询结果集较小的情况。如果子查询返回大量数据，<code>IN</code> 的性能可能会下降，因为它需要将整个结果集加载到内存。</p>
<p>而 EXISTS 适用于子查询结果集可能很大的情况。由于 <code>EXISTS</code> 只需要判断子查询是否返回行，而不需要加载整个结果集，因此在某些情况下性能更好，特别是当子查询可以使用索引时。</p>
<p><strong>NULL值陷</strong></p>
<p><code>IN</code>: 如果子查询的结果集中包含 <code>NULL</code> 值，可能会导致意外的结果。例如，<code>WHERE column IN (subquery)</code>，如果 <code>subquery</code> 返回 <code>NULL</code>，则 <code>column IN (subquery)</code> 永远不会为真，除非 <code>column</code> 本身也为 <code>NULL</code>。</p>
<p><code>EXISTS</code>: 对 <code>NULL</code> 值的处理更加直接。<code>EXISTS</code> 只是检查子查询是否返回行，不关心行的具体值，因此不受 <code>NULL</code> 值的影响。</p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="Redis为什么快？单线程如何处理高并发？"><a href="#Redis为什么快？单线程如何处理高并发？" class="headerlink" title="Redis为什么快？单线程如何处理高并发？"></a>Redis为什么快？单线程如何处理高并发？</h3><p>对于Redis的高性能设计，我的理解主要得益于以下几点：</p>
<ul>
<li>内存操作：Redis数据存储在内存，相比于磁盘数据库，减少了IO开销</li>
<li>高效的数据结构：Redis针对不同场景设计了不同的数据结构，优化了空间和访问效率</li>
<li>单线程：Redis使用单线程处理命令，避免了多线程之间的竞争和上下文切换的开销</li>
<li>IO多路复用：Redis基于epoll&#x2F;kqueue实现了非阻塞的网络模型，通过事件机制循环处理请求</li>
</ul>
<p><strong>追问1：单线程如何利用多核CPU</strong></p>
<p>可以部署分片集群，每个Redis实例绑定一个CPU核（如何部署和绑定？）</p>
<p><strong>追问2：为什么选用单线程而不是多线程</strong></p>
<ul>
<li>避免锁竞争</li>
<li>避免上下文切换开销</li>
<li>多线程内存管理复杂</li>
</ul>
<p><strong>追问3： 什么场景下单线程会成为瓶颈</strong></p>
<ul>
<li>超大 Value 操作（如10MB的string）（什么操作，普通读写就会阻塞吗）</li>
<li>复杂 Lua 脚本执行（阻塞其他命令）</li>
</ul>
<p><strong>Q：Redis有哪些数据结构，分别有哪些使用场景场景？</strong></p>
<p>Redis的基础数据结构包括string、hash、list、set、zset，高级数据结构包括hyperloglog、geo、bitmap、stream</p>
<h3 id="解释一下缓存穿透-雪崩-击穿，对应的解决方案是什么"><a href="#解释一下缓存穿透-雪崩-击穿，对应的解决方案是什么" class="headerlink" title="解释一下缓存穿透&#x2F;雪崩&#x2F;击穿，对应的解决方案是什么"></a>解释一下缓存穿透&#x2F;雪崩&#x2F;击穿，对应的解决方案是什么</h3><p><strong>缓存穿透</strong>是指查询数据库中不存在的数据，导致请求每次都穿过缓存查询数据库。</p>
<p>解决方案：</p>
<ul>
<li><strong>布隆过滤器（Bloom Filter）</strong></li>
</ul>
<p>服务启动时加载全量有效key，标记数据是否存在；新增数据时同步更新过滤器</p>
<p>缺点：存在一定的误判率</p>
<ul>
<li><strong>缓存空值</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getData</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> redis.get(key);</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> NullValue) &#123; <span class="comment">// 空值标记</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    value = db.query(key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        redis.setex(key, <span class="number">300</span>, <span class="keyword">new</span> <span class="title class_">NullValue</span>()); <span class="comment">// 缓存空值5分钟</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redis.setex(key, <span class="number">3600</span>, value); <span class="comment">// 正常缓存1小时</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>增强请求参数的复杂度，避免被猜测，同时做好数据的基础格式校验</li>
</ul>
<p><strong>缓存雪崩</strong>是指<strong>大量key</strong>同时失效，导致大量请求都去查询数据库，造成数据库压力骤增。</p>
<p>解决方案：</p>
<ul>
<li><strong>差异化过期时间</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基础过期时间，1小时</span></span><br><span class="line"><span class="type">int</span> <span class="variable">baseExpire</span> <span class="operator">=</span> <span class="number">3600</span>;</span><br><span class="line"><span class="comment">// 随机0-5分钟</span></span><br><span class="line"><span class="type">int</span> <span class="variable">randomExpire</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">300</span>);</span><br><span class="line">redis.setex(key, baseExpire + randomExpire, value);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>永不过期+异步更新</strong></li>
<li><strong>添加降级限流策略</strong></li>
<li><strong>添加多级缓存</strong></li>
</ul>
<p><strong>缓存击穿</strong>是指某个<strong>热点key</strong>失效的瞬间，有大量请求同时访问这个key，导致所有请求都去查询数据库。</p>
<p>解决方案：</p>
<ul>
<li><strong>互斥锁</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> Redission.getLock(<span class="string">&quot;PREFIX:&quot;</span> + key);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lock.tryLock(<span class="number">3</span>, <span class="number">30</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">        <span class="comment">// 查库并重建缓存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>逻辑过期</strong></li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;真实数据&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;expire_ts&quot;</span><span class="punctuation">:</span> <span class="number">1672502400</span> <span class="comment">// 逻辑过期时间戳</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>处理流程：</p>
<ol>
<li>判断逻辑过期时间<ol>
<li>未过期，直接返回数据</li>
<li>已过期，创建子线程，异步重建缓存</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th>解决方案</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>互斥锁</td>
<td>实现简单；保证一致性；无需消耗额外内存</td>
<td>线程需等待，影响性能</td>
</tr>
<tr>
<td>逻辑过期</td>
<td>线程无需等待，性能较好</td>
<td>存在不一致性；消耗额外内存；实现复杂</td>
</tr>
</tbody></table>
<h3 id="RDB和AOF持久化原理及优劣对比"><a href="#RDB和AOF持久化原理及优劣对比" class="headerlink" title="RDB和AOF持久化原理及优劣对比"></a>RDB和AOF持久化原理及优劣对比</h3><p>RDB，存储某一时刻内存中所有的数据，触发命令<code>save</code>、<code>bgsave</code>，主进程<code>fork</code>子进程，阻塞。</p>
<p>触发条件：</p>
<ol>
<li>客户端发送<code>shutdown</code></li>
<li>从节点要进行全量复制</li>
<li>达到<code>redis.conf</code>文件中配置的条件</li>
<li>客户端执行<code>flushall</code>（生成空的<code>dump.rdb</code>，慎用）</li>
</ol>
<p>不能频繁生成 RBD 快照，原因：</p>
<ul>
<li>多次 RDB 会竞争磁盘带宽</li>
<li><code>fork</code> 子进程会阻塞主进程</li>
</ul>
<p>写时复制<code>copy-on-write</code>：</p>
<ul>
<li><strong>共享内存初始化</strong>：子进程刚创建时，<strong>与父进程共享全部内存页</strong>，此时内存占用几乎无额外开销。</li>
<li><strong>写操作触发复制</strong>：若父进程收到写请求（修改数据），操作系统会<strong>将被修改的内存页复制一份</strong>，父进程在副本上修改，子进程仍读取原始页。</li>
<li><strong>子进程视角固定</strong>：子进程看到的数据始终是 <code>fork()</code> 瞬间的状态，确保快照一致性。</li>
</ul>
<p>AOF，所有写命令追加到 <code>aof_buf</code>，刷盘策略由 <code>appendfsync</code> 决定。</p>
<p>如果有 AOF 文件，加载 AOF；否则，加载 RDB 文件。AOF 最多丢失 1s 数据。</p>
<p>AOF重写是直接为当前内存的数据生成对应命令，并不是读取旧AOF文件进行命令合并</p>
<ul>
<li>父子进程写同一个文件会产生竞争问题，影响父进程的性能。</li>
<li>如果AOF重写过程中失败了，相当于污染了原本的AOF文件，无法做恢复数据使用</li>
</ul>
<p>修复已损害的AOF文件：<code>redis-check-aof --fix appendonly.aof</code></p>
<table>
<thead>
<tr>
<th></th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody><tr>
<td>启动加载优先级</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>体积</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>恢复速度</td>
<td>慢</td>
<td>快</td>
</tr>
</tbody></table>
<p>总结：RDB适合用作数据备份，AOF适合用作数据恢复。</p>
<h3 id="什么是热Key问题"><a href="#什么是热Key问题" class="headerlink" title="什么是热Key问题"></a>什么是热Key问题</h3><h3 id="Redis事务与MySQL事务有什么区别"><a href="#Redis事务与MySQL事务有什么区别" class="headerlink" title="Redis事务与MySQL事务有什么区别"></a>Redis事务与MySQL事务有什么区别</h3><h3 id="使用Redis实现分布式锁的演进过程"><a href="#使用Redis实现分布式锁的演进过程" class="headerlink" title="使用Redis实现分布式锁的演进过程"></a>使用Redis实现分布式锁的演进过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.ValueOperations;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisDistributedLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_KEY</span> <span class="operator">=</span> <span class="string">&quot;myLock&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LOCK_EXPIRE_TIME</span> <span class="operator">=</span> <span class="number">5000</span>; <span class="comment">// 锁过期时间，单位毫秒</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisDistributedLock</span><span class="params">(RedisTemplate&lt;String, String&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">acquireLock</span><span class="params">()</span> &#123;</span><br><span class="line">        ValueOperations&lt;String, String&gt; valueOperations = redisTemplate.opsForValue();</span><br><span class="line">        <span class="comment">// 尝试获取分布式锁</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">result</span> <span class="operator">=</span> valueOperations.setIfAbsent(LOCK_KEY, <span class="string">&quot;locked&quot;</span>); <span class="comment">// RedisTemplate 的 setIfAbsent 方法，如果键不存在则设置键值对并返回 true，否则返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span> &amp;&amp; result) &#123;</span><br><span class="line">            <span class="comment">// 成功获取到锁，设置锁的过期时间</span></span><br><span class="line">            redisTemplate.expire(LOCK_KEY, LOCK_EXPIRE_TIME, TimeUnit.MILLISECONDS); <span class="comment">// 设置键的过期时间，单位毫秒</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">releaseLock</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.delete(LOCK_KEY); <span class="comment">// 删除键</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用分布式锁的业务逻辑</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBusinessWithLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acquireLock()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获得分布式锁后执行业务逻辑</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Acquired lock, do business logic...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>); <span class="comment">// 模拟业务处理时间</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                releaseLock(); <span class="comment">// 业务处理完成后释放锁</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Released lock.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 未获得分布式锁，执行其他逻辑</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Failed to acquire lock, do other logic...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 RedisTemplate 实例并设置连接信息</span></span><br><span class="line">        RedisTemplate&lt;String, String&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置 Redis 连接工厂、序列化方式等</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="type">RedisDistributedLock</span> <span class="variable">distributedLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisDistributedLock</span>(redisTemplate);</span><br><span class="line">        distributedLock.doBusinessWithLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>竞争条件（Race Condition）：在多个客户端同时尝试获取锁时，可能会出现竞争条件，导致多个客户端都成功获得锁，从而引发并发访问资源的问题。</li>
<li>死锁（Deadlock）：如果某个持有锁的客户端在业务处理期间发生异常或崩溃，导致没有释放锁的操作，可能会出现死锁的情况，导致其他客户端无法获得锁。</li>
<li>锁过期（Lock Expiration）：为了避免死锁，通常会给锁设置过期时间，但如果业务处理时间较长，超过了锁的过期时间，可能会导致其他客户端误认为锁已经释放，从而引发并发访问资源的问题。</li>
<li>锁的重入性（Lock Reentrancy）：在某些场景下，同一个客户端可能需要多次获取同一个锁，例如嵌套的业务处理逻辑。如果分布式锁没有支持锁的重入性，可能会导致同一个客户端无法在业务处理期间重新获取锁，从而引发死锁或并发访问资源的问题。</li>
<li>性能开销（Performance Overhead）：使用分布式锁可能会增加系统的性能开销，例如频繁的锁获取和锁释放操作，以及锁的管理和维护。如果锁的使用不当，可能会影响系统的性能和响应时间。</li>
</ol>
<h3 id="全量同步和增量同步的区别"><a href="#全量同步和增量同步的区别" class="headerlink" title="全量同步和增量同步的区别"></a>全量同步和增量同步的区别</h3><p>全量同步：master生成当前内存中所有数据的RDB文件，将RDB发送给slave。在此过程中，master将新的命令记录在<code>repl_backlog</code>中，后续再发送给slave。</p>
<p>执行时机：</p>
<ol>
<li>slave第一次连接到master</li>
<li>slave宕机太久，导致它在<code>repl_backlog</code>中的<code>offset</code>已经被覆盖掉了</li>
</ol>
<p>增量同步：salve将自己的<code>offset</code>发送到master，master将<code>repl_backlog</code>中<code>offset</code>之后的命令发送给slave</p>
<p>执行时机：</p>
<ol>
<li>slave断开重连之后，<code>repl_backlog</code>中的<code>offset</code>尚未被覆盖</li>
</ol>
<h3 id="内存淘汰策略与LRU实现"><a href="#内存淘汰策略与LRU实现" class="headerlink" title="内存淘汰策略与LRU实现"></a>内存淘汰策略与LRU实现</h3><table>
<thead>
<tr>
<th align="left"><strong>数据范围</strong></th>
<th align="left"><strong>策略</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>所有Key</strong></td>
<td align="left"><code>allkeys-lru</code></td>
<td align="left">从所有Key中淘汰最近最少使用的</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>allkeys-lfu</code></td>
<td align="left">从所有Key中淘汰最不经常使用的（Redis 4.0+）</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>allkeys-random</code></td>
<td align="left">从所有Key中随机淘汰</td>
</tr>
<tr>
<td align="left"><strong>过期Key</strong></td>
<td align="left"><code>volatile-lru</code></td>
<td align="left">从设置了过期时间的Key中淘汰最近最少使用的</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>volatile-lfu</code></td>
<td align="left">从设置了过期时间的Key中淘汰最不经常使用的</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>volatile-random</code></td>
<td align="left">从设置了过期时间的Key中随机淘汰</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>volatile-ttl</code></td>
<td align="left">淘汰剩余存活时间（TTL）最短的Key</td>
</tr>
<tr>
<td align="left"><strong>不淘汰</strong></td>
<td align="left"><code>noeviction</code>（默认）</td>
<td align="left">内存不足时拒绝写入，返回错误</td>
</tr>
</tbody></table>
<h3 id="Redis和MySQL的区别"><a href="#Redis和MySQL的区别" class="headerlink" title="Redis和MySQL的区别"></a>Redis和MySQL的区别</h3><table>
<thead>
<tr>
<th></th>
<th>Redis</th>
<th>MySQL</th>
</tr>
</thead>
<tbody><tr>
<td>数据结构</td>
<td>非结构化</td>
<td>结构化</td>
</tr>
<tr>
<td>持久化</td>
<td>可选持久化</td>
<td>默认持久化</td>
</tr>
<tr>
<td>事务支持</td>
<td>简单支持</td>
<td>支持完整的ACID</td>
</tr>
<tr>
<td>扩展性</td>
<td>通过分片水平扩展</td>
<td>复杂，需分库分表或中间件</td>
</tr>
<tr>
<td>数据一致性</td>
<td>最终一致性</td>
<td>强一致性</td>
</tr>
</tbody></table>
<p>总结：</p>
<ul>
<li>当需要复杂查询和事务支持，对数据一致性要求较高，需要长期持久化存储的场景，选择MySQL</li>
<li>当需要超高性能和灵活数据类型，对数据的一致性要求不那么高，且容忍一定的数据丢失的情况下，选择Redis</li>
</ul>
<h3 id="Redis和memchahed的区别"><a href="#Redis和memchahed的区别" class="headerlink" title="Redis和memchahed的区别"></a>Redis和memchahed的区别</h3><table>
<thead>
<tr>
<th></th>
<th>Redis</th>
<th>Memcached</th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>丰富的数据类型：string、hash、list等</td>
<td>只支持string</td>
</tr>
<tr>
<td>持久化</td>
<td>支持（RDB、AOF）</td>
<td>不支持</td>
</tr>
<tr>
<td>事务</td>
<td>简单支持（MULTI&#x2F;EXEC）</td>
<td>不支持</td>
</tr>
<tr>
<td>分布式</td>
<td>支持，集群自动分片</td>
<td>依赖客户端一致性哈希或第三方工具实现分布式</td>
</tr>
<tr>
<td>命令</td>
<td>支持丰富的命令</td>
<td>仅支持SET、GET、ADD、DELTE等基础操作</td>
</tr>
<tr>
<td>内存占用</td>
<td>复杂数据结构可能导致内存消耗较高</td>
<td>内存利用率高，但灵活性较低</td>
</tr>
</tbody></table>
<p>总结：</p>
<ul>
<li>需要复杂数据结构、持久化、事务支持和高可用性的场景，选择Redis</li>
<li>追求极致的性能和简单性，数据结构简单且无需持久化的场景，可以选择Memcached</li>
</ul>
<h3 id="Redis-IO多路复用"><a href="#Redis-IO多路复用" class="headerlink" title="Redis IO多路复用"></a>Redis IO多路复用</h3><p>常见的 I&#x2F;O 多路复用机制包括 select、poll 和 epoll 等。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>select</code></th>
<th><code>poll</code></th>
<th><code>epoll</code></th>
</tr>
</thead>
<tbody><tr>
<td>文件描述符限制</td>
<td>受 <code>FD_SETSIZE</code> 限制</td>
<td>无限制</td>
<td>无限制</td>
</tr>
<tr>
<td>时间复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>数据复制</td>
<td>需要</td>
<td>需要</td>
<td>不需要</td>
</tr>
<tr>
<td>工作方式</td>
<td>线性扫描</td>
<td>线性扫描</td>
<td>事件通知</td>
</tr>
<tr>
<td>内核支持</td>
<td>所有 UNIX 系统</td>
<td>所有 UNIX 系统</td>
<td>Linux 2.6 及以上版本</td>
</tr>
<tr>
<td>适用场景</td>
<td>少量连接</td>
<td>中等连接</td>
<td>大量并发连接</td>
</tr>
</tbody></table>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/redis-20240918114125.png" alt="有盐先生：IO 多路复用"></p>
<h3 id="Redis-6-0-多线程"><a href="#Redis-6-0-多线程" class="headerlink" title="Redis 6.0 多线程"></a>Redis 6.0 多线程</h3><p>在 Redis 6.0 中，多线程主要用来处理网络 IO 操作，命令解析和执行仍然是单线程完成，这样既可以发挥多核 CPU 的优势，又能避免锁和上下文切换带来的性能损耗。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-b7b24e25-d2dc-4457-994f-95bdb3674b8e.png" alt="三分恶面渣逆袭：Redis6.0多线程"></p>
<h2 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h2><h3 id="Elasticsearch-的核心概念"><a href="#Elasticsearch-的核心概念" class="headerlink" title="Elasticsearch 的核心概念"></a><strong>Elasticsearch 的核心概念</strong></h3><ul>
<li><strong>文档：</strong> 数据的基本单位，通常是 JSON 格式。相当于数据库中的一行记录。</li>
<li><strong>索引：</strong> 具有相似特征的文档集合。相当于数据库中的一个表。一个索引对应一个或多个分片。</li>
<li><strong>类型：</strong> (7.x 之前) 索引内部的逻辑分区，允许在同一索引中存储不同类型的文档（如 <code>user</code>, <code>product</code>）。(<strong>注意：</strong> 在 7.x 中类型被废弃，8.x 中完全移除。现在一个索引通常只包含一种文档类型)。</li>
<li><strong>分片：</strong> 索引被水平分割成的子集。每个分片本身就是一个功能完整且独立的“索引”。<ul>
<li><strong>主分片：</strong> 存储文档数据和处理索引&#x2F;更新操作。索引创建时指定数量，后续不可更改（除非 Reindex）。</li>
<li><strong>副本分片：</strong> 主分片的拷贝。提供高可用性（主分片故障时副本可提升为主）和读取吞吐量（查询可负载均衡到所有副本）。</li>
</ul>
</li>
<li><strong>节点：</strong> 运行中的 Elasticsearch 实例。</li>
<li><strong>集群：</strong> 一个或多个节点协同工作的集合，共同持有整个数据并提供联合索引和搜索能力。</li>
<li><strong>倒排索引：</strong> ES 实现快速全文搜索的核心数据结构。它存储了词项（Token）到包含该词项的文档 ID 列表的映射。相比传统数据库的正排索引（文档 ID 到字段值），它更擅长回答“哪些文档包含某个词？”的问题。</li>
</ul>
<h3 id="什么是倒排索引？为什么它对搜索很重要？"><a href="#什么是倒排索引？为什么它对搜索很重要？" class="headerlink" title="什么是倒排索引？为什么它对搜索很重要？"></a><strong>什么是倒排索引？为什么它对搜索很重要？</strong></h3><ul>
<li><strong>定义：</strong> 倒排索引是一种将文档中的词项（Token）映射到包含该词项的文档列表的数据结构。它包含两个核心部分：<ul>
<li><strong>词项字典：</strong> 包含所有不重复的词项（Token），通常按字典序排序。</li>
<li><strong>倒排列表：</strong> 对于每个词项，记录包含该词项的所有文档 ID 列表（Postings List），以及词项在文档中出现的位置（Position）、频率（Term Frequency）等信息（用于相关性评分）。</li>
</ul>
</li>
<li><strong>重要性：</strong><ul>
<li><strong>快速定位：</strong> 直接通过词项找到包含它的文档，避免了扫描所有文档。</li>
<li><strong>高效布尔查询：</strong> AND&#x2F;OR&#x2F;NOT 操作可以通过对倒排列表进行交&#x2F;并&#x2F;差集运算高效完成。</li>
<li><strong>相关性评分基础：</strong> TF-IDF、BM25 等经典评分模型严重依赖倒排索引中存储的词频（TF）、文档频率（DF&#x2F;IDF）信息。</li>
<li><strong>支持短语查询：</strong> 利用存储的位置信息，可以精确查找相邻出现的词组。</li>
</ul>
</li>
</ul>
<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><ol>
<li>Kafka高吞吐量实现原理</li>
<li>消息丢失与重复消费解决方案</li>
<li>顺序消息实现方案</li>
<li>延迟消息实现原理</li>
<li>死信队列应用场景</li>
<li>消息堆积处理策略</li>
<li>RocketMQ事务消息流程</li>
<li>Pulsar分层存储架构优势</li>
<li>如何设计消息轨迹系统？</li>
<li>Broker选举机制对比（Kafka vs RocketMQ）</li>
</ol>
<h3 id="Kafka-为什么能实现高吞吐量？"><a href="#Kafka-为什么能实现高吞吐量？" class="headerlink" title="Kafka 为什么能实现高吞吐量？"></a>Kafka 为什么能实现高吞吐量？</h3><ul>
<li><strong>顺序读写磁盘:</strong> 消息按顺序追加到 Partition 文件末尾，充分利用磁盘顺序 I&#x2F;O 的高性能（远高于随机 I&#x2F;O）。</li>
<li><strong>Page Cache:</strong> 利用操作系统 Page Cache 缓存数据，减少直接磁盘访问。</li>
<li><strong>零拷贝 (Zero-Copy):</strong> 使用 <code>**sendfile**</code> 和 <code>**mmap**</code> 等技术，减少数据在用户空间和内核空间之间的拷贝次数，降低 CPU 开销和上下文切换。</li>
<li><strong>批量处理 (Batching):</strong> Producer 批量发送消息，Broker 批量写入磁盘和批量发送给 Consumer，减少网络和 I&#x2F;O 开销。</li>
<li><strong>消息压缩:</strong> Producer 端可配置压缩算法 (Snappy, LZ4, Gzip, Zstd)，减少网络传输和磁盘存储开销。</li>
<li><strong>Partition 并行:</strong> Topic 被分成多个 Partition，分布在多个 Broker 上，读写操作可以并行发生在不同 Partition，充分利用多 Broker、多磁盘、多核 CPU。</li>
</ul>
<h3 id="解释-Kafka-中-Topic、Partition、Replica-的关系"><a href="#解释-Kafka-中-Topic、Partition、Replica-的关系" class="headerlink" title="解释 Kafka 中 Topic、Partition、Replica 的关系"></a>解释 Kafka 中 Topic、Partition、Replica 的关系</h3><ul>
<li><strong>Topic</strong> 是消息发布的类别或主题。</li>
<li>一个 <strong>Topic</strong> 被划分为一个或多个 <strong>Partition</strong>。Partition 是物理存储单元，分布在不同的 Broker 上。</li>
<li>每个 <strong>Partition</strong> 可以有多个 <strong>Replica</strong> (副本)。其中一个 Replica 是 <strong>Leader</strong>，负责读写；其他是 <strong>Follower</strong>，只负责从 Leader 同步数据。Replica 也分布在不同的 Broker 上，提供容错能力。</li>
</ul>
<h3 id="Producer-的-acks-参数有哪几种？分别代表什么含义？"><a href="#Producer-的-acks-参数有哪几种？分别代表什么含义？" class="headerlink" title="Producer 的 acks 参数有哪几种？分别代表什么含义？"></a>Producer 的 <code>acks</code> <strong>参数有哪几种？分别代表什么含义？</strong></h3><ul>
<li><code>**acks=0**</code>: Producer 发送消息后<strong>不等待</strong> Broker 的任何确认。<strong>最高吞吐，最低延迟，最低可靠性</strong> (可能丢失数据)。</li>
<li><code>**acks=1**</code>: Producer 发送消息后，等待 <strong>Leader 副本成功写入本地日志</strong> 的确认。<strong>折中方案</strong>。Leader 故障但数据未同步到 Follower 时可能丢失数据。</li>
<li><code>**acks=all**</code> <strong>(或</strong> <code>**acks=-1**</code><strong>)</strong>: Producer 发送消息后，等待 <strong>Leader 收到消息并确认该消息已被当前 ISR 集合中的所有副本成功写入本地日志</strong>。<strong>最高可靠性</strong>，最低丢失风险，但延迟最高，吞吐可能最低。需要配合 <code>**min.insync.replicas**</code> 参数使用。</li>
</ul>
<h3 id="解释-Consumer-Group-和-Rebalance-的概念。"><a href="#解释-Consumer-Group-和-Rebalance-的概念。" class="headerlink" title="解释 Consumer Group 和 Rebalance 的概念。"></a>解释 Consumer Group 和 Rebalance 的概念。</h3><ul>
<li><strong>Consumer Group (CG):</strong> 一组 Consumer 实例的集合，它们共同消费一个或多个 Topic。组内消费实例<strong>协作消费</strong>订阅 Topic 的所有 Partition。一个 Partition 只能被组内<strong>一个</strong> Consumer 实例消费，实现负载均衡。</li>
<li><strong>Rebalance (重平衡):</strong> 当以下情况发生时，Kafka 会重新分配 CG 内 Consumer 负责的 Partition：</li>
<li>组内 Consumer 数量变化 (新 Consumer 加入、Consumer 崩溃或主动离开)。</li>
<li>订阅的 Topic Partition 数量变化 (如 Topic 被修改增加了 Partition)。</li>
<li>订阅的 Topic 本身变化。</li>
<li><strong>影响:</strong> Rebalance 期间，整个 CG 会<strong>短暂停止消费</strong>，直到分配完成。频繁或长时间的 Rebalance 会影响消费进度和系统稳定性。</li>
</ul>
<h3 id="Kafka-如何保证消息不丢失？"><a href="#Kafka-如何保证消息不丢失？" class="headerlink" title="Kafka 如何保证消息不丢失？"></a>Kafka 如何保证消息不丢失？</h3><ul>
<li><strong>Producer 端:</strong></li>
<li>设置 <code>**acks=all**</code>，确保消息被 ISR 所有副本确认。</li>
<li>使用带回调的异步发送或同步发送，正确处理发送失败（重试 + 业务逻辑处理）。</li>
<li>设置 <code>**retries**</code> &gt; 0 和合理的 <code>**retry.backoff.ms**</code>。</li>
<li><strong>Broker 端:</strong></li>
<li>设置 <code>**unclean.leader.election.enable=false**</code>，防止落后太多的非 ISR 副本成为 Leader（可能导致数据丢失）。</li>
<li>设置 <code>**replication.factor &gt;= 3**</code>，保证足够的副本数。</li>
<li>设置 <code>**min.insync.replicas &gt; 1**</code> (通常 &#x3D; <code>**replication.factor - 1**</code>)，确保 ISR 最小存活副本数。当 ISR 数量不足 <code>**min.insync.replicas**</code> 时，Producer <code>**acks=all**</code> 的请求会失败。</li>
<li>确保 Broker 磁盘可靠 (RAID，监控)。</li>
<li><strong>Consumer 端:</strong></li>
<li>关闭自动提交 (<code>**enable.auto.commit=false**</code>)，在消息<strong>业务逻辑处理完成并确认成功后</strong>再<strong>手动提交 Offset</strong>。</li>
<li>处理好消费逻辑异常，避免因异常导致消息未处理但 Offset 已提交。</li>
</ul>
<h3 id="解释-Kafka-的-ISR-机制及其在-Leader-选举中的作用。"><a href="#解释-Kafka-的-ISR-机制及其在-Leader-选举中的作用。" class="headerlink" title="解释 Kafka 的 ISR 机制及其在 Leader 选举中的作用。"></a>解释 Kafka 的 ISR 机制及其在 Leader 选举中的作用。</h3><ul>
<li><strong>ISR (In-Sync Replicas):</strong> 指与 Partition Leader 副本<strong>保持同步</strong>的 Follower 副本集合。Leader 维护 ISR 列表。</li>
<li><strong>同步标准:</strong> Follower 副本在 <code>**replica.lag.time.max.ms**</code> 时间内成功从 Leader 拉取到最新数据。</li>
<li><strong>Leader 选举:</strong> 当 Leader 副本所在 Broker 宕机时，Controller 会<strong>从当前 ISR 集合中选择一个副本</strong>作为新的 Leader。这是为了保证新 Leader 拥有最新的已提交数据，避免数据丢失或不一致。</li>
<li><code>**unclean.leader.election.enable**</code><strong>:</strong></li>
<li><code>**false**</code> (默认推荐): 必须从 ISR 中选举 Leader。如果 ISR 为空，则分区不可用（牺牲可用性保一致性）。</li>
<li><code>**true**</code>: 允许从非 ISR (不同步) 的副本中选举 Leader。可能丢失数据或导致数据不一致（牺牲一致性保可用性）。</li>
</ul>
<h3 id="Kafka-如何实现-Exactly-Once-语义？"><a href="#Kafka-如何实现-Exactly-Once-语义？" class="headerlink" title="Kafka 如何实现 Exactly-Once 语义？"></a>Kafka 如何实现 Exactly-Once 语义？</h3><ul>
<li><strong>幂等性 (Idempotence -</strong> <code>**enable.idempotence=true**</code><strong>)：</strong></li>
<li>解决单个 Producer 会话内发送<strong>单分区</strong>的<strong>重复</strong>问题 (at-least-once 引起的重复)。</li>
<li>原理：Producer 为每个发送批次分配唯一 PID (Producer ID) 和序列号 (Sequence Number)。Broker 根据 PID+Partition+SeqNum 去重，丢弃重复的批次。</li>
<li><strong>事务 (Transactions)：</strong></li>
<li>解决跨分区、跨会话的“读-处理-写”模式下的<strong>精确一次</strong>语义 (例如 Kafka Streams 应用)。</li>
<li>原理：</li>
<li>Producer 开启事务 (<code>**initTransactions()**</code>)。</li>
<li>发送的消息标记为事务性消息。</li>
<li>将消费和生产的 Offset 提交都包含在同一个事务中 (<code>**sendOffsetsToTransaction()**</code> + <code>**commitTransaction()**</code>)。</li>
<li>Broker 使用事务协调器 (Transaction Coordinator) 管理事务状态 (PREPARE_COMMIT, COMMITTED, ABORTED)。</li>
<li>消费者配置 <code>**isolation.level=read_committed**</code> 只读取已提交的事务消息。</li>
<li><strong>注意:</strong> 严格意义的端到端 EOS 还需要 Consumer 的输出操作是幂等的。</li>
</ul>
<h3 id="Kafka-如何保证消息的顺序性？"><a href="#Kafka-如何保证消息的顺序性？" class="headerlink" title="Kafka 如何保证消息的顺序性？"></a>Kafka 如何保证消息的顺序性？</h3><ul>
<li><strong>Kafka 仅保证单个 Partition 内消息的严格顺序 (FIFO)。</strong> 这是由其追加写入和单线程消费分区的特性保证的。</li>
<li><strong>无法保证跨 Partition 的消息全局顺序。</strong></li>
<li><strong>需要全局顺序怎么办？</strong> 将所有需要保证顺序的消息发送到<strong>同一个 Partition</strong>。通常通过为这些消息指定<strong>相同的 Key</strong> 来实现 (Producer 根据 Key 的哈希值决定 Partition)。</li>
<li><strong>需要分区顺序怎么办？</strong> 确保同一个 Key 的消息总是发到同一个 Partition (同样通过 Key 哈希)，则该 Key 相关的消息在该 Partition 内是顺序的。</li>
</ul>
<h3 id="Kafka-中-Zookeeper-和-KRaft-的区别？为什么-Kafka-要去-Zookeeper-化？"><a href="#Kafka-中-Zookeeper-和-KRaft-的区别？为什么-Kafka-要去-Zookeeper-化？" class="headerlink" title="Kafka 中 Zookeeper 和 KRaft 的区别？为什么 Kafka 要去 Zookeeper 化？"></a>Kafka 中 Zookeeper 和 KRaft 的区别？为什么 Kafka 要去 Zookeeper 化？</h3><ul>
<li><strong>Zookeeper (ZK)：</strong> 是 Kafka 2.7 及之前版本的核心外部依赖。负责：<ul>
<li>Broker 注册与发现</li>
<li>Controller 选举</li>
<li>Topic 配置存储</li>
<li>ACL 权限存储</li>
<li>(旧版) Consumer Offset 存储</li>
</ul>
</li>
<li><strong>KRaft：</strong> 是 Kafka 内部实现的基于 Raft 共识协议的元数据管理系统，从 Kafka 2.8 (预览) &#x2F; 3.0+ (生产可用) 开始引入，旨在完全取代 Zookeeper。</li>
<li><strong>去 ZK 化原因 (KRaft 优势)：</strong><ul>
<li><strong>简化架构与部署：</strong> 移除外部依赖，Kafka 自包含，部署、配置、监控更简单。</li>
<li><strong>提升性能与可伸缩性：</strong> 元数据操作直接在 Kafka 协议上处理，减少一次网络跳转和序列化开销。KRaft 设计上能更好地支持大规模集群（数万个 Partition）。</li>
<li><strong>更强的元数据一致性模型：</strong> KRaft 使用 Raft 强一致性协议管理元数据状态机。</li>
<li><strong>更直接的运维：</strong> 所有操作通过 Kafka API 或 <code>**kafka-metadata-shell**</code> 完成，无需单独管理 ZK。</li>
<li><strong>统一安全模型：</strong> 元数据通信复用 Kafka 的安全机制 (SSL&#x2F;SASL)，无需单独配置 ZK 安全。</li>
<li><strong>现状：</strong> KRaft 已成为生产推荐模式，新集群应优先使用 KRaft。Zookeeper 模式在逐步淘汰。</li>
</ul>
</li>
</ul>
<h3 id="什么是-Consumer-Lag？如何监控和处理-Lag？"><a href="#什么是-Consumer-Lag？如何监控和处理-Lag？" class="headerlink" title="什么是 Consumer Lag？如何监控和处理 Lag？"></a>什么是 Consumer Lag？如何监控和处理 Lag？</h3><ul>
<li><strong>定义：</strong> Consumer Lag 指 Consumer Group 在某个 Partition 上<strong>最新提交的 Offset</strong> 与 <strong>Partition 当前最新消息的 Offset (LEO)</strong> 之间的差值。即 <strong>未消费的消息数量</strong>。</li>
<li><strong>监控重要性：</strong> Lag 是衡量消费健康状况的关键指标。持续增长的 Lag 意味着消费速度跟不上生产速度，可能导致延迟和数据积压</li>
<li><strong>原因：</strong><ul>
<li>消费者处理能力不足 (CPU, 内存, 逻辑复杂, I&#x2F;O 慢)。</li>
<li>消费者实例数量不足 (Partition 数 &gt; Consumer 实例数)。</li>
<li>下游系统故障或慢。</li>
<li>消费者代码 Bug 或配置问题 (如 <code>**max.poll.records**</code> 太大导致单次处理时间过长)。</li>
<li>网络问题。</li>
</ul>
</li>
<li><strong>处理：</strong><ul>
<li><strong>监控:</strong> 使用 Kafka 自带工具 (<code>**kafka-consumer-groups.sh**</code>)，JMX 指标 (&#96;&#96;&#96;, <code>**,** </code>, &#96;&#96;)，或第三方监控系统 (Prometheus+Grafana, Confluent Control Center)。</li>
<li><strong>扩容：</strong> 增加 Consumer Group 内的 Consumer 实例数 (确保 &lt;&#x3D; Partition 数)。</li>
<li><strong>优化消费者：</strong> 提升单 Consumer 处理能力 (优化代码逻辑、异步处理、批处理、调优 JVM)。</li>
<li><strong>调整参数：</strong> 适当增加 <code>**fetch.min.bytes**</code>, <code>**fetch.max.wait.ms**</code> 提高拉取效率；调整 <code>**max.poll.records**</code> 避免单次处理过多消息超时；检查 <code>**session.timeout.ms**</code> 和 <code>**max.poll.interval.ms**</code> 避免误判离线触发 Rebalance。</li>
<li><strong>排查下游依赖。</strong></li>
</ul>
</li>
</ul>
<h3 id="kafka主要应用场景：异步、削峰、解耦"><a href="#kafka主要应用场景：异步、削峰、解耦" class="headerlink" title="kafka主要应用场景：异步、削峰、解耦"></a>kafka主要应用场景：异步、削峰、解耦</h3><p>异步：缩短响应时间</p>
<p>实际应用</p>
<p>削峰：</p>
<p>解耦：</p>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><h1 id="开发框架"><a href="#开发框架" class="headerlink" title="开发框架"></a>开发框架</h1><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="循环依赖解决原理"><a href="#循环依赖解决原理" class="headerlink" title="循环依赖解决原理"></a>循环依赖解决原理</h3><p>Spring 通过<strong>三级缓存（三级 Map 结构）</strong>解决单例 Bean 的循环依赖问题，其核心原理是<strong>提前暴露未完成初始化的 Bean 引用</strong>，从而打破循环依赖的僵局。以下是详细原理和流程：</p>
<p><strong>三级缓存的定义与作用</strong></p>
<ol>
<li><strong>一级缓存（singletonObjects）</strong><br>存放<strong>完全初始化好的 Bean</strong>，可以直接使用。</li>
<li><strong>二级缓存（earlySingletonObjects）</strong><br>存放<strong>提前暴露的 Bean 的早期引用</strong>（仅实例化，尚未填充属性和初始化）。</li>
<li><strong>三级缓存（singletonFactories）</strong><br>存放 Bean 的 <strong>ObjectFactory</strong>，用于生成 Bean 的早期引用（可能生成代理对象，用于支持 AOP）。</li>
</ol>
<p><strong>解决循环依赖的流程</strong></p>
<p>以 <code>A → B → A</code> 的循环依赖为例：</p>
<ol>
<li><strong>创建 Bean A</strong></li>
</ol>
<ul>
<li><strong>实例化 A</strong>：调用构造函数创建 A 对象（此时属性未填充，称为“早期对象”）。</li>
<li><strong>将 A 的 ObjectFactory 放入三级缓存</strong>：<br><code>addSingletonFactory(A_name, () -&gt; getEarlyBeanReference(A))</code><br>（这一步是关键，允许后续依赖通过 ObjectFactory 获取 A 的早期引用）</li>
</ul>
<ol start="2">
<li><strong>填充 A 的属性</strong></li>
</ol>
<ul>
<li>发现 A 依赖 B，触发 <code>getBean(B)</code>。</li>
</ul>
<ol start="3">
<li><strong>创建 Bean B</strong></li>
</ol>
<ul>
<li><strong>实例化 B</strong>：构造函数创建 B 对象。</li>
<li><strong>将 B 的 ObjectFactory 放入三级缓存</strong>：<br><code>addSingletonFactory(B_name, () -&gt; getEarlyBeanReference(B))</code></li>
</ul>
<ol start="4">
<li><strong>填充 B 的属性</strong></li>
</ol>
<ul>
<li>发现 B 依赖 A，触发 <code>getBean(A)</code>。</li>
<li><strong>从三级缓存获取 A 的 ObjectFactory</strong>，生成 A 的早期引用（可能是原始对象或代理对象）。</li>
<li>将 A 的早期引用放入二级缓存，<strong>同时删除三级缓存中的 A</strong>。</li>
</ul>
<ol start="5">
<li><strong>完成 B 的初始化</strong></li>
</ol>
<ul>
<li>B 的早期引用注入 A 后，继续完成其他初始化和后置处理。</li>
<li>将 B 放入一级缓存，<strong>删除二级和三级缓存中的 B</strong>。</li>
</ul>
<ol start="6">
<li><strong>完成 A 的初始化</strong></li>
</ol>
<ul>
<li>B 已就绪，A 注入 B 后完成属性填充和初始化。</li>
<li>将 A 放入一级缓存，<strong>删除二级缓存中的 A</strong>。</li>
</ul>
<p><strong>关键设计点</strong></p>
<ol>
<li><strong>为什么需要三级缓存？</strong><ul>
<li><strong>支持 AOP 代理</strong>：<br>如果 Bean 需要被代理，三级缓存的 ObjectFactory 可以延迟生成代理对象，确保依赖注入的是最终代理对象，而非原始对象。</li>
<li><strong>避免重复创建代理</strong>：<br>二级缓存（<code>earlySingletonObjects</code>）保存已生成的早期对象（可能是代理），避免多次调用 ObjectFactory。</li>
</ul>
</li>
<li><strong>只能解决单例 Bean 的循环依赖</strong><br>原型（Prototype）Bean 每次都会新建实例，无法通过缓存提前暴露引用。</li>
<li><strong>构造函数循环依赖无法解决</strong><br>若循环依赖通过构造函数发生，Bean 尚未实例化，无法提前暴露引用，Spring 会抛出 <code>BeanCurrentlyInCreationException</code>。</li>
</ol>
<p><strong>总结</strong></p>
<p>Spring 通过三级缓存实现：</p>
<ol>
<li><strong>提前暴露未初始化的 Bean 引用</strong>（通过 ObjectFactory）。</li>
<li><strong>延迟代理对象的生成</strong>，确保依赖注入正确的对象。</li>
<li><strong>缓存层级隔离</strong>，平衡性能与正确性。</li>
</ol>
<p>这一机制使得大多数单例 Bean 的循环依赖问题得以解决，同时保持了框架的灵活性和扩展性。</p>
<h3 id="FactoryBean-的作用与应用"><a href="#FactoryBean-的作用与应用" class="headerlink" title="FactoryBean 的作用与应用"></a><code>FactoryBean</code> 的作用与应用</h3><p><strong>1. FactoryBean 的核心作用</strong><br>FactoryBean 是 Spring 框架中用于 <strong>封装复杂对象创建逻辑</strong> 的特殊接口，其核心作用如下：</p>
<ul>
<li><strong>隐藏复杂构造过程</strong>：将初始化繁琐的对象（如第三方库组件）的创建细节封装在 FactoryBean 中。</li>
<li><strong>动态决定对象类型</strong>：根据条件返回不同类型的 Bean 实例。</li>
<li><strong>延迟初始化</strong>：控制对象的创建时机，实现按需加载。</li>
<li><strong>统一管理依赖</strong>：集中处理对象创建时的依赖注入及配置。</li>
</ul>
<p><strong>2. FactoryBean 接口方法解析</strong><br>实现 <code>FactoryBean</code> 接口需重写以下方法：</p>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>T getObject()</code></td>
<td align="left">返回由 FactoryBean 创建的实际对象实例。</td>
</tr>
<tr>
<td align="left"><code>Class&lt;?&gt; getObjectType()</code></td>
<td align="left">返回创建的对象类型，用于 Spring 容器类型检查。</td>
</tr>
<tr>
<td align="left"><code>boolean isSingleton()</code></td>
<td align="left">决定对象是否为单例。默认 <code>true</code>，若返回 <code>false</code> 则每次请求创建新实例。</td>
</tr>
</tbody></table>
<p><strong>3. 实际应用示例：自定义加密工具 FactoryBean</strong><br>假设需创建一个根据配置动态选择加密算法的工具类，步骤如下：</p>
<p><strong>步骤 1：定义加密接口及实现类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EncryptionTool</span> &#123;</span><br><span class="line">    String <span class="title function_">encrypt</span><span class="params">(String text)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AES 加密实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AesEncryptionTool</span> <span class="keyword">implements</span> <span class="title class_">EncryptionTool</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encrypt</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;AES加密后的数据: &quot;</span> + text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RSA 加密实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RsaEncryptionTool</span> <span class="keyword">implements</span> <span class="title class_">EncryptionTool</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encrypt</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;RSA加密后的数据: &quot;</span> + text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 2：实现 EncryptionToolFactoryBean</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.FactoryBean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EncryptionToolFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;EncryptionTool&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> String algorithm; <span class="comment">// 配置属性，决定加密算法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置算法类型（通过Spring属性注入）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAlgorithm</span><span class="params">(String algorithm)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.algorithm = algorithm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> EncryptionTool <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;AES&quot;</span>.equalsIgnoreCase(algorithm)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AesEncryptionTool</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;RSA&quot;</span>.equalsIgnoreCase(algorithm)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RsaEncryptionTool</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;不支持的加密算法: &quot;</span> + algorithm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> EncryptionTool.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 单例模式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 3：配置 Spring Bean</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- XML 配置方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;encryptionTool&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.EncryptionToolFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;algorithm&quot;</span> <span class="attr">value</span>=<span class="string">&quot;AES&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>或使用 Java 配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FactoryBean&lt;EncryptionTool&gt; <span class="title function_">encryptionTool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">EncryptionToolFactoryBean</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EncryptionToolFactoryBean</span>();</span><br><span class="line">        factory.setAlgorithm(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 4：在业务类中注入使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EncryptionTool encryptionTool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">encrypted</span> <span class="operator">=</span> encryptionTool.encrypt(password);</span><br><span class="line">        System.out.println(<span class="string">&quot;加密后的密码: &quot;</span> + encrypted);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>执行结果</strong>：<br>根据配置的 <code>algorithm</code> 值（AES 或 RSA），<code>UserService</code> 将自动使用对应的加密工具。</p>
<p><strong>4. 获取 FactoryBean 实例本身</strong><br>若需直接获取 <code>FactoryBean</code> 而非其创建的对象，可在 Bean 名称前加 <code>&amp;</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FactoryBean&lt;?&gt; factory = context.getBean(<span class="string">&quot;&amp;encryptionTool&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>5. 实际应用场景总结</strong></p>
<ul>
<li><strong>MyBatis 的 SqlSessionFactoryBean</strong>：封装 <code>SqlSessionFactory</code> 的创建，处理数据源、Mapper 扫描等复杂配置。</li>
<li><strong>Spring 的 ScheduledTaskFactoryBean</strong>：用于动态创建定时任务 Bean。</li>
<li><strong>连接池配置</strong>：如自定义 Druid 数据源的详细参数初始化。</li>
<li><strong>动态代理生成</strong>：结合 AOP，为特定接口生成代理实例。</li>
</ul>
<p><strong>6. 对比普通 @Bean 方法</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>FactoryBean</strong></th>
<th align="left"><strong>@Bean 方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>灵活性</strong></td>
<td align="left">高（可动态决定对象类型，实现复杂初始化逻辑）</td>
<td align="left">中（适合简单对象创建）</td>
</tr>
<tr>
<td align="left"><strong>代码复用</strong></td>
<td align="left">可通过继承复用逻辑</td>
<td align="left">需重复编写相似代码</td>
</tr>
<tr>
<td align="left"><strong>生命周期控制</strong></td>
<td align="left">支持延迟初始化及单例控制</td>
<td align="left">依赖 <code>@Lazy</code> 和 <code>@Scope</code> 注解</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">复杂对象创建、框架集成</td>
<td align="left">简单 Bean 定义、快速配置</td>
</tr>
</tbody></table>
<p><strong>总结</strong><br>FactoryBean 是 Spring 中处理复杂对象创建的强大工具，特别适用于封装初始化逻辑、动态生成实例及框架集成。合理使用 FactoryBean 能显著提升代码的可维护性和扩展性，尤其在需要精细控制 Bean 创建过程时，其优势更为明显。</p>
<h3 id="BeanFactoryPostProcessor-和-BeanPostProcessor-的区别"><a href="#BeanFactoryPostProcessor-和-BeanPostProcessor-的区别" class="headerlink" title="BeanFactoryPostProcessor 和 BeanPostProcessor 的区别"></a><code>BeanFactoryPostProcessor</code> 和 <code>BeanPostProcessor</code> 的区别</h3><table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>BeanFactoryPostProcessor</strong></th>
<th align="left"><strong>BeanPostProcessor</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>作用阶段</strong></td>
<td align="left">Bean 定义加载后、Bean 实例化<strong>之前</strong></td>
<td align="left">Bean 实例化后、初始化（<code>init-method</code>）<strong>前后</strong></td>
</tr>
<tr>
<td align="left"><strong>操作对象</strong></td>
<td align="left">修改 Bean 的<strong>定义</strong>（<code>BeanDefinition</code>）</td>
<td align="left">修改或增强 Bean 的<strong>实例</strong></td>
</tr>
<tr>
<td align="left"><strong>触发次数</strong></td>
<td align="left">每个容器启动时<strong>执行一次</strong></td>
<td align="left"><strong>每个 Bean 初始化时都会触发</strong></td>
</tr>
<tr>
<td align="left"><strong>主要用途</strong></td>
<td align="left">动态修改 Bean 配置（如属性占位符替换）</td>
<td align="left">Bean 实例的代理增强（如 AOP）、属性注入</td>
</tr>
<tr>
<td align="left"><strong>接口方法</strong></td>
<td align="left"><code>postProcessBeanFactory(ConfigurableListableBeanFactory)</code></td>
<td align="left"><code>postProcessBeforeInitialization(Object, String)</code> <code>postProcessAfterInitialization(Object, String)</code></td>
</tr>
<tr>
<td align="left"><strong>典型实现类</strong></td>
<td align="left"><code>PropertySourcesPlaceholderConfigurer</code> <code>ConfigurationClassPostProcessor</code></td>
<td align="left"><code>AutowiredAnnotationBeanPostProcessor</code> <code>AnnotationAwareAspectJAutoProxyCreator</code></td>
</tr>
</tbody></table>
<p><strong>总结</strong></p>
<ul>
<li><strong>BeanFactoryPostProcessor</strong>：干预 Bean 的<strong>定义阶段</strong>，用于容器级配置调整。</li>
<li><strong>BeanPostProcessor</strong>：干预 Bean 的<strong>实例化阶段</strong>，用于 Bean 级功能增强。</li>
</ul>
<h3 id="Bean生命周期扩展点实战"><a href="#Bean生命周期扩展点实战" class="headerlink" title="Bean生命周期扩展点实战"></a>Bean生命周期扩展点实战</h3><p>Spring Bean 生命周期的核心阶段和扩展点顺序：</p>
<ol>
<li><strong>实例化</strong>（调用构造函数）</li>
<li><strong>属性赋值</strong>（依赖注入）</li>
<li><strong>BeanPostProcessor 前置处理</strong>（<code>postProcessBeforeInitialization</code>）</li>
<li><strong>初始化方法</strong>（<code>@PostConstruct</code> → <code>InitializingBean</code> → <code>init-method</code>）</li>
<li><strong>BeanPostProcessor 后置处理</strong>（<code>postProcessAfterInitialization</code>）</li>
<li><strong>Bean 就绪，进入运行期</strong></li>
<li><strong>销毁方法</strong>（<code>@PreDestroy</code> → <code>DisposableBean</code> → <code>destroy-method</code>）</li>
</ol>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-942a927a-86e4-4a01-8f52-9addd89642ff.png" alt="三分恶面渣逆袭：Spring Bean生命周期"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instantiate the bean.</span></span><br><span class="line">    <span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">    <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">            isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                    <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">                    mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">                String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(dependentBeans.length);</span><br><span class="line">                <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                        actualDependentBeans.add(dependentBean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName,</span><br><span class="line">                            <span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">                            StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                            <span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;&#x27;getBeanNamesForType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean as disposable.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SpringBoot自动配置原理"><a href="#SpringBoot自动配置原理" class="headerlink" title="SpringBoot自动配置原理"></a>SpringBoot自动配置原理</h3><p>Spring Boot的自动配置是其核心特性之一，旨在简化应用的配置过程。以下是其实现机制的详细步骤解析：</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-df77ee15-2ff0-4ec7-8e65-e4ebb8ba88f1.png" alt="三分恶面渣逆袭：SpringBoot自动配置原理"></p>
<ol>
<li><strong>启用自动配置</strong></li>
</ol>
<p>通过主类上的<code>@SpringBootApplication</code>注解，该注解组合了<code>@EnableAutoConfiguration</code>，从而触发自动配置机制。</p>
<ol start="2">
<li><strong>加载自动配置类</strong></li>
</ol>
<p>Spring Boot会扫描所有jar包中的<code>META-INF/spring.factories</code>文件，读取<code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>键下的配置类列表。例如：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>条件化筛选配置类</strong></li>
</ol>
<p>每个自动配置类使用条件注解决定是否生效，常见条件包括：</p>
<ul>
<li><strong>@ConditionalOnClass</strong>：类路径存在指定类时生效。</li>
<li><strong>@ConditionalOnMissingBean</strong>：容器中无指定Bean时生效。</li>
<li><strong>@ConditionalOnProperty</strong>：配置文件中存在特定属性时生效。</li>
</ul>
<p><strong>示例：DataSourceAutoConfiguration</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;DataSource.class, EmbeddedDatabaseType.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(DataSourceProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">(DataSourceProperties properties)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> properties.initializeDataSourceBuilder().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>@ConditionalOnClass</strong>确保存在数据库相关类。</li>
<li><strong>@ConditionalOnMissingBean</strong>仅在用户未自定义DataSource时创建Bean。</li>
</ul>
<ol start="4">
<li><strong>绑定配置属性</strong></li>
</ol>
<p>使用<code>@EnableConfigurationProperties</code>将配置属性类（如<code>DataSourceProperties</code>）与配置文件（如<code>application.yml</code>）绑定，允许通过属性动态配置Bean。</p>
<p><strong>application.yml示例</strong></p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mydb</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">secret</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>自动配置Bean的注册</strong></li>
</ol>
<p>满足条件的配置类中的Bean定义被注册到Spring应用上下文，供其他组件注入使用。</p>
<h3 id="自定义Starter开发要点"><a href="#自定义Starter开发要点" class="headerlink" title="自定义Starter开发要点"></a>自定义Starter开发要点</h3><p><strong>1. Starter 的核心组成</strong></p>
<p>一个完整的 Starter 包含两个模块（可合并）：</p>
<ol>
<li><strong><code>xxx-spring-boot-starter</code></strong><br>空模块，仅声明依赖（如自动配置模块和其他必要依赖），供用户直接引入。</li>
<li><strong><code>xxx-spring-boot-autoconfigure</code></strong><br>核心实现模块，包含自动配置类、条件注解、配置属性绑定等。</li>
</ol>
<p><strong>2. 开发步骤与关键代码</strong></p>
<p><strong>步骤 1：创建项目结构</strong></p>
<p>使用 Maven 或 Gradle 创建模块，建议结构：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">my-starter/</span><br><span class="line">  ├── my-starter-spring-boot-autoconfigure/  # 自动配置模块</span><br><span class="line">  │   ├── src/main/java</span><br><span class="line">  │   │   └── com/example/autoconfigure</span><br><span class="line">  │   │       ├── MyServiceAutoConfiguration.java  # 自动配置类</span><br><span class="line">  │   │       └── MyServiceProperties.java         # 配置属性类</span><br><span class="line">  │   └── src/main/resources/META-INF</span><br><span class="line">  │       ├── spring.factories                    # 自动配置注册</span><br><span class="line">  │       └── additional-spring-configuration-metadata.json  # 配置提示（可选）</span><br><span class="line">  │</span><br><span class="line">  └── my-starter-spring-boot-starter/         # Starter 入口模块</span><br><span class="line">      └── pom.xml                             # 仅依赖自动配置模块</span><br></pre></td></tr></table></figure>

<p><strong>步骤 2：编写自动配置类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(MyServiceProperties.class)</span>  <span class="comment">// 启用配置属性绑定</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(MyService.class)</span>  <span class="comment">// 类路径存在 MyService 时生效</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServiceAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>  <span class="comment">// 用户未自定义时注册 Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyService <span class="title function_">myService</span><span class="params">(MyServiceProperties properties)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyService</span>(properties.getUrl(), properties.getTimeout());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 3：定义配置属性类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;my.service&quot;)</span>  <span class="comment">// 配置前缀</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServiceProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://default-url&quot;</span>;  <span class="comment">// 默认值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">timeout</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter 和 Setter 必须提供</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUrl</span><span class="params">()</span> &#123; <span class="keyword">return</span> url; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUrl</span><span class="params">(String url)</span> &#123; <span class="built_in">this</span>.url = url; &#125;</span><br><span class="line">    <span class="comment">// ... 其他属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 4：注册自动配置类</strong></p>
<p>在 <code>resources/META-INF/spring.factories</code> 中声明：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">com.example.autoconfigure.MyServiceAutoConfiguration</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤 5：配置提示（可选）</strong></p>
<p>在 <code>resources/META-INF/additional-spring-configuration-metadata.json</code> 中为配置项添加描述：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my.service.url&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java.lang.String&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;服务 URL 地址&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;defaultValue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://default-url&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my.service.timeout&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java.lang.Integer&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;请求超时时间（毫秒）&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;defaultValue&quot;</span><span class="punctuation">:</span> <span class="number">5000</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤 6：打包并发布</strong></p>
<ul>
<li><strong>Maven</strong>：通过 <code>mvn clean install</code> 安装到本地仓库，或部署到 Nexus 私服。</li>
<li><strong>Gradle</strong>：使用 <code>publishToMavenLocal</code> 或配置发布任务。</li>
</ul>
<p><strong>3. 使用自定义 Starter</strong></p>
<p>用户引入依赖后，可直接通过配置文件（如 <code>application.yml</code>）配置参数：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">my:</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://custom-url</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure>

<p><strong>4. 关键注意事项</strong></p>
<ol>
<li><p><strong>条件化配置</strong><br>使用 <code>@ConditionalOnClass</code>, <code>@ConditionalOnProperty</code> 等注解，确保 Starter 灵活适配不同场景。</p>
</li>
<li><p><strong>避免 Bean 冲突</strong></p>
<ul>
<li>核心 Bean 使用 <code>@ConditionalOnMissingBean</code>，允许用户覆盖。</li>
<li>避免与其他 Starter 的 Bean 名称重复。</li>
</ul>
</li>
<li><p><strong>版本兼容性</strong></p>
<ul>
<li>Starter 的 Spring Boot 版本需与用户项目匹配。</li>
<li>使用 <code>spring-boot-dependencies</code> 管理依赖版本。</li>
</ul>
</li>
<li><p><strong>依赖范围控制</strong></p>
<ul>
<li>非必要依赖标记为 <code>optional</code>（Maven）或 <code>optional = true</code>（Gradle），避免传递依赖污染用户项目。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Maven 示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>some-library<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>日志与文档</strong></p>
<ul>
<li>在 Starter 中提供清晰的日志输出，帮助用户调试。</li>
<li>编写 README 说明配置项和使用示例。</li>
</ul>
</li>
</ol>
<p><strong>5. 测试 Starter</strong></p>
<p>编写测试类验证自动配置是否生效：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServiceAutoConfigurationTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="keyword">private</span> MyService myService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAutoConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">        assertNotNull(myService);</span><br><span class="line">        assertEquals(<span class="string">&quot;http://custom-url&quot;</span>, myService.getUrl());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6. 最佳实践</strong></p>
<ul>
<li><strong>模块化设计</strong>：将自动配置与 Starter 分离，方便其他模块复用。</li>
<li><strong>防御性编程</strong>：在自动配置类中检查依赖是否存在（如通过 <code>@ConditionalOnClass</code>）。</li>
<li><strong>默认配置合理</strong>：提供安全、通用的默认值，减少用户配置负担。</li>
</ul>
<h3 id="统一异常处理的最佳实践"><a href="#统一异常处理的最佳实践" class="headerlink" title="统一异常处理的最佳实践"></a>统一异常处理的最佳实践</h3><p>以下是 <strong>Spring Boot 统一异常处理的最佳实践</strong>，涵盖异常分类、全局处理、日志记录、错误响应规范等关键环节，帮助开发者构建健壮且易维护的应用程序：</p>
<p><strong>核心原则</strong></p>
<ol>
<li><strong>统一入口</strong>：所有异常由全局处理器捕获，避免分散在各处。</li>
<li><strong>友好响应</strong>：前端接收结构化错误信息（如JSON），包含错误码、提示消息等。</li>
<li><strong>分类处理</strong>：区分业务异常、系统异常、参数校验异常等，针对性处理。</li>
<li><strong>安全日志</strong>：敏感信息脱敏，异常日志详细记录，但避免暴露给客户端。</li>
</ol>
<p><strong>实现步骤与代码示例</strong></p>
<ol>
<li><strong>定义统一响应格式</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;    <span class="comment">// 状态码（如200成功，500系统错误）</span></span><br><span class="line">    <span class="keyword">private</span> String msg;  <span class="comment">// 提示信息（用户友好）</span></span><br><span class="line">    <span class="keyword">private</span> T data;      <span class="comment">// 响应数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功响应</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">success</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;(<span class="number">200</span>, <span class="string">&quot;操作成功&quot;</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 失败响应</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">error</span><span class="params">(<span class="type">int</span> code, String msg)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;(code, msg, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法、Getter/Setter省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>创建全局异常处理器</strong></li>
</ol>
<p>使用 <code>@ControllerAdvice</code> + <code>@ExceptionHandler</code> 捕获全局异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理业务异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(BusinessException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Void&gt; <span class="title function_">handleBusinessException</span><span class="params">(BusinessException e)</span> &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;业务异常: &#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> Result.error(e.getCode(), e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理参数校验异常（JSR-303）</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Void&gt; <span class="title function_">handleValidationException</span><span class="params">(MethodArgumentNotValidException e)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> e.getBindingResult().getFieldErrors().stream()</span><br><span class="line">                .map(fieldError -&gt; fieldError.getField() + <span class="string">&quot;: &quot;</span> + fieldError.getDefaultMessage())</span><br><span class="line">                .collect(Collectors.joining(<span class="string">&quot;; &quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="number">400</span>, <span class="string">&quot;参数校验失败: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理其他未捕获异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Void&gt; <span class="title function_">handleException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;系统异常: &quot;</span>, e);  <span class="comment">// 记录完整堆栈</span></span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="number">500</span>, <span class="string">&quot;系统繁忙，请稍后再试&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>自定义业务异常</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BusinessException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BusinessException</span><span class="params">(<span class="type">int</span> code, String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快速创建常用异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BusinessException <span class="title function_">of</span><span class="params">(<span class="type">int</span> code, String msg)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(code, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123; <span class="keyword">return</span> code; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>参数校验规范化</strong></li>
</ol>
<p>在 DTO 中使用校验注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDTO</span> &#123;</span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;用户名不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Email(message = &quot;邮箱格式不正确&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter/Setter省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>HTTP状态码与错误码映射</strong></li>
</ol>
<table>
<thead>
<tr>
<th align="left">异常类型</th>
<th align="left">HTTP状态码</th>
<th align="left">错误码</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>BusinessException</code></td>
<td align="left">200</td>
<td align="left">自定义</td>
<td align="left">业务逻辑错误（如订单状态异常）</td>
</tr>
<tr>
<td align="left"><code>MethodArgumentNotValid</code></td>
<td align="left">400</td>
<td align="left">400</td>
<td align="left">参数校验失败</td>
</tr>
<tr>
<td align="left"><code>AuthenticationException</code></td>
<td align="left">401</td>
<td align="left">401</td>
<td align="left">未登录或Token过期</td>
</tr>
<tr>
<td align="left"><code>AccessDeniedException</code></td>
<td align="left">403</td>
<td align="left">403</td>
<td align="left">无权限访问</td>
</tr>
<tr>
<td align="left"><code>其他未捕获异常</code></td>
<td align="left">500</td>
<td align="left">500</td>
<td align="left">系统内部错误</td>
</tr>
</tbody></table>
<p><strong>三、最佳实践</strong></p>
<ol>
<li><strong>异常分类分层处理</strong></li>
</ol>
<ul>
<li><strong>业务异常</strong>：由开发者主动抛出（如库存不足），明确提示用户。</li>
<li><strong>系统异常</strong>：数据库连接失败等，提示友好信息，记录详细日志。</li>
<li><strong>第三方服务异常</strong>：封装为特定异常（如 <code>ThirdPartyException</code>），避免污染核心逻辑。</li>
</ul>
<ol start="2">
<li><strong>日志记录规范</strong></li>
</ol>
<ul>
<li><strong>业务异常</strong>：记录 <code>WARN</code> 级别，包含关键参数。</li>
<li><strong>系统异常</strong>：记录 <code>ERROR</code> 级别，输出完整堆栈。</li>
<li><strong>敏感信息脱敏</strong>：如身份证号、手机号在日志中掩码处理。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(PaymentException.class)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;Void&gt; <span class="title function_">handlePaymentException</span><span class="params">(PaymentException e)</span> &#123;</span><br><span class="line">    log.warn(<span class="string">&quot;支付失败, 订单号: &#123;&#125;, 原因: &#123;&#125;&quot;</span>, e.getOrderId(), e.getMessage());</span><br><span class="line">    <span class="keyword">return</span> Result.error(<span class="number">1001</span>, <span class="string">&quot;支付失败，请重试&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>错误码规范</strong></li>
</ol>
<ul>
<li><strong>模块划分</strong>：按模块定义错误码范围（如用户模块1000-1999）。</li>
<li><strong>文档维护</strong>：提供错误码对照表，方便前后端协作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误码常量类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ErrorCode</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">USER_NOT_FOUND</span> <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ORDER_EXPIRED</span> <span class="operator">=</span> <span class="number">2001</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>前端友好提示</strong></li>
</ol>
<ul>
<li><strong>用户可见消息</strong>：简洁明确，如“密码强度不足，至少包含大小写字母”。</li>
<li><strong>技术细节隔离</strong>：不返回Java异常类名、堆栈信息。</li>
</ul>
<ol start="5">
<li><strong>测试覆盖</strong></li>
</ol>
<p>验证异常处理逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionHandlerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBusinessException</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        mockMvc.perform(get(<span class="string">&quot;/api/order/123&quot;</span>))</span><br><span class="line">               .andExpect(status().isOk())</span><br><span class="line">               .andExpect(jsonPath(<span class="string">&quot;$.code&quot;</span>).value(<span class="number">1001</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>四、常见问题与解决</strong></p>
<ol>
<li><strong>异常未被捕获</strong><ul>
<li>检查 <code>@ControllerAdvice</code> 是否在组件扫描路径内。</li>
<li>确认没有其他异常处理器冲突。</li>
</ul>
</li>
<li><strong>循环依赖导致处理器失效</strong><ul>
<li>确保全局处理器不依赖可能抛出异常的Bean。</li>
</ul>
</li>
<li><strong>异步线程异常丢失</strong><ul>
<li>使用 <code>AsyncUncaughtExceptionHandler</code> 处理异步任务异常。</li>
</ul>
</li>
</ol>
<p><strong>五、总结</strong></p>
<p>通过统一异常处理机制，可以实现：</p>
<ul>
<li><strong>代码简洁性</strong>：消除重复的 <code>try-catch</code> 块。</li>
<li><strong>维护便捷性</strong>：集中管理错误响应逻辑。</li>
<li><strong>接口规范性</strong>：前后端遵循统一的错误协议。</li>
<li><strong>系统健壮性</strong>：关键异常不漏处理，日志可追溯。</li>
</ul>
<h3 id="配置加载优先级（命令行-环境变量）"><a href="#配置加载优先级（命令行-环境变量）" class="headerlink" title="配置加载优先级（命令行&gt;环境变量）"></a>配置加载优先级（命令行&gt;环境变量）</h3><table>
<thead>
<tr>
<th align="left">优先级</th>
<th align="left">配置源</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>1</strong></td>
<td align="left"><strong>命令行参数</strong></td>
<td align="left"><code>--server.port=8081</code></td>
</tr>
<tr>
<td align="left"><strong>2</strong></td>
<td align="left">Java 系统属性 (<code>-D</code>)</td>
<td align="left"><code>-Dspring.datasource.url=jdbc:mysql://...</code></td>
</tr>
<tr>
<td align="left"><strong>3</strong></td>
<td align="left"><strong>操作系统环境变量</strong></td>
<td align="left"><code>export SERVER_PORT=8081</code> (Linux)</td>
</tr>
<tr>
<td align="left"><strong>4</strong></td>
<td align="left">配置文件（如 <code>application.yml</code>）</td>
<td align="left"><code>server.port: 8080</code></td>
</tr>
</tbody></table>
<h3 id="Spring-AOP-和-AspectJ-有什么区别"><a href="#Spring-AOP-和-AspectJ-有什么区别" class="headerlink" title="Spring AOP 和 AspectJ 有什么区别"></a><code>Spring AOP</code> 和 <code>AspectJ</code> 有什么区别</h3><h3 id="过滤器、拦截器、AOP的区别与实践"><a href="#过滤器、拦截器、AOP的区别与实践" class="headerlink" title="过滤器、拦截器、AOP的区别与实践"></a>过滤器、拦截器、AOP的区别与实践</h3><table>
<thead>
<tr>
<th align="left"><strong>维度</strong></th>
<th align="left"><strong>过滤器（Filter）</strong></th>
<th align="left"><strong>拦截器（Interceptor）</strong></th>
<th align="left"><strong>AOP（Aspect）</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>规范&#x2F;框架</strong></td>
<td align="left">Servlet 规范（Java EE）</td>
<td align="left">Spring MVC 框架</td>
<td align="left">Spring AOP &#x2F; AspectJ</td>
</tr>
<tr>
<td align="left"><strong>作用阶段</strong></td>
<td align="left">请求进入 Servlet 前&#x2F;响应返回客户端前</td>
<td align="left">Controller 方法执行前后</td>
<td align="left">任意 Bean 方法执行前后</td>
</tr>
<tr>
<td align="left"><strong>作用范围</strong></td>
<td align="left">所有 HTTP 请求（包括静态资源）</td>
<td align="left">Spring MVC 处理的请求（动态资源）</td>
<td align="left">Spring 管理的 Bean 方法</td>
</tr>
<tr>
<td align="left"><strong>依赖关系</strong></td>
<td align="left">依赖 Servlet 容器（Tomcat&#x2F;Jetty）</td>
<td align="left">依赖 Spring 容器</td>
<td align="left">依赖 Spring 容器</td>
</tr>
<tr>
<td align="left"><strong>可访问对象</strong></td>
<td align="left">ServletRequest&#x2F;ServletResponse</td>
<td align="left">HttpServletRequest&#x2F;ModelAndView</td>
<td align="left">方法参数、注解、返回值</td>
</tr>
<tr>
<td align="left"><strong>执行顺序</strong></td>
<td align="left">过滤器链顺序（web.xml 或注解顺序）</td>
<td align="left">拦截器注册顺序</td>
<td align="left">切面优先级（<code>@Order</code> 注解）</td>
</tr>
<tr>
<td align="left"><strong>典型场景</strong></td>
<td align="left">字符编码、跨域处理、请求日志</td>
<td align="left">权限校验、参数预处理、日志记录</td>
<td align="left">事务管理、性能监控、缓存控制</td>
</tr>
</tbody></table>
<p><strong>执行流程与顺序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// HTTP 请求处理流程</span><br><span class="line">HTTP Request → Filter Chain → DispatcherServlet → Interceptor Chain → Controller → AOP Advice → Response</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>过滤器（Filter）</strong>：最先执行，可拦截所有请求（如静态资源）。</li>
<li><strong>拦截器（Interceptor）</strong>：在 <code>DispatcherServlet</code> 之后、Controller 方法之前执行。</li>
<li><strong>AOP 切面（Aspect）</strong>：在 Controller 或 Service 方法执行前后触发。</li>
</ol>
<p><strong>实践场景与代码示例</strong></p>
<p><strong>场景 1：全局请求日志（跨所有请求）</strong></p>
<ul>
<li><p><strong>选择方案</strong>：<strong>过滤器（Filter）</strong><br><strong>原因</strong>：需记录所有请求（包括静态资源）的原始信息（如 IP、URL）。<br><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        chain.doFilter(req, res); <span class="comment">// 放行请求</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">cost</span> <span class="operator">=</span> System.currentTimeMillis() - start;</span><br><span class="line">        System.out.println(<span class="string">&quot;请求耗时: &quot;</span> + cost + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>场景 2：用户登录校验（仅动态请求）</strong></p>
<ul>
<li><p><strong>选择方案</strong>：<strong>拦截器（Interceptor）</strong><br><strong>原因</strong>：需访问 Spring 上下文（如获取用户 Session），且仅需拦截动态请求。<br><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest req, HttpServletResponse res, Object handler)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (req.getSession().getAttribute(<span class="string">&quot;user&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">            res.sendRedirect(<span class="string">&quot;/login&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 中断请求</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册拦截器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">AuthInterceptor</span>()).addPathPatterns(<span class="string">&quot;/api/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>场景 3：方法级事务管理</strong></p>
<ul>
<li><p><strong>选择方案</strong>：<strong>AOP（声明式事务）</strong><br><strong>原因</strong>：需在方法执行前后管理事务，与业务逻辑解耦。<br><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PlatformTransactionManager txManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(org.springframework.transaction.annotation.Transactional)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">manageTransaction</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> txManager.getTransaction(<span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">            txManager.commit(status);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            txManager.rollback(status);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>场景 4：接口耗时统计</strong></p>
<ul>
<li><p><strong>选择方案</strong>：<strong>AOP（环绕通知）</strong><br><strong>原因</strong>：需统计任意方法的执行时间，灵活作用于 Service 层或 Controller 层。<br><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PerformanceAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">logTime</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行耗时: &quot;</span> + (System.currentTimeMillis() - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>如何选择？</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>技术</strong></th>
<th align="left"><strong>优先使用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>过滤器</strong></td>
<td align="left">处理原始请求&#x2F;响应（如跨域、压缩）、全局日志、安全过滤（XSS&#x2F;SQL 注入防御）</td>
</tr>
<tr>
<td align="left"><strong>拦截器</strong></td>
<td align="left">需要 Spring 上下文支持、动态请求拦截（如权限校验、参数预处理）</td>
</tr>
<tr>
<td align="left"><strong>AOP</strong></td>
<td align="left">与业务逻辑解耦的横切关注点（如事务、日志、缓存、性能监控）</td>
</tr>
</tbody></table>
<p><strong>最佳实践</strong></p>
<ol>
<li><strong>避免功能重叠</strong>：<ul>
<li>若过滤器与拦截器实现相似功能（如日志），选择更靠近请求入口的组件（过滤器）。</li>
</ul>
</li>
<li><strong>慎用 AOP 拦截 Controller</strong>：<ul>
<li>Controller 方法通常已由拦截器处理，AOP 更适合 Service 层。</li>
</ul>
</li>
<li><strong>注意执行顺序</strong>：<ul>
<li>多个过滤器&#x2F;拦截器需明确顺序，避免依赖问题。</li>
</ul>
</li>
<li><strong>性能优化</strong>：<ul>
<li>过滤器链和拦截器链较长时，可能影响吞吐量，需合理设计。</li>
</ul>
</li>
</ol>
<p>通过合理选择过滤器、拦截器和 AOP，开发者可以高效管理横切关注点，提升代码的可维护性和系统性能。</p>
<h3 id="注解的实现原理"><a href="#注解的实现原理" class="headerlink" title="注解的实现原理"></a>注解的实现原理</h3><p>在 Java 中，<strong>注解（Annotation）</strong> 是一种元数据机制，其本质是代码中的特殊标记，需配合 <strong>注解处理器</strong> 实现具体功能。注解本身不包含逻辑，其作用由处理器决定。以下是注解的实现原理详解：</p>
<p><strong>一、注解的本质</strong></p>
<ol>
<li><strong>注解的底层结构</strong></li>
</ol>
<ul>
<li><p>注解本质是继承 <code>java.lang.annotation.Annotation</code> 的 <strong>接口</strong>。</p>
</li>
<li><p>通过 JDK 动态代理生成注解的实例。</p>
</li>
<li><p><strong>示例</strong>：反编译 <code>@Override</code> 注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Override</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span> &#123;</span><br><span class="line">    <span class="comment">// 空接口，仅作标记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><strong>元注解（Meta-Annotation）</strong></li>
</ol>
<p>用于定义注解的行为，常见元注解：</p>
<table>
<thead>
<tr>
<th align="left">元注解</th>
<th align="left">作用</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>@Target</code></td>
<td align="left">指定注解可应用的目标（类、方法、字段等）</td>
<td align="left"><code>@Target(ElementType.METHOD)</code></td>
</tr>
<tr>
<td align="left"><code>@Retention</code></td>
<td align="left">指定注解的保留策略（源码、类文件、运行时）</td>
<td align="left"><code>@Retention(RetentionPolicy.RUNTIME)</code></td>
</tr>
<tr>
<td align="left"><code>@Documented</code></td>
<td align="left">注解是否包含在 Javadoc 中</td>
<td align="left"><code>@Documented</code></td>
</tr>
<tr>
<td align="left"><code>@Inherited</code></td>
<td align="left">子类是否继承父类的注解</td>
<td align="left"><code>@Inherited</code></td>
</tr>
</tbody></table>
<p><strong>二、注解的处理机制</strong></p>
<ol>
<li><strong>编译时处理（Annotation Processing Tool, APT）</strong></li>
</ol>
<ul>
<li><p><strong>原理</strong>：在编译阶段，通过注解处理器（继承 <code>AbstractProcessor</code>）扫描和处理注解。</p>
</li>
<li><p><strong>应用场景</strong>：</p>
<ul>
<li>生成代码（如 Lombok 生成 Getter&#x2F;Setter）。</li>
<li>语法检查（如 <code>@Override</code> 验证方法重写）。</li>
</ul>
</li>
<li><p><strong>示例</strong>：自定义编译时注解处理器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SupportedAnnotationTypes(&quot;com.example.MyAnnotation&quot;)</span></span><br><span class="line"><span class="meta">@SupportedSourceVersion(SourceVersion.RELEASE_8)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProcessor</span> <span class="keyword">extends</span> <span class="title class_">AbstractProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理注解逻辑，如生成代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><strong>运行时处理（反射机制）</strong></li>
</ol>
<ul>
<li><p><strong>原理</strong>：通过反射 API（如 <code>Class.getAnnotation()</code>）在运行时读取注解信息。</p>
</li>
<li><p><strong>应用场景</strong>：</p>
<ul>
<li>动态配置（如 Spring 的 <code>@Autowired</code> 依赖注入）。</li>
<li>自定义逻辑（如权限校验、日志记录）。</li>
</ul>
</li>
<li><p><strong>示例</strong>：读取方法上的注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> obj.getClass().getMethod(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (method.isAnnotationPresent(MyAnnotation.class)) &#123;</span><br><span class="line">    <span class="type">MyAnnotation</span> <span class="variable">anno</span> <span class="operator">=</span> method.getAnnotation(MyAnnotation.class);</span><br><span class="line">    System.out.println(anno.value());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li><strong>字节码增强处理（AOP 框架）</strong></li>
</ol>
<ul>
<li><strong>原理</strong>：在类加载时修改字节码，植入与注解相关的逻辑。</li>
<li><strong>工具</strong>：AspectJ、ASM、Byte Buddy。</li>
<li><strong>应用场景</strong>：<ul>
<li>实现 AOP 切面（如 <code>@Transactional</code> 事务管理）。</li>
<li>动态代理（如 Spring AOP）。</li>
</ul>
</li>
</ul>
<p><strong>三、注解处理的核心流程</strong></p>
<ol>
<li><strong>定义注解</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LogExecution &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;default log&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>使用注解</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@LogExecution(&quot;用户查询方法&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>处理注解（以运行时为例）</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">logIfNeeded</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(LogExecution.class)) &#123;</span><br><span class="line">            <span class="type">LogExecution</span> <span class="variable">log</span> <span class="operator">=</span> method.getAnnotation(LogExecution.class);</span><br><span class="line">            System.out.println(<span class="string">&quot;执行日志: &quot;</span> + log.value());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> UserService.class.getMethod(<span class="string">&quot;getUser&quot;</span>);</span><br><span class="line">        logIfNeeded(method); <span class="comment">// 输出：执行日志: 用户查询方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>四、注解的底层实现（反射动态代理）</strong></p>
<p>当使用 <code>@LogExecution</code> 时，JVM 会通过动态代理生成注解实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成的代理类（简化版）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogExecutionProxy</span> <span class="keyword">implements</span> <span class="title class_">LogExecution</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;用户查询方法&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotationType() &#123;</span><br><span class="line">        <span class="keyword">return</span> LogExecution.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>五、常见框架中的注解应用</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>框架</strong></th>
<th align="left"><strong>注解示例</strong></th>
<th align="left"><strong>处理机制</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Spring</strong></td>
<td align="left"><code>@Autowired</code></td>
<td align="left">运行时反射 + 依赖注入</td>
</tr>
<tr>
<td align="left"><strong>Lombok</strong></td>
<td align="left"><code>@Data</code></td>
<td align="left">编译时 APT 生成代码</td>
</tr>
<tr>
<td align="left"><strong>JUnit</strong></td>
<td align="left"><code>@Test</code></td>
<td align="left">运行时反射执行测试方法</td>
</tr>
<tr>
<td align="left"><strong>Hibernate</strong></td>
<td align="left"><code>@Entity</code></td>
<td align="left">运行时反射映射数据库表</td>
</tr>
<tr>
<td align="left"><strong>AspectJ</strong></td>
<td align="left"><code>@Around</code></td>
<td align="left">编译时&#x2F;类加载时字节码增强</td>
</tr>
</tbody></table>
<p><strong>六、注解的局限性</strong></p>
<ol>
<li><strong>无法独立工作</strong>：必须依赖处理器（APT、反射、AOP 等）。</li>
<li><strong>性能开销</strong>：运行时反射处理可能影响性能。</li>
<li><strong>复杂度高</strong>：字节码增强需掌握 ASM 等工具。</li>
</ol>
<p><strong>七、最佳实践</strong></p>
<ol>
<li><strong>明确保留策略</strong>：<ul>
<li>若只需编译时检查（如 <code>@Override</code>），使用 <code>RetentionPolicy.SOURCE</code>。</li>
<li>若需运行时处理（如 Spring 注解），使用 <code>RetentionPolicy.RUNTIME</code>。</li>
</ul>
</li>
<li><strong>避免过度使用</strong>：注解滥用会导致代码可读性下降。</li>
<li><strong>结合工具链</strong>：使用 Lombok、MapStruct 等工具简化开发。</li>
</ol>
<p>通过理解注解的实现原理，开发者可以更高效地利用其实现代码解耦、动态配置和自动化处理，提升框架的灵活性和可维护性。</p>
<h3 id="MapperScan-的实现原理"><a href="#MapperScan-的实现原理" class="headerlink" title="@MapperScan 的实现原理"></a><code>@MapperScan</code> 的实现原理</h3><p><code>@MapperScan</code> 是 MyBatis-Spring 整合中的核心注解，用于自动扫描并注册 Mapper 接口为 Spring Bean。其实现原理基于 Spring 的扩展机制和 MyBatis 的动态代理，以下是详细步骤和核心逻辑：</p>
<p><strong>1. 注解定义与入口</strong></p>
<p><code>@MapperScan</code> 通过 <code>@Import</code> 引入 <code>MapperScannerRegistrar</code>，触发扫描和注册逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Import(MapperScannerRegistrar.class)</span> <span class="comment">// 关键：引入注册器</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MapperScan &#123;</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;; <span class="comment">// 扫描的包路径</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotationClass() <span class="keyword">default</span> Annotation.class;</span><br><span class="line">    <span class="comment">// 其他配置属性...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. MapperScannerRegistrar 注册 Bean 定义</strong></p>
<p><code>MapperScannerRegistrar</code> 实现 <code>ImportBeanDefinitionRegistrar</code> 接口，在 Spring 容器启动时动态注册 Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperScannerRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 解析 @MapperScan 注解的属性（如包路径）</span></span><br><span class="line">        <span class="type">AnnotationAttributes</span> <span class="variable">attrs</span> <span class="operator">=</span> AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(MapperScan.class.getName()));</span><br><span class="line">        <span class="comment">// 创建并配置 ClassPathMapperScanner</span></span><br><span class="line">        <span class="type">ClassPathMapperScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathMapperScanner</span>(registry);</span><br><span class="line">        scanner.scan(attrs.getStringArray(<span class="string">&quot;value&quot;</span>)); <span class="comment">// 执行扫描</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. ClassPathMapperScanner 扫描接口</strong></p>
<p><code>ClassPathMapperScanner</code> 继承自 Spring 的 <code>ClassPathBeanDefinitionScanner</code>，自定义扫描规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassPathMapperScanner</span> <span class="keyword">extends</span> <span class="title class_">ClassPathBeanDefinitionScanner</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">doScan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用父类扫描方法，筛选出符合条件的接口</span></span><br><span class="line">        Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="built_in">super</span>.doScan(basePackages);</span><br><span class="line">        <span class="comment">// 为每个接口生成 BeanDefinition，绑定到 MapperFactoryBean</span></span><br><span class="line">        <span class="keyword">for</span> (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class="line">            <span class="type">GenericBeanDefinition</span> <span class="variable">definition</span> <span class="operator">=</span> (GenericBeanDefinition) holder.getBeanDefinition();</span><br><span class="line">            <span class="comment">// 设置 Bean 的工厂类为 MapperFactoryBean</span></span><br><span class="line">            definition.getConstructorArgumentValues().addGenericArgumentValue(definition.getBeanClassName());</span><br><span class="line">            definition.setBeanClass(MapperFactoryBean.class); <span class="comment">// 关键：代理工厂</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isCandidateComponent</span><span class="params">(AnnotatedBeanDefinition beanDefinition)</span> &#123;</span><br><span class="line">        <span class="comment">// 仅选择接口作为候选组件（排除类）</span></span><br><span class="line">        <span class="keyword">return</span> beanDefinition.getMetadata().isInterface();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. MapperFactoryBean 创建代理对象</strong></p>
<p><code>MapperFactoryBean</code> 是 Spring 的 <code>FactoryBean</code> 实现，负责生成 Mapper 接口的代理实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperFactoryBean</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 通过 SqlSession 获取 Mapper 动态代理</span></span><br><span class="line">        <span class="keyword">return</span> getSqlSession().getMapper(<span class="built_in">this</span>.mapperInterface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;T&gt; <span class="title function_">getObjectType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.mapperInterface;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5. 动态代理与 SQL 执行</strong></p>
<p>MyBatis 通过 <code>MapperProxy</code> 生成接口的 JDK 动态代理对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperProxy</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>, Serializable &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 将方法调用转换为 MappedStatement 执行</span></span><br><span class="line">        <span class="type">MapperMethod</span> <span class="variable">mapperMethod</span> <span class="operator">=</span> cachedMapperMethod(method);</span><br><span class="line">        <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6. 整合 Spring 容器</strong></p>
<ul>
<li><strong>SqlSessionTemplate 注入</strong>：<br>MyBatis-Spring 配置 <code>SqlSessionTemplate</code>（线程安全的 SqlSession 实现），由 Spring 管理数据库连接和事务。</li>
<li><strong>依赖关系</strong>：<br><code>MapperFactoryBean</code> 依赖 <code>SqlSessionTemplate</code>，确保所有 Mapper 代理使用同一事务上下文。</li>
</ul>
<p><strong>7. 自动配置与 Spring Boot 集成</strong></p>
<p>在 Spring Boot 中，<code>@MapperScan</code> 通常与自动配置类 <code>MyBatisAutoConfiguration</code> 配合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfiguration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; SqlSessionFactory.class, SqlSessionFactoryBean.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建 SqlSessionFactory</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结流程</strong></p>
<ol>
<li><strong>注解触发</strong>：<code>@MapperScan</code> 引入 <code>MapperScannerRegistrar</code>。</li>
<li><strong>动态注册</strong>：<code>MapperScannerRegistrar</code> 使用 <code>ClassPathMapperScanner</code> 扫描指定包下的接口。</li>
<li><strong>Bean 定义生成</strong>：为每个 Mapper 接口创建绑定到 <code>MapperFactoryBean</code> 的 Bean 定义。</li>
<li><strong>代理实例化</strong>：Spring 容器实例化时，<code>MapperFactoryBean</code> 通过 <code>SqlSessionTemplate</code> 创建动态代理对象。</li>
<li><strong>方法拦截</strong>：调用 Mapper 方法时，代理对象将请求转发给 MyBatis 执行 SQL。</li>
</ol>
<p><strong>关键设计点</strong></p>
<ul>
<li><strong>解耦与扩展</strong>：通过 Spring 的 <code>FactoryBean</code> 和 <code>ImportBeanDefinitionRegistrar</code> 实现无缝整合。</li>
<li><strong>性能优化</strong>：动态代理和缓存机制（如 <code>MapperMethod</code> 缓存）减少反射开销。</li>
<li><strong>事务一致性</strong>：依赖 Spring 管理的事务，确保 Mapper 操作在同一个 <code>SqlSession</code> 中执行。</li>
</ul>
<p>通过 <code>@MapperScan</code>，开发者无需手动配置每个 Mapper，框架自动完成接口到 Bean 的映射及代理生成，极大简化了 MyBatis 在 Spring 中的使用。</p>
<h3 id="Autowired-的实现原理"><a href="#Autowired-的实现原理" class="headerlink" title="@Autowired 的实现原理"></a><code>@Autowired</code> 的实现原理</h3><p><code>@Autowired</code> 是 Spring 框架中实现依赖注入的核心注解，其底层原理基于 <strong>Bean 生命周期管理</strong>、<strong>反射机制</strong> 和 <strong>BeanPostProcessor</strong> 的协作。以下是其实现原理的详细分析：</p>
<p><strong>1. 核心流程</strong></p>
<p><code>@Autowired</code> 的依赖注入发生在 Bean 的实例化阶段（属性填充阶段），具体步骤如下：</p>
<p><strong>1.1 Bean 实例化</strong></p>
<p>Spring 容器通过反射调用构造函数创建 Bean 实例（若存在多个构造函数，优先选择无参构造函数，或标记 <code>@Autowired</code> 的构造函数）。</p>
<p><strong>1.2 属性填充（依赖注入）</strong></p>
<ul>
<li><strong>触发时机</strong>：在 <code>AbstractAutowireCapableBeanFactory</code> 的 <code>populateBean()</code> 方法中。</li>
<li><strong>处理组件</strong>：<code>AutowiredAnnotationBeanPostProcessor</code>（继承自 <code>BeanPostProcessor</code>）。</li>
</ul>
<p><strong>1.3 依赖解析与注入</strong></p>
<ol>
<li><strong>扫描注解</strong>：<br>通过反射检查 Bean 的字段、方法和构造函数上的 <code>@Autowired</code> 注解。</li>
<li><strong>解析依赖</strong>：<ul>
<li><strong>按类型匹配</strong>：查找与依赖类型匹配的候选 Bean。</li>
<li><strong>按名称匹配</strong>：若存在多个同类型 Bean，按字段&#x2F;方法参数名称匹配（需结合 <code>@Qualifier</code> 或 <code>@Primary</code> 解决歧义）。</li>
</ul>
</li>
<li><strong>注入依赖</strong>：<ul>
<li><strong>字段注入</strong>：通过反射 <code>Field.setAccessible(true)</code> 设置私有字段值。</li>
<li><strong>方法注入</strong>：反射调用 Setter 方法。</li>
<li><strong>构造函数注入</strong>：在实例化时通过构造函数参数注入。</li>
</ul>
</li>
</ol>
<p><strong>2. 关键组件解析</strong></p>
<p><strong>2.1 AutowiredAnnotationBeanPostProcessor</strong></p>
<p>Spring 内置的 <code>BeanPostProcessor</code>，负责处理 <code>@Autowired</code> 和 <code>@Value</code> 注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutowiredAnnotationBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span>, MergedBeanDefinitionPostProcessor &#123;</span><br><span class="line">    <span class="comment">// 存储待注入的元数据（字段、方法）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InjectionMetadata metadata;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PropertyValues <span class="title function_">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> &#123;</span><br><span class="line">        <span class="comment">// 查找并注入依赖</span></span><br><span class="line">        <span class="type">InjectionMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> findAutowiringMetadata(bean.getClass());</span><br><span class="line">        metadata.inject(bean, beanName, pvs);</span><br><span class="line">        <span class="keyword">return</span> pvs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.2 依赖解析流程</strong></p>
<p>在 <code>DefaultListableBeanFactory</code> 中解析依赖：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">resolveDependency</span><span class="params">(DependencyDescriptor descriptor, String beanName, Set&lt;String&gt; autowiredBeanNames, TypeConverter typeConverter)</span> &#123;</span><br><span class="line">    <span class="comment">// 按类型获取候选 Bean 名称</span></span><br><span class="line">    String[] candidateNames = findAutowireCandidates(beanName, type, descriptor);</span><br><span class="line">    <span class="comment">// 筛选唯一候选 Bean</span></span><br><span class="line">    <span class="keyword">if</span> (candidateNames.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> getBean(candidateNames[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (candidateNames.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 按名称或 @Primary/@Priority 解决冲突</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">primaryCandidate</span> <span class="operator">=</span> determinePrimaryCandidate(candidateNames);</span><br><span class="line">        <span class="keyword">return</span> primaryCandidate != <span class="literal">null</span> ? primaryCandidate : determineHighestPriorityCandidate(candidateNames);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 抛出 NoUniqueBeanDefinitionException 异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 注入方式与优先级</strong></p>
<p><strong>3.1 构造函数注入</strong></p>
<ul>
<li><p><strong>触发条件</strong>：若类中存在唯一构造函数，或构造函数标记了 <code>@Autowired</code>。</p>
</li>
<li><p><strong>优势</strong>：保证依赖不可变，符合不可变对象设计。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserRepository userRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>3.2 Setter 方法注入</strong></p>
<ul>
<li><p><strong>触发条件</strong>：Setter 方法标记 <code>@Autowired</code>。</p>
</li>
<li><p><strong>优势</strong>：允许可选依赖或动态更新依赖。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPaymentService</span><span class="params">(PaymentService paymentService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.paymentService = paymentService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>3.3 字段注入</strong></p>
<ul>
<li><p><strong>触发条件</strong>：字段直接标记 <code>@Autowired</code>。</p>
</li>
<li><p><strong>劣势</strong>：难以实现不可变性，测试时需通过反射注入。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> InventoryService inventoryService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>4. 解决依赖冲突</strong></p>
<p><strong>4.1 @Qualifier</strong></p>
<p>通过名称指定注入的 Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;mysqlDataSource&quot;)</span></span><br><span class="line"><span class="keyword">private</span> DataSource dataSource;</span><br></pre></td></tr></table></figure>

<p><strong>4.2 @Primary</strong></p>
<p>标记优先选择的 Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">primaryDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.3 自定义限定符</strong></p>
<p>结合自定义注解与 <code>@Qualifier</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MysqlDatabase &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@MysqlDatabase</span></span><br><span class="line"><span class="keyword">private</span> DataSource dataSource;</span><br></pre></td></tr></table></figure>

<p><strong>5. 源码级关键逻辑</strong></p>
<p><strong>5.1 字段注入实现</strong></p>
<p>反射设置字段值（简化代码）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> bean.getClass().getDeclaredField(<span class="string">&quot;userRepository&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(bean, userRepository);</span><br></pre></td></tr></table></figure>

<p><strong>5.2 方法注入实现</strong></p>
<p>反射调用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> bean.getClass().getMethod(<span class="string">&quot;setUserRepository&quot;</span>, UserRepository.class);</span><br><span class="line">method.invoke(bean, userRepository);</span><br></pre></td></tr></table></figure>

<p><strong>6. 总结与最佳实践</strong></p>
<ul>
<li><strong>原理本质</strong>：<code>@Autowired</code> 通过 <code>BeanPostProcessor</code> 在 Bean 生命周期中动态解析并注入依赖。</li>
<li><strong>推荐方式</strong>：优先使用 <strong>构造函数注入</strong> 保证依赖不可变。</li>
<li><strong>避免陷阱</strong>：<ul>
<li><strong>循环依赖</strong>：避免 A 依赖 B，B 又依赖 A，可通过 <code>@Lazy</code> 延迟加载解决。</li>
<li><strong>多实例冲突</strong>：使用 <code>@Qualifier</code> 或 <code>@Primary</code> 明确指定 Bean。</li>
</ul>
</li>
<li><strong>性能优化</strong>：反射操作有一定开销，但 Spring 通过缓存元数据（如 <code>InjectionMetadata</code>）减少重复解析。</li>
</ul>
<h3 id="SpringMVC-工作流程"><a href="#SpringMVC-工作流程" class="headerlink" title="SpringMVC 工作流程"></a>SpringMVC 工作流程</h3><p><strong>核心组件</strong></p>
<ol>
<li><strong>DispatcherServlet</strong>：前置控制器，是整个流程控制的<strong>核心</strong>，控制其他组件的执行，进行统一调度，降低组件之间的耦合性，相当于总指挥。</li>
<li><strong>Handler</strong>：处理器，完成具体的业务逻辑，相当于 Servlet 或 Action。</li>
<li><strong>HandlerMapping</strong>：DispatcherServlet 接收到请求之后，通过 HandlerMapping 将不同的请求映射到不同的 Handler。</li>
<li><strong>HandlerInterceptor</strong>：处理器拦截器，是一个接口，如果需要完成一些拦截处理，可以实现该接口。</li>
<li><strong>HandlerExecutionChain</strong>：处理器执行链，包括两部分内容：Handler 和 HandlerInterceptor（系统会有一个默认的 HandlerInterceptor，如果需要额外设置拦截，可以添加拦截器）。</li>
<li><strong>HandlerAdapter</strong>：处理器适配器，Handler 执行业务方法之前，需要进行一系列的操作，包括表单数据的验证、数据类型的转换、将表单数据封装到 JavaBean 等，这些操作都是由 HandlerApater 来完成，开发者只需将注意力集中业务逻辑的处理上，DispatcherServlet 通过 HandlerAdapter 执行不同的 Handler。</li>
<li><strong>ModelAndView</strong>：装载了模型数据和视图信息，作为 Handler 的处理结果，返回给 DispatcherServlet。</li>
<li><strong>ViewResolver</strong>：视图解析器，DispatcheServlet 通过它将逻辑视图解析为物理视图，最终将渲染结果响应给客户端。</li>
</ol>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-e29a122b-db07-48b8-8289-7251032e87a1.png" alt="三分恶面渣逆袭：Spring MVC的工作流程"></p>
<h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><h3 id="SpringBoot自动装配原理"><a href="#SpringBoot自动装配原理" class="headerlink" title="SpringBoot自动装配原理"></a>SpringBoot自动装配原理</h3><p>Spring Boot 的自动装配是其核心特性之一，它极大地简化了 Spring 应用的配置过程，遵循“<strong>约定大于配置</strong>”的理念。其核心原理可以分解为以下几个关键点：</p>
<ol>
<li><strong><code>@SpringBootApplication</code> 注解：</strong><ul>
<li>这是 Spring Boot 应用的入口注解，标注在主启动类上。</li>
<li>它是一个<strong>组合注解</strong>，包含了三个核心注解：<ul>
<li><code>@SpringBootConfiguration</code>: 表明该类是一个 Spring Boot 的配置类（本质上是 <code>@Configuration</code>）。</li>
<li><code>@EnableAutoConfiguration</code>: <strong>开启自动装配的核心注解</strong>。</li>
<li><code>@ComponentScan</code>: 开启组件扫描，默认扫描主配置类所在包及其子包下的 <code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, <code>@Controller</code> 等注解的类。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>@EnableAutoConfiguration</code> 的核心作用：</strong><ul>
<li>这个注解通过 <code>@Import(AutoConfigurationImportSelector.class)</code> 导入了 <code>AutoConfigurationImportSelector</code>。</li>
<li><strong><code>AutoConfigurationImportSelector</code> 是自动装配的关键引擎：</strong><ul>
<li>它实现了 <code>DeferredImportSelector</code> 接口，在 Spring 容器处理完所有常规的 <code>@Configuration</code> 类之后才会执行。</li>
<li>它的核心方法是 <code>selectImports()</code>。这个方法负责<strong>决定需要导入哪些自动配置类</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>spring.factories</code> &#x2F; <code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>（新方式）：</strong><ul>
<li><code>AutoConfigurationImportSelector</code> 会去<strong>类路径下查找一个特定的文件</strong>来获取所有候选的自动配置类全限定名。</li>
<li><strong>Spring Boot 2.7 之前：</strong> 查找 <code>META-INF/spring.factories</code> 文件。在这个文件中，有一个键为 <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code> 的属性，其值是一个<strong>逗号分隔</strong>的自动配置类全限定名列表。</li>
<li><strong>Spring Boot 2.7 及之后：</strong> 推荐使用 <code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code> 文件。这个文件<strong>每行写一个</strong>自动配置类的全限定名。这是为了更好的 IDE 支持和工具链兼容性（如 GraalVM Native Image）。Spring Boot 仍然兼容 <code>spring.factories</code>，但新项目建议使用新方式。</li>
<li><strong>来源：</strong> 这些文件通常存在于 <code>spring-boot-autoconfigure</code> jar 包以及你引入的各种 <code>starter</code> jar 包（如 <code>spring-boot-starter-web</code>, <code>spring-boot-starter-data-jpa</code>）中。每个 <code>starter</code> 通过提供自己的 <code>spring.factories</code> 或 <code>AutoConfiguration.imports</code> 文件来声明它需要哪些自动配置。</li>
</ul>
</li>
<li><strong>自动配置类 (<code>@Configuration</code>)：</strong><ul>
<li>通过上述机制找到的候选类都是标有 <code>@Configuration</code> 注解的 Spring 配置类。</li>
<li>这些配置类内部使用 <code>@Bean</code> 注解定义了大量<strong>条件化</strong>的 Bean。这些 Bean 通常是框架或库的核心组件（如 <code>DataSource</code>, <code>EntityManagerFactory</code>, <code>RestTemplate</code>, <code>DispatcherServlet</code> 等）。</li>
</ul>
</li>
<li><strong>条件注解 (<code>@Conditional</code> 及其衍生注解)：</strong><ul>
<li>这是自动装配<strong>智能性</strong>的关键！自动配置类及其内部的 <code>@Bean</code> 方法上会大量使用条件注解。</li>
<li>这些注解控制着配置类和 Bean <strong>是否会被真正加载和创建</strong>。常见的条件注解有：<ul>
<li><code>@ConditionalOnClass</code>: 当类路径中存在指定的类时才生效。</li>
<li><code>@ConditionalOnMissingClass</code>: 当类路径中不存在指定的类时才生效。</li>
<li><code>@ConditionalOnBean</code>: 当容器中存在指定的 Bean 时才生效。</li>
<li><code>@ConditionalOnMissingBean</code>: 当容器中不存在指定的 Bean 时才生效。<strong>这是允许用户自定义 Bean 覆盖默认配置的关键！</strong></li>
<li><code>@ConditionalOnProperty</code>: 当指定的配置属性满足特定条件（如存在、等于某个值）时才生效。</li>
<li><code>@ConditionalOnWebApplication</code> &#x2F; <code>@ConditionalOnNotWebApplication</code>: 根据应用是否是 Web 应用来决定。</li>
<li><code>@ConditionalOnResource</code>: 当指定的资源文件存在时才生效。</li>
<li><code>@ConditionalOnJava</code>: 当运行在指定的 Java 版本上时才生效。</li>
</ul>
</li>
<li><strong>过程：</strong> Spring Boot 在启动时，会<strong>按顺序加载</strong>所有候选的自动配置类。对于每个配置类和其中的每个 <code>@Bean</code> 方法，Spring Boot 会<strong>评估其上的条件注解</strong>。只有当所有条件都满足时，这个配置类或 Bean 定义才会被真正处理并加入到 Spring 容器中。</li>
</ul>
</li>
<li><strong>自动配置元数据 (<code>spring-autoconfigure-metadata.properties</code>)：</strong><ul>
<li>为了<strong>提高启动性能</strong>（避免通过反射加载和解析大量不满足条件的配置类），Spring Boot 在编译时会为自动配置模块生成一个 <code>META-INF/spring-autoconfigure-metadata.properties</code> 文件。</li>
<li>这个文件预先存储了所有自动配置类上的<strong>条件信息</strong>（如 <code>@ConditionalOnClass</code> 要求的类）。</li>
<li>在启动的早期阶段，<code>AutoConfigurationImportSelector</code> 会首先读取这个元数据文件，<strong>快速过滤掉一大批明显不满足条件</strong>（例如，类路径上根本没有所需依赖的类）的自动配置类。只有通过元数据初步筛选的配置类才会被真正加载和解析，大大减少了类加载和条件评估的开销。</li>
</ul>
</li>
</ol>
<p><strong>总结流程：</strong></p>
<ol>
<li>启动 <code>main</code> 方法，加载标注了 <code>@SpringBootApplication</code> 的主类。</li>
<li><code>@SpringBootApplication</code> 中的 <code>@EnableAutoConfiguration</code> 激活自动装配。</li>
<li><code>@EnableAutoConfiguration</code> 通过 <code>@Import</code> 引入 <code>AutoConfigurationImportSelector</code>。</li>
<li><code>AutoConfigurationImportSelector</code> 在适当的时候执行：<ul>
<li>读取 <code>spring-autoconfigure-metadata.properties</code> 进行<strong>快速过滤</strong>。</li>
<li>读取 <code>META-INF/spring.factories</code> 或 <code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code> 文件，获取<strong>所有候选自动配置类</strong>的全名列表。</li>
<li><strong>应用自动配置元数据过滤器</strong>，剔除明显不满足条件的候选类。</li>
</ul>
</li>
<li>遍历剩下的候选自动配置类：<ul>
<li>使用反射加载类。</li>
<li><strong>详细评估类上的 <code>@Conditional</code> 及其衍生注解</strong>。</li>
<li>如果类级别的条件满足，则将该配置类作为一个 <code>@Configuration</code> 类处理。</li>
<li>处理配置类内部的 <code>@Bean</code> 方法，同样评估方法上的条件注解，满足条件的才注册为 Bean。</li>
</ul>
</li>
<li>最终，所有满足条件的自动配置类中定义的 Bean 被注册到 Spring IoC 容器中，应用就拥有了所需的基础设施 Bean。</li>
</ol>
<p><strong>关键优势：</strong></p>
<ul>
<li><strong>简化配置：</strong> 开发者只需引入 Starter 依赖，无需手动配置大量 Bean。</li>
<li><strong>开箱即用：</strong> 提供合理的默认配置，满足大部分场景。</li>
<li><strong>易于定制：</strong> 通过定义自己的 <code>@Bean</code> (利用 <code>@ConditionalOnMissingBean</code> 覆盖) 或修改 <code>application.properties</code>&#x2F;<code>application.yml</code> 即可轻松覆盖默认配置。</li>
<li><strong>按需加载：</strong> 基于条件注解，只加载当前应用实际需要的配置和 Bean，避免资源浪费。</li>
</ul>
<p><strong>理解要点：</strong></p>
<ul>
<li>自动装配不是黑魔法，本质上是 Spring <code>@Configuration</code> 和 <code>@Bean</code> 的<strong>条件化、批量化使用</strong>。</li>
<li><code>spring.factories</code> &#x2F; <code>AutoConfiguration.imports</code> 文件是<strong>自动配置类的注册中心</strong>。</li>
<li>条件注解 (<code>@ConditionalXXX</code>) 是<strong>决定哪些配置生效的规则引擎</strong>。</li>
<li>自动配置元数据 (<code>spring-autoconfigure-metadata.properties</code>) 是<strong>优化启动速度的关键</strong>。</li>
</ul>
<h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><h2 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h2><h2 id="日志框架"><a href="#日志框架" class="headerlink" title="日志框架"></a>日志框架</h2><h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><h2 id="基本理论"><a href="#基本理论" class="headerlink" title="基本理论"></a>基本理论</h2><h3 id="什么是CAP"><a href="#什么是CAP" class="headerlink" title="什么是CAP"></a>什么是CAP</h3><p>CAP定理是分布式系统设计中的一个核心原则，由计算机科学家Eric Brewer在2000年提出，后于2002年被证明。它指出，在存在<strong>网络分区（Partition Tolerance）</strong>的情况下，分布式系统无法同时满足以下三个特性：</p>
<ol>
<li><strong>一致性（Consistency）</strong><br>所有节点在同一时刻看到的数据完全相同。写入操作后，所有读取请求都会立即获得最新数据，不会出现数据不一致的情况。</li>
<li><strong>可用性（Availability）</strong><br>每个请求（无论读写）都能在合理时间内获得非错误响应，但不保证返回的数据是最新版本。即使部分节点故障，系统仍能正常响应。</li>
<li><strong>分区容忍性（Partition Tolerance）</strong><br>系统在网络分区（节点间通信中断，形成孤岛）时仍能继续运行。网络分区是分布式系统的客观现实，因此这一特性通常被视为必须支持的基础。</li>
</ol>
<img src="/post/65a5b0d7/image-20250505093121422.png" class="" title="image-20250505093121422">

<h3 id="什么是BASE"><a href="#什么是BASE" class="headerlink" title="什么是BASE"></a>什么是BASE</h3><p>BASE 是基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语的缩写。</p>
<p>BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>
<p><strong>基本可用</strong></p>
<p>指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。</p>
<p>例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。</p>
<p><strong>软状态</strong></p>
<p>指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在时延。</p>
<p><strong>最终一致性</strong></p>
<p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。</p>
<p>ACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。</p>
<p>在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用。</p>
<ol>
<li>分布式ID生成方案（雪花算法优化）</li>
<li>一致性Hash算法虚拟节点设计</li>
<li>分布式锁的三种实现方式对比</li>
<li>分布式Session解决方案</li>
<li>如何实现最终一致性（消息表+重试）</li>
<li>分库分表后分页查询方案</li>
<li>分布式事务最大努力通知型实现</li>
<li>数据同步方案（canal+MQ）</li>
<li>高并发下单系统设计（库存扣减）</li>
<li>分布式缓存更新策略（Cache Aside）</li>
<li>分布式系统时钟同步问题</li>
<li>脑裂问题解决方案</li>
</ol>
<h2 id="一致性协议"><a href="#一致性协议" class="headerlink" title="一致性协议"></a>一致性协议</h2><h3 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h3><h3 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h3><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h2 id="分布式ID生成"><a href="#分布式ID生成" class="headerlink" title="分布式ID生成"></a>分布式ID生成</h2><h1 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h1><ol>
<li>服务注册发现AP与CP架构对比</li>
<li>熔断降级策略（滑动窗口实现）</li>
<li>分布式配置中心推拉模式对比</li>
<li>灰度发布实现方案</li>
<li>分布式链路追踪原理（Span树）</li>
<li>Seata AT模式实现原理</li>
<li>接口性能突增的限流策略</li>
<li>如何设计服务治理平台？</li>
<li>设计微信朋友圈的存储架构</li>
<li>短链系统如何实现高并发写入？</li>
<li>分布式唯一ID生成方案（Snowflake优化）</li>
<li>如何设计一个分布式定时任务系统？</li>
<li>实现跨数据中心的数据同步方案</li>
<li>设计支持千万级用户的推送系统</li>
<li>微博热搜榜实时计算架构设计</li>
<li>电商库存扣减的防超卖方案</li>
<li>多级缓存架构设计（本地缓存+Redis+JVM）</li>
<li>设计支持PB级数据的日志分析系统</li>
<li>实现一个分布式配置中心</li>
<li>设计支持动态扩容的分库分表方案</li>
<li>如何设计API网关的限流熔断功能？</li>
<li>实时聊天系统的消息可靠投递方案</li>
<li>设计支持版本回滚的配置管理系统</li>
<li>实现跨语言服务调用（Thrift&#x2F;gRPC选型）</li>
<li>设计支持弹性伸缩的微服务架构</li>
<li>实现分布式Session一致性方案</li>
<li>设计一个高性能的日志采集系统</li>
<li>如何设计可追溯的操作日志系统？</li>
<li>如何实现熔断器模式（Circuit Breaker）？</li>
<li>CQRS模式在电商系统中的应用</li>
<li>事件溯源（Event Sourcing）的优缺点分析</li>
<li>Sidecar模式在服务治理中的应用</li>
<li>网关模式中的路由策略设计</li>
<li>防腐层（Anti-Corruption Layer）设计实践</li>
<li>领域驱动设计（DDD）中的聚合根设计</li>
<li>重试模式中的指数退避算法实现</li>
<li>前端的后端模式（BFF）适用场景</li>
<li>分片模式（Sharding）的数据迁移方案</li>
<li>管道过滤器模式在ETL中的应用</li>
<li>物化视图模式优化查询性能案例</li>
<li>策略模式在支付渠道选择中的应用</li>
<li>观察者模式实现配置动态更新</li>
<li>代理模式在缓存穿透防护中的应用</li>
<li>工厂方法模式在连接池创建中的应用</li>
<li>装饰器模式实现API限流功能</li>
<li>状态模式在订单状态流转中的应用</li>
<li>组合模式实现权限树结构设计</li>
<li>模板方法模式在事务管理中的应用</li>
<li>HTTPS握手过程优化策略</li>
<li>零拷贝技术实现原理</li>
<li>百万连接服务器架构设计</li>
<li>线上CPU飙高排查流程</li>
<li>设计一个短链系统</li>
<li>接口性能优化全链路方案</li>
<li>海量数据判重方案（布隆过滤器）</li>
<li>如何设计秒杀系统？</li>
<li>大型项目代码规范落地实践</li>
<li>线上问题排查工具箱（arthas+prometheus）</li>
</ol>
<h2 id="认证授权"><a href="#认证授权" class="headerlink" title="认证授权"></a>认证授权</h2><h2 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h2><h2 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h2><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><p>核心思想：<strong>在单位时间内，只允许特定数量的请求通过，超过阈值的请求将被拒绝、排队等待或降级处理。</strong> 目的是保护系统不被突发流量压垮，确保系统在最大承受能力内稳定运行。</p>
<h4 id="常见的限流算法有哪些"><a href="#常见的限流算法有哪些" class="headerlink" title="常见的限流算法有哪些"></a>常见的限流算法有哪些</h4><p><strong>固定窗口计算器算法</strong></p>
<p><strong>滑动窗口计数器算法</strong></p>
<p><strong>漏桶算法</strong></p>
<p><strong>令牌桶算法</strong></p>
<h3 id="降级-熔断"><a href="#降级-熔断" class="headerlink" title="降级&amp;熔断"></a>降级&amp;熔断</h3><h1 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h1><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><h2 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI&#x2F;CD"></a>CI&#x2F;CD</h2><h1 id="工具类库"><a href="#工具类库" class="headerlink" title="工具类库"></a>工具类库</h1><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h1><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ol>
<li>用户态与内核态切换的开销来源？</li>
<li>进程间通信IPC的5种方式对比</li>
<li>虚拟内存与物理内存映射原理（页表寻址）</li>
<li>死锁的必要条件及银行家算法实现</li>
<li>自旋锁与互斥锁的使用场景差异</li>
<li>零拷贝技术实现原理（sendfile&#x2F;mmap）</li>
<li>孤儿进程与僵尸进程的区别及处理</li>
<li>CPU软中断与硬中断处理机制</li>
<li>如何用top命令分析CPU负载异常？</li>
<li>内存泄漏与内存溢出的定位方法</li>
<li>大页内存（HugePage）优化原理</li>
<li>协程与线程的调度效率差异</li>
<li>文件描述符（fd）耗尽如何处理？</li>
<li>CPU缓存行伪共享问题解决方案</li>
<li>NUMA架构下的性能调优要点</li>
<li>系统调用过程详解（int 0x80&#x2F;syscall）</li>
<li>实时操作系统与非实时系统的调度差异</li>
<li>容器与虚拟机的资源隔离原理对比</li>
<li>如何实现一个简单的线程池？</li>
<li>系统平均负载（Load Average）的深层含义</li>
</ol>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ol>
<li>TCP三次握手与四次挥手的状态变迁图</li>
<li>TIME_WAIT状态过多如何优化？</li>
<li>HTTPS双向认证流程与中间人攻击防范</li>
<li>QUIC协议如何解决队头阻塞问题？</li>
<li>TCP拥塞控制算法（CUBIC&#x2F;BBR）</li>
<li>HTTP&#x2F;2多路复用与队头阻塞解决方案</li>
<li>Websocket握手协议与心跳机制实现</li>
<li>DNS解析过程（递归查询与迭代查询）</li>
<li>CDN动态加速与静态加速技术原理</li>
<li>如何设计一个高并发连接的服务端？</li>
<li>长连接保活策略（TCP Keepalive vs 应用层心跳）</li>
<li>网络抓包分析实战（Wireshark过滤技巧）</li>
<li>单机百万连接的实现与优化</li>
<li>HTTP Range请求与断点续传实现</li>
<li>5层协议栈中每层的典型设备</li>
<li>VLAN与VXLAN的区别及使用场景</li>
<li>如何实现UDP可靠传输？</li>
<li>MTU与MSS的关系及分片问题</li>
<li>SYN Flood攻击原理与防御方案</li>
<li>TLS1.3相比1.2的核心改进点</li>
</ol>
<h1 id="思维逻辑"><a href="#思维逻辑" class="headerlink" title="思维逻辑"></a>思维逻辑</h1><h2 id="小白鼠试毒药"><a href="#小白鼠试毒药" class="headerlink" title="小白鼠试毒药"></a>小白鼠试毒药</h2><h2 id="100个人按灯"><a href="#100个人按灯" class="headerlink" title="100个人按灯"></a>100个人按灯</h2><blockquote>
<p>有100盏灯,编号依次为1,2,3…100,电灯全部关着。现在来了100个人,第一个人把所有的灯开关按下；第二个人隔一个灯按下（2,4,6…）；第三个人每隔两个灯按下（3,6,9…）.第100个人隔99个灯按下（100）,最后还有几盏灯，那几盏灯亮着？</p>
</blockquote>
<h2 id="100的阶乘有几个0"><a href="#100的阶乘有几个0" class="headerlink" title="100的阶乘有几个0"></a>100的阶乘有几个0</h2><p>100的阶乘（100!）有多少个末尾的零，可以通过计算其因式分解中10的因子个数来确定，因为末尾的零是由2和5相乘得到的。</p>
<p>首先，我们将100!进行因式分解。100!表示从1乘到100的连续整数的乘积，可以写成：</p>
<p>100! &#x3D; 1 × 2 × 3 × 4 × … × 99 × 100</p>
<p>接下来，我们观察乘法中每一项的因子中2和5的个数。</p>
<p>在100!中，偶数的因子2的个数明显比5多，因为每隔一个数就会有一个偶数出现，而偶数都包含因子2。所以，我们只需要关注100!中5的因子个数。</p>
<p>在100!中，5、10、15、20、…、95、100这些数都包含因子5，共有20个数。而25、50、75、100这些数包含两个因子5，所以需要将其计算在内。</p>
<p>因此，100!中总共有20 + 4 &#x3D; 24个因子5。</p>
<p>综上所述，100!末尾共有24个零。</p>
<h2 id="用天平找最轻-重的球"><a href="#用天平找最轻-重的球" class="headerlink" title="用天平找最轻&#x2F;重的球"></a>用天平找最轻&#x2F;重的球</h2><blockquote>
<p>8个球，一个轻，天平2次找出来</p>
</blockquote>
<p>第一次称重：将任意三个球放在天平的一边，再将另外三个球放在另一边，剩下的两个球不放在天平上。如果天平平衡，则轻的球在剩下的两个球中，可以直接通过目测或者手感来找出轻的球。如果天平不平衡，那么轻的球一定在轻的那一边。</p>
<p>第二次称重：将轻的那一边的三个球中的两个球放在天平的一边，将剩下的一个球放在另一边。如果天平平衡，则剩下的那个球就是轻的球；如果天平不平衡，那么轻的球就是轻的那一边的球。</p>
<h2 id="2017的2017-次方的最后一位数"><a href="#2017的2017-次方的最后一位数" class="headerlink" title="2017的2017 次方的最后一位数"></a>2017的2017 次方的最后一位数</h2><p>计算2017的2017次方的最后一位数，可以使用数论中的数学性质来简化计算。根据数学性质，一个整数的末位数只和该整数的个位数有关，而与其他位数无关。</p>
<p>首先，我们观察2017的个位数是什么。2017除以10的余数是7，因此2017的个位数是7。</p>
<p>接下来，我们观察7的幂的个位数的规律。我们可以列举一些7的幂，看看个位数的变化：</p>
<p>7^1 &#x3D; 7 7^2 &#x3D; 49 7^3 &#x3D; 343 7^4 &#x3D; 2401 7^5 &#x3D; 16807 …</p>
<p>可以观察到，7的幂的个位数会在7、9、3、1这四个数字之间循环。具体地，7^1的个位数是7，7^2的个位数是9，7^3的个位数是3，7^4的个位数是1，7^5的个位数又是7，以此类推。</p>
<p>因此，我们可以利用这个规律来简化计算2017的2017次方的个位数。2017除以4的余数是1，所以2017的2017次方的个位数也是1。</p>
<p>综上所述，2017的2017次方的最后一位数是1。</p>
<h2 id="25匹马，5个跑道，最少比多少次能比出前3名"><a href="#25匹马，5个跑道，最少比多少次能比出前3名" class="headerlink" title="25匹马，5个跑道，最少比多少次能比出前3名"></a>25匹马，5个跑道，最少比多少次能比出前3名</h2><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/d6b72329.html" rel="prev" title="Spring/SpringBoot常用扩展点">
                  <i class="fa fa-angle-left"></i> Spring/SpringBoot常用扩展点
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa-regular fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder"></span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Word count total">84k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">5:07</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>

  <script class="next-config" data-name="wavedrom" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/wavedrom.min.js","integrity":"sha256-INLAoJc6quTNfiMWkGZniYO2cxE8mHpddnLow1m6RFs="}}</script>
  <script class="next-config" data-name="wavedrom_skin" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/skins/default.js","integrity":"sha256-fduc/Zszk5ezWws2uInY/ALWVmIrmV6VTgXbsYSReFI="}}</script>
  <script src="/js/third-party/tags/wavedrom.js"></script>




  





</body>
</html>
