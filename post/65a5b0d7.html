<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"timewait7.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":true,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Java新特性Java 8（📍）Java 9Java 10Java 11Java 12 &amp; 13Java 14 &amp; 15Java 16Java 17（📍）Java 18Java 19Java 20Java 21（📍）Java 22 &amp; 23Java 24Java基础语法基础&#x3D;&#x3D;和equals的区别&#x3D;&#x3D; 用于比较基本数据类型的值或对象引用的内存地址，equals 用户比">
<meta property="og:type" content="article">
<meta property="og:title" content="Java学习&amp;面试">
<meta property="og:url" content="http://timewait7.github.io/post/65a5b0d7.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Java新特性Java 8（📍）Java 9Java 10Java 11Java 12 &amp; 13Java 14 &amp; 15Java 16Java 17（📍）Java 18Java 19Java 20Java 21（📍）Java 22 &amp; 23Java 24Java基础语法基础&#x3D;&#x3D;和equals的区别&#x3D;&#x3D; 用于比较基本数据类型的值或对象引用的内存地址，equals 用户比">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-07-19T05:58:30.000Z">
<meta property="article:modified_time" content="2025-07-19T09:25:39.970Z">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://timewait7.github.io/post/65a5b0d7.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://timewait7.github.io/post/65a5b0d7.html","path":"post/65a5b0d7.html","title":"Java学习&面试"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java学习&面试 | Hexo</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-archives"><a href="/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="Searching..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java"><span class="nav-number">1.</span> <span class="nav-text">Java</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.1.</span> <span class="nav-text">新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-8%EF%BC%88%F0%9F%93%8D%EF%BC%89"><span class="nav-number">1.1.1.</span> <span class="nav-text">Java 8（📍）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-9"><span class="nav-number">1.1.2.</span> <span class="nav-text">Java 9</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-10"><span class="nav-number">1.1.3.</span> <span class="nav-text">Java 10</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-11"><span class="nav-number">1.1.4.</span> <span class="nav-text">Java 11</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-12-13"><span class="nav-number">1.1.5.</span> <span class="nav-text">Java 12 &amp; 13</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-14-15"><span class="nav-number">1.1.6.</span> <span class="nav-text">Java 14 &amp; 15</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-16"><span class="nav-number">1.1.7.</span> <span class="nav-text">Java 16</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-17%EF%BC%88%F0%9F%93%8D%EF%BC%89"><span class="nav-number">1.1.8.</span> <span class="nav-text">Java 17（📍）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-18"><span class="nav-number">1.1.9.</span> <span class="nav-text">Java 18</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-19"><span class="nav-number">1.1.10.</span> <span class="nav-text">Java 19</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-20"><span class="nav-number">1.1.11.</span> <span class="nav-text">Java 20</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-21%EF%BC%88%F0%9F%93%8D%EF%BC%89"><span class="nav-number">1.1.12.</span> <span class="nav-text">Java 21（📍）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-22-23"><span class="nav-number">1.1.13.</span> <span class="nav-text">Java 22 &amp; 23</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-24"><span class="nav-number">1.1.14.</span> <span class="nav-text">Java 24</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="nav-number">1.2.</span> <span class="nav-text">Java基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80"><span class="nav-number">1.2.1.</span> <span class="nav-text">语法基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">&#x3D;&#x3D;和equals的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#equals%E5%92%8ChashCode%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%90%8C%E6%97%B6%E9%87%8D%E5%86%99"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">equals和hashCode为什么要同时重写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">异常的层次结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">1.2.2.</span> <span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B3%9B%E5%9E%8B"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">为什么需要泛型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">什么是泛型擦除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E9%99%90%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">泛型的上下限及应用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">1.2.3.</span> <span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">什么是反射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">反射的优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84-Class-%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">如何获取一个类的 Class 对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.2.3.4.</span> <span class="nav-text">如何通过反射创建一个类的实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.2.3.5.</span> <span class="nav-text">反射有哪些实际应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Class-forName-%E5%92%8C-ClassLoader-loadClass-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.3.6.</span> <span class="nav-text">Class.forName() 和 ClassLoader.loadClass() 有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%B0%84%E7%A0%B4%E5%9D%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.2.3.7.</span> <span class="nav-text">如何防止反射破坏单例模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.2.4.</span> <span class="nav-text">注解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E4%B8%AD%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">Java中都有哪些元注解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SPI"><span class="nav-number">1.2.5.</span> <span class="nav-text">SPI</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E9%9B%86%E5%90%88"><span class="nav-number">1.3.</span> <span class="nav-text">Java集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80"><span class="nav-number">1.3.1.</span> <span class="nav-text">集合基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Iterator-%E5%92%8C-ListIterator-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">Iterator 和 ListIterator 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-fail-fast-%E6%9C%BA%E5%88%B6"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">什么是 fail-fast 机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fail-fast-%E5%92%8C-fail-safe-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">fail-fast 和 fail-safe 的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List"><span class="nav-number">1.3.2.</span> <span class="nav-text">List</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">ArrayList的扩容机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Vector-%E5%92%8C-ArrayList-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">Vector 和 ArrayList 的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set"><span class="nav-number">1.3.3.</span> <span class="nav-text">Set</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HashSet%E3%80%81LinkedHashSet-%E5%92%8C-TreeSet-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">HashSet、LinkedHashSet 和 TreeSet 的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map"><span class="nav-number">1.3.4.</span> <span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">HashMap 的底层实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap-%E5%92%8C-HashTable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">HashMap 和 HashTable 的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-IO"><span class="nav-number">1.4.</span> <span class="nav-text">Java IO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%B9%B6%E5%8F%91"><span class="nav-number">1.5.</span> <span class="nav-text">Java并发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JUC%E9%9B%86%E5%90%88"><span class="nav-number">1.5.1.</span> <span class="nav-text">JUC集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentHashMap-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">ConcurrentHashMap 的实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-ConcurrentHashMap-%E6%AF%94-Hashtable-%E6%95%88%E7%8E%87%E9%AB%98"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">为什么 ConcurrentHashMap 比 Hashtable 效率高</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM"><span class="nav-number">1.6.</span> <span class="nav-text">JVM</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="nav-number">2.</span> <span class="nav-text">数据存储</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL"><span class="nav-number">2.1.</span> <span class="nav-text">MySQL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis"><span class="nav-number">2.2.</span> <span class="nav-text">Redis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ElasticSearch"><span class="nav-number">2.3.</span> <span class="nav-text">ElasticSearch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MongoDB"><span class="nav-number">2.4.</span> <span class="nav-text">MongoDB</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">3.</span> <span class="nav-text">消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka"><span class="nav-number">3.1.</span> <span class="nav-text">Kafka</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RabbitMQ"><span class="nav-number">3.2.</span> <span class="nav-text">RabbitMQ</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RocketMQ"><span class="nav-number">3.3.</span> <span class="nav-text">RocketMQ</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6"><span class="nav-number">4.</span> <span class="nav-text">开发框架</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring"><span class="nav-number">4.1.</span> <span class="nav-text">Spring</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringBoot"><span class="nav-number">4.2.</span> <span class="nav-text">SpringBoot</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tomcat"><span class="nav-number">4.3.</span> <span class="nav-text">Tomcat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MyBatis"><span class="nav-number">4.4.</span> <span class="nav-text">MyBatis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JPA"><span class="nav-number">4.5.</span> <span class="nav-text">JPA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6"><span class="nav-number">4.6.</span> <span class="nav-text">日志框架</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F"><span class="nav-number">5.</span> <span class="nav-text">分布式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">6.</span> <span class="nav-text">架构设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83"><span class="nav-number">6.1.</span> <span class="nav-text">认证授权</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8"><span class="nav-number">6.2.</span> <span class="nav-text">数据安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E6%80%A7%E8%83%BD"><span class="nav-number">6.3.</span> <span class="nav-text">高性能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="nav-number">6.4.</span> <span class="nav-text">高可用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DevOps"><span class="nav-number">7.</span> <span class="nav-text">DevOps</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux"><span class="nav-number">7.1.</span> <span class="nav-text">Linux</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker"><span class="nav-number">7.2.</span> <span class="nav-text">Docker</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CI-CD"><span class="nav-number">7.3.</span> <span class="nav-text">CI&#x2F;CD</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%BA%93"><span class="nav-number">8.</span> <span class="nav-text">工具类库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Git"><span class="nav-number">8.1.</span> <span class="nav-text">Git</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Maven"><span class="nav-number">8.2.</span> <span class="nav-text">Maven</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80"><span class="nav-number">9.</span> <span class="nav-text">计算机基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">9.1.</span> <span class="nav-text">操作系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="nav-number">9.2.</span> <span class="nav-text">计算机网络</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/">
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="Back to top">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://timewait7.github.io/post/65a5b0d7.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java学习&面试 | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java学习&面试
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-07-19 13:58:30" itemprop="dateCreated datePublished" datetime="2025-07-19T13:58:30+08:00">2025-07-19</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>7.3k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>27 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><h3 id="Java-8（📍）"><a href="#Java-8（📍）" class="headerlink" title="Java 8（📍）"></a>Java 8（📍）</h3><h3 id="Java-9"><a href="#Java-9" class="headerlink" title="Java 9"></a>Java 9</h3><h3 id="Java-10"><a href="#Java-10" class="headerlink" title="Java 10"></a>Java 10</h3><h3 id="Java-11"><a href="#Java-11" class="headerlink" title="Java 11"></a>Java 11</h3><h3 id="Java-12-13"><a href="#Java-12-13" class="headerlink" title="Java 12 &amp; 13"></a>Java 12 &amp; 13</h3><h3 id="Java-14-15"><a href="#Java-14-15" class="headerlink" title="Java 14 &amp; 15"></a>Java 14 &amp; 15</h3><h3 id="Java-16"><a href="#Java-16" class="headerlink" title="Java 16"></a>Java 16</h3><h3 id="Java-17（📍）"><a href="#Java-17（📍）" class="headerlink" title="Java 17（📍）"></a>Java 17（📍）</h3><h3 id="Java-18"><a href="#Java-18" class="headerlink" title="Java 18"></a>Java 18</h3><h3 id="Java-19"><a href="#Java-19" class="headerlink" title="Java 19"></a>Java 19</h3><h3 id="Java-20"><a href="#Java-20" class="headerlink" title="Java 20"></a>Java 20</h3><h3 id="Java-21（📍）"><a href="#Java-21（📍）" class="headerlink" title="Java 21（📍）"></a>Java 21（📍）</h3><h3 id="Java-22-23"><a href="#Java-22-23" class="headerlink" title="Java 22 &amp; 23"></a>Java 22 &amp; 23</h3><h3 id="Java-24"><a href="#Java-24" class="headerlink" title="Java 24"></a>Java 24</h3><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h3><h4 id="和equals的区别"><a href="#和equals的区别" class="headerlink" title="==和equals的区别"></a><code>==</code>和<code>equals</code>的区别</h4><p><code>==</code> 用于比较基本数据类型的值或对象引用的内存地址，<code>equals</code> 用户比较对象内容。</p>
<h4 id="equals和hashCode为什么要同时重写"><a href="#equals和hashCode为什么要同时重写" class="headerlink" title="equals和hashCode为什么要同时重写"></a><code>equals</code>和<code>hashCode</code>为什么要同时重写</h4><ol>
<li>契约要求：对象相等性的一致性</li>
</ol>
<ul>
<li><p><strong><code>Object</code>类的规范</strong>明确规定：</p>
<blockquote>
<p>如果两个对象通过<code>equals()</code>方法比较是相等的，那么它们的<code>hashCode()</code><strong>必须</strong>返回相同的值。</p>
</blockquote>
</li>
<li><p>如果违反此契约，对象在基于哈希的集合中会出现不可预测的行为（如<code>HashMap</code>无法正确查找对象）。</p>
</li>
</ul>
<ol start="2">
<li>基于哈希的集合（如<code>HashMap</code>, <code>HashSet</code>）依赖<code>hashCode()</code>和<code>equals()</code>协同工作：</li>
</ol>
<ul>
<li><p><strong><code>hashCode()</code>定位桶（Bucket）</strong>：<br>集合首先调用<code>hashCode()</code>确定对象存储在哪个哈希桶中。</p>
</li>
<li><p><strong><code>equals()</code>确认唯一性</strong>：<br>在同一个桶内，再调用<code>equals()</code>检查对象是否真正相等（解决哈希冲突）。</p>
</li>
</ul>
<ol start="3">
<li><p>假设只重写了<code>equals()</code>但未重写<code>hashCode()</code>：</p>
<ul>
<li><p><strong>场景</strong>：两个对象<code>a</code>和<code>b</code>满足<code>a.equals(b) == true</code>，但<code>a.hashCode() != b.hashCode()</code>。</p>
</li>
<li><p><strong>问题</strong>：</p>
<ul>
<li>它们会被存入<code>HashMap</code>的<strong>不同桶</strong>中（因为哈希值不同，未重写的<code>hasoCode()</code>默认返回内存地址）。</li>
<li><code>map.put(a, val1)</code>和<code>map.put(b, val2)</code>会同时存在，违反<code>Map</code>的键唯一性。</li>
</ul>
</li>
<li><p>示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">// 重写equals但未重写hashCode</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    Set&lt;Person&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    set.add(p1);</span><br><span class="line">    set.add(p2);  <span class="comment">// p1.equals(p2)=true，但Set会存储两个对象！</span></span><br><span class="line">    System.out.println(set.size()); <span class="comment">// 输出2（错误，应为1）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>重写<code>hashCode()</code>需满足：</p>
<ul>
<li><strong>一致性</strong>：如果<code>a.equals(b)</code>，则<code>a.hashCode() == b.hashCode()</code>。</li>
<li><strong>稳定性</strong>：在对象状态不变时，多次调用<code>hashCode()</code>应返回相同值。</li>
<li><strong>高效性</strong>：尽量减少哈希冲突（不同对象尽量返回不同哈希值）。</li>
</ul>
<p><strong>推荐方法</strong>（使用<code>Objects.hash()</code>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(name, age); <span class="comment">// 包含所有equals中使用的字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="异常的层次结构"><a href="#异常的层次结构" class="headerlink" title="异常的层次结构"></a>异常的层次结构</h4><p><code>Throwable</code>：所有异常和错误的父类</p>
<p><code>Error</code>：</p>
<ul>
<li><strong>系统级严重问题</strong>，应用程序通常无法恢复</li>
<li>示例：<ul>
<li><code>OutOfMemoryError</code>：内存耗尽</li>
<li><code>StackOverflowError</code>：栈溢出</li>
<li><code>VirtualMachineError</code>：JVM致命错误</li>
</ul>
</li>
<li>❗ <strong>无需捕获处理</strong>（即使捕获也难以恢复）</li>
</ul>
<p><code>Exception</code>：</p>
<ol>
<li><ul>
<li><p><strong>程序可处理的异常</strong>，分为两类：</p>
<ul>
<li><p><strong>Checked Exceptions（受检异常）</strong><br>编译器强制要求处理（必须<code>try-catch</code>或<code>throws</code>）<br>✅ <strong>典型代表</strong>：<code>IOException</code>、<code>SQLException</code>、<code>ClassNotFoundException</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须处理IOException的示例</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Files.readString(Path.of(<span class="string">&quot;file.txt&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123; <span class="comment">// 必须捕获</span></span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>RuntimeException</code>（运行时异常&#x2F;非受检异常）</strong><br>编译器不强制处理，通常由<strong>编程逻辑错误</strong>引起<br>⚠️ <strong>典型代表</strong>：<code>NullPointerException</code>、<code>IndexOutOfBoundsException</code>、<code>IllegalArgumentException</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可选的运行时异常处理</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  System.out.println(str.length()); <span class="comment">// 抛出NullPointerException</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// 非强制捕获</span></span><br><span class="line">  System.out.println(<span class="string">&quot;逻辑错误！&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ol>
<pre class="mermaid">classDiagram
  Throwable <|-- Error
  Throwable <|-- Exception
  Exception <|-- RuntimeException
  Exception <|-- 其他Checked Exceptions
  RuntimeException <|-- Unchecked Exceptions

  class Throwable {
    +String getMessage()
    +void printStackTrace()
  }
  class Error {
    <<系统级错误>>
    +OutOfMemoryError
    +StackOverflowError
    +VirtualMachineError
  }
  class Exception {
    <<程序可处理的异常>>
  }
  class RuntimeException {
    <<运行时异常>>
    +NullPointerException
    +IndexOutOfBoundsException
    +IllegalArgumentException
  }</pre>



<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="为什么需要泛型"><a href="#为什么需要泛型" class="headerlink" title="为什么需要泛型"></a>为什么需要泛型</h4><p>泛型（Generics）是现代编程语言（如 Java、C#、C++、TypeScript 等）中一项极其重要的特性，它的出现主要是为了解决<strong>代码复用</strong>、<strong>类型安全</strong>和<strong>可读性</strong>这三大核心问题。</p>
<p>📍 1. <strong>类型安全（Type Safety）</strong></p>
<ul>
<li><strong>问题：</strong> 在没有泛型之前（例如使用 Java 的 <code>Object</code> 或 C# 的 <code>object</code>），容器类（如集合 <code>List</code>、<code>Array</code>）可以存放任何类型的对象。当你从容器中取出对象时，你需要进行强制类型转换 (<code>(String) myList.get(0)</code>)。</li>
<li><strong>风险：</strong> 如果容器里不小心放入了错误的类型（比如你期望是 <code>String</code>，但实际放入了 <code>Integer</code>），这个错误在<strong>编译时不会被发现</strong>，只有在**运行时进行强制转换时才会抛出 <code>ClassCastException</code>**，导致程序崩溃。</li>
<li><strong>泛型解决方案：</strong> 泛型允许你在<strong>声明</strong>容器时就指定它只能存放特定类型（如 <code>List&lt;String&gt;</code>）。编译器会在<strong>编译时</strong>严格检查你放入容器的对象类型是否匹配。如果尝试放入错误类型，编译器会直接报错，阻止潜在的类型错误运行到生产环境。</li>
</ul>
<p>🔁 2. <strong>消除强制类型转换（Eliminating Casts）</strong></p>
<ul>
<li><strong>问题：</strong> 使用原始类型（非泛型）容器时，每次取出元素都需要进行显式的、冗长的、容易出错的强制类型转换。 *   <strong>泛型解决方案：</strong> 使用泛型容器（如 <code>List&lt;String&gt;</code>）后，当你从容器中获取元素时（如 <code>String s = myList.get(0);</code>），<strong>编译器会自动知道返回的是 <code>String</code> 类型，不需要任何强制转换</strong>。代码更简洁，更安全。</li>
</ul>
<p>♻ 3. <strong>代码复用（Code Reuse）</strong></p>
<ul>
<li><strong>问题：</strong> 编写一个算法（比如排序、搜索、比较），你希望它能作用于多种不同类型的对象（整数、字符串、自定义对象等）。没有泛型时，你需要为每种类型重写算法，或者使用 <code>Object</code> 并伴随类型检查和转换。</li>
<li><strong>泛型解决方案：</strong> 泛型允许你编写<strong>类型无关的算法</strong>。你可以定义一个操作在类型参数 <code>T</code> 上的方法或类（例如 <code>public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code>）。只要类型 <code>T</code> 满足算法所需的基本条件（比如实现了 <code>Comparable</code> 接口），同一个算法代码就可以安全地应用于各种不同的数据类型。</li>
</ul>
<p>📖 4. <strong>提高代码可读性和可维护性（Improved Readability &amp; Maintainability）</strong></p>
<ul>
<li><strong>问题：</strong> 使用原始类型或 <code>Object</code>，代码的意图变得模糊。阅读代码的人需要仔细查看上下文（或者注释）才能理解某个容器预期存放什么类型的数据。</li>
<li><strong>泛型解决方案：</strong> 泛型声明（如 <code>Map&lt;String, Customer&gt;</code>）本身就是<strong>清晰、自文档化的代码</strong>。它明确地告诉开发者和编译器：这个容器是做什么用的（存储键为 <code>String</code>、值为 <code>Customer</code> 的映射）。这使得代码更容易理解、维护和调试。</li>
</ul>
<h4 id="什么是泛型擦除"><a href="#什么是泛型擦除" class="headerlink" title="什么是泛型擦除"></a>什么是泛型擦除</h4><p>泛型擦除（Type Erasure）是 <strong>Java 泛型实现的核心机制</strong>，它指编译器在编译阶段<strong>移除所有泛型类型信息</strong>，将其替换为原始类型（Raw Type）或边界类型（Bound Type），并在必要时插入强制类型转换。这一设计主要是为了<strong>兼容旧版本的 Java（JDK 5 之前）</strong>，确保泛型代码能与非泛型遗留代码互操作。</p>
<p><strong>一、泛型擦除的核心规则</strong></p>
<ol>
<li><p><strong>类型参数替换为边界类型</strong></p>
<ul>
<li>若类型参数有上限（如 <code>&lt;T extends Number&gt;</code>），<code>T</code> 被替换为<strong>边界类型</strong>（<code>Number</code>）。</li>
<li>若无明确上限（如 <code>&lt;T&gt;</code>），<code>T</code> 被替换为 **<code>Object</code>**。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123; <span class="built_in">this</span>.value = value; &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后（擦除后）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object value;         <span class="comment">// T → Object</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Object value)</span> &#123; <span class="built_in">this</span>.value = value; &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> value; &#125; <span class="comment">// 返回 Object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在调用处插入强制类型转换</strong><br>编译器在<strong>使用泛型的地方</strong>自动添加类型转换代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line">Box&lt;String&gt; box = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();</span><br><span class="line">box.set(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> box.get(); <span class="comment">// 无需显式转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后（擦除后）</span></span><br><span class="line"><span class="type">Box</span> <span class="variable">box</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Box</span>();</span><br><span class="line">box.set(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) box.get(); <span class="comment">// 编译器插入 (String) 强制转换</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>保证类型安全的桥接方法（Bridge Methods）</strong><br>当泛型类继承或实现接口时，编译器会生成<strong>合成方法</strong>确保多态性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T other)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String other)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后（擦除后）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="comment">// 编译器生成的桥接方法（保持多态）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object other)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> compareTo((String) other); <span class="comment">// 调用实际方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际编写的泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String other)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>二、泛型擦除导致的关键限制</strong></p>
<ol>
<li><p><strong>无法使用基本类型作为类型参数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 编译错误！不能使用 int</span></span><br><span class="line">List&lt;<span class="type">int</span>&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br><span class="line"><span class="comment">// 必须使用包装类</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>无法获取泛型具体类型的 <code>Class</code> 对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// ❌ 编译错误！List&lt;String&gt;.class 不存在</span></span><br><span class="line">Class&lt;?&gt; clazz = list.getClass(); </span><br><span class="line"><span class="comment">// 输出：java.util.ArrayList（无法得知是 List&lt;String&gt;）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>无法使用 <code>instanceof</code> 检查泛型类型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (list <span class="keyword">instanceof</span> List&lt;String&gt;) &#123; ... &#125; <span class="comment">// ❌ 编译错误！</span></span><br><span class="line"><span class="keyword">if</span> (list <span class="keyword">instanceof</span> List&lt;?&gt;) &#123; ... &#125;      <span class="comment">// ✅ 允许（但无具体类型信息）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>无法创建泛型数组</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 编译错误！</span></span><br><span class="line">T[] array = <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">10</span>]; </span><br><span class="line"><span class="comment">// 替代方案：使用反射或 ArrayList</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>方法签名冲突（重载失效）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 编译错误！擦除后都是 void print(List list)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;String&gt; list)</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;Integer&gt; list)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>三、为什么 Java 选择泛型擦除？</strong></p>
<ol>
<li><strong>向后兼容性（Backward Compatibility）</strong><ul>
<li>确保 JDK 5+ 的泛型代码能运行在旧 JVM（1.4 或更早）上。</li>
<li>非泛型集合（如 <code>ArrayList</code>）和泛型集合（<code>ArrayList&lt;String&gt;</code>）在 JVM 层面都是同一个类。</li>
</ul>
</li>
<li><strong>运行时效率（Runtime Efficiency）</strong><ul>
<li>不需要为每种泛型组合生成新的类（如 C# 的泛型实现），节省内存。</li>
<li>JVM 无需修改即可支持泛型（仅编译器层处理）。</li>
</ul>
</li>
</ol>
<p><strong>四、如何绕过擦除的限制？</strong></p>
<ol>
<li><p><strong>类型令牌（Type Token）</strong><br>通过传递 <code>Class&lt;T&gt;</code> 对象保留类型信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Box</span><span class="params">(Class&lt;T&gt; type)</span> &#123; <span class="built_in">this</span>.type = type; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInstance</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type.isInstance(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>反射 API（Reflection）</strong><br>运行时获取泛型参数（需接口&#x2F;父类保留信息）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> myList.getClass().getGenericSuperclass();</span><br><span class="line"><span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">    <span class="type">Type</span> <span class="variable">actualType</span> <span class="operator">=</span> ((ParameterizedType)type).getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">    System.out.println(actualType); <span class="comment">// 输出如 String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>五、与其他语言泛型实现的对比</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>语言</strong></th>
<th align="left"><strong>泛型实现</strong></th>
<th align="left"><strong>运行时类型保留</strong></th>
<th align="left"><strong>特点</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">Java</td>
<td align="left">类型擦除</td>
<td align="left">❌</td>
<td align="left">兼容旧版，效率高</td>
</tr>
<tr>
<td align="left">C#</td>
<td align="left">具现化（Reified）</td>
<td align="left">✅</td>
<td align="left">运行时保留类型，支持泛型数组</td>
</tr>
<tr>
<td align="left">Kotlin</td>
<td align="left">擦除（JVM上）</td>
<td align="left">❌</td>
<td align="left">通过 <code>inline</code> + <code>reified</code> 绕过限制</td>
</tr>
<tr>
<td align="left">TypeScript</td>
<td align="left">编译时擦除</td>
<td align="left">❌</td>
<td align="left">仅静态类型检查</td>
</tr>
</tbody></table>
<p><strong>总结</strong></p>
<ul>
<li><strong>泛型擦除的本质</strong>：编译器移除泛型类型信息，替换为原始类型（<code>Object</code> 或边界类型），并在使用点插入强制转换。</li>
<li><strong>优点</strong>：无缝兼容旧代码，运行时效率高。</li>
<li><strong>代价</strong>：运行时无法获取泛型类型信息，导致部分操作受限（如 <code>instanceof</code>、泛型数组）。</li>
<li><strong>应对</strong>：通过类型令牌、反射或设计模式（如工厂）绕过限制。</li>
</ul>
<p>泛型擦除是 Java 在兼容性与类型安全之间的折衷方案，理解其原理能帮助你写出更健壮的泛型代码！</p>
<h4 id="泛型的上下限及应用场景"><a href="#泛型的上下限及应用场景" class="headerlink" title="泛型的上下限及应用场景"></a>泛型的上下限及应用场景</h4><p>泛型的<strong>上限（Upper Bound）</strong> 和<strong>下限（Lower Bound）</strong> 是用于<strong>约束类型参数范围</strong>的关键机制，主要解决泛型代码需要<strong>限制可接受的类型</strong>或<strong>支持更灵活的子类型关系</strong>的问题。以下是详细解释：</p>
<p><strong>一、泛型的上限（Upper Bound）</strong></p>
<p>定义：限制类型参数必须是<strong>某个类&#x2F;接口本身或其子类</strong>。<br>语法：<code>&lt;T extends 类/接口&gt;</code> 或 <code>&lt;? extends 类/接口&gt;</code>（通配符形式）。</p>
<p><strong>核心作用</strong></p>
<ol>
<li><p><strong>确保类型具备某些能力</strong><br>要求类型 <code>T</code> 必须实现特定接口（如 <code>Comparable</code>）或继承特定类，从而在泛型代码中安全调用其方法。<br><strong>示例</strong>：要求类型必须可比较</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T 必须是实现了 Comparable 接口的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; T <span class="title function_">max</span><span class="params">(T a, T b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.compareTo(b) &gt; <span class="number">0</span> ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可安全调用 a.compareTo(b)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安全访问数据（只读不写）</strong><br>在通配符 <code>? extends T</code> 中，表示“某个 <code>T</code> 的子类型”，此时容器<strong>只能读取数据</strong>（返回 <code>T</code> 类型），<strong>不能写入数据</strong>（除 <code>null</code> 外）。<br><strong>示例</strong>：安全读取数字集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">printNumbers</span><span class="params">(List&lt;? extends Number&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Number n : list) &#123;</span><br><span class="line">        System.out.println(n);  <span class="comment">// ✅ 可读</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// list.add(10); ❌ 编译错误！无法写入（除 null 外）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>典型场景</strong></p>
<ul>
<li>定义泛型类&#x2F;方法时，约束类型参数的能力（如 <code>T extends Runnable</code>）。</li>
<li>作为方法参数时，安全接收<strong>某种子类型的集合</strong>（生产者场景）。</li>
</ul>
<p><strong>二、泛型的下限（Lower Bound）</strong></p>
<p>定义：限制类型参数必须是<strong>某个类&#x2F;接口本身或其父类</strong>。<br>语法：<code>&lt;? super 类/接口&gt;</code>（仅通配符形式）。</p>
<p><strong>核心作用</strong></p>
<ol>
<li><p><strong>支持安全写入数据</strong><br>表示“某个 <code>T</code> 的父类型”，此时容器<strong>可以写入 <code>T</code> 及其子类型对象</strong>，但读取时只能视为 <code>Object</code>。<br><strong>示例</strong>：向集合添加元素</p>
<p>java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void addNumbers(List&lt;? super Integer&gt; list) &#123;</span><br><span class="line">    list.add(10);     // ✅ 可写入 Integer</span><br><span class="line">    list.add(1000L);  // ❌ 错误！Long 不是 Integer 的子类</span><br><span class="line">    // Object obj = list.get(0);  // 读取时只能视为 Object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>实现灵活的子类型兼容</strong><br>允许方法接收比预期更宽泛的容器（如需要 <code>List&lt;Number&gt;</code> 时，也可传入 <code>List&lt;Object&gt;</code>）。</p>
</li>
</ol>
<p><strong>典型场景</strong></p>
<ul>
<li><p>向泛型容器<strong>写入数据</strong>（消费者场景）。</p>
</li>
<li><p>配合 <code>Comparator</code> 等接口实现类型灵活的API：</p>
<p>java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 可接收 Person 或其父类的 Comparator</span><br><span class="line">void sort(List&lt;Person&gt; list, Comparator&lt;? super Person&gt; comparator) &#123;</span><br><span class="line">    Collections.sort(list, comparator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>三、关键对比：<code>extends</code> vs <code>super</code></strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>上限 (<code>? extends T</code>)</strong></th>
<th align="left"><strong>下限 (<code>? super T</code>)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>类型范围</strong></td>
<td align="left"><code>T</code> 或其<strong>子类型</strong></td>
<td align="left"><code>T</code> 或其<strong>父类型</strong></td>
</tr>
<tr>
<td align="left"><strong>数据读取</strong></td>
<td align="left">✅ 返回 <code>T</code> 类型</td>
<td align="left">❌ 只能视为 <code>Object</code></td>
</tr>
<tr>
<td align="left"><strong>数据写入</strong></td>
<td align="left">❌ 禁止（除 <code>null</code>）</td>
<td align="left">✅ 可写入 <code>T</code> <strong>及其子类</strong></td>
</tr>
<tr>
<td align="left"><strong>设计意图</strong></td>
<td align="left"><strong>生产者</strong>（Producer）只提供数据</td>
<td align="left"><strong>消费者</strong>（Consumer）只消费数据</td>
</tr>
<tr>
<td align="left"><strong>经典口诀</strong></td>
<td align="left"><strong>PECS</strong> (Producer-Extends, Consumer-Super)</td>
<td align="left"></td>
</tr>
</tbody></table>
<p><strong>四、实际应用：PECS 原则</strong></p>
<p>在泛型编程中，遵循 <strong>PECS（Producer-Extends, Consumer-Super）</strong> 原则：</p>
<ul>
<li><strong>生产者（Producer）</strong>：产生 <code>T</code> 的对象 → 用 <code>&lt;? extends T&gt;</code></li>
<li><strong>消费者（Consumer）</strong>：消费 <code>T</code> 的对象 → 用 <code>&lt;? super T&gt;</code></li>
</ul>
<p><strong>示例</strong>：Java 集合工具类 <code>Collections.copy()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(</span></span><br><span class="line"><span class="params">    List&lt;? <span class="built_in">super</span> T&gt; dest,    // 消费者：写入目标集合</span></span><br><span class="line"><span class="params">    List&lt;? extends T&gt; src    // 生产者：读取源集合</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; src.size(); i++) &#123;</span><br><span class="line">        dest.set(i, src.get(i));  <span class="comment">// ✅ 安全读写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>五、使用场景总结</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>场景</strong></th>
<th align="left"><strong>推荐语法</strong></th>
<th align="left"><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">需要调用类型特定方法</td>
<td align="left"><code>&lt;T extends Interface&gt;</code></td>
<td align="left"><code>T</code> 必须实现某个接口</td>
</tr>
<tr>
<td align="left">安全读取泛型集合内容</td>
<td align="left"><code>&lt;? extends T&gt;</code></td>
<td align="left">遍历 <code>List&lt;? extends Number&gt;</code></td>
</tr>
<tr>
<td align="left">安全写入泛型集合</td>
<td align="left"><code>&lt;? super T&gt;</code></td>
<td align="left">向 <code>List&lt;? super Integer&gt;</code> 添加值</td>
</tr>
<tr>
<td align="left">同时支持读写</td>
<td align="left">使用确定的类型参数 <code>T</code></td>
<td align="left"><code>List&lt;T&gt;</code></td>
</tr>
</tbody></table>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h4 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h4><p>在程序运行期间，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 Java 的反射机制。</p>
<h4 id="反射的优缺点"><a href="#反射的优缺点" class="headerlink" title="反射的优缺点"></a>反射的优缺点</h4><ul>
<li><strong>优点：</strong><ul>
<li><strong>动态性：</strong> 运行时才确定类型、绑定对象，极大提高了程序的灵活性和扩展性。是框架设计的基石（如 Spring 的 IOC）。</li>
<li><strong>灵活性：</strong> 可以访问和操作私有成员（通过 <code>setAccessible(true)</code>），突破封装限制（需谨慎）。</li>
<li><strong>通用性：</strong> 可以编写非常通用的代码（如通用序列化&#x2F;反序列化工具、对象比较工具、动态代理等）。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li><strong>性能开销：</strong> 反射操作比直接调用慢很多。因为涉及动态类型解析、方法查找、安全检查等。JVM 难以对其优化。</li>
<li><strong>安全隐患：</strong> 可以破坏封装性（访问 private 成员），可能引发安全问题。需要额外的安全管理策略。</li>
<li><strong>代码复杂性：</strong> 反射代码通常比直接代码更复杂、可读性更差、更难维护。</li>
<li><strong>内部暴露：</strong> 可能暴露类的内部实现细节，破坏抽象。</li>
</ul>
</li>
</ul>
<h4 id="如何获取一个类的-Class-对象"><a href="#如何获取一个类的-Class-对象" class="headerlink" title="如何获取一个类的 Class 对象"></a>如何获取一个类的 <code>Class</code> 对象</h4><ol>
<li><code>Class clazz = Object.getClass();</code> (通过对象实例获取)</li>
<li><code>Class clazz = ClassName.class;</code> (通过类字面常量 <code>.class</code> 获取)</li>
<li><code>Class clazz = Class.forName(&quot;fully.qualified.ClassName&quot;);</code> (通过完整类名字符串获取，常用，可能抛出 <code>ClassNotFoundException</code>)</li>
<li>(对于基本类型和数组) <code>Class clazz = int.class;</code> &#x2F; <code>Class clazz = String[].class;</code></li>
</ol>
<h4 id="如何通过反射创建一个类的实例"><a href="#如何通过反射创建一个类的实例" class="headerlink" title="如何通过反射创建一个类的实例"></a>如何通过反射创建一个类的实例</h4><ol>
<li><p><strong>使用 <code>Class.newInstance()</code>（已过时）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) clazz.newInstance(); <span class="comment">// 调用无参构造器</span></span><br></pre></td></tr></table></figure>

<p>只能调用无参构造器；在 Java 9 开始被标记为 <code>@Deprecated(since=&quot;9&quot;)</code>，推荐使用 <code>Constructor.newInstance()</code>。</p>
</li>
<li><p><strong>使用 <code>Constructor.newInstance()</code> (推荐)：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getConstructor(String.class, <span class="type">int</span>.class); <span class="comment">// 获取特定参数类型的构造器</span></span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) constructor.newInstance(<span class="string">&quot;arg1&quot;</span>, <span class="number">42</span>); <span class="comment">// 传入参数创建实例</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="反射有哪些实际应用场景"><a href="#反射有哪些实际应用场景" class="headerlink" title="反射有哪些实际应用场景"></a>反射有哪些实际应用场景</h4><ul>
<li><strong>框架开发：</strong> 是几乎所有 Java 框架的核心（如 Spring, Hibernate, MyBatis, JUnit）。<ul>
<li><strong>Spring IOC：</strong> 通过反射读取配置（XML 或注解），动态创建 Bean 实例，注入依赖。</li>
<li><strong>Spring AOP：</strong> 动态代理（JDK Proxy 或 CGLIB）底层依赖反射调用目标方法。</li>
<li><strong>Hibernate&#x2F;MyBatis：</strong> 将数据库结果集映射到 Java 对象时，通过反射设置对象的属性值。</li>
</ul>
</li>
<li><strong>注解处理：</strong> 在运行时通过反射读取类、方法、字段上的注解信息，并根据注解执行特定逻辑（如 JUnit 查找 <code>@Test</code> 方法）。</li>
<li><strong>动态代理：</strong> JDK 动态代理 (<code>java.lang.reflect.Proxy</code>) 的核心就是利用反射调用被代理对象的方法。</li>
<li><strong>通用工具库：</strong> 如 Apache Commons BeanUtils, Jackson&#x2F;Gson (JSON 序列化&#x2F;反序列化)，通过反射操作对象的属性。</li>
<li><strong>IDE 和开发工具：</strong> 代码提示、调试器、反编译工具等利用反射获取类的结构信息。</li>
</ul>
<h4 id="Class-forName-和-ClassLoader-loadClass-有什么区别"><a href="#Class-forName-和-ClassLoader-loadClass-有什么区别" class="headerlink" title="Class.forName() 和 ClassLoader.loadClass() 有什么区别"></a><strong><code>Class.forName()</code> 和 <code>ClassLoader.loadClass()</code> 有什么区别</strong></h4><ul>
<li>**<code>Class.forName(String name)</code>**：<ul>
<li>默认会触发类的<strong>加载、链接（验证、准备）、初始化</strong>（执行 <code>&lt;clinit&gt;</code> 静态初始化块）。</li>
<li>有一个重载方法 <code>Class.forName(String name, boolean initialize, ClassLoader loader)</code> 可以控制是否初始化 (<code>initialize</code>) 和指定类加载器 (<code>loader</code>)。</li>
</ul>
</li>
<li>**<code>ClassLoader.loadClass(String name)</code>**：<ul>
<li>只触发类的<strong>加载</strong>和<strong>链接（验证、准备）</strong> 阶段，<strong>不会执行初始化</strong> (<code>&lt;clinit&gt;</code>)。只有首次主动使用时（如创建实例、访问静态字段&#x2F;方法）才会初始化。</li>
</ul>
</li>
<li><strong>考察点：</strong> 理解类加载过程的阶段（加载 -&gt; 链接（验证、准备、解析） -&gt; 初始化），以及这两个关键方法在触发类加载行为上的差异。知道 <code>forName</code> 默认会初始化类，而 <code>loadClass</code> 不会。</li>
</ul>
<h4 id="如何防止反射破坏单例模式"><a href="#如何防止反射破坏单例模式" class="headerlink" title="如何防止反射破坏单例模式"></a><strong>如何防止反射破坏单例模式</strong></h4><ul>
<li><p><strong>问题：</strong> 标准的饿汉式或懒汉式（非枚举）单例，其私有构造器可以通过反射的 <code>setAccessible(true)</code> 被访问，从而创建多个实例。</p>
</li>
<li><p><strong>防御方法：</strong></p>
<ul>
<li><p><strong>在构造器中检查：</strong> 如果实例已存在，则在私有构造器中抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Singleton instance already created&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用枚举实现单例 (推荐)：</strong> 枚举的单例实现是《Effective Java》作者 Josh Bloch 强烈推荐的方式。JVM 从根本上保证了枚举类型的构造器只会被调用一次，且反射 API 被设计为<strong>不能通过反射创建枚举实例</strong>（<code>Constructor.newInstance()</code> 方法内部会检查并阻止）。这是最安全、简洁的方式。</p>
</li>
</ul>
</li>
</ul>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><h4 id="Java中都有哪些元注解"><a href="#Java中都有哪些元注解" class="headerlink" title="Java中都有哪些元注解"></a>Java中都有哪些元注解</h4><table>
<thead>
<tr>
<th align="left">元注解</th>
<th align="left">作用域</th>
<th align="left">主要用途</th>
<th align="left">Java 版本</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>@Target</code></strong></td>
<td align="left">注解</td>
<td align="left">指定注解可应用的程序元素（类、方法、字段等）</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left"><strong><code>@Retention</code></strong></td>
<td align="left">注解</td>
<td align="left">指定注解的保留策略（源码、类文件、运行时）</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left"><strong><code>@Documented</code></strong></td>
<td align="left">注解</td>
<td align="left">指示注解应包含在 Javadoc 中</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left"><strong><code>@Inherited</code></strong></td>
<td align="left">注解</td>
<td align="left">指示注解具有继承性（仅对类注解有效）</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left"><strong><code>@Repeatable</code></strong></td>
<td align="left">注解</td>
<td align="left">允许同一注解在单个元素上重复使用（需配合容器注解）</td>
<td align="left"><strong>8</strong></td>
</tr>
<tr>
<td align="left"><strong><code>@Native</code></strong></td>
<td align="left">字段</td>
<td align="left">标记可能被本机代码引用的常量字段（主要在 JDK 内部使用）</td>
<td align="left"><strong>8</strong></td>
</tr>
</tbody></table>
<h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><p><strong>SPI</strong> 是 Java 提供的一种<strong>服务发现机制</strong>，通过<strong>接口与实现解耦</strong>实现动态扩展。核心流程如下：</p>
<ol>
<li><strong>定义服务接口</strong>（如 <code>PaymentService</code>）</li>
<li><strong>提供实现类</strong>（如 <code>AlipayService</code>, <code>WechatPayService</code>）</li>
<li><strong>注册实现</strong>：在 <code>META-INF/services/</code> 下创建以接口全限定名命名的文件，写入实现类全限定名</li>
<li><strong>动态加载</strong>：通过 <code>ServiceLoader</code> 加载所有注册的实现</li>
</ol>
<p><strong>优势：</strong></p>
<ul>
<li><strong>开闭原则</strong>：新增实现无需修改核心代码</li>
<li><strong>解耦</strong>：接口与实现分离</li>
<li><strong>可插拔</strong>：通过配置文件动态替换实现</li>
</ul>
<p><strong>Java SPI 完整 Demo</strong></p>
<ol>
<li>定义服务接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PaymentService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">double</span> amount)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>实现服务接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AlipayService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AlipayService</span> <span class="keyword">implements</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[支付宝] 支付: ¥&quot;</span> + amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WechatPayService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WechatPayService</span> <span class="keyword">implements</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[微信支付] 支付: ¥&quot;</span> + amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>注册服务实现</li>
</ol>
<p>创建资源文件：<br><code>src/main/resources/META-INF/services/com.example.PaymentService</code><br>内容：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.example.AlipayService</span><br><span class="line">com.example.WechatPayService</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用 SPI 加载服务</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPIDemo.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.ServiceLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SPIDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 加载所有 PaymentService 实现</span></span><br><span class="line">        ServiceLoader&lt;PaymentService&gt; services = </span><br><span class="line">            ServiceLoader.load(PaymentService.class);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;=== 发现 &quot;</span> + getServiceCount(services) + <span class="string">&quot; 个支付服务 ===&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用所有实现</span></span><br><span class="line">        <span class="keyword">for</span> (PaymentService service : services) &#123;</span><br><span class="line">            service.pay(<span class="number">100.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getServiceCount</span><span class="params">(ServiceLoader&lt;PaymentService&gt; services)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (PaymentService ignored : services) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>项目结构</li>
</ol>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">├── main/</span><br><span class="line">│   ├── java/</span><br><span class="line">│   │   ├── com/example/</span><br><span class="line">│   │   │   ├── PaymentService.java</span><br><span class="line">│   │   │   ├── AlipayService.java</span><br><span class="line">│   │   │   ├── WechatPayService.java</span><br><span class="line">│   │   │   └── SPIDemo.java</span><br><span class="line">│   │</span><br><span class="line">│   └── resources/</span><br><span class="line">│       └── META-INF/services/</span><br><span class="line">│           └── com.example.PaymentService  &lt;-- 关键配置文件</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>运行结果</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">=== 发现 2 个支付服务 ===</span><br><span class="line">[支付宝] 支付: ¥100.0</span><br><span class="line">[微信支付] 支付: ¥100.0</span><br></pre></td></tr></table></figure>

<p><strong>关键点解析：</strong></p>
<ol>
<li><strong>配置文件路径</strong>：<code>META-INF/services/接口全限定名</code></li>
<li><strong>文件内容</strong>：实现类的全限定名（每行一个）</li>
<li><strong>ServiceLoader</strong>：核心加载工具，实现懒加载</li>
<li><strong>迭代顺序</strong>：按配置文件中定义的顺序加载</li>
</ol>
<p><strong>实际应用场景：</strong></p>
<ul>
<li>JDBC 驱动加载（<code>DriverManager</code>）</li>
<li>日志门面（SLF4J）</li>
<li>序列化框架（Jackson）</li>
<li>Spring Boot 自动配置</li>
</ul>
<blockquote>
<p>通过 SPI 机制，Java 实现了真正的面向接口编程，使系统具备高度可扩展性，符合「开闭原则」。</p>
</blockquote>
<h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><h3 id="集合基础"><a href="#集合基础" class="headerlink" title="集合基础"></a>集合基础</h3><p>Java 集合框架主要包括 <code>Collection</code> 和 <code>Map</code> 两大接口体系。<code>Collection</code> 主要有 <code>List</code>、<code>Set</code>、<code>Queue</code> 几个核心子接口。</p>
<h4 id="Iterator-和-ListIterator-的区别"><a href="#Iterator-和-ListIterator-的区别" class="headerlink" title="Iterator 和 ListIterator 的区别"></a><strong><code>Iterator</code> 和 <code>ListIterator</code> 的区别</strong></h4><ul>
<li><code>Iterator</code>：通用迭代器接口。提供 <code>hasNext()</code>, <code>next()</code>, <code>remove()</code> 方法。只能<strong>单向</strong>遍历 (<code>Collection</code> 接口使用)。</li>
<li><code>ListIterator</code>：继承 <code>Iterator</code>。专门用于 <code>List</code>。额外提供：<ul>
<li><strong>双向遍历</strong>：<code>hasPrevious()</code>, <code>previous()</code>。</li>
<li><strong>获取索引</strong>：<code>nextIndex()</code>, <code>previousIndex()</code>。</li>
<li><strong>修改元素</strong>：<code>set(E e)</code> (替换上次调用 <code>next()</code> 或 <code>previous()</code> 返回的元素)。</li>
<li><strong>添加元素</strong>：<code>add(E e)</code> (在当前游标位置插入元素)。</li>
</ul>
</li>
<li><code>ListIterator</code> 功能更强大，但只能用于 <code>List</code> 及其实现类。</li>
</ul>
<h4 id="什么是-fail-fast-机制"><a href="#什么是-fail-fast-机制" class="headerlink" title="什么是 fail-fast 机制"></a><strong>什么是 <code>fail-fast</code> 机制</strong></h4><ul>
<li>一种<strong>错误检测机制</strong>。当使用迭代器 (<code>Iterator</code>) 遍历集合时，如果<strong>在遍历过程中（除了通过迭代器自身的 <code>remove()</code> 方法外）对集合结构进行了修改</strong>（添加、删除元素），则会立即抛出 <code>ConcurrentModificationException</code>。</li>
<li><strong>实现原理</strong>：集合内部维护一个 <code>modCount</code> (修改计数器)。创建迭代器时，会将当前的 <code>modCount</code> 记录为 <code>expectedModCount</code>。在迭代过程中，每次调用 <code>next()</code>、<code>remove()</code> 等方法前都会检查 <code>modCount == expectedModCount</code>。如果不相等，说明有其他线程或本线程其他操作修改了集合结构，抛出异常。</li>
<li><strong>目的</strong>：快速失败，避免在不确定状态下继续操作导致更难以预料的结果。<strong>它不能保证并发修改一定被检测到，主要用于单线程环境下的错误检测</strong>。</li>
</ul>
<h4 id="fail-fast-和-fail-safe-的区别"><a href="#fail-fast-和-fail-safe-的区别" class="headerlink" title="fail-fast 和 fail-safe 的区别"></a><strong><code>fail-fast</code> 和 <code>fail-safe</code> 的区别</strong></h4><ul>
<li><strong><code>fail-fast</code><strong>：直接在原集合上操作。迭代时检测到并发修改就</strong>立即抛异常</strong>。代表：<code>ArrayList</code>, <code>HashMap</code> 等非并发集合的迭代器。</li>
<li><strong><code>fail-safe</code> (Concurrent Modification Tolerance)<strong>：</strong>不在原集合上操作</strong>，而是基于原集合的<strong>快照 (snapshot)</strong> 或 <strong>只读视图</strong> 进行迭代。迭代过程中原集合的修改不会影响迭代器，不会抛异常。代表：<code>ConcurrentHashMap</code>, <code>CopyOnWriteArrayList</code> 的迭代器。</li>
<li><strong>注意</strong>：<code>java.util.concurrent</code> 包下的集合通常采用 <strong>弱一致性 (Weakly Consistent)</strong> 迭代器，它提供 <code>fail-safe</code> 行为，但不保证迭代器看到所有修改。</li>
</ul>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a><code>List</code></h3><h4 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a><code>ArrayList</code>的扩容机制</h4><ul>
<li>使用 <code>Object[] elementData</code> 存储元素。</li>
<li>创建时如果未指定大小，初始容量为 <strong>0</strong> (JDK 1.8+) 或 <strong>10</strong> (旧版本，需确认具体版本)，第一次添加元素时扩容到 <strong>10</strong>。</li>
<li>当添加元素时发现容量不足（<code>size + 1 &gt; elementData.length</code>），触发扩容。</li>
<li>新容量 &#x3D; <code>ArraysSupport.newLength(oldCapacity, minCapacity - oldCapacity, oldCapacity &gt;&gt; 1)</code>，即计算新容量为 <code>oldCapacity + max(需要的最小增量, oldCapacity / 2)</code>，简单理解通常是 <strong>原容量的1.5倍</strong>。</li>
<li>创建一个新的更大的数组，将旧数组元素<strong>复制</strong>到新数组。</li>
</ul>
<h4 id="Vector-和-ArrayList-的区别"><a href="#Vector-和-ArrayList-的区别" class="headerlink" title="Vector 和 ArrayList 的区别"></a><code>Vector</code> 和 <code>ArrayList</code> 的区别</h4><ul>
<li><strong>线程安全</strong>：<ul>
<li><code>Vector</code>：<strong>线程安全</strong>。关键方法使用 <code>synchronized</code> 修饰，性能较低。</li>
<li><code>ArrayList</code>：<strong>非线程安全</strong>。性能更高。</li>
</ul>
</li>
<li><strong>扩容机制</strong>：<ul>
<li><code>Vector</code>：默认扩容为原来的 <strong>2倍</strong>，可通过构造函数指定扩容增量。</li>
<li><code>ArrayList</code>：默认扩容为原来的 <strong>1.5倍</strong> (<code>(oldCapacity * 3)/2 + 1</code>)。</li>
</ul>
</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a><code>Set</code></h3><h4 id="HashSet、LinkedHashSet-和-TreeSet-的区别"><a href="#HashSet、LinkedHashSet-和-TreeSet-的区别" class="headerlink" title="HashSet、LinkedHashSet 和 TreeSet 的区别"></a><strong><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的区别</strong></h4><ul>
<li><strong>底层实现</strong>：<ul>
<li><code>HashSet</code>：基于 <strong><code>HashMap</code></strong> (只需 Key，Value 用常量 <code>PRESENT</code> 填充)。</li>
<li><code>LinkedHashSet</code>：继承自 <code>HashSet</code>，基于 **<code>LinkedHashMap</code>**。</li>
<li><code>TreeSet</code>：基于 <strong><code>TreeMap</code></strong> (红黑树)。</li>
</ul>
</li>
<li><strong>元素顺序</strong>：<ul>
<li><code>HashSet</code>：<strong>无序</strong> (不保证插入顺序或恒久不变)。</li>
<li><code>LinkedHashSet</code>：<strong>按元素插入顺序排序</strong> (双向链表维护插入次序)。</li>
<li><code>TreeSet</code>：<strong>按元素的自然顺序 (<code>Comparable</code>) 或指定的 <code>Comparator</code> 排序</strong>。</li>
</ul>
</li>
<li><strong>性能</strong>：<ul>
<li><code>HashSet</code>&#x2F;<code>LinkedHashSet</code>：添加、删除、查找 <strong>O(1)</strong> (平均情况)。</li>
<li><code>TreeSet</code>：添加、删除、查找 **O(log n)**。</li>
</ul>
</li>
<li><strong>元素要求</strong>：<ul>
<li><code>HashSet</code>&#x2F;<code>LinkedHashSet</code>：元素必须正确实现 <code>equals()</code> 和 <code>hashCode()</code>。</li>
<li><code>TreeSet</code>：元素必须实现 <code>Comparable</code> 接口或在构造时传入 <code>Comparator</code>。</li>
</ul>
</li>
<li><strong>线程安全</strong>：三者都<strong>非线程安全</strong>。</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a><code>Map</code></h3><h4 id="HashMap-的底层实现原理"><a href="#HashMap-的底层实现原理" class="headerlink" title="HashMap 的底层实现原理"></a><strong><code>HashMap</code> 的底层实现原理</strong></h4><p><strong>JDK7：数组 + 链表</strong></p>
<ul>
<li><strong>扩容</strong>：创建新数组 (通常是原数组长度的 <strong>2倍</strong>)，遍历所有元素，<strong>重新计算每个元素在新数组中的位置</strong> (<code>rehash</code>)，将元素转移到新数组。<strong>头插法会导致扩容时链表元素顺序反转</strong>。</li>
</ul>
<p><strong>JDK8：数组 + 链表 &#x2F; 红黑树</strong></p>
<p><strong>主要改进</strong>：</p>
<ul>
<li><strong>尾插法</strong>：解决 JDK7 头插法多线程下可能导致死循环的问题（未解决线程安全问题）。</li>
<li><strong>链表转红黑树</strong>：当链表长度 <strong>&gt;&#x3D; 8 (TREEIFY_THRESHOLD)</strong> 且 <strong>数组长度 &gt;&#x3D; 64 (MIN_TREEIFY_CAPACITY)</strong> 时，链表转换为红黑树，提高长链表的查找效率 (O(n) -&gt; O(log n))。</li>
<li><strong>优化哈希算法</strong>：<code>(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，高位参与运算，减少哈希冲突。</li>
<li><strong>扩容</strong>：根据 <code>(e.hash &amp; oldCap) == 0</code> 将链表拆分成两个子链表，结果为 0 的节点保持原索引位置 <code>i</code>，结果不为 0 的节点放到新位置 <code>i + oldCap</code>，避免全量 <code>rehash</code>，提升了效率。</li>
</ul>
<h4 id="HashMap-和-HashTable-的区别"><a href="#HashMap-和-HashTable-的区别" class="headerlink" title="HashMap 和 HashTable 的区别"></a><strong><code>HashMap</code> 和 <code>HashTable</code> 的区别</strong></h4><ul>
<li><strong>线程安全</strong>：<ul>
<li><code>HashMap</code>：<strong>非线程安全</strong>。性能更高。</li>
<li><code>Hashtable</code>：<strong>线程安全</strong>。几乎所有公共方法都用 <code>synchronized</code> 修饰，性能较低。</li>
</ul>
</li>
<li><strong><code>null</code> 值</strong>：<ul>
<li><code>HashMap</code>：允许 <code>key</code> 和 <code>value</code> 为 <code>null</code>。</li>
<li><code>Hashtable</code>：不允许 <code>key</code> 或 <code>value</code> 为 <code>null</code>。</li>
</ul>
</li>
<li><strong>继承体系</strong>：<ul>
<li><code>HashMap</code>：继承 <code>AbstractMap</code>。</li>
<li><code>Hashtable</code>：继承 <code>Dictionary</code> (一个古老的类)。</li>
</ul>
</li>
<li><strong>迭代器</strong>：<ul>
<li><code>HashMap</code> 的 <code>Iterator</code> 是 <strong>fail-fast</strong> 的。</li>
<li><code>Hashtable</code> 的 <code>Enumerator</code> 不是 fail-fast 的。</li>
</ul>
</li>
<li><strong>初始容量与扩容</strong>：<ul>
<li><code>HashMap</code>：默认 16，扩容为 2 倍。</li>
<li><code>Hashtable</code>：默认 11，扩容为 2 倍 + 1 (<code>oldCapacity * 2 + 1</code>)。</li>
</ul>
</li>
<li><strong>哈希计算</strong>：<ul>
<li><code>HashMap</code>：优化了哈希函数 (<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>)。</li>
<li><code>Hashtable</code>：直接使用 <code>key.hashCode()</code>。</li>
</ul>
</li>
<li><strong>推荐使用</strong>：**<code>HashMap</code> + <code>ConcurrentHashMap</code> 或 <code>Collections.synchronizedMap()</code> 代替 <code>Hashtable</code>**。</li>
</ul>
<h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h2><h2 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h2><h3 id="JUC集合"><a href="#JUC集合" class="headerlink" title="JUC集合"></a>JUC集合</h3><h4 id="ConcurrentHashMap-的实现原理"><a href="#ConcurrentHashMap-的实现原理" class="headerlink" title="ConcurrentHashMap 的实现原理"></a><strong><code>ConcurrentHashMap</code> 的实现原理</strong></h4><ul>
<li><strong>JDK7：分段锁 (Segment Locking)</strong><ul>
<li>将数据分成多个段 (<code>Segment</code> 数组，默认 16 个段)。</li>
<li>每个 <code>Segment</code> 本身是一个类似 <code>ReentrantLock</code> 的锁，并管理一个独立的 <code>HashEntry</code> 数组 (相当于一个小型的 <code>HashMap</code>)。</li>
<li><strong>锁粒度</strong>：锁住的是<strong>整个段</strong>。不同段上的操作可以并发进行。并发度等于 <code>Segment</code> 的数量。</li>
<li><strong>PUT</strong>：先定位到哪个 <code>Segment</code>，然后对该 <code>Segment</code> <strong>加锁</strong>，再在该 <code>Segment</code> 内部的哈希表上进行操作（类似 <code>HashMap</code> JDK7）。</li>
<li><strong>GET</strong>：<strong>无锁</strong> (volatile 读)。定位到 <code>Segment</code> 和 <code>HashEntry</code> 后直接读取 <code>value</code> (value 是 volatile 的)。</li>
</ul>
</li>
<li><strong>JDK8：<code>synchronized</code> + <code>CAS</code> + 红黑树</strong><ul>
<li>摒弃分段锁，采用 <code>Node</code> 数组 + 链表 &#x2F; 红黑树 (结构类似 <code>HashMap</code> JDK8)。</li>
<li><strong>锁粒度</strong>：<strong>锁单个链表头节点或树根节点</strong> (桶级别)。并发度大大提高。</li>
<li><strong>关键机制</strong>：<ul>
<li>**<code>CAS</code> (Compare-And-Swap)**：用于无锁化的初始化数组、插入新节点 (<code>tabAt</code>, <code>casTabAt</code>, <code>setTabAt</code> 使用 <code>Unsafe</code> 操作)。</li>
<li><strong><code>synchronized</code><strong>：当发生哈希冲突（桶不为空）时，对链表的头节点或树的根节点</strong>加 <code>synchronized</code> 锁</strong>。锁对象是头节点本身。</li>
<li>**<code>volatile</code>**：<code>Node</code> 的 <code>val</code> 和 <code>next</code> 字段用 <code>volatile</code> 修饰，保证可见性。</li>
</ul>
</li>
<li><strong>PUT</strong>：<ol>
<li>计算哈希值，定位桶位置。</li>
<li>如果桶为空，尝试用 <code>CAS</code> 插入新节点。</li>
<li>如果桶不为空（可能有锁竞争）：<ul>
<li>如果该桶节点正在扩容 (<code>MOVED</code>)，当前线程协助扩容 (<code>helpTransfer</code>)。</li>
<li>否则，<strong>对桶的头节点加 <code>synchronized</code> 锁</strong>。</li>
<li>在锁内，根据是链表还是树，执行类似 <code>HashMap</code> JDK8 的插入逻辑（尾插法，树化）。</li>
</ul>
</li>
<li>检查是否需要扩容（链表长度达到 8 且数组长度 &lt; 64 时优先扩容）。</li>
</ol>
</li>
<li><strong>GET</strong>：<strong>完全无锁</strong>。定位到桶后，根据链表或树遍历查找。依赖 <code>volatile</code> 读保证可见性。</li>
<li><strong>扩容</strong>：支持<strong>多线程协同扩容</strong> (<code>transfer</code>)。当一个线程触发扩容时，它负责分配迁移任务区间。其他线程在 PUT 操作时如果发现正在扩容，会协助迁移一部分数据。使用 <code>ForwardingNode</code> 节点标记迁移完成的桶。</li>
</ul>
</li>
</ul>
<h4 id="为什么-ConcurrentHashMap-比-Hashtable-效率高"><a href="#为什么-ConcurrentHashMap-比-Hashtable-效率高" class="headerlink" title="为什么 ConcurrentHashMap 比 Hashtable 效率高"></a><strong>为什么 <code>ConcurrentHashMap</code> 比 <code>Hashtable</code> 效率高</strong></h4><ul>
<li><strong>锁粒度</strong>：<ul>
<li><code>Hashtable</code>：<strong>全局锁</strong>。锁住整个表，一次只允许一个线程操作。</li>
<li><code>ConcurrentHashMap</code> (JDK7)：<strong>分段锁</strong>。锁住一个段，不同段操作可并发。</li>
<li><code>ConcurrentHashMap</code> (JDK8)：**桶锁 (头节点锁)**。锁粒度更细，冲突概率更低，并发度更高。</li>
</ul>
</li>
<li><strong>无锁读</strong>：<ul>
<li><code>Hashtable</code>：读操作也需要获取锁。</li>
<li><code>ConcurrentHashMap</code> (JDK7 &amp; JDK8)：<strong>读操作完全无锁</strong> (JDK7 利用 volatile value，JDK8 利用 volatile val&#x2F;next 和 Unsafe 的原子读)，极大提升读性能。</li>
</ul>
</li>
</ul>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h1 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h1><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h2 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h2><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><h1 id="开发框架"><a href="#开发框架" class="headerlink" title="开发框架"></a>开发框架</h1><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><h2 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h2><h2 id="日志框架"><a href="#日志框架" class="headerlink" title="日志框架"></a>日志框架</h2><h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><h1 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h1><h2 id="认证授权"><a href="#认证授权" class="headerlink" title="认证授权"></a>认证授权</h2><h2 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h2><h2 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h2><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><h1 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h1><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><h2 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI&#x2F;CD"></a>CI&#x2F;CD</h2><h1 id="工具类库"><a href="#工具类库" class="headerlink" title="工具类库"></a>工具类库</h1><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h1><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/d6b72329.html" rel="prev" title="Spring/SpringBoot常用扩展点">
                  <i class="fa fa-angle-left"></i> Spring/SpringBoot常用扩展点
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa-regular fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder"></span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Word count total">92k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">5:35</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>

  <script class="next-config" data-name="wavedrom" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/wavedrom.min.js","integrity":"sha256-INLAoJc6quTNfiMWkGZniYO2cxE8mHpddnLow1m6RFs="}}</script>
  <script class="next-config" data-name="wavedrom_skin" type="application/json">{"enable":true,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.5.0/skins/default.js","integrity":"sha256-fduc/Zszk5ezWws2uInY/ALWVmIrmV6VTgXbsYSReFI="}}</script>
  <script src="/js/third-party/tags/wavedrom.js"></script>




  





</body>
</html>
