<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>脚本库</title>
      <link href="/post/7ad2e472.html"/>
      <url>/post/7ad2e472.html</url>
      
        <content type="html"><![CDATA[<h1 id="Python脚本"><a href="#Python脚本" class="headerlink" title="Python脚本"></a>Python脚本</h1><h2 id="抽取json文件字段并写入excel"><a href="#抽取json文件字段并写入excel" class="headerlink" title="抽取json文件字段并写入excel"></a>抽取json文件字段并写入excel</h2><p>json样例</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;migrations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;up&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;ADD_OR_UPDATE&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;targetService&quot;</span><span class="punctuation">:</span> <span class="string">&quot;targetService&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;GET&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;endpointId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;endpointId&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;targetUri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;targetUri&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;readTimout&quot;</span><span class="punctuation">:</span> <span class="number">30</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;targetProtocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uri&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;seqId&quot;</span><span class="punctuation">:</span> <span class="number">5661418</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">]</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;endpointId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;endpintId&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">MigrationExtractor.py</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">extract_data</span>(<span class="params">json_data</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    从 JSON 数据中提取指定字段</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    extracted_data = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查数据结构是否有效</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;migrations&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> json_data:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;错误：JSON 数据中缺少 &#x27;migrations&#x27; 字段&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> extracted_data</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> migration <span class="keyword">in</span> json_data[<span class="string">&quot;migrations&quot;</span>]:</span><br><span class="line">        <span class="comment"># 检查是否有 &quot;up&quot; 部分</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;up&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> migration:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 检查是否有 &quot;ADD_OR_UPDATE&quot; 数组</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;ADD_OR_UPDATE&quot;</span> <span class="keyword">in</span> migration[<span class="string">&quot;up&quot;</span>]:</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> migration[<span class="string">&quot;up&quot;</span>][<span class="string">&quot;ADD_OR_UPDATE&quot;</span>]:</span><br><span class="line">                <span class="comment"># 提取所需字段，处理缺失值</span></span><br><span class="line">                row = &#123;</span><br><span class="line">                    <span class="string">&quot;targetService&quot;</span>: item.get(<span class="string">&quot;targetService&quot;</span>, <span class="string">&quot;N/A&quot;</span>),</span><br><span class="line">                    <span class="string">&quot;uri&quot;</span>: item.get(<span class="string">&quot;uri&quot;</span>, <span class="string">&quot;N/A&quot;</span>),</span><br><span class="line">                    <span class="string">&quot;method&quot;</span>: item.get(<span class="string">&quot;method&quot;</span>, <span class="string">&quot;N/A&quot;</span>),</span><br><span class="line">                    <span class="string">&quot;targetUri&quot;</span>: item.get(<span class="string">&quot;targetUri&quot;</span>, <span class="string">&quot;N/A&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                extracted_data.append(row)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> extracted_data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">export_to_excel</span>(<span class="params">data, output_file</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    将提取的数据导出到 Excel 文件</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;警告：没有提取到数据，不创建 Excel 文件&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建 DataFrame</span></span><br><span class="line">    df = pd.DataFrame(data)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 确保列顺序正确</span></span><br><span class="line">    df = df[[<span class="string">&quot;targetService&quot;</span>, <span class="string">&quot;uri&quot;</span>, <span class="string">&quot;method&quot;</span>, <span class="string">&quot;targetUri&quot;</span>]]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 导出到 Excel</span></span><br><span class="line">        df.to_excel(output_file, index=<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;导出到 Excel 时出错: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 设置命令行参数</span></span><br><span class="line">    parser = argparse.ArgumentParser(</span><br><span class="line">        description=<span class="string">&quot;MigrationExtractor - 从 JSON 迁移文件中提取 ADD_OR_UPDATE 数据并导出到 Excel&quot;</span>,</span><br><span class="line">        formatter_class=argparse.ArgumentDefaultsHelpFormatter</span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(<span class="string">&quot;input&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;输入 JSON 文件路径&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-o&quot;</span>, <span class="string">&quot;--output&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;输出 Excel 文件路径&quot;</span>, default=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 验证输入文件</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(args.<span class="built_in">input</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;错误：输入文件不存在 - <span class="subst">&#123;args.<span class="built_in">input</span>&#125;</span>&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置默认输出文件名</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> args.output:</span><br><span class="line">        timestamp = datetime.now().strftime(<span class="string">&quot;%Y%m%d_%H%M%S&quot;</span>)</span><br><span class="line">        args.output = <span class="string">f&quot;migration_data_<span class="subst">&#123;timestamp&#125;</span>.xlsx&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 读取 JSON 文件</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(args.<span class="built_in">input</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            json_data = json.load(f)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;读取 JSON 文件时出错: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 提取数据</span></span><br><span class="line">    extracted_data = extract_data(json_data)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> extracted_data:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;警告：未提取到任何数据，请检查 JSON 文件结构&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 导出到 Excel</span></span><br><span class="line">    <span class="keyword">if</span> export_to_excel(extracted_data, args.output):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;成功导出 <span class="subst">&#123;<span class="built_in">len</span>(extracted_data)&#125;</span> 条记录到 <span class="subst">&#123;args.output&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;导出失败&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">50</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;MigrationExtractor - JSON 迁移数据提取工具&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">50</span>)</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><strong>脚本功能说明</strong></p><ol><li><strong>脚本名称</strong>：MigrationExtractor</li><li><strong>核心功能</strong>：<ul><li>从 JSON 文件中读取迁移数据</li><li>提取 ADD_OR_UPDATE 列表中的指定字段</li><li>将提取的数据导出到 Excel 文件</li></ul></li><li><strong>提取字段</strong>（按指定顺序）：<ul><li>targetService</li><li>uri</li><li>method</li><li>targetUri</li></ul></li><li><strong>高级特性</strong>：<ul><li>命令行参数支持</li><li>自动生成带时间戳的输出文件名</li><li>健壮的错误处理</li><li>缺失值处理（用 “N&#x2F;A” 替代）</li><li>详细的状态反馈</li></ul></li></ol><p><strong>使用示例</strong></p><p><strong>基本用法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python MigrationExtractor.py input.json</span><br></pre></td></tr></table></figure><p><strong>指定输出文件名</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python MigrationExtractor.py input.json -o output.xlsx</span><br></pre></td></tr></table></figure><h2 id="批量重命名文件"><a href="#批量重命名文件" class="headerlink" title="批量重命名文件"></a>批量重命名文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">批量重命名文件工具</span></span><br><span class="line"><span class="string">支持功能：</span></span><br><span class="line"><span class="string">1. 添加前缀</span></span><br><span class="line"><span class="string">2. 添加后缀</span></span><br><span class="line"><span class="string">3. 替换文本</span></span><br><span class="line"><span class="string">4. 正则表达式重命名</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">batch_rename</span>(<span class="params">path, prefix=<span class="string">&quot;&quot;</span>, suffix=<span class="string">&quot;&quot;</span>, find_str=<span class="string">&quot;&quot;</span>, replace_str=<span class="string">&quot;&quot;</span>, use_regex=<span class="literal">False</span>, dry_run=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    批量重命名文件</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        path: 目录路径</span></span><br><span class="line"><span class="string">        prefix: 要添加的前缀</span></span><br><span class="line"><span class="string">        suffix: 要添加的后缀</span></span><br><span class="line"><span class="string">        find_str: 要查找的文本</span></span><br><span class="line"><span class="string">        replace_str: 要替换的文本</span></span><br><span class="line"><span class="string">        use_regex: 是否使用正则表达式</span></span><br><span class="line"><span class="string">        dry_run: 试运行，只显示将要重命名的文件，不实际执行</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;错误：路径 &#x27;<span class="subst">&#123;path&#125;</span>&#x27; 不存在&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取文件列表</span></span><br><span class="line">    files = [f <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(path) <span class="keyword">if</span> os.path.isfile(os.path.join(path, f))]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> files:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;指定目录中没有文件&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;找到 <span class="subst">&#123;<span class="built_in">len</span>(files)&#125;</span> 个文件&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 重命名计数器</span></span><br><span class="line">    renamed_count = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> files:</span><br><span class="line">        new_name = filename</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 替换文本</span></span><br><span class="line">        <span class="keyword">if</span> find_str:</span><br><span class="line">            <span class="keyword">if</span> use_regex:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    new_name = re.sub(find_str, replace_str, new_name)</span><br><span class="line">                <span class="keyword">except</span> re.error <span class="keyword">as</span> e:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;正则表达式错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                new_name = new_name.replace(find_str, replace_str)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 添加前缀</span></span><br><span class="line">        <span class="keyword">if</span> prefix:</span><br><span class="line">            new_name = prefix + new_name</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 添加后缀（在扩展名之前）</span></span><br><span class="line">        <span class="keyword">if</span> suffix:</span><br><span class="line">            name, ext = os.path.splitext(new_name)</span><br><span class="line">            new_name = name + suffix + ext</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果文件名有变化，则重命名</span></span><br><span class="line">        <span class="keyword">if</span> new_name != filename:</span><br><span class="line">            old_path = os.path.join(path, filename)</span><br><span class="line">            new_path = os.path.join(path, new_name)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 检查新文件名是否已存在</span></span><br><span class="line">            <span class="keyword">if</span> os.path.exists(new_path):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;警告：目标文件已存在，跳过: <span class="subst">&#123;new_name&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;重命名: <span class="subst">&#123;filename&#125;</span> -&gt; <span class="subst">&#123;new_name&#125;</span>&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> dry_run:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    os.rename(old_path, new_path)</span><br><span class="line">                    renamed_count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">except</span> OSError <span class="keyword">as</span> e:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;错误：重命名失败: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;无变化: <span class="subst">&#123;filename&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;操作完成。成功重命名 <span class="subst">&#123;renamed_count&#125;</span> 个文件&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&quot;批量重命名文件工具&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;path&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;目录路径&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-p&quot;</span>, <span class="string">&quot;--prefix&quot;</span>, default=<span class="string">&quot;&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;添加前缀&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-s&quot;</span>, <span class="string">&quot;--suffix&quot;</span>, default=<span class="string">&quot;&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;添加后缀（在扩展名之前）&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-f&quot;</span>, <span class="string">&quot;--find&quot;</span>, default=<span class="string">&quot;&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;要查找的文本&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-r&quot;</span>, <span class="string">&quot;--replace&quot;</span>, default=<span class="string">&quot;&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;要替换的文本&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--regex&quot;</span>, action=<span class="string">&quot;store_true&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;使用正则表达式&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--dry-run&quot;</span>, action=<span class="string">&quot;store_true&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;试运行，不实际重命名文件&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    </span><br><span class="line">    batch_rename(</span><br><span class="line">        path=args.path,</span><br><span class="line">        prefix=args.prefix,</span><br><span class="line">        suffix=args.suffix,</span><br><span class="line">        find_str=args.find,</span><br><span class="line">        replace_str=args.replace,</span><br><span class="line">        use_regex=args.regex,</span><br><span class="line">        dry_run=args.dry_run</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加前缀</span></span><br><span class="line">./rename_files.py /path/to/files -p <span class="string">&quot;vacation_&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加后缀</span></span><br><span class="line">./rename_files.py /path/to/files -s <span class="string">&quot;_2023&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换文本</span></span><br><span class="line">./rename_files.py /path/to/files -f <span class="string">&quot;IMG&quot;</span> -r <span class="string">&quot;Photo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用正则表达式</span></span><br><span class="line">./rename_files.py /path/to/files -f <span class="string">&quot;\d+&quot;</span> -r <span class="string">&quot;NUM&quot;</span> --regex</span><br><span class="line"></span><br><span class="line"><span class="comment"># 试运行（不实际重命名）</span></span><br><span class="line">./rename_files.py /path/to/files -f <span class="string">&quot;old&quot;</span> -r <span class="string">&quot;new&quot;</span> --dry-run</span><br></pre></td></tr></table></figure><h1 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h1><h2 id="搜索可执行文件"><a href="#搜索可执行文件" class="headerlink" title="搜索可执行文件"></a>搜索可执行文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># finding files in the PATH</span></span><br><span class="line"></span><br><span class="line">IFS=:</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">dir</span> <span class="keyword">in</span> <span class="variable">$PATH</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="comment"># 检查目录是否存在</span></span><br><span class="line">    <span class="keyword">if</span> [ -d <span class="variable">$dir</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$dir</span>:&quot;</span></span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> <span class="variable">$dir</span>/*:</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">            <span class="comment"># 检查是否是可执行文件且不是目录</span></span><br><span class="line">            <span class="keyword">if</span> [ -x <span class="variable">$file</span> ] &amp;&amp; [ ! -d <span class="variable">$file</span> ]; <span class="keyword">then</span> <span class="comment"># 中括号与条件表达式需空格隔开</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;    <span class="variable">$file</span>&quot;</span></span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$dir</span>: [Not a valid directory]&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="打印指定时间段的日志"><a href="#打印指定时间段的日志" class="headerlink" title="打印指定时间段的日志"></a>打印指定时间段的日志</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看指定时间段内的日志</span></span><br><span class="line">$ sed -n <span class="string">&#x27;/2022-11-25T14:15:*/,/2022-11-25T15:*/p&#x27;</span> filename</span><br><span class="line">$ sed -n <span class="string">&#x27;/2024-01-25 08:54:*/,/2024-01-25 08:55:*/p&#x27;</span> filename</span><br></pre></td></tr></table></figure><h2 id="倒序输出文本内容"><a href="#倒序输出文本内容" class="headerlink" title="倒序输出文本内容"></a>倒序输出文本内容</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sed -n <span class="string">&#x27;1!G; h; $p&#x27;</span> data.txt</span><br><span class="line">This is the last line.</span><br><span class="line">This is the second data line.</span><br><span class="line">This is the first data line.</span><br><span class="line">This is the header line.</span><br></pre></td></tr></table></figure><p>命令分解：</p><ul><li><code>-n</code>：禁止自动打印模式空间的内容</li><li><code>1!G</code>：除了第一行外，将保持空间的内容追加到模式空间</li><li><code>h</code>：将模式空间的内容复制到保持空间</li><li><code>$p</code>：在最后一行时打印模式空间的内容</li></ul><h2 id="给文件的行编号"><a href="#给文件的行编号" class="headerlink" title="给文件的行编号"></a>给文件的行编号</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">&#x27;=&#x27;</span> data.txt</span><br><span class="line">1</span><br><span class="line">This is the header line.</span><br><span class="line">2</span><br><span class="line">This is the first data line.</span><br><span class="line">3</span><br><span class="line">This is the second data line.</span><br><span class="line">4</span><br><span class="line">This is the last line.</span><br></pre></td></tr></table></figure><p>sed编辑器的<code>=</code>命令会在每一行文本前输出一个行号，但是行号与文本跨行，需要进行合并处理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">&#x27;=&#x27;</span> data.txt | sed <span class="string">&#x27;N; s/\n/ /g&#x27;</span></span><br><span class="line">1 This is the header line.</span><br><span class="line">2 This is the first data line.</span><br><span class="line">3 This is the second data line.</span><br><span class="line">4 This is the last line.</span><br></pre></td></tr></table></figure><p>命令分解：</p><ul><li><code>N</code> 命令：将下一行读取到模式空间，与当前行合并（用换行符分隔）</li><li><code>s/\n/ /g</code>：将模式空间中的换行符替换为空格</li></ul><h2 id="插入空白行"><a href="#插入空白行" class="headerlink" title="插入空白行"></a>插入空白行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;$!G&#x27;</span> data.txt</span><br><span class="line">This is the header line.</span><br><span class="line"></span><br><span class="line">This is the first data line.</span><br><span class="line"></span><br><span class="line">This is the second data line.</span><br><span class="line"></span><br><span class="line">This is the last line.</span><br></pre></td></tr></table></figure><p>命令分解：</p><ul><li><code>$!</code>：表示”除了最后一行”</li><li><code>G</code>：将保持空间的内容追加到模式空间（默认为空行）</li></ul><p>上面这个命令会有一点小问题，如果文本行之间已经有空行，空行会加倍：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># data.txt</span></span><br><span class="line">$ <span class="built_in">cat</span> data.txt</span><br><span class="line">This is the header line.</span><br><span class="line">This is the first data line.</span><br><span class="line"></span><br><span class="line">This is the second data line.</span><br><span class="line">This is the last line.</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">&#x27;$!G&#x27;</span> data.txt</span><br><span class="line">This is the header line.</span><br><span class="line"></span><br><span class="line">This is the first data line.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">This is the second data line.</span><br><span class="line"></span><br><span class="line">This is the last line.</span><br></pre></td></tr></table></figure><p>解决办法是先删除所有空白行再插入空白行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">&#x27;/^$/d; $!G&#x27;</span> data.txt</span><br><span class="line">This is the header line.</span><br><span class="line"></span><br><span class="line">This is the first data line.</span><br><span class="line"></span><br><span class="line">This is the second data line.</span><br><span class="line"></span><br><span class="line">This is the last line.</span><br></pre></td></tr></table></figure><h2 id="删除多余的空白行"><a href="#删除多余的空白行" class="headerlink" title="删除多余的空白行"></a>删除多余的空白行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># data.txt</span></span><br><span class="line">$ <span class="built_in">cat</span> data.txt</span><br><span class="line">This is line one.</span><br><span class="line"></span><br><span class="line">This is line two.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">This is line three.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">This is line four.</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">&#x27;/./,/^$/!d&#x27;</span> data.txt</span><br><span class="line">This is line one.</span><br><span class="line"></span><br><span class="line">This is line two.</span><br><span class="line"></span><br><span class="line">This is line three.</span><br><span class="line"></span><br><span class="line">This is line four.</span><br></pre></td></tr></table></figure><p>命令分解：</p><ul><li><code>/./,/^$/</code>：这是一个地址范围，匹配从非空行（包含至少一个字符的行）到空行（不包含任何字符的行）之间的所有行</li><li><code>!d</code>：对不匹配上述地址范围的行执行删除操作（<code>d</code> 命令）</li></ul><h2 id="删除结尾的空白行"><a href="#删除结尾的空白行" class="headerlink" title="删除结尾的空白行"></a>删除结尾的空白行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># data.txt</span></span><br><span class="line">$ <span class="built_in">cat</span> data.txt</span><br><span class="line">This is the first line.</span><br><span class="line">This is the second line.</span><br><span class="line"><span class="comment"># 空行</span></span><br><span class="line"><span class="comment"># 空行</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">&gt; :start</span></span><br><span class="line"><span class="string">&gt; /^\n*$/&#123;$d; N; b start&#125;</span></span><br><span class="line"><span class="string">&gt; &#125;&#x27;</span> data.txt</span><br><span class="line">This is the first line.</span><br><span class="line">This is the second line.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不同Linux系统，sed命令实现方式可能略微有点差异</span></span><br><span class="line">$ sed <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">:start</span></span><br><span class="line"><span class="string">/^\n*$/&#123;</span></span><br><span class="line"><span class="string">$d</span></span><br><span class="line"><span class="string">N</span></span><br><span class="line"><span class="string">b start</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span> data.txt</span><br><span class="line">This is the first line.</span><br><span class="line">This is the second line.</span><br></pre></td></tr></table></figure><h2 id="删除HMTL标签"><a href="#删除HMTL标签" class="headerlink" title="删除HMTL标签"></a>删除HMTL标签</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># data.txt</span></span><br><span class="line">$ <span class="built_in">cat</span> data.txt</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;<span class="built_in">head</span>&gt;</span><br><span class="line">&lt;title&gt;This is the page title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">This is the &lt;b&gt;first&lt;/b&gt; line <span class="keyword">in</span> the Web page.</span><br><span class="line">This should provide some &lt;i&gt;useful&lt;/i&gt;</span><br><span class="line">information to use <span class="keyword">in</span> our sed script.</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">&#x27;s/&lt;.*&gt;//g&#x27;</span> data13.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">This is the  line <span class="keyword">in</span> the Web page.</span><br><span class="line">This should provide some</span><br><span class="line">information to use <span class="keyword">in</span> our sed script.</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>/&lt;.*&gt;/</code>模式会匹配到<code>&lt;head&gt;</code>、<code>&lt;b&gt;first&lt;/b&gt;</code>等，因此会把<code>&lt;head&gt;</code>、<code>&lt;b&gt;first&lt;/b&gt;</code>都替换成空字符。为了正确地匹配标签，<code>&lt;</code>和<code>&gt;</code>之间的内容不能包含<code>&lt;</code>和<code>&gt;</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">&#x27;s/&lt;[^&gt;]*&gt;//g&#x27;</span> data.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">This is the page title</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">This is the first line <span class="keyword">in</span> the Web page.</span><br><span class="line">This should provide some useful</span><br><span class="line">information to use <span class="keyword">in</span> our sed script.</span><br><span class="line"></span><br><span class="line">$ sed <span class="string">&#x27;s/&lt;[^&lt;]*&gt;//g&#x27;</span> data.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">This is the page title</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">This is the first line <span class="keyword">in</span> the Web page.</span><br><span class="line">This should provide some useful</span><br><span class="line">information to use <span class="keyword">in</span> our sed script.</span><br></pre></td></tr></table></figure><p>进一步可以删除多余的空白行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">&#x27;s/&lt;[^&lt;]*&gt;//g; /./,/^$/!d&#x27;</span> data.txt</span><br><span class="line">This is the page title</span><br><span class="line"></span><br><span class="line">This is the first line <span class="keyword">in</span> the Web page.</span><br><span class="line">This should provide some useful</span><br><span class="line">information to use <span class="keyword">in</span> our sed script.</span><br></pre></td></tr></table></figure><h2 id="打印末尾n行"><a href="#打印末尾n行" class="headerlink" title="打印末尾n行"></a>打印末尾n行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> data.txt</span><br><span class="line">This is line 1.</span><br><span class="line">This is line 2.</span><br><span class="line">This is line 3.</span><br><span class="line">This is line 4.</span><br><span class="line">This is line 5.</span><br><span class="line">This is line 6.</span><br><span class="line">This is line 7.</span><br><span class="line">This is line 8.</span><br><span class="line">This is line 9.</span><br><span class="line">This is line 10.</span><br><span class="line">This is line 11.</span><br><span class="line">This is line 12.</span><br><span class="line">This is line 13.</span><br><span class="line">This is line 14.</span><br><span class="line">This is line 15.</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">&gt; :start</span></span><br><span class="line"><span class="string">&gt; $q; N; 11,$D</span></span><br><span class="line"><span class="string">&gt; b start</span></span><br><span class="line"><span class="string">&gt; &#125;&#x27;</span> data.txt</span><br><span class="line">This is line 6.</span><br><span class="line">This is line 7.</span><br><span class="line">This is line 8.</span><br><span class="line">This is line 9.</span><br><span class="line">This is line 10.</span><br><span class="line">This is line 11.</span><br><span class="line">This is line 12.</span><br><span class="line">This is line 13.</span><br><span class="line">This is line 14.</span><br><span class="line">This is line 15.</span><br></pre></td></tr></table></figure><p>命令分解：</p><ul><li><code>:start</code>：定义一个标签 “start”</li><li><code>$q</code>：如果是最后一行，则退出（quit）</li><li><code>N</code>：将下一行读取到模式空间，与当前行合并</li><li><code>11,$D</code>：对于第11行到最后一行的范围，删除模式空间的第一行（直到换行符）</li><li><code>b start</code>：无条件跳转（branch）到 “start” 标签</li></ul><h2 id="批量重命名文件-1"><a href="#批量重命名文件-1" class="headerlink" title="批量重命名文件"></a>批量重命名文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 批量重命名文件工具</span></span><br><span class="line"><span class="comment"># 支持功能：</span></span><br><span class="line"><span class="comment"># 1. 添加前缀</span></span><br><span class="line"><span class="comment"># 2. 添加后缀</span></span><br><span class="line"><span class="comment"># 3. 替换文本</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示帮助信息</span></span><br><span class="line"><span class="function"><span class="title">show_help</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;用法: <span class="variable">$0</span> [选项] 目录路径&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;选项:&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;  -p, --prefix PREFIX    添加前缀&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;  -s, --suffix SUFFIX    添加后缀（在扩展名之前）&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;  -f, --find TEXT        要查找的文本&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;  -r, --replace TEXT     要替换的文本&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;  -d, --dry-run          试运行，只显示将要重命名的文件，不实际执行&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;  -h, --help             显示此帮助信息&quot;</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;示例:&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;  <span class="variable">$0</span> -p \&quot;vacation_\&quot; -s \&quot;_2023\&quot; /path/to/photos&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;  <span class="variable">$0</span> -f \&quot;IMG\&quot; -r \&quot;Photo\&quot; --dry-run /path/to/files&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化变量</span></span><br><span class="line">PREFIX=<span class="string">&quot;&quot;</span></span><br><span class="line">SUFFIX=<span class="string">&quot;&quot;</span></span><br><span class="line">FIND_TEXT=<span class="string">&quot;&quot;</span></span><br><span class="line">REPLACE_TEXT=<span class="string">&quot;&quot;</span></span><br><span class="line">DRY_RUN=<span class="literal">false</span></span><br><span class="line">TARGET_DIR=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析命令行参数</span></span><br><span class="line"><span class="keyword">while</span> [[ <span class="variable">$#</span> -gt 0 ]]; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">        -p|--prefix)</span><br><span class="line">            PREFIX=<span class="string">&quot;<span class="variable">$2</span>&quot;</span></span><br><span class="line">            <span class="built_in">shift</span></span><br><span class="line">            <span class="built_in">shift</span></span><br><span class="line">            ;;</span><br><span class="line">        -s|--suffix)</span><br><span class="line">            SUFFIX=<span class="string">&quot;<span class="variable">$2</span>&quot;</span></span><br><span class="line">            <span class="built_in">shift</span></span><br><span class="line">            <span class="built_in">shift</span></span><br><span class="line">            ;;</span><br><span class="line">        -f|--find)</span><br><span class="line">            FIND_TEXT=<span class="string">&quot;<span class="variable">$2</span>&quot;</span></span><br><span class="line">            <span class="built_in">shift</span></span><br><span class="line">            <span class="built_in">shift</span></span><br><span class="line">            ;;</span><br><span class="line">        -r|--replace)</span><br><span class="line">            REPLACE_TEXT=<span class="string">&quot;<span class="variable">$2</span>&quot;</span></span><br><span class="line">            <span class="built_in">shift</span></span><br><span class="line">            <span class="built_in">shift</span></span><br><span class="line">            ;;</span><br><span class="line">        -d|--dry-run)</span><br><span class="line">            DRY_RUN=<span class="literal">true</span></span><br><span class="line">            <span class="built_in">shift</span></span><br><span class="line">            ;;</span><br><span class="line">        -h|--<span class="built_in">help</span>)</span><br><span class="line">            show_help</span><br><span class="line">            <span class="built_in">exit</span> 0</span><br><span class="line">            ;;</span><br><span class="line">        -*)</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;未知选项: <span class="variable">$1</span>&quot;</span></span><br><span class="line">            show_help</span><br><span class="line">            <span class="built_in">exit</span> 1</span><br><span class="line">            ;;</span><br><span class="line">        *)</span><br><span class="line">            TARGET_DIR=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">            <span class="built_in">shift</span></span><br><span class="line">            ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查目标目录</span></span><br><span class="line"><span class="keyword">if</span> [[ -z <span class="string">&quot;<span class="variable">$TARGET_DIR</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;错误：必须指定目录路径&quot;</span></span><br><span class="line">    show_help</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ ! -d <span class="string">&quot;<span class="variable">$TARGET_DIR</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;错误：目录 &#x27;<span class="variable">$TARGET_DIR</span>&#x27; 不存在&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入目标目录</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$TARGET_DIR</span>&quot;</span> || <span class="built_in">exit</span> 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计数器</span></span><br><span class="line">count=0</span><br><span class="line">total=0</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;目标目录: <span class="variable">$TARGET_DIR</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;模式: 前缀=&#x27;<span class="variable">$PREFIX</span>&#x27;, 后缀=&#x27;<span class="variable">$SUFFIX</span>&#x27;, 查找=&#x27;<span class="variable">$FIND_TEXT</span>&#x27;, 替换=&#x27;<span class="variable">$REPLACE_TEXT</span>&#x27;&quot;</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$DRY_RUN</span>&quot;</span> = <span class="literal">true</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;模式: 试运行&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理文件</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> *; <span class="keyword">do</span></span><br><span class="line">    <span class="comment"># 跳过目录</span></span><br><span class="line">    <span class="keyword">if</span> [[ -d <span class="string">&quot;<span class="variable">$file</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">continue</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    </span><br><span class="line">    total=$((total + <span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取文件名和扩展名</span></span><br><span class="line">    filename=<span class="string">&quot;<span class="variable">$file</span>&quot;</span></span><br><span class="line">    extension=<span class="string">&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理后缀时，需要分离扩展名</span></span><br><span class="line">    <span class="keyword">if</span> [[ -n <span class="string">&quot;<span class="variable">$SUFFIX</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">        base_name=<span class="string">&quot;<span class="variable">$&#123;file%.*&#125;</span>&quot;</span></span><br><span class="line">        extension=<span class="string">&quot;<span class="variable">$&#123;file##*.&#125;</span>&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果文件没有扩展名或者扩展名与文件名相同（如点文件）</span></span><br><span class="line">        <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$base_name</span>&quot;</span> = <span class="string">&quot;&quot;</span> || <span class="string">&quot;<span class="variable">$base_name</span>&quot;</span> = <span class="string">&quot;<span class="variable">$file</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">            base_name=<span class="string">&quot;<span class="variable">$file</span>&quot;</span></span><br><span class="line">            extension=<span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            extension=<span class="string">&quot;.<span class="variable">$extension</span>&quot;</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        base_name=<span class="string">&quot;<span class="variable">$file</span>&quot;</span></span><br><span class="line">        extension=<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 替换文本</span></span><br><span class="line">    new_base_name=<span class="string">&quot;<span class="variable">$base_name</span>&quot;</span></span><br><span class="line">    <span class="keyword">if</span> [[ -n <span class="string">&quot;<span class="variable">$FIND_TEXT</span>&quot;</span> &amp;&amp; -n <span class="string">&quot;<span class="variable">$REPLACE_TEXT</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">        new_base_name=<span class="string">&quot;<span class="variable">$&#123;base_name//$FIND_TEXT/$REPLACE_TEXT&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 添加前缀和后缀</span></span><br><span class="line">    new_name=<span class="string">&quot;<span class="variable">$&#123;PREFIX&#125;</span><span class="variable">$&#123;new_base_name&#125;</span><span class="variable">$&#123;SUFFIX&#125;</span><span class="variable">$&#123;extension&#125;</span>&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果文件名有变化，则重命名</span></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$new_name</span>&quot;</span> != <span class="string">&quot;<span class="variable">$file</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;重命名: <span class="variable">$file</span> -&gt; <span class="variable">$new_name</span>&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 检查新文件名是否已存在</span></span><br><span class="line">        <span class="keyword">if</span> [[ -e <span class="string">&quot;<span class="variable">$new_name</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;警告：目标文件已存在，跳过: <span class="variable">$new_name</span>&quot;</span></span><br><span class="line">            <span class="built_in">continue</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$DRY_RUN</span>&quot;</span> = <span class="literal">false</span> ]]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">mv</span> -- <span class="string">&quot;<span class="variable">$file</span>&quot;</span> <span class="string">&quot;<span class="variable">$new_name</span>&quot;</span></span><br><span class="line">            <span class="keyword">if</span> [[ $? -eq 0 ]]; <span class="keyword">then</span></span><br><span class="line">                count=$((count + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;错误：重命名失败: <span class="variable">$file</span>&quot;</span></span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;无变化: <span class="variable">$file</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;操作完成。共处理 <span class="variable">$total</span> 个文件，成功重命名 <span class="variable">$count</span> 个文件&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加前缀</span></span><br><span class="line">./rename_files.sh -p <span class="string">&quot;vacation_&quot;</span> /path/to/files</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加后缀</span></span><br><span class="line">./rename_files.sh -s <span class="string">&quot;_2023&quot;</span> /path/to/files</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换文本</span></span><br><span class="line">./rename_files.sh -f <span class="string">&quot;IMG&quot;</span> -r <span class="string">&quot;Photo&quot;</span> /path/to/files</span><br><span class="line"></span><br><span class="line"><span class="comment"># 试运行（不实际重命名）</span></span><br><span class="line">./rename_files.sh -f <span class="string">&quot;old&quot;</span> -r <span class="string">&quot;new&quot;</span> -d /path/to/files</span><br></pre></td></tr></table></figure><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="批量删除分支"><a href="#批量删除分支" class="headerlink" title="批量删除分支"></a>批量删除分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch | grep <span class="string">&#x27;feature_&#x27;</span> | xargs git branch -d/-D</span><br></pre></td></tr></table></figure><h2 id="统计代码量"><a href="#统计代码量" class="headerlink" title="统计代码量"></a>统计代码量</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --since=<span class="string">&quot;2021-08-01&quot;</span> --<span class="keyword">until</span>==<span class="string">&quot;2023-05-31&quot;</span> --author=<span class="string">&quot;linfeng&quot;</span> --pretty=format: --numstat | awk <span class="string">&#x27; &#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %sn&quot;, add, subs, loc &#125;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="清理包含敏感信息的提交"><a href="#清理包含敏感信息的提交" class="headerlink" title="清理包含敏感信息的提交"></a>清理包含敏感信息的提交</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1. 列出所有包含敏感信息提交的分支或tag：`git branch(tag) -a --contains commitID`</span><br><span class="line"></span><br><span class="line">2. 编写replacements.txt，内容：敏感信息==&gt;替换文本</span><br><span class="line"></span><br><span class="line">3. 利用replacements.txt替换本地仓库所有的敏感信息：`git filter-repo --replace-text replacements.txt(完整路径) --replace-refs delete-no-add --force`</span><br><span class="line"></span><br><span class="line">4. 上一步会删除对远程仓库的跟踪，执行 `git remote add origin 仓库地址` 重新跟踪</span><br><span class="line"></span><br><span class="line">5. `git push origin 分支（第1步查出来的分支） --force`</span><br><span class="line"></span><br><span class="line">   如果分支有共性，比如都以feature开头，可以用以下脚本快速push（需在本地仓库的根目录下执行）</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span> branch <span class="keyword">in</span> $(git for-each-ref --format=<span class="string">&quot;%(refname:short)&quot;</span> refs/heads/feature/*)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;强制推送分支:<span class="variable">$branch</span>&quot;</span></span><br><span class="line">  git push origin <span class="string">&quot;<span class="variable">$branch</span>:<span class="variable">$branch</span>&quot;</span> --force</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">如果历史提交的敏感信息所在文件为config.yml，但是后来文件重命名为conf.yml，以上命令就无法有效清理那些包含敏感信息的历史提交。可以使用以下命令直接删除历史提交中的敏感文件：</span><br><span class="line"></span><br><span class="line">`git filter-repo --path 文件名 --invert-paths --replace-refs delete-no-add --force` </span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>学习&amp;面试-算法与设计模式</title>
      <link href="/post/8f20a568.html"/>
      <url>/post/8f20a568.html</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><h3 id="策略模式-Strategy-Pattern"><a href="#策略模式-Strategy-Pattern" class="headerlink" title="策略模式 (Strategy Pattern)"></a><strong>策略模式 (Strategy Pattern)</strong></h3><ul><li><strong>意图：</strong> 定义一系列算法，将它们封装起来，并且使它们可以相互替换。策略模式让算法的变化独立于使用它的客户。</li><li><strong>如何工作：</strong><ul><li>定义一个<code>Strategy</code>接口，声明所有支持的算法的公共方法。</li><li>创建多个具体的策略类(<code>ConcreteStrategyA</code>, <code>ConcreteStrategyB</code>等)，每个类实现<code>Strategy</code>接口并提供该算法的具体实现。</li><li>定义一个<code>Context</code>类。它包含一个对<code>Strategy</code>对象的引用(<code>strategy</code>)。<code>Context</code>可以定义一个接口让外部设置它所使用的策略对象（通常通过构造函数或setter方法注入）。</li><li><code>Context</code>类将客户端的请求<strong>委托</strong>给它持有的<code>Strategy</code>对象来执行具体的算法。<code>Context</code>并不关心当前使用的是哪个具体策略，它只通过接口与策略交互。</li></ul></li><li><strong>适用场景：</strong><ul><li><strong>需要在运行时动态选择算法时：</strong> 例如，根据用户选择、配置、系统状态等切换不同的排序算法（快速排序、归并排序、冒泡排序）、不同的支付方式（信用卡、PayPal、加密货币）、不同的压缩算法（ZIP、RAR、7z）、不同的折扣计算规则等。</li><li><strong>一个类定义了多种行为，并且这些行为在类中以多个条件语句的形式出现：</strong> 可以将每个分支移入它们各自的策略类中，消除复杂的条件逻辑。</li><li><strong>需要隔离算法逻辑和使用算法的代码：</strong> 算法实现细节被封装在具体的策略类中，<code>Context</code>只依赖接口，符合依赖倒置原则。</li><li><strong>有大量相关的类，仅在行为上有所不同：</strong> 策略模式提供了一种用多个行为配置一个类的方法。</li><li><strong>需要提供算法的多种实现，并且希望客户端能够轻松地在它们之间切换。</strong></li></ul></li><li><strong>优点：</strong> 算法可自由切换；避免使用多重条件判断；扩展性好（新增策略容易）；符合开闭原则；算法复用（如果多个上下文需要相同算法）。</li><li><strong>缺点：</strong> 客户端必须了解不同策略的区别以选择合适的策略（可能引入选择逻辑）；增加了策略类和对象的数量；策略间的通信可能需要通过<code>Context</code>传递数据，或者策略本身需要访问<code>Context</code>的状态（可能增加耦合）。</li></ul><h3 id="模板方法模式-Template-Method-Pattern"><a href="#模板方法模式-Template-Method-Pattern" class="headerlink" title="模板方法模式 (Template Method Pattern)"></a><strong>模板方法模式 (Template Method Pattern)</strong></h3><ul><li><strong>意图：</strong> 定义一个操作中的算法骨架，而将一些步骤延迟到子类中实现。模板方法使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤。</li><li><strong>如何工作：</strong><ul><li>定义一个<code>AbstractClass</code>（抽象类）。它包含：<ul><li><strong>模板方法(<code>templateMethod()</code>):</strong> 这是一个<strong>具体方法</strong>，定义了算法的骨架&#x2F;步骤顺序。它按顺序调用其他方法（包括抽象方法、具体方法和钩子方法）。</li><li><strong>原语操作(<code>primitiveOperationX()</code>):</strong> 这些是<strong>抽象方法</strong>，代表算法中需要子类提供具体实现的<strong>可变步骤</strong>。它们是算法骨架中的“占位符”。</li><li><strong>具体方法(<code>concreteOperation()</code>):</strong> 在抽象类中已经实现的方法，代表算法骨架中<strong>固定不变</strong>的步骤，所有子类共享。模板方法会调用它们。</li><li><strong>钩子方法(<code>hook()</code>):</strong> （可选）在抽象类中提供<strong>默认实现</strong>（通常是空实现或返回默认值）的<strong>具体方法</strong>。子类可以选择性地覆盖它们以在算法流程的特定点插入自己的逻辑，但不改变主要流程。它们为子类提供额外的扩展点。</li></ul></li><li>创建具体的子类(<code>ConcreteClassA</code>, <code>ConcreteClassB</code>等)，继承自<code>AbstractClass</code>。</li><li>子类<strong>必须</strong>实现父类中定义的所有<strong>抽象方法（原语操作）</strong>。它们<strong>可以</strong>选择覆盖父类的<strong>具体方法</strong>或<strong>钩子方法</strong>（但通常不鼓励覆盖具体方法，除非明确设计为可覆盖）。</li></ul></li><li><strong>适用场景：</strong><ul><li><strong>有多个子类共有相同的行为逻辑（算法骨架），但其中某些具体步骤的实现不同时：</strong> 例如，不同类型的文档导出（PDFExport, WordExport）都有固定的流程（准备数据、生成内容、添加页眉页脚、保存文件），但“生成内容”和“保存文件”的具体步骤不同。</li><li><strong>需要控制子类扩展的点时：</strong> 父类通过定义原语操作和钩子方法，精确地指定了子类可以改变算法的哪些部分（步骤实现），哪些部分不能改变（步骤顺序和固定步骤）。</li><li><strong>代码复用：</strong> 将公共的、不变的行为提升到父类中，避免代码重复。</li><li><strong>框架设计：</strong> 框架定义核心流程（模板方法），用户通过实现特定的步骤（原语操作）来定制框架行为。如Servlet中的<code>service()</code>方法调用<code>doGet()</code>&#x2F;<code>doPost()</code>，JUnit的生命周期方法(<code>setUp()</code>, <code>testX()</code>, <code>tearDown()</code>)。</li></ul></li><li><strong>优点：</strong> 代码复用度高（公共部分在父类）；封装不变部分，扩展可变部分；父类控制算法结构，子类专注于特定步骤；通过钩子方法提供灵活扩展点。</li><li><strong>缺点：</strong> 对每个不同的实现都需要一个子类，可能导致类数量增加；子类对父类产生了依赖（继承的强耦合）；通过覆盖具体方法改变行为可能导致意外结果（违反里氏替换原则）；骨架的修改可能影响所有子类。</li></ul><h2 id="模式比较"><a href="#模式比较" class="headerlink" title="模式比较"></a>模式比较</h2><h3 id="策略模式vs模板方法模式"><a href="#策略模式vs模板方法模式" class="headerlink" title="策略模式vs模板方法模式"></a>策略模式vs模板方法模式</h3><p>策略模式和模板方法模式都是行为型设计模式，用于封装变化的部分，但它们解决问题的角度和实现方式有本质区别。</p><p><strong>核心区别总结：</strong></p><table><thead><tr><th align="left">特性</th><th align="left">策略模式 (Strategy Pattern)</th><th align="left">模板方法模式 (Template Method Pattern)</th></tr></thead><tbody><tr><td align="left"><strong>核心思想</strong></td><td align="left"><strong>封装可互换的算法族</strong>，让客户端根据需要<strong>动态选择</strong>具体算法。</td><td align="left"><strong>定义算法的骨架</strong>，将<strong>某些步骤</strong>延迟到子类中实现。</td></tr><tr><td align="left"><strong>关注点</strong></td><td align="left"><strong>算法实现的完整替换</strong>。</td><td align="left"><strong>算法结构（步骤顺序）的固定，步骤实现的扩展</strong>。</td></tr><tr><td align="left"><strong>关系</strong></td><td align="left">**组合 (Composition)**：上下文持有策略接口引用。</td><td align="left">**继承 (Inheritance)**：子类继承抽象父类。</td></tr><tr><td align="left"><strong>变化点</strong></td><td align="left">整个算法的<strong>实现逻辑</strong>可以完全改变。</td><td align="left">算法<strong>骨架不变</strong>，<strong>特定步骤的实现</strong>可以改变。</td></tr><tr><td align="left"><strong>灵活性</strong></td><td align="left">运行时动态切换策略，<strong>更灵活</strong>。</td><td align="left">编译时通过子类确定行为，相对静态。</td></tr><tr><td align="left"><strong>开闭原则</strong></td><td align="left">添加新策略不影响上下文，<strong>对扩展开放</strong>。</td><td align="left">修改步骤实现需创建新子类，骨架修改可能违反开闭原则。</td></tr><tr><td align="left"><strong>代码复用</strong></td><td align="left">策略之间通常<strong>无复用</strong>（除非共享公共逻辑）。</td><td align="left"><strong>复用父类定义的算法骨架</strong>。</td></tr><tr><td align="left"><strong>典型结构</strong></td><td align="left">Context + Strategy Interface + Concrete Strategies</td><td align="left">AbstractClass + ConcreteSubclasses (<code>templateMethod()</code> + <code>primitiveOperationX()</code>)</td></tr></tbody></table><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>题目描述：有一个几乎有序的数组，意思是每个元素最多只需要移动不超过k个位置就可以到达排序后的位置，且k远小于数组大小。</p><p>要求：用最高效的算法排序。</p><p>要高效地对几乎有序的数组（每个元素最多只需移动k个位置，且k远小于数组大小）进行排序，可以使用最小堆（优先队列）优化算法。核心思路是利用数组的特性：最小元素一定位于前k+1个元素内。通过维护大小为k+1的最小堆，每次弹出最小值并加入新元素，实现O(n log k)的时间复杂度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AlmostSortedArraySorter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sortAlmostSorted</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || k &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="comment">// 创建最小堆，大小为k+1（防止k过大导致堆过大）</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Math.min(k + <span class="number">1</span>, n));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始填充堆：前min(k+1, n)个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Math.min(k + <span class="number">1</span>, n); i++) &#123;</span><br><span class="line">            minHeap.offer(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 当前排序位置</span></span><br><span class="line">        <span class="comment">// 处理剩余元素：每弹出一个最小值，加入一个新元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k + <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr[index++] = minHeap.poll(); <span class="comment">// 弹出最小值放入数组</span></span><br><span class="line">            minHeap.offer(arr[i]);         <span class="comment">// 加入新元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理堆中剩余元素</span></span><br><span class="line">        <span class="keyword">while</span> (!minHeap.isEmpty()) &#123;</span><br><span class="line">            arr[index++] = minHeap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>&#125;; <span class="comment">// k=2时几乎有序</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    sortAlmostSorted(arr, k);</span><br><span class="line">    System.out.println(java.util.Arrays.toString(arr)); <span class="comment">// 输出: [1, 2, 3, 4, 5, 6]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>学习&amp;面试-项目</title>
      <link href="/post/9811b68b.html"/>
      <url>/post/9811b68b.html</url>
      
        <content type="html"><![CDATA[<h1 id="Dolphin知识库"><a href="#Dolphin知识库" class="headerlink" title="Dolphin知识库"></a>Dolphin知识库</h1><p>时间：2025.4～至今</p><h2 id="文件上传的实现细节"><a href="#文件上传的实现细节" class="headerlink" title="文件上传的实现细节"></a>文件上传的实现细节</h2><h2 id="有没有历史版本的diff能力，应该怎么设计"><a href="#有没有历史版本的diff能力，应该怎么设计" class="headerlink" title="有没有历史版本的diff能力，应该怎么设计"></a>有没有历史版本的diff能力，应该怎么设计</h2><h2 id="熔断降级怎么实现"><a href="#熔断降级怎么实现" class="headerlink" title="熔断降级怎么实现"></a>熔断降级怎么实现</h2><h2 id="协同编辑怎么实现的"><a href="#协同编辑怎么实现的" class="headerlink" title="协同编辑怎么实现的"></a>协同编辑怎么实现的</h2><h2 id="微服务之间如何通信"><a href="#微服务之间如何通信" class="headerlink" title="微服务之间如何通信"></a>微服务之间如何通信</h2><h1 id="AI工作台"><a href="#AI工作台" class="headerlink" title="AI工作台"></a>AI工作台</h1><p>时间：2024.6～2025.4</p><h1 id="效能洞察"><a href="#效能洞察" class="headerlink" title="效能洞察"></a>效能洞察</h1><p>时间：2023.6～2024.6</p><h1 id="目标绩效系统"><a href="#目标绩效系统" class="headerlink" title="目标绩效系统"></a>目标绩效系统</h1><p>时间：2021.8～2023.6</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>学习&amp;面试-思维逻辑</title>
      <link href="/post/181e3e1b.html"/>
      <url>/post/181e3e1b.html</url>
      
        <content type="html"><![CDATA[<h2 id="小白鼠试毒药"><a href="#小白鼠试毒药" class="headerlink" title="小白鼠试毒药"></a>小白鼠试毒药</h2><h2 id="100个人按灯"><a href="#100个人按灯" class="headerlink" title="100个人按灯"></a>100个人按灯</h2><blockquote><p>有100盏灯,编号依次为1,2,3…100,电灯全部关着。现在来了100个人,第一个人把所有的灯开关按下；第二个人隔一个灯按下（2,4,6…）；第三个人每隔两个灯按下（3,6,9…）.第100个人隔99个灯按下（100）,最后还有几盏灯，那几盏灯亮着？</p></blockquote><h2 id="100的阶乘有几个0"><a href="#100的阶乘有几个0" class="headerlink" title="100的阶乘有几个0"></a>100的阶乘有几个0</h2><p>100的阶乘（100!）有多少个末尾的零，可以通过计算其因式分解中10的因子个数来确定，因为末尾的零是由2和5相乘得到的。</p><p>首先，我们将100!进行因式分解。100!表示从1乘到100的连续整数的乘积，可以写成：</p><p>100! &#x3D; 1 × 2 × 3 × 4 × … × 99 × 100</p><p>接下来，我们观察乘法中每一项的因子中2和5的个数。</p><p>在100!中，偶数的因子2的个数明显比5多，因为每隔一个数就会有一个偶数出现，而偶数都包含因子2。所以，我们只需要关注100!中5的因子个数。</p><p>在100!中，5、10、15、20、…、95、100这些数都包含因子5，共有20个数。而25、50、75、100这些数包含两个因子5，所以需要将其计算在内。</p><p>因此，100!中总共有20 + 4 &#x3D; 24个因子5。</p><p>综上所述，100!末尾共有24个零。</p><h2 id="用天平找最轻-重的球"><a href="#用天平找最轻-重的球" class="headerlink" title="用天平找最轻&#x2F;重的球"></a>用天平找最轻&#x2F;重的球</h2><blockquote><p>8个球，一个轻，天平2次找出来</p></blockquote><p>第一次称重：将任意三个球放在天平的一边，再将另外三个球放在另一边，剩下的两个球不放在天平上。如果天平平衡，则轻的球在剩下的两个球中，可以直接通过目测或者手感来找出轻的球。如果天平不平衡，那么轻的球一定在轻的那一边。</p><p>第二次称重：将轻的那一边的三个球中的两个球放在天平的一边，将剩下的一个球放在另一边。如果天平平衡，则剩下的那个球就是轻的球；如果天平不平衡，那么轻的球就是轻的那一边的球。</p><h2 id="2017的2017-次方的最后一位数"><a href="#2017的2017-次方的最后一位数" class="headerlink" title="2017的2017 次方的最后一位数"></a>2017的2017 次方的最后一位数</h2><p>计算2017的2017次方的最后一位数，可以使用数论中的数学性质来简化计算。根据数学性质，一个整数的末位数只和该整数的个位数有关，而与其他位数无关。</p><p>首先，我们观察2017的个位数是什么。2017除以10的余数是7，因此2017的个位数是7。</p><p>接下来，我们观察7的幂的个位数的规律。我们可以列举一些7的幂，看看个位数的变化：</p><p>7^1 &#x3D; 7 7^2 &#x3D; 49 7^3 &#x3D; 343 7^4 &#x3D; 2401 7^5 &#x3D; 16807 …</p><p>可以观察到，7的幂的个位数会在7、9、3、1这四个数字之间循环。具体地，7^1的个位数是7，7^2的个位数是9，7^3的个位数是3，7^4的个位数是1，7^5的个位数又是7，以此类推。</p><p>因此，我们可以利用这个规律来简化计算2017的2017次方的个位数。2017除以4的余数是1，所以2017的2017次方的个位数也是1。</p><p>综上所述，2017的2017次方的最后一位数是1。</p><h2 id="25匹马，5个跑道，最少比多少次能比出前3名"><a href="#25匹马，5个跑道，最少比多少次能比出前3名" class="headerlink" title="25匹马，5个跑道，最少比多少次能比出前3名"></a>25匹马，5个跑道，最少比多少次能比出前3名</h2><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维逻辑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习&amp;面试-计算机基础</title>
      <link href="/post/caa317df.html"/>
      <url>/post/caa317df.html</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ol><li>用户态与内核态切换的开销来源？</li><li>进程间通信IPC的5种方式对比</li><li>虚拟内存与物理内存映射原理（页表寻址）</li><li>死锁的必要条件及银行家算法实现</li><li>自旋锁与互斥锁的使用场景差异</li><li>零拷贝技术实现原理（sendfile&#x2F;mmap）</li><li>孤儿进程与僵尸进程的区别及处理</li><li>CPU软中断与硬中断处理机制</li><li>如何用top命令分析CPU负载异常？</li><li>内存泄漏与内存溢出的定位方法</li><li>大页内存（HugePage）优化原理</li><li>协程与线程的调度效率差异</li><li>文件描述符（fd）耗尽如何处理？</li><li>CPU缓存行伪共享问题解决方案</li><li>NUMA架构下的性能调优要点</li><li>系统调用过程详解（int 0x80&#x2F;syscall）</li><li>实时操作系统与非实时系统的调度差异</li><li>容器与虚拟机的资源隔离原理对比</li><li>如何实现一个简单的线程池？</li><li>系统平均负载（Load Average）的深层含义</li></ol><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ol><li>TCP三次握手与四次挥手的状态变迁图</li><li>TIME_WAIT状态过多如何优化？</li><li>HTTPS双向认证流程与中间人攻击防范</li><li>QUIC协议如何解决队头阻塞问题？</li><li>TCP拥塞控制算法（CUBIC&#x2F;BBR）</li><li>HTTP&#x2F;2多路复用与队头阻塞解决方案</li><li>Websocket握手协议与心跳机制实现</li><li>DNS解析过程（递归查询与迭代查询）</li><li>CDN动态加速与静态加速技术原理</li><li>如何设计一个高并发连接的服务端？</li><li>长连接保活策略（TCP Keepalive vs 应用层心跳）</li><li>网络抓包分析实战（Wireshark过滤技巧）</li><li>单机百万连接的实现与优化</li><li>HTTP Range请求与断点续传实现</li><li>5层协议栈中每层的典型设备</li><li>VLAN与VXLAN的区别及使用场景</li><li>如何实现UDP可靠传输？</li><li>MTU与MSS的关系及分片问题</li><li>SYN Flood攻击原理与防御方案</li><li>TLS1.3相比1.2的核心改进点</li></ol><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="候选码"><a href="#候选码" class="headerlink" title="候选码"></a>候选码</h3><p>关系模式中，能够唯一标识每一行数据的最小属性集。在多个候选码中，可以选择一个作为表的主键（Primary Key），一个关系只能有一个主键。</p><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>给定关系模式R，如果属性集X的值确定属性集Y的值，则成Y依赖于X，记作：X→Y。</p><p>对于X→Y，如果存在X的真子集使得X’→Y，那么X→Y就是部分函数依赖，否则就是完全函数依赖。</p><p>如果X→Y，Y→Z，那么X→Z就是传递函数依赖。</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>假设有一个学生课程关系模式如下：</p><table><thead><tr><th>Sno</th><th>Sname</th><th>Sdept</th><th>Mname</th><th>Cname</th><th>Grade</th></tr></thead><tbody><tr><td>1</td><td>学生-1</td><td>学院-1</td><td>院长-1</td><td>课程-1</td><td>90</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td><td>院长-2</td><td>课程-2</td><td>80</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td><td>院长-2</td><td>课程-1</td><td>100</td></tr><tr><td>3</td><td>学生-3</td><td>学院-2</td><td>院长-2</td><td>课程-2</td><td>95</td></tr></tbody></table><p>可以看出这个关系模式的候选码是{Sno, Cname}，因为{Sno, Cname}是可以唯一标识每一行数据的最小数据集。</p><p>这是一个不符合范式的关系模式，存在如下异常：</p><ul><li>数据冗余：例如学生-2、课程-1、课程-2都出现了多次</li><li>插入异常：如果关系模式要求课程不能为空，那么在学生尚未选课的情况下就无法单独插入学生数据</li><li>修改异常：出现多次的数据只修改了其中一部分，导致数据不一致</li><li>删除异常：例如删除所有课程-1相关数据会导致学生-1信息丢失</li></ul><h3 id="范式vs反范式"><a href="#范式vs反范式" class="headerlink" title="范式vs反范式"></a>范式vs反范式</h3><p>为了解决上面提到的这些异常，关系模式的设计就需要规范化。</p><p><strong>第一范式（1NF）</strong>：属性不可分割，即每个属性都是不可分割的原子项。</p><p><strong>第二范式（2NF）</strong>：满足第一范式，且不存在部分函数依赖，即任意非主属性完全依赖于主键。</p><p><strong>第三范式（3NF）</strong>：满足第二范式，且不存在传递函数依赖，即任意非主属性直接依赖于主键。</p><p><strong>反范式</strong>：完全遵循范式的数据库设计可能性能较差，因为需要大量的连表查询。反范式是牺牲部分范式以提高性能的一种设计方式，具体有以下方式：</p><ul><li>增加冗余列：在多个表中具有相同的列，通常用来避免查询时的连表操作。</li><li>增加派生列：增加的列可以通过表中其他数据计算胜场，作用是减少查询时的计算量，从而加快查询速度。</li><li>重新组表：如果许多用户需要查看两个表连接出来的结果数据，则把这两个表重新组成一个表来减少连接从而提高性能。</li><li>分割表：垂直分割、水平分割</li></ul><p>很显然，牺牲范式以提高性能的反范式设计会带来一些问题，如：</p><ul><li>数据冗余，浪费存储空间</li><li>数据不一致</li><li>增、删、改效率降低</li><li>可能导致插入异常、删除异常、修改异常</li></ul><p>因此在实际的设计中，需要根据具体应用场景进行权衡。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习&amp;面试-DevOps</title>
      <link href="/post/9dab8c66.html"/>
      <url>/post/9dab8c66.html</url>
      
        <content type="html"><![CDATA[<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>学习&amp;面试-工具与类库</title>
      <link href="/post/924495ff.html"/>
      <url>/post/924495ff.html</url>
      
        <content type="html"><![CDATA[<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>Maven 是一个 <strong>项目管理和构建工具</strong>，主要用于 Java 项目的依赖管理、构建自动化以及项目生命周期管理。</p><h3 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h3><table><thead><tr><th>依赖范围</th><th>说明</th></tr></thead><tbody><tr><td><code>compile</code></td><td><code>scope</code>元素的缺省值。编译、测试、运行阶段都会引入</td></tr><tr><td><code>test</code></td><td>测试阶段引入</td></tr><tr><td><code>provided</code></td><td>编译、测试阶段引入</td></tr><tr><td><code>runtime</code></td><td>测试、运行阶段引入</td></tr><tr><td><code>system</code></td><td>用于添加本地依赖，不推荐使用</td></tr><tr><td><code>import</code></td><td>与 <code>dependencyManagement</code> 元素配合使⽤，其功能是将⽬标 <code>pom.xml</code> ⽂件中 <code>dependencyManagement</code> 的配置导⼊合并到当前 <code>pom.xml</code> 的 <code>dependencyManagement</code> 中</td></tr></tbody></table><h3 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h3><p>有三个模块A、B、C，A依赖B，B依赖C，C是否能传递到A，取决于B依赖C时使用的依赖范围和配置。</p><ul><li><code>compile</code>或<code>runtime</code>依赖可以传递，其他依赖范围不能传递</li></ul><img src="/post/924495ff/image-20241201105858259.png" class="" title="compile依赖"><img src="/post/924495ff/image-20241201110755516.png" class="" title="runtime依赖"><img src="/post/924495ff/image-20241201110400431.png" class="" title="test依赖"><img src="/post/924495ff/image-20241201110500022.png" class="" title="provided依赖"><ul><li><code>optional</code>为<code>true</code>的依赖不能传递</li></ul><img src="/post/924495ff/image-20241201111836452.png" class="" title="optional依赖"><h3 id="依赖冲突"><a href="#依赖冲突" class="headerlink" title="依赖冲突"></a>依赖冲突</h3><p>当直接和间接引用了同一个依赖，最终的依赖版本取决于依赖的路径和顺序。</p><ul><li>最短路径原则</li></ul><p>在下面的截图中，<code>A</code>到<code>jackson-bind</code>有两条依赖路径<code>A-&gt;B-&gt;C-&gt;jackson-databind</code>和<code>A-&gt;jackson-databind</code>，根据最短路径原则，最终<code>A</code>会依赖<code>jackson-databind</code>的<code>2.15.0</code>版本</p><img src="/post/924495ff/image-20241201113454944.png" class="" title="最短路径原则"><ul><li>声明顺序原则</li></ul><p>在下面截图中，<code>A</code>到<code>jackson-bind</code>的依赖路径包括<code>A-&gt;B-&gt;jackson-databind</code>和<code>A-&gt;C-&gt;jsckson-databind</code>，依赖路径长度一样，所以最短路径依赖原则不适用。此时就需要根据<code>B</code>和<code>C</code>的声明顺序来决定<code>jackson-databind</code>的依赖版本。</p><img src="/post/924495ff/image-20241201113752360-3024301.png" class="" title="B声明在先"><img src="/post/924495ff/image-20241201114225143.png" class="" title="C声明在先"><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习&amp;面试-系统设计</title>
      <link href="/post/53a2d197.html"/>
      <url>/post/53a2d197.html</url>
      
        <content type="html"><![CDATA[<h1 id="DDD"><a href="#DDD" class="headerlink" title="DDD"></a>DDD</h1><h2 id="DDD的一些核心概念"><a href="#DDD的一些核心概念" class="headerlink" title="DDD的一些核心概念"></a>DDD的一些核心概念</h2><p><strong>战略设计（Strategic Design）：划分领域边界，明确核心问题</strong></p><ul><li><strong>领域（Domain）</strong>：业务问题的范围（如电商领域的“订单”、“支付”）。</li><li><strong>子域（Subdomain）</strong>：领域的细分，分为：<ul><li><strong>核心子域</strong>（核心竞争力，如电商的“交易系统”）。</li><li><strong>支撑子域</strong>（辅助业务，如“物流跟踪”）。</li><li><strong>通用子域</strong>（通用功能，如“用户认证”）。</li></ul></li><li><strong>限界上下文（Bounded Context）</strong>：<ul><li>领域模型的<strong>明确边界</strong>，每个上下文有独立的<strong>统一语言</strong>和模型。</li><li>例如：电商中“订单上下文”和“库存上下文”的“商品”模型可能不同。</li></ul></li><li><strong>上下文映射（Context Mapping）</strong>：<ul><li>描述限界上下文间的交互方式，如：<ul><li><strong>合作关系（Partnership）</strong>：两个上下文协同完成目标。</li><li><strong>防腐层（Anti-Corruption Layer, ACL）</strong>：隔离外部上下文的不合理模型。</li><li><strong>开放主机服务（Open Host Service）</strong>：通过标准化协议（如API）暴露功能。</li></ul></li></ul></li></ul><p><strong>战术设计（Tactical Design）：在限界上下文内构建领域模型</strong></p><ul><li><strong>实体（Entity）</strong>：<ul><li>具有唯一标识的对象（如<code>Order</code>通过<code>orderId</code>区分）。</li><li>标识不变，属性可变。</li></ul></li><li><strong>值对象（Value Object）</strong>：<ul><li>通过属性值定义的无标识对象（如<code>Money</code>包含金额和货币类型）。</li><li>通常不可变（Immutable）。</li></ul></li><li><strong>聚合（Aggregate）</strong>：<ul><li><strong>一组关联对象的集合</strong>，根实体（Aggregate Root）是唯一访问入口。</li><li>例如：<code>Order</code>（聚合根）包含<code>OrderItem</code>和<code>Address</code>，外部只能通过<code>Order</code>修改其内部对象。</li><li>保证业务一致性（事务边界）。</li></ul></li><li><strong>领域服务（Domain Service）</strong>：<ul><li>处理<strong>跨聚合</strong>或<strong>与外部交互</strong>的逻辑（如<code>PaymentService</code>处理支付）。</li><li>通常是无状态的。</li></ul></li><li><strong>领域事件（Domain Event）</strong>：<ul><li>表示领域中发生的重要事件（如<code>OrderPaidEvent</code>）。</li><li>用于解耦系统（事件驱动架构）。</li></ul></li><li><strong>仓储（Repository）</strong>：<ul><li>封装聚合的持久化逻辑（如<code>OrderRepository</code>）。</li><li>隔离领域模型与基础设施。</li></ul></li><li><strong>工厂（Factory）</strong>：<ul><li>负责复杂对象的创建逻辑（如<code>OrderFactory</code>处理订单初始化）。</li></ul></li></ul><p><strong>其他关键概念</strong></p><ul><li><strong>统一语言（Ubiquitous Language）</strong>：<ul><li>开发人员与业务专家共同定义的术语，贯穿代码、文档、对话。</li></ul></li><li><strong>分层架构（Layered Architecture）</strong>：<ul><li>典型分层：<ul><li><strong>用户界面层（Presentation）</strong></li><li><strong>应用层（Application）</strong>：协调领域对象，处理用例流程。</li><li><strong>领域层（Domain）</strong>：核心业务逻辑。</li><li><strong>基础设施层（Infrastructure）</strong>：技术实现（数据库、消息队列等）。</li></ul></li></ul></li></ul><p><strong>技术实现模式</strong></p><ul><li><strong>CQRS（Command Query Responsibility Segregation）</strong>：<ul><li>分离读写模型，优化查询和命令处理（如用不同数据库）。</li></ul></li><li><strong>事件溯源（Event Sourcing）</strong>：<ul><li>通过存储事件（而非状态）重建聚合状态。</li></ul></li><li><strong>六边形架构（Hexagonal Architecture）</strong>：<ul><li>领域模型位于核心，通过端口&#x2F;适配器与外部交互。</li></ul></li></ul><p><strong>核心思想总结</strong></p><ol><li><strong>聚焦核心领域</strong>，通过限界上下文划分边界。</li><li><strong>模型驱动设计</strong>，统一语言消除歧义。</li><li><strong>战术模式</strong>（实体&#x2F;值对象&#x2F;聚合等）实现高内聚、低耦合。</li></ol><p><strong>适用场景</strong></p><ul><li>业务逻辑复杂、需长期演化的系统（如金融、电商、SaaS平台）。</li><li>团队需与业务专家紧密协作的场景。</li></ul><p>DDD通过清晰的模型和边界，帮助开发者应对复杂性，避免代码腐化。</p><ol><li>服务注册发现AP与CP架构对比</li><li>熔断降级策略（滑动窗口实现）</li><li>分布式配置中心推拉模式对比</li><li>灰度发布实现方案</li><li>分布式链路追踪原理（Span树）</li><li>Seata AT模式实现原理</li><li>接口性能突增的限流策略</li><li>如何设计服务治理平台？</li><li>设计微信朋友圈的存储架构</li><li>短链系统如何实现高并发写入？</li><li>分布式唯一ID生成方案（Snowflake优化）</li><li>如何设计一个分布式定时任务系统？</li><li>实现跨数据中心的数据同步方案</li><li>设计支持千万级用户的推送系统</li><li>微博热搜榜实时计算架构设计</li><li>电商库存扣减的防超卖方案</li><li>多级缓存架构设计（本地缓存+Redis+JVM）</li><li>设计支持PB级数据的日志分析系统</li><li>实现一个分布式配置中心</li><li>设计支持动态扩容的分库分表方案</li><li>如何设计API网关的限流熔断功能？</li><li>实时聊天系统的消息可靠投递方案</li><li>设计支持版本回滚的配置管理系统</li><li>实现跨语言服务调用（Thrift&#x2F;gRPC选型）</li><li>设计支持弹性伸缩的微服务架构</li><li>实现分布式Session一致性方案</li><li>设计一个高性能的日志采集系统</li><li>如何设计可追溯的操作日志系统？</li><li>如何实现熔断器模式（Circuit Breaker）？</li><li>CQRS模式在电商系统中的应用</li><li>事件溯源（Event Sourcing）的优缺点分析</li><li>Sidecar模式在服务治理中的应用</li><li>网关模式中的路由策略设计</li><li>防腐层（Anti-Corruption Layer）设计实践</li><li>领域驱动设计（DDD）中的聚合根设计</li><li>重试模式中的指数退避算法实现</li><li>前端的后端模式（BFF）适用场景</li><li>分片模式（Sharding）的数据迁移方案</li><li>管道过滤器模式在ETL中的应用</li><li>物化视图模式优化查询性能案例</li><li>策略模式在支付渠道选择中的应用</li><li>观察者模式实现配置动态更新</li><li>代理模式在缓存穿透防护中的应用</li><li>工厂方法模式在连接池创建中的应用</li><li>装饰器模式实现API限流功能</li><li>状态模式在订单状态流转中的应用</li><li>组合模式实现权限树结构设计</li><li>模板方法模式在事务管理中的应用</li><li>HTTPS握手过程优化策略</li><li>零拷贝技术实现原理</li><li>百万连接服务器架构设计</li><li>线上CPU飙高排查流程</li><li>设计一个短链系统</li><li>接口性能优化全链路方案</li><li>海量数据判重方案（布隆过滤器）</li><li>如何设计秒杀系统？</li><li>大型项目代码规范落地实践</li><li>线上问题排查工具箱（arthas+prometheus）</li></ol><h1 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h1><h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>核心思想：<strong>在单位时间内，只允许特定数量的请求通过，超过阈值的请求将被拒绝、排队等待或降级处理。</strong> 目的是保护系统不被突发流量压垮，确保系统在最大承受能力内稳定运行。</p><h3 id="常见的限流算法与实现"><a href="#常见的限流算法与实现" class="headerlink" title="常见的限流算法与实现"></a>常见的限流算法与实现</h3><h4 id="计数器固定窗口算法"><a href="#计数器固定窗口算法" class="headerlink" title="计数器固定窗口算法"></a>计数器固定窗口算法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FixedWindowLimiter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maxRequests;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> windowMillis;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> windowStart;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FixedWindowLimiter</span><span class="params">(<span class="type">int</span> maxRequests, <span class="type">long</span> windowMillis)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxRequests = maxRequests;</span><br><span class="line">        <span class="built_in">this</span>.windowMillis = windowMillis;</span><br><span class="line">        <span class="built_in">this</span>.windowStart = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">allow</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (now - windowStart &gt; windowMillis) &#123;</span><br><span class="line">            count = <span class="number">0</span>; <span class="comment">// 重置计数器</span></span><br><span class="line">            windowStart = now;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; maxRequests) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题</strong>：窗口切换时可能瞬间涌入2倍流量（临界问题）。</p><h4 id="滑动日志算法（解决临界问题）"><a href="#滑动日志算法（解决临界问题）" class="headerlink" title="滑动日志算法（解决临界问题）"></a>滑动日志算法（解决临界问题）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SlidingLogLimiter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maxRequests;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> windowMillis;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Long&gt; timestamps = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SlidingLogLimiter</span><span class="params">(<span class="type">int</span> maxRequests, <span class="type">long</span> windowMillis)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxRequests = maxRequests;</span><br><span class="line">        <span class="built_in">this</span>.windowMillis = windowMillis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">allow</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 移除超时请求</span></span><br><span class="line">        <span class="keyword">while</span> (!timestamps.isEmpty() &amp;&amp; now - timestamps.peek() &gt; windowMillis) &#123;</span><br><span class="line">            timestamps.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timestamps.size() &lt; maxRequests) &#123;</span><br><span class="line">            timestamps.add(now);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="漏桶算法（平滑流量）"><a href="#漏桶算法（平滑流量）" class="headerlink" title="漏桶算法（平滑流量）"></a>漏桶算法（平滑流量）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeakyBucketLimiter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">water</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> lastLeakTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> leakRateMillis; <span class="comment">// 漏出间隔（毫秒/请求）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LeakyBucketLimiter</span><span class="params">(<span class="type">int</span> capacity, <span class="type">long</span> leakRateMillis)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.leakRateMillis = leakRateMillis;</span><br><span class="line">        <span class="built_in">this</span>.lastLeakTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">allow</span><span class="params">()</span> &#123;</span><br><span class="line">        leakWater();</span><br><span class="line">        <span class="keyword">if</span> (water &lt; capacity) &#123;</span><br><span class="line">            water++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">leakWater</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">elapsed</span> <span class="operator">=</span> now - lastLeakTime;</span><br><span class="line">        <span class="type">long</span> <span class="variable">leaks</span> <span class="operator">=</span> elapsed / leakRateMillis;</span><br><span class="line">        <span class="keyword">if</span> (leaks &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            water = Math.max(<span class="number">0</span>, water - leaks);</span><br><span class="line">            lastLeakTime = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="令牌桶算法（允许突发流量）"><a href="#令牌桶算法（允许突发流量）" class="headerlink" title="令牌桶算法（允许突发流量）"></a>令牌桶算法（允许突发流量）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenBucketLimiter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> tokens;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> lastRefillTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> refillRate; <span class="comment">// 令牌/毫秒</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TokenBucketLimiter</span><span class="params">(<span class="type">long</span> capacity, <span class="type">double</span> refillPerSecond)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.refillRate = refillPerSecond / <span class="number">1000.0</span>;</span><br><span class="line">        <span class="built_in">this</span>.tokens = capacity;</span><br><span class="line">        <span class="built_in">this</span>.lastRefillTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">allow</span><span class="params">()</span> &#123;</span><br><span class="line">        refillTokens();</span><br><span class="line">        <span class="keyword">if</span> (tokens &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            tokens--;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">refillTokens</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">double</span> <span class="variable">elapsed</span> <span class="operator">=</span> now - lastRefillTime;</span><br><span class="line">        tokens = Math.min(capacity, tokens + elapsed * refillRate);</span><br><span class="line">        lastRefillTime = now;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h3 id="业界限流工具"><a href="#业界限流工具" class="headerlink" title="业界限流工具"></a>业界限流工具</h3><h4 id="单机限流"><a href="#单机限流" class="headerlink" title="单机限流"></a>单机限流</h4><ul><li><p><strong>Guava RateLimiter</strong></p><ul><li>基于令牌桶，支持预热模式。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RateLimiter</span> <span class="variable">limiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">10.0</span>); <span class="comment">// 每秒10个请求</span></span><br><span class="line"><span class="keyword">if</span> (limiter.tryAcquire()) &#123;</span><br><span class="line">    <span class="comment">// 执行业务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h4><ul><li><p><strong>Redis Cell</strong></p><ul><li>通过 <code>CL.THROTTLE</code> 命令实现漏桶算法。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CL.THROTTLE user123 15 30 60 1</span><br><span class="line"><span class="comment"># 含义：15容量，30秒内60个请求，1次请求</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Sentinel</strong>（阿里开源）</p><ul><li>支持QPS&#x2F;线程数限流、系统自适应保护、实时监控。</li><li>集成Dubbo&#x2F;Spring Cloud&#x2F;Gateway。</li></ul></li><li><p><strong>Resilience4j</strong></p><ul><li>轻量级容错库，提供限流、熔断等功能。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RateLimiter</span> <span class="variable">limiter</span> <span class="operator">=</span> RateLimiter.of(<span class="string">&quot;serviceA&quot;</span>, RateLimiterConfig.custom()</span><br><span class="line">    .limitForPeriod(<span class="number">100</span>)</span><br><span class="line">    .limitRefreshPeriod(Duration.ofSeconds(<span class="number">1</span>))</span><br><span class="line">    .build());</span><br></pre></td></tr></table></figure></li></ul><h4 id="网关层限流"><a href="#网关层限流" class="headerlink" title="网关层限流"></a>网关层限流</h4><ul><li><p><strong>Spring Cloud Gateway</strong></p><ul><li>内置RedisRateLimiter。</li></ul></li><li><p><strong>Nginx</strong></p><ul><li><p>通过 <code>limit_req_zone</code> 实现漏桶算法：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">limit_req_zone</span> <span class="variable">$binary_remote_addr</span> zone=api:<span class="number">10m</span> rate=10r/s;</span><br><span class="line"><span class="section">location</span> /api &#123;</span><br><span class="line">    <span class="attribute">limit_req</span> zone=api burst=<span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>选型建议</strong></p><table><thead><tr><th align="left">场景</th><th align="left">推荐方案</th></tr></thead><tbody><tr><td align="left">单机限流</td><td align="left">Guava RateLimiter</td></tr><tr><td align="left">分布式服务限流</td><td align="left">Sentinel &#x2F; Resilience4j</td></tr><tr><td align="left">API网关层限流</td><td align="left">Nginx &#x2F; Spring Cloud Gateway</td></tr><tr><td align="left">高精度分布式限流</td><td align="left">Redis + Lua</td></tr></tbody></table><h2 id="降级-熔断"><a href="#降级-熔断" class="headerlink" title="降级&amp;熔断"></a>降级&amp;熔断</h2><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDD </tag>
            
            <tag> 限流 </tag>
            
            <tag> 降级 </tag>
            
            <tag> 熔断 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习&amp;面试-分布式</title>
      <link href="/post/9787b587.html"/>
      <url>/post/9787b587.html</url>
      
        <content type="html"><![CDATA[<h2 id="基本理论"><a href="#基本理论" class="headerlink" title="基本理论"></a>基本理论</h2><ul><li><strong>核心概念:</strong> CAP 定理、BASE 理论、一致性协议（Raft, Paxos 了解）、分布式事务（2PC, 3PC, TCC, Saga, 本地消息表、Seata）、服务发现、负载均衡、熔断降级、限流。</li><li><strong>服务治理:</strong><ul><li><strong>Spring Cloud Alibaba&#x2F;Netflix:</strong> 深入理解 Nacos&#x2F;Eureka（服务发现、配置中心）、Ribbon&#x2F;LoadBalancer（负载均衡）、Feign&#x2F;OpenFeign（声明式调用）、Hystrix&#x2F;Sentinel（熔断限流）、Gateway&#x2F;Zuul（API 网关）、Sleuth&#x2F;Zipkin（链路追踪）的原理、配置和最佳实践。</li></ul></li><li><strong>RPC 框架:</strong> 理解 Dubbo 或 gRPC 的核心原理（服务暴露与引用、集群容错、负载均衡、网络通信协议、序列化）。</li></ul><h3 id="什么是CAP"><a href="#什么是CAP" class="headerlink" title="什么是CAP"></a>什么是CAP</h3><p>CAP定理是分布式系统设计中的一个核心原则，由计算机科学家Eric Brewer在2000年提出，后于2002年被证明。它指出，在存在<strong>网络分区（Partition Tolerance）</strong>的情况下，分布式系统无法同时满足以下三个特性：</p><ol><li><strong>一致性（Consistency）</strong><br>所有节点在同一时刻看到的数据完全相同。写入操作后，所有读取请求都会立即获得最新数据，不会出现数据不一致的情况。</li><li><strong>可用性（Availability）</strong><br>每个请求（无论读写）都能在合理时间内获得非错误响应，但不保证返回的数据是最新版本。即使部分节点故障，系统仍能正常响应。</li><li><strong>分区容忍性（Partition Tolerance）</strong><br>系统在网络分区（节点间通信中断，形成孤岛）时仍能继续运行。网络分区是分布式系统的客观现实，因此这一特性通常被视为必须支持的基础。</li></ol><img src="/post/9787b587/image-20250505093121422-6167231.png" class="" title="image-20250505093121422"><h3 id="什么是BASE"><a href="#什么是BASE" class="headerlink" title="什么是BASE"></a>什么是BASE</h3><p>BASE 是基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语的缩写。</p><p>BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p><p><strong>基本可用</strong></p><p>指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。</p><p>例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。</p><p><strong>软状态</strong></p><p>指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在时延。</p><p><strong>最终一致性</strong></p><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。</p><p>ACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。</p><p>在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用。</p><h3 id="什么是分布式事务"><a href="#什么是分布式事务" class="headerlink" title="什么是分布式事务"></a>什么是分布式事务</h3><p>分布式事务是指<strong>涉及多个独立服务或数据库资源的一个操作单元</strong>，这些服务或资源通常分布在网络的不同节点上。其核心目标是保证整个操作要么在所有参与的节点上<strong>全部成功提交</strong>，要么在发生任何失败时<strong>全部回滚</strong>，以维护数据的<strong>ACID特性</strong>（原子性、一致性、隔离性、持久性），尤其是在跨系统边界和网络不可靠的环境下。</p><p><strong>为什么需要分布式事务？</strong></p><p>随着系统架构从单体应用向微服务、分布式数据库演进：</p><ol><li><strong>数据&#x2F;服务拆分：</strong> 业务逻辑涉及多个独立的数据库或服务。</li><li><strong>跨系统调用：</strong> 完成一个业务目标需要调用多个不同的服务。</li><li><strong>原子性挑战：</strong> 在单个数据库内，事务由数据库引擎保证。但当操作跨越多个独立资源（服务&#x2F;数据库）时，需要额外的机制来协调它们，确保整体原子性。</li></ol><p><strong>实现分布式事务的主要模式与技术：</strong></p><p>没有一种“银弹”方案适用于所有场景，选择取决于业务需求（如对强一致性的要求、性能容忍度、复杂度）和系统架构。主要模式包括：</p><ol><li><strong>两阶段提交：</strong><ul><li><strong>原理：</strong> 引入一个独立的<strong>协调者</strong>来管理事务的提交过程，分为两个阶段：<ul><li><strong>准备阶段：</strong> 协调者询问所有参与者是否可以提交事务。参与者执行事务操作（锁定资源、写Redo&#x2F;Undo日志），但<strong>不实际提交</strong>，然后向协调者投票（“同意”或“中止”）。</li><li><strong>提交&#x2F;回滚阶段：</strong><ul><li>如果所有参与者都投票“同意”，协调者发送<strong>提交</strong>指令给所有参与者。参与者收到后<strong>正式提交</strong>事务并释放资源，然后向协调者发送“完成”确认。</li><li>如果<strong>任何一个</strong>参与者投票“中止”，或者协调者在等待投票时超时，协调者发送<strong>回滚</strong>指令给所有参与者。参与者收到后利用Undo日志<strong>回滚</strong>事务并释放资源。</li></ul></li></ul></li><li><strong>优点：</strong> 理论上提供强一致性（ACID），实现相对标准（如XA协议）。</li><li><strong>缺点：</strong><ul><li><strong>性能瓶颈：</strong> 同步阻塞（参与者在准备阶段锁定资源直到收到第二阶段指令）、多轮网络通信。</li><li><strong>协调者单点故障：</strong> 如果协调者崩溃，参与者可能一直持有锁，阻塞其他操作。</li><li><strong>数据不一致风险（脑裂）：</strong> 在第二阶段，如果协调者发出提交指令后部分参与者崩溃或网络中断，可能导致部分提交、部分未提交的数据不一致状态（需要人工干预）。</li></ul></li><li><strong>适用场景：</strong> 对强一致性要求极高且性能要求不高、参与方较少的内部系统（如传统银行核心系统）。常用协议：<strong>XA</strong> (由数据库&#x2F;中间件实现，如Java JTA)。</li></ul></li><li><strong>补偿事务：</strong><ul><li><strong>原理：</strong> 放弃全局锁和强一致性，采用“事后补偿”的思路实现最终一致性。核心思想是为每个正向业务操作定义一个对应的、可逆的<strong>补偿操作</strong>。<ul><li>顺序执行各个服务调用（T1, T2, T3…）。</li><li>如果某个步骤（如Tn）失败，则<strong>按相反顺序</strong>执行前面所有已成功步骤的补偿操作（Cn-1, …, C1）。</li><li>补偿操作需要是幂等的（可重复执行无副作用）。</li></ul></li><li><strong>常见实现：</strong><ul><li><strong>TCC：</strong> 最典型的补偿模式。每个业务服务需要实现三个接口：<ul><li><strong>Try：</strong> 预留业务资源（冻结库存、扣减信用额度等）。完成所有检查，为最终操作做准备。</li><li><strong>Confirm：</strong> 真正提交业务（确认扣款、确认库存）。Try成功才会执行，通常必须成功。</li><li><strong>Cancel：</strong> 补偿操作（释放冻结的库存、恢复信用额度）。Try成功后，如果整体事务需要回滚，则执行Cancel。</li></ul></li><li><strong>Saga：</strong><ul><li><strong>协调方式：</strong><ul><li><em>编排：</em> 没有中心协调者，每个服务执行后发布事件，下一个服务监听事件并执行自己的操作或补偿操作。</li><li><em>编排：</em> 一个中心协调器负责按顺序调用服务，并在失败时触发补偿流程。</li></ul></li><li><strong>执行模式：</strong><ul><li><em>向前恢复：</em> 某个步骤失败，则重试该步骤（适用于可重试的临时错误）。</li><li><em>向后恢复：</em> 某个步骤失败，则触发补偿流程。</li></ul></li></ul></li></ul></li><li><strong>优点：</strong><ul><li>避免了全局锁，性能较高，吞吐量好。</li><li>服务设计更松耦合。</li><li>适用于长事务。</li></ul></li><li><strong>缺点：</strong><ul><li>实现复杂：每个服务都需要设计Try&#x2F;Confirm&#x2F;Cancel接口（TCC）或补偿逻辑（Saga）。</li><li>最终一致性：存在中间状态（如库存冻结但未扣减），业务需要容忍短暂不一致。</li><li>补偿操作的设计和实现挑战：需要保证幂等性、可重试；补偿可能失败，需要重试策略。</li></ul></li><li><strong>适用场景：</strong> 高并发、性能要求高、业务上可以接受短暂最终一致性的场景（电商下单、支付、订单管理等）。TCC适用于金融等对隔离性要求稍高的场景，Saga更通用。</li></ul></li><li><strong>基于可靠消息的最终一致性：</strong><ul><li><strong>原理：</strong> 利用<strong>消息队列</strong>的可靠投递特性来解耦服务和保证最终一致性。<ul><li>事务发起方（服务A）在本地事务中执行操作，并<strong>同时</strong>向消息队列发送一条“待确认”的消息（记录操作状态）。这需要本地数据库和消息队列支持<strong>本地消息表</strong>或<strong>事务性发件箱</strong>模式。</li><li>本地事务提交成功后，由一个独立的<strong>消息转发器</strong>将“待确认”消息可靠地发送到消息队列。</li><li>消息队列将消息投递给消费者（服务B）。</li><li>服务B执行本地操作。</li><li>服务B操作成功后，向消息队列发送ACK确认消费成功。如果失败或超时，消息队列会重投。</li><li>（可选）服务B执行成功后，可以再发送消息驱动后续操作。</li></ul></li><li><strong>关键机制：</strong><ul><li><strong>本地消息表&#x2F;事务发件箱：</strong> 保证服务A本地事务执行和消息记录存储的原子性。</li><li><strong>消息队列的持久化与重试：</strong> 保证消息至少被投递一次。</li><li><strong>消费者幂等性：</strong> 服务B的操作必须是幂等的，以应对消息可能重复投递的情况。</li></ul></li><li><strong>优点：</strong><ul><li>系统解耦，容错性好。</li><li>性能较好。</li><li>实现相对简单（利用成熟的消息中间件）。</li></ul></li><li><strong>缺点：</strong><ul><li><strong>最终一致性：</strong> 存在延迟，A成功到B成功之间数据不一致。</li><li><strong>消息积压风险：</strong> 如果B处理能力不足。</li><li><strong>依赖消息队列的可靠性。</strong></li><li><strong>要求消费者幂等。</strong></li></ul></li><li><strong>适用场景：</strong> 异步处理、事件驱动架构、对实时一致性要求不高的场景（如用户注册后发送欢迎邮件、积分增减、状态更新通知等）。</li></ul></li></ol><p><strong>如何选择？</strong></p><ul><li><strong>强一致性要求极高，性能要求不高，参与方少且可控：</strong> 考虑 <strong>2PC&#x2F;XA</strong> (但要非常清楚其代价和风险)。</li><li><strong>高并发、性能要求高、可接受最终一致性、业务逻辑可补偿：</strong> <strong>TCC</strong> 或 <strong>Saga</strong> 是主流选择。TCC隔离性更好但实现更重，Saga更灵活。</li><li><strong>异步解耦、对延迟容忍度高、需要高可用：</strong> <strong>基于可靠消息的最终一致性</strong> 是最常用、最推荐的方式之一，实现相对简单可靠。</li><li><strong>长业务流程、事件驱动：</strong> <strong>Saga</strong> (尤其是Choreography模式) 或 <strong>基于事件+可靠消息</strong>。</li></ul><p><strong>总结：</strong></p><p>分布式事务的核心挑战是在网络分区和节点故障的情况下保证数据一致性。没有完美的解决方案，都是在<strong>一致性(C)、可用性(A)、分区容忍性(P)<strong>（CAP定理）和</strong>性能、复杂度</strong>之间进行权衡。现代分布式系统设计中，<strong>基于可靠消息的最终一致性</strong>和<strong>补偿事务(TCC&#x2F;Saga)</strong> 因其更好的扩展性和可用性，比传统的2PC使用得更广泛。理解业务需求（对一致性和延迟的容忍度）是选择合适方案的关键。</p><ol><li>分布式ID生成方案（雪花算法优化）</li><li>一致性Hash算法虚拟节点设计</li><li>分布式锁的三种实现方式对比</li><li>分布式Session解决方案</li><li>如何实现最终一致性（消息表+重试）</li><li>分库分表后分页查询方案</li><li>分布式事务最大努力通知型实现</li><li>数据同步方案（canal+MQ）</li><li>高并发下单系统设计（库存扣减）</li><li>分布式缓存更新策略（Cache Aside）</li><li>分布式系统时钟同步问题</li><li>脑裂问题解决方案</li></ol><h2 id="一致性协议"><a href="#一致性协议" class="headerlink" title="一致性协议"></a>一致性协议</h2><h3 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h3><h3 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h3><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h2 id="分布式ID生成"><a href="#分布式ID生成" class="headerlink" title="分布式ID生成"></a>分布式ID生成</h2><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习&amp;面试-开发框架</title>
      <link href="/post/18f2748c.html"/>
      <url>/post/18f2748c.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><ul><li><strong>IoC&#x2F;DI:</strong> 深入理解其实现原理（反射、工厂模式）、Bean 生命周期、作用域、循环依赖解决机制（三级缓存）、AOP 底层（动态代理 - JDK vs CGLIB）、事务管理原理（传播行为、隔离级别、实现机制）。</li><li><strong>Spring MVC:</strong> 深入理解请求处理流程（DispatcherServlet, HandlerMapping, HandlerAdapter, ViewResolver）、常用注解原理、RESTful 设计最佳实践。</li><li><strong>Spring Boot:</strong> 自动配置原理（<code>spring.factories</code>, <code>@Conditional</code>）、启动过程、外部化配置、Actuator 深度使用与定制。</li><li><strong>Spring Data:</strong> JPA&#x2F;Hibernate 原理（一级&#x2F;二级缓存、脏检查、延迟加载、N+1问题）、Spring Data JPA 抽象与实现。MyBatis 核心原理（SqlSession, Mapper 代理、插件机制）。</li><li><strong>Spring Security&#x2F;OAuth2:</strong> 认证授权流程、过滤器链、RBAC&#x2F;ABAC、OAuth2 授权模式、JWT 深度应用与安全考量。</li><li><strong>源码阅读:</strong> 这是进阶的关键！选择常用模块（如 <code>BeanFactory</code>, <code>AOP</code>, <code>Transaction</code>）阅读源码，理解设计模式的应用和核心实现逻辑。📚</li></ul><h2 id="循环依赖解决原理"><a href="#循环依赖解决原理" class="headerlink" title="循环依赖解决原理"></a>循环依赖解决原理</h2><h2 id="FactoryBean-的作用与应用"><a href="#FactoryBean-的作用与应用" class="headerlink" title="FactoryBean 的作用与应用"></a><code>FactoryBean</code> 的作用与应用</h2><p><code>FactoryBean</code> 是 Spring 框架中用于 <strong>封装复杂对象创建逻辑</strong> 的特殊接口，其核心作用如下：</p><ul><li><strong>隐藏复杂构造过程</strong>：将初始化繁琐的对象（如第三方库组件）的创建细节封装在 <code>FactoryBean</code> 中。</li><li><strong>动态决定对象类型</strong>：根据条件返回不同类型的 Bean 实例。</li><li><strong>延迟初始化</strong>：控制对象的创建时机，实现按需加载。</li><li><strong>统一管理依赖</strong>：集中处理对象创建时的依赖注入及配置。</li></ul><p>实现 <code>FactoryBean</code> 接口需重写以下方法：</p><table><thead><tr><th align="left">方法名</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left"><code>T getObject()</code></td><td align="left">返回由 <code>FactoryBean</code> 创建的实际对象实例。</td></tr><tr><td align="left"><code>Class&lt;?&gt; getObjectType()</code></td><td align="left">返回创建的对象类型，用于 Spring 容器类型检查。</td></tr><tr><td align="left"><code>boolean isSingleton()</code></td><td align="left">决定对象是否为单例。默认 <code>true</code>，若返回 <code>false</code> 则每次请求创建新实例。</td></tr></tbody></table><p><strong>应用示例：自定义加密工具 FactoryBean</strong><br>假设需创建一个根据配置动态选择加密算法的工具类，步骤如下：</p><p><strong>1：定义加密接口及实现类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EncryptionTool</span> &#123;</span><br><span class="line">    String <span class="title function_">encrypt</span><span class="params">(String text)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AES 加密实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AesEncryptionTool</span> <span class="keyword">implements</span> <span class="title class_">EncryptionTool</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encrypt</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;AES加密后的数据: &quot;</span> + text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RSA 加密实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RsaEncryptionTool</span> <span class="keyword">implements</span> <span class="title class_">EncryptionTool</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encrypt</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;RSA加密后的数据: &quot;</span> + text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2：实现 EncryptionToolFactoryBean</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.FactoryBean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EncryptionToolFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;EncryptionTool&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> String algorithm; <span class="comment">// 配置属性，决定加密算法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置算法类型（通过Spring属性注入）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAlgorithm</span><span class="params">(String algorithm)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.algorithm = algorithm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> EncryptionTool <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;AES&quot;</span>.equalsIgnoreCase(algorithm)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AesEncryptionTool</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;RSA&quot;</span>.equalsIgnoreCase(algorithm)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RsaEncryptionTool</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;不支持的加密算法: &quot;</span> + algorithm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> EncryptionTool.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 单例模式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3：配置 Spring Bean</strong></p><p>xml配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- XML 配置方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;encryptionTool&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.EncryptionToolFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;algorithm&quot;</span> <span class="attr">value</span>=<span class="string">&quot;AES&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Java 配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FactoryBean&lt;EncryptionTool&gt; <span class="title function_">encryptionTool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">EncryptionToolFactoryBean</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EncryptionToolFactoryBean</span>();</span><br><span class="line">        factory.setAlgorithm(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4：在业务类中注入使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EncryptionTool encryptionTool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">encrypted</span> <span class="operator">=</span> encryptionTool.encrypt(password);</span><br><span class="line">        System.out.println(<span class="string">&quot;加密后的密码: &quot;</span> + encrypted);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若需直接获取 <code>FactoryBean</code> 而非其创建的对象，可在 Bean 名称前加 <code>&amp;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FactoryBean&lt;?&gt; factory = context.getBean(<span class="string">&quot;&amp;encryptionTool&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="Bean生命周期扩展点实战"><a href="#Bean生命周期扩展点实战" class="headerlink" title="Bean生命周期扩展点实战"></a>Bean生命周期扩展点实战</h2><p>Spring Bean 生命周期的核心阶段和扩展点顺序：</p><ol><li><strong>实例化</strong>（调用构造函数）</li><li><strong>属性赋值</strong>（依赖注入）</li><li><strong>BeanPostProcessor 前置处理</strong>（<code>postProcessBeforeInitialization</code>）</li><li><strong>初始化方法</strong>（<code>@PostConstruct</code> → <code>InitializingBean</code> → <code>init-method</code>）</li><li><strong>BeanPostProcessor 后置处理</strong>（<code>postProcessAfterInitialization</code>）</li><li><strong>Bean 就绪，进入运行期</strong></li><li><strong>销毁方法</strong>（<code>@PreDestroy</code> → <code>DisposableBean</code> → <code>destroy-method</code>）</li></ol><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-942a927a-86e4-4a01-8f52-9addd89642ff.png" alt="三分恶面渣逆袭：Spring Bean生命周期"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化bean</span></span><br><span class="line">    <span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许后置处理器修改bean定义</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴露早期引用，解决循环引用问题</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">            isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                    <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化bean</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 填充属性</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">                    mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean as disposable.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringBoot自动配置原理"><a href="#SpringBoot自动配置原理" class="headerlink" title="SpringBoot自动配置原理"></a>SpringBoot自动配置原理</h2><p>Spring Boot的自动配置是其核心特性之一，旨在简化应用的配置过程。以下是其实现机制的详细步骤解析：</p><p><strong><code>@SpringBootApplication</code> 注解：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>@EnableAutoConfiguration</code>注解：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>META-INF/spring.factories</code>或<code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>获取配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoConfigurationImportSelector</span> <span class="keyword">implements</span> <span class="title class_">DeferredImportSelector</span>, BeanClassLoaderAware,</span><br><span class="line">ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered &#123;</span><br><span class="line">            <span class="keyword">protected</span> List&lt;String&gt; <span class="title function_">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> &#123;</span><br><span class="line">List&lt;String&gt; configurations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(</span><br><span class="line">SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()));</span><br><span class="line">ImportCandidates.load(AutoConfiguration.class, getBeanClassLoader()).forEach(configurations::add);</span><br><span class="line">Assert.notEmpty(configurations,</span><br><span class="line"><span class="string">&quot;No auto configuration classes found in META-INF/spring.factories nor in META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports. If you &quot;</span></span><br><span class="line">+ <span class="string">&quot;are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述机制找到的候选类都是标有 <code>@Configuration</code> 注解的 Spring 配置类。</p><p>这些配置类内部使用 <code>@Bean</code> 注解定义了大量<strong>条件化</strong>的 Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;DataSource.class, EmbeddedDatabaseType.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(DataSourceProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">(DataSourceProperties properties)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> properties.initializeDataSourceBuilder().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>@EnableConfigurationProperties</code>将配置属性类（如<code>DataSourceProperties</code>）与配置文件（如<code>application.yml</code>）绑定，允许通过属性动态配置Bean。</p><p><strong>application.yml示例</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mydb</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">secret</span></span><br></pre></td></tr></table></figure><p><strong>总结流程：</strong></p><ol><li>启动 <code>main</code> 方法，加载标注了 <code>@SpringBootApplication</code> 的主类。</li><li><code>@SpringBootApplication</code> 中的 <code>@EnableAutoConfiguration</code> 激活自动装配。</li><li><code>@EnableAutoConfiguration</code> 通过 <code>@Import</code> 引入 <code>AutoConfigurationImportSelector</code>。</li><li><code>AutoConfigurationImportSelector</code> 在适当的时候执行：<ul><li>读取 <code>spring-autoconfigure-metadata.properties</code> 进行<strong>快速过滤</strong>。</li><li>读取 <code>META-INF/spring.factories</code> 或 <code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code> 文件，获取<strong>所有候选自动配置类</strong>的全名列表。</li><li><strong>应用自动配置元数据过滤器</strong>，剔除明显不满足条件的候选类。</li></ul></li><li>遍历剩下的候选自动配置类：<ul><li>使用反射加载类。</li><li><strong>详细评估类上的 <code>@Conditional</code> 及其衍生注解</strong>。</li><li>如果类级别的条件满足，则将该配置类作为一个 <code>@Configuration</code> 类处理。</li><li>处理配置类内部的 <code>@Bean</code> 方法，同样评估方法上的条件注解，满足条件的才注册为 Bean。</li></ul></li><li>最终，所有满足条件的自动配置类中定义的 Bean 被注册到 Spring IoC 容器中，应用就拥有了所需的基础设施 Bean。</li></ol><h2 id="自定义Starter开发要点"><a href="#自定义Starter开发要点" class="headerlink" title="自定义Starter开发要点"></a>自定义Starter开发要点</h2><p><strong>1. Starter 的核心组成</strong></p><p>一个完整的 Starter 包含两个模块（可合并）：</p><ol><li><strong><code>xxx-spring-boot-starter</code></strong><br>空模块，仅声明依赖（如自动配置模块和其他必要依赖），供用户直接引入。</li><li><strong><code>xxx-spring-boot-autoconfigure</code></strong><br>核心实现模块，包含自动配置类、条件注解、配置属性绑定等。</li></ol><p><strong>2. 开发步骤与关键代码</strong></p><p><strong>创建项目结构</strong></p><p>使用 Maven 或 Gradle 创建模块，建议结构：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">my-starter/</span><br><span class="line">  ├── my-starter-spring-boot-autoconfigure/  # 自动配置模块</span><br><span class="line">  │   ├── src/main/java</span><br><span class="line">  │   │   └── com/example/autoconfigure</span><br><span class="line">  │   │       ├── MyServiceAutoConfiguration.java  # 自动配置类</span><br><span class="line">  │   │       └── MyServiceProperties.java         # 配置属性类</span><br><span class="line">  │   └── src/main/resources/META-INF</span><br><span class="line">  │       ├── spring.factories                    # 自动配置注册</span><br><span class="line">  │       └── additional-spring-configuration-metadata.json  # 配置提示（可选）</span><br><span class="line">  │</span><br><span class="line">  └── my-starter-spring-boot-starter/         # Starter 入口模块</span><br><span class="line">      └── pom.xml                             # 仅依赖自动配置模块</span><br></pre></td></tr></table></figure><p><strong>编写自动配置类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(MyServiceProperties.class)</span>  <span class="comment">// 启用配置属性绑定</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(MyService.class)</span>  <span class="comment">// 类路径存在 MyService 时生效</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServiceAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>  <span class="comment">// 用户未自定义时注册 Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyService <span class="title function_">myService</span><span class="params">(MyServiceProperties properties)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyService</span>(properties.getUrl(), properties.getTimeout());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义配置属性类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;my.service&quot;)</span>  <span class="comment">// 配置前缀</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServiceProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://default-url&quot;</span>;  <span class="comment">// 默认值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">timeout</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter 和 Setter 必须提供</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUrl</span><span class="params">()</span> &#123; <span class="keyword">return</span> url; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUrl</span><span class="params">(String url)</span> &#123; <span class="built_in">this</span>.url = url; &#125;</span><br><span class="line">    <span class="comment">// ... 其他属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注册自动配置类</strong></p><p>在 <code>resources/META-INF/spring.factories</code> 中声明：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">com.example.autoconfigure.MyServiceAutoConfiguration</span></span><br></pre></td></tr></table></figure><p><strong>配置提示（可选）</strong></p><p>在 <code>resources/META-INF/additional-spring-configuration-metadata.json</code> 中为配置项添加描述：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my.service.url&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java.lang.String&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;服务 URL 地址&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;defaultValue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://default-url&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my.service.timeout&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java.lang.Integer&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;请求超时时间（毫秒）&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;defaultValue&quot;</span><span class="punctuation">:</span> <span class="number">5000</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>打包并发布</strong></p><ul><li><strong>Maven</strong>：通过 <code>mvn clean install</code> 安装到本地仓库，或部署到 Nexus 私服。</li><li><strong>Gradle</strong>：使用 <code>publishToMavenLocal</code> 或配置发布任务。</li></ul><p><strong>3. 使用自定义 Starter</strong></p><p>用户引入依赖后，可直接通过配置文件（如 <code>application.yml</code>）配置参数：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">my:</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://custom-url</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure><p><strong>4. 最佳实践</strong></p><ul><li><strong>模块化设计</strong>：将自动配置与 Starter 分离，方便其他模块复用。</li><li><strong>防御性编程</strong>：在自动配置类中检查依赖是否存在（如通过 <code>@ConditionalOnClass</code>）。</li><li><strong>默认配置合理</strong>：提供安全、通用的默认值，减少用户配置负担。</li></ul><h2 id="统一异常处理的最佳实践"><a href="#统一异常处理的最佳实践" class="headerlink" title="统一异常处理的最佳实践"></a>统一异常处理的最佳实践</h2><p>以下是 <strong>Spring Boot 统一异常处理的最佳实践</strong>，涵盖异常分类、全局处理、日志记录、错误响应规范等关键环节，帮助开发者构建健壮且易维护的应用程序：</p><p><strong>核心原则</strong></p><ol><li><strong>统一入口</strong>：所有异常由全局处理器捕获，避免分散在各处。</li><li><strong>友好响应</strong>：前端接收结构化错误信息（如JSON），包含错误码、提示消息等。</li><li><strong>分类处理</strong>：区分业务异常、系统异常、参数校验异常等，针对性处理。</li><li><strong>安全日志</strong>：敏感信息脱敏，异常日志详细记录，但避免暴露给客户端。</li></ol><p><strong>实现步骤与代码示例</strong></p><ol><li><strong>定义统一响应格式</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;    <span class="comment">// 状态码（如200成功，500系统错误）</span></span><br><span class="line">    <span class="keyword">private</span> String msg;  <span class="comment">// 提示信息（用户友好）</span></span><br><span class="line">    <span class="keyword">private</span> T data;      <span class="comment">// 响应数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功响应</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">success</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;(<span class="number">200</span>, <span class="string">&quot;操作成功&quot;</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 失败响应</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">error</span><span class="params">(<span class="type">int</span> code, String msg)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;(code, msg, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法、Getter/Setter省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>创建全局异常处理器</strong></li></ol><p>使用 <code>@ControllerAdvice</code> + <code>@ExceptionHandler</code> 捕获全局异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理业务异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(BusinessException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Void&gt; <span class="title function_">handleBusinessException</span><span class="params">(BusinessException e)</span> &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;业务异常: &#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> Result.error(e.getCode(), e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理参数校验异常（JSR-303）</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Void&gt; <span class="title function_">handleValidationException</span><span class="params">(MethodArgumentNotValidException e)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> e.getBindingResult().getFieldErrors().stream()</span><br><span class="line">                .map(fieldError -&gt; fieldError.getField() + <span class="string">&quot;: &quot;</span> + fieldError.getDefaultMessage())</span><br><span class="line">                .collect(Collectors.joining(<span class="string">&quot;; &quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="number">400</span>, <span class="string">&quot;参数校验失败: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理其他未捕获异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Void&gt; <span class="title function_">handleException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;系统异常: &quot;</span>, e);  <span class="comment">// 记录完整堆栈</span></span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="number">500</span>, <span class="string">&quot;系统繁忙，请稍后再试&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>自定义业务异常</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BusinessException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BusinessException</span><span class="params">(<span class="type">int</span> code, String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快速创建常用异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BusinessException <span class="title function_">of</span><span class="params">(<span class="type">int</span> code, String msg)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(code, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123; <span class="keyword">return</span> code; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>参数校验规范化</strong></li></ol><p>在 DTO 中使用校验注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDTO</span> &#123;</span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;用户名不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Email(message = &quot;邮箱格式不正确&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter/Setter省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>HTTP状态码与错误码映射</strong></li></ol><table><thead><tr><th align="left">异常类型</th><th align="left">HTTP状态码</th><th align="left">错误码</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>BusinessException</code></td><td align="left">200</td><td align="left">自定义</td><td align="left">业务逻辑错误（如订单状态异常）</td></tr><tr><td align="left"><code>MethodArgumentNotValid</code></td><td align="left">400</td><td align="left">400</td><td align="left">参数校验失败</td></tr><tr><td align="left"><code>AuthenticationException</code></td><td align="left">401</td><td align="left">401</td><td align="left">未登录或Token过期</td></tr><tr><td align="left"><code>AccessDeniedException</code></td><td align="left">403</td><td align="left">403</td><td align="left">无权限访问</td></tr><tr><td align="left"><code>其他未捕获异常</code></td><td align="left">500</td><td align="left">500</td><td align="left">系统内部错误</td></tr></tbody></table><p><strong>三、最佳实践</strong></p><ol><li><strong>异常分类分层处理</strong></li></ol><ul><li><strong>业务异常</strong>：由开发者主动抛出（如库存不足），明确提示用户。</li><li><strong>系统异常</strong>：数据库连接失败等，提示友好信息，记录详细日志。</li><li><strong>第三方服务异常</strong>：封装为特定异常（如 <code>ThirdPartyException</code>），避免污染核心逻辑。</li></ul><ol start="2"><li><strong>日志记录规范</strong></li></ol><ul><li><strong>业务异常</strong>：记录 <code>WARN</code> 级别，包含关键参数。</li><li><strong>系统异常</strong>：记录 <code>ERROR</code> 级别，输出完整堆栈。</li><li><strong>敏感信息脱敏</strong>：如身份证号、手机号在日志中掩码处理。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(PaymentException.class)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;Void&gt; <span class="title function_">handlePaymentException</span><span class="params">(PaymentException e)</span> &#123;</span><br><span class="line">    log.warn(<span class="string">&quot;支付失败, 订单号: &#123;&#125;, 原因: &#123;&#125;&quot;</span>, e.getOrderId(), e.getMessage());</span><br><span class="line">    <span class="keyword">return</span> Result.error(<span class="number">1001</span>, <span class="string">&quot;支付失败，请重试&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>错误码规范</strong></li></ol><ul><li><strong>模块划分</strong>：按模块定义错误码范围（如用户模块1000-1999）。</li><li><strong>文档维护</strong>：提供错误码对照表，方便前后端协作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误码常量类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ErrorCode</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">USER_NOT_FOUND</span> <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ORDER_EXPIRED</span> <span class="operator">=</span> <span class="number">2001</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>前端友好提示</strong></li></ol><ul><li><strong>用户可见消息</strong>：简洁明确，如“密码强度不足，至少包含大小写字母”。</li><li><strong>技术细节隔离</strong>：不返回Java异常类名、堆栈信息。</li></ul><ol start="5"><li><strong>测试覆盖</strong></li></ol><p>验证异常处理逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionHandlerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBusinessException</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        mockMvc.perform(get(<span class="string">&quot;/api/order/123&quot;</span>))</span><br><span class="line">               .andExpect(status().isOk())</span><br><span class="line">               .andExpect(jsonPath(<span class="string">&quot;$.code&quot;</span>).value(<span class="number">1001</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>四、常见问题与解决</strong></p><ol><li><strong>异常未被捕获</strong><ul><li>检查 <code>@ControllerAdvice</code> 是否在组件扫描路径内。</li><li>确认没有其他异常处理器冲突。</li></ul></li><li><strong>循环依赖导致处理器失效</strong><ul><li>确保全局处理器不依赖可能抛出异常的Bean。</li></ul></li><li><strong>异步线程异常丢失</strong><ul><li>使用 <code>AsyncUncaughtExceptionHandler</code> 处理异步任务异常。</li></ul></li></ol><p><strong>五、总结</strong></p><p>通过统一异常处理机制，可以实现：</p><ul><li><strong>代码简洁性</strong>：消除重复的 <code>try-catch</code> 块。</li><li><strong>维护便捷性</strong>：集中管理错误响应逻辑。</li><li><strong>接口规范性</strong>：前后端遵循统一的错误协议。</li><li><strong>系统健壮性</strong>：关键异常不漏处理，日志可追溯。</li></ul><h2 id="配置加载优先级（命令行-环境变量）"><a href="#配置加载优先级（命令行-环境变量）" class="headerlink" title="配置加载优先级（命令行&gt;环境变量）"></a>配置加载优先级（命令行&gt;环境变量）</h2><table><thead><tr><th align="left">优先级</th><th align="left">配置源</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><strong>1</strong></td><td align="left"><strong>命令行参数</strong></td><td align="left"><code>--server.port=8081</code></td></tr><tr><td align="left"><strong>2</strong></td><td align="left">Java 系统属性 (<code>-D</code>)</td><td align="left"><code>-Dspring.datasource.url=jdbc:mysql://...</code></td></tr><tr><td align="left"><strong>3</strong></td><td align="left"><strong>操作系统环境变量</strong></td><td align="left"><code>export SERVER_PORT=8081</code> (Linux)</td></tr><tr><td align="left"><strong>4</strong></td><td align="left">配置文件（如 <code>application.yml</code>）</td><td align="left"><code>server.port: 8080</code></td></tr></tbody></table><h2 id="过滤器、拦截器、AOP的区别"><a href="#过滤器、拦截器、AOP的区别" class="headerlink" title="过滤器、拦截器、AOP的区别"></a>过滤器、拦截器、AOP的区别</h2><table><thead><tr><th align="left"><strong>维度</strong></th><th align="left"><strong>过滤器（Filter）</strong></th><th align="left"><strong>拦截器（Interceptor）</strong></th><th align="left"><strong>AOP（Aspect）</strong></th></tr></thead><tbody><tr><td align="left"><strong>规范&#x2F;框架</strong></td><td align="left">Servlet 规范（Java EE）</td><td align="left">Spring MVC 框架</td><td align="left">Spring AOP &#x2F; AspectJ</td></tr><tr><td align="left"><strong>作用阶段</strong></td><td align="left">请求进入 Servlet 前&#x2F;响应返回客户端前</td><td align="left">Controller 方法执行前后</td><td align="left">任意 Bean 方法执行前后</td></tr><tr><td align="left"><strong>作用范围</strong></td><td align="left">所有 HTTP 请求（包括静态资源）</td><td align="left">Spring MVC 处理的请求（动态资源）</td><td align="left">Spring 管理的 Bean 方法</td></tr><tr><td align="left"><strong>依赖关系</strong></td><td align="left">依赖 Servlet 容器（Tomcat&#x2F;Jetty）</td><td align="left">依赖 Spring 容器</td><td align="left">依赖 Spring 容器</td></tr><tr><td align="left"><strong>典型场景</strong></td><td align="left">字符编码、跨域处理、请求日志</td><td align="left">权限校验、参数预处理、日志记录</td><td align="left">事务管理、性能监控、缓存控制</td></tr></tbody></table><p><strong>执行流程与顺序</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// HTTP 请求处理流程</span><br><span class="line">HTTP Request → Filter Chain → DispatcherServlet → Interceptor Chain → Controller → AOP Advice → Response</span><br></pre></td></tr></table></figure><ol><li><strong>过滤器（Filter）</strong>：最先执行，可拦截所有请求（如静态资源）。</li><li><strong>拦截器（Interceptor）</strong>：在 <code>DispatcherServlet</code> 之后、Controller 方法之前执行。</li><li><strong>AOP 切面（Aspect）</strong>：在 Controller 或 Service 方法执行前后触发。</li></ol><p><strong>实践场景与代码示例</strong></p><p><strong>场景 1：全局请求日志（跨所有请求）</strong></p><ul><li><p><strong>选择方案</strong>：<strong>过滤器（Filter）</strong><br><strong>原因</strong>：需记录所有请求（包括静态资源）的原始信息（如 IP、URL）。<br><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        chain.doFilter(req, res); <span class="comment">// 放行请求</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">cost</span> <span class="operator">=</span> System.currentTimeMillis() - start;</span><br><span class="line">        System.out.println(<span class="string">&quot;请求耗时: &quot;</span> + cost + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>场景 2：用户登录校验（仅动态请求）</strong></p><ul><li><p><strong>选择方案</strong>：<strong>拦截器（Interceptor）</strong><br><strong>原因</strong>：需访问 Spring 上下文（如获取用户 Session），且仅需拦截动态请求。<br><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest req, HttpServletResponse res, Object handler)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (req.getSession().getAttribute(<span class="string">&quot;user&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">            res.sendRedirect(<span class="string">&quot;/login&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 中断请求</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册拦截器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">AuthInterceptor</span>()).addPathPatterns(<span class="string">&quot;/api/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>场景 3：接口耗时统计</strong></p><ul><li><p><strong>选择方案</strong>：<strong>AOP（环绕通知）</strong><br><strong>原因</strong>：需统计任意方法的执行时间，灵活作用于 Service 层或 Controller 层。<br><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PerformanceAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">logTime</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行耗时: &quot;</span> + (System.currentTimeMillis() - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>如何选择？</strong></p><table><thead><tr><th align="left"><strong>技术</strong></th><th align="left"><strong>优先使用场景</strong></th></tr></thead><tbody><tr><td align="left"><strong>过滤器</strong></td><td align="left">处理原始请求&#x2F;响应（如跨域、压缩）、全局日志、安全过滤（XSS&#x2F;SQL 注入防御）</td></tr><tr><td align="left"><strong>拦截器</strong></td><td align="left">需要 Spring 上下文支持、动态请求拦截（如权限校验、参数预处理）</td></tr><tr><td align="left"><strong>AOP</strong></td><td align="left">与业务逻辑解耦的横切关注点（如事务、日志、缓存、性能监控）</td></tr></tbody></table><p><strong>最佳实践</strong></p><ol><li><strong>避免功能重叠</strong>：<ul><li>若过滤器与拦截器实现相似功能（如日志），选择更靠近请求入口的组件（过滤器）。</li></ul></li><li><strong>慎用 AOP 拦截 Controller</strong>：<ul><li>Controller 方法通常已由拦截器处理，AOP 更适合 Service 层。</li></ul></li><li><strong>性能优化</strong>：<ul><li>过滤器链和拦截器链较长时，可能影响吞吐量，需合理设计。</li></ul></li></ol><h2 id="MapperScan-的实现原理"><a href="#MapperScan-的实现原理" class="headerlink" title="@MapperScan 的实现原理"></a><code>@MapperScan</code> 的实现原理</h2><p><code>@MapperScan</code> 是 MyBatis-Spring 整合中的核心注解，用于自动扫描并注册 Mapper 接口为 Spring Bean。其实现原理基于 Spring 的扩展机制和 MyBatis 的动态代理，以下是详细步骤和核心逻辑：</p><p><strong>1. 注解定义与入口</strong></p><p><code>@MapperScan</code> 通过 <code>@Import</code> 引入 <code>MapperScannerRegistrar</code>，触发扫描和注册逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Import(MapperScannerRegistrar.class)</span> <span class="comment">// 关键：引入注册器</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MapperScan &#123;</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;; <span class="comment">// 扫描的包路径</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotationClass() <span class="keyword">default</span> Annotation.class;</span><br><span class="line">    <span class="comment">// 其他配置属性...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. MapperScannerRegistrar 注册 Bean 定义</strong></p><p><code>MapperScannerRegistrar</code> 实现 <code>ImportBeanDefinitionRegistrar</code> 接口，在 Spring 容器启动时动态注册 Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperScannerRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 解析 @MapperScan 注解的属性（如包路径）</span></span><br><span class="line">        <span class="type">AnnotationAttributes</span> <span class="variable">attrs</span> <span class="operator">=</span> AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(MapperScan.class.getName()));</span><br><span class="line">        <span class="comment">// 创建并配置 ClassPathMapperScanner</span></span><br><span class="line">        <span class="type">ClassPathMapperScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathMapperScanner</span>(registry);</span><br><span class="line">        scanner.scan(attrs.getStringArray(<span class="string">&quot;value&quot;</span>)); <span class="comment">// 执行扫描</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. ClassPathMapperScanner 扫描接口</strong></p><p><code>ClassPathMapperScanner</code> 继承自 Spring 的 <code>ClassPathBeanDefinitionScanner</code>，自定义扫描规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassPathMapperScanner</span> <span class="keyword">extends</span> <span class="title class_">ClassPathBeanDefinitionScanner</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">doScan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用父类扫描方法，筛选出符合条件的接口</span></span><br><span class="line">        Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="built_in">super</span>.doScan(basePackages);</span><br><span class="line">        <span class="comment">// 为每个接口生成 BeanDefinition，绑定到 MapperFactoryBean</span></span><br><span class="line">        <span class="keyword">for</span> (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class="line">            <span class="type">GenericBeanDefinition</span> <span class="variable">definition</span> <span class="operator">=</span> (GenericBeanDefinition) holder.getBeanDefinition();</span><br><span class="line">            <span class="comment">// 设置 Bean 的工厂类为 MapperFactoryBean</span></span><br><span class="line">            definition.getConstructorArgumentValues().addGenericArgumentValue(definition.getBeanClassName());</span><br><span class="line">            definition.setBeanClass(MapperFactoryBean.class); <span class="comment">// 关键：代理工厂</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isCandidateComponent</span><span class="params">(AnnotatedBeanDefinition beanDefinition)</span> &#123;</span><br><span class="line">        <span class="comment">// 仅选择接口作为候选组件（排除类）</span></span><br><span class="line">        <span class="keyword">return</span> beanDefinition.getMetadata().isInterface();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. MapperFactoryBean 创建代理对象</strong></p><p><code>MapperFactoryBean</code> 是 Spring 的 <code>FactoryBean</code> 实现，负责生成 Mapper 接口的代理实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperFactoryBean</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 通过 SqlSession 获取 Mapper 动态代理</span></span><br><span class="line">        <span class="keyword">return</span> getSqlSession().getMapper(<span class="built_in">this</span>.mapperInterface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;T&gt; <span class="title function_">getObjectType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.mapperInterface;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. 动态代理与 SQL 执行</strong></p><p>MyBatis 通过 <code>MapperProxy</code> 生成接口的 JDK 动态代理对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperProxy</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>, Serializable &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 将方法调用转换为 MappedStatement 执行</span></span><br><span class="line">        <span class="type">MapperMethod</span> <span class="variable">mapperMethod</span> <span class="operator">=</span> cachedMapperMethod(method);</span><br><span class="line">        <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6. 整合 Spring 容器</strong></p><ul><li><strong>SqlSessionTemplate 注入</strong>：<br>MyBatis-Spring 配置 <code>SqlSessionTemplate</code>（线程安全的 SqlSession 实现），由 Spring 管理数据库连接和事务。</li><li><strong>依赖关系</strong>：<br><code>MapperFactoryBean</code> 依赖 <code>SqlSessionTemplate</code>，确保所有 Mapper 代理使用同一事务上下文。</li></ul><p><strong>7. 自动配置与 Spring Boot 集成</strong></p><p>在 Spring Boot 中，<code>@MapperScan</code> 通常与自动配置类 <code>MyBatisAutoConfiguration</code> 配合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfiguration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; SqlSessionFactory.class, SqlSessionFactoryBean.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建 SqlSessionFactory</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结流程</strong></p><ol><li><strong>注解触发</strong>：<code>@MapperScan</code> 引入 <code>MapperScannerRegistrar</code>。</li><li><strong>动态注册</strong>：<code>MapperScannerRegistrar</code> 使用 <code>ClassPathMapperScanner</code> 扫描指定包下的接口。</li><li><strong>Bean 定义生成</strong>：为每个 Mapper 接口创建绑定到 <code>MapperFactoryBean</code> 的 Bean 定义。</li><li><strong>代理实例化</strong>：Spring 容器实例化时，<code>MapperFactoryBean</code> 通过 <code>SqlSessionTemplate</code> 创建动态代理对象。</li><li><strong>方法拦截</strong>：调用 Mapper 方法时，代理对象将请求转发给 MyBatis 执行 SQL。</li></ol><p><strong>关键设计点</strong></p><ul><li><strong>解耦与扩展</strong>：通过 Spring 的 <code>FactoryBean</code> 和 <code>ImportBeanDefinitionRegistrar</code> 实现无缝整合。</li><li><strong>性能优化</strong>：动态代理和缓存机制（如 <code>MapperMethod</code> 缓存）减少反射开销。</li><li><strong>事务一致性</strong>：依赖 Spring 管理的事务，确保 Mapper 操作在同一个 <code>SqlSession</code> 中执行。</li></ul><p>通过 <code>@MapperScan</code>，开发者无需手动配置每个 Mapper，框架自动完成接口到 Bean 的映射及代理生成，极大简化了 MyBatis 在 Spring 中的使用。</p><h2 id="Autowired-的实现原理"><a href="#Autowired-的实现原理" class="headerlink" title="@Autowired 的实现原理"></a><code>@Autowired</code> 的实现原理</h2><p><code>@Autowired</code> 是 Spring 框架中实现依赖注入的核心注解，其底层原理基于 <strong>Bean 生命周期管理</strong>、<strong>反射机制</strong> 和 <strong>BeanPostProcessor</strong> 的协作。以下是其实现原理的详细分析：</p><p><strong>1. 核心流程</strong></p><p><code>@Autowired</code> 的依赖注入发生在 Bean 的属性填充阶段，具体步骤如下：</p><p><strong>1.1 Bean 实例化</strong></p><p>Spring 容器通过反射调用构造函数创建 Bean 实例（若存在多个构造函数，优先选择无参构造函数，或标记 <code>@Autowired</code> 的构造函数）。</p><p><strong>1.2 属性填充（依赖注入）</strong></p><ul><li><strong>触发时机</strong>：在 <code>AbstractAutowireCapableBeanFactory</code> 的 <code>populateBean()</code> 方法中。</li><li><strong>处理组件</strong>：<code>AutowiredAnnotationBeanPostProcessor</code>（继承自 <code>BeanPostProcessor</code>）。</li></ul><p><strong>1.3 依赖解析与注入</strong></p><ol><li><strong>扫描注解</strong>：<br>通过反射检查 Bean 的字段、方法和构造函数上的 <code>@Autowired</code> 注解。</li><li><strong>解析依赖</strong>：<ul><li><strong>按类型匹配</strong>：查找与依赖类型匹配的候选 Bean。</li><li><strong>按名称匹配</strong>：若存在多个同类型 Bean，按字段&#x2F;方法参数名称匹配（需结合 <code>@Qualifier</code> 或 <code>@Primary</code> 解决歧义）。</li></ul></li><li><strong>注入依赖</strong>：<ul><li><strong>字段注入</strong>：通过反射 <code>Field.setAccessible(true)</code> 设置私有字段值。</li><li><strong>方法注入</strong>：反射调用 Setter 方法。</li><li><strong>构造函数注入</strong>：在实例化时通过构造函数参数注入。</li></ul></li></ol><p><strong>2. 关键组件解析</strong></p><p><strong>2.1 AutowiredAnnotationBeanPostProcessor</strong></p><p>Spring 内置的 <code>BeanPostProcessor</code>，负责处理 <code>@Autowired</code> 和 <code>@Value</code> 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutowiredAnnotationBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span>, MergedBeanDefinitionPostProcessor &#123;</span><br><span class="line">    <span class="comment">// 存储待注入的元数据（字段、方法）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InjectionMetadata metadata;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PropertyValues <span class="title function_">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> &#123;</span><br><span class="line">        <span class="comment">// 查找并注入依赖</span></span><br><span class="line">        <span class="type">InjectionMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> findAutowiringMetadata(bean.getClass());</span><br><span class="line">        metadata.inject(bean, beanName, pvs);</span><br><span class="line">        <span class="keyword">return</span> pvs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.2 依赖解析流程</strong></p><p>在 <code>DefaultListableBeanFactory</code> 中解析依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">resolveDependency</span><span class="params">(DependencyDescriptor descriptor, String beanName, Set&lt;String&gt; autowiredBeanNames, TypeConverter typeConverter)</span> &#123;</span><br><span class="line">    <span class="comment">// 按类型获取候选 Bean 名称</span></span><br><span class="line">    String[] candidateNames = findAutowireCandidates(beanName, type, descriptor);</span><br><span class="line">    <span class="comment">// 筛选唯一候选 Bean</span></span><br><span class="line">    <span class="keyword">if</span> (candidateNames.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> getBean(candidateNames[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (candidateNames.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 按名称或 @Primary/@Priority 解决冲突</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">primaryCandidate</span> <span class="operator">=</span> determinePrimaryCandidate(candidateNames);</span><br><span class="line">        <span class="keyword">return</span> primaryCandidate != <span class="literal">null</span> ? primaryCandidate : determineHighestPriorityCandidate(candidateNames);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 抛出 NoUniqueBeanDefinitionException 异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 注入方式与优先级</strong></p><p><strong>3.1 构造函数注入</strong></p><ul><li><p><strong>触发条件</strong>：若类中存在唯一构造函数，或构造函数标记了 <code>@Autowired</code>。</p></li><li><p><strong>优势</strong>：保证依赖不可变，符合不可变对象设计。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserRepository userRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>3.2 Setter 方法注入</strong></p><ul><li><p><strong>触发条件</strong>：Setter 方法标记 <code>@Autowired</code>。</p></li><li><p><strong>优势</strong>：允许可选依赖或动态更新依赖。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPaymentService</span><span class="params">(PaymentService paymentService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.paymentService = paymentService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>3.3 字段注入</strong></p><ul><li><p><strong>触发条件</strong>：字段直接标记 <code>@Autowired</code>。</p></li><li><p><strong>劣势</strong>：难以实现不可变性，测试时需通过反射注入。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> InventoryService inventoryService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>4. 解决依赖冲突</strong></p><p><strong>4.1 @Qualifier</strong></p><p>通过名称指定注入的 Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;mysqlDataSource&quot;)</span></span><br><span class="line"><span class="keyword">private</span> DataSource dataSource;</span><br></pre></td></tr></table></figure><p><strong>4.2 @Primary</strong></p><p>标记优先选择的 Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">primaryDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. 总结与最佳实践</strong></p><ul><li><strong>原理本质</strong>：<code>@Autowired</code> 通过 <code>BeanPostProcessor</code> 在 Bean 生命周期中动态解析并注入依赖。</li><li><strong>推荐方式</strong>：优先使用 <strong>构造函数注入</strong> 保证依赖不可变。</li><li><strong>避免陷阱</strong>：<ul><li><strong>循环依赖</strong>：避免 A 依赖 B，B 又依赖 A，可通过 <code>@Lazy</code> 延迟加载解决。</li><li><strong>多实例冲突</strong>：使用 <code>@Qualifier</code> 或 <code>@Primary</code> 明确指定 Bean。</li></ul></li><li><strong>性能优化</strong>：反射操作有一定开销，但 Spring 通过缓存元数据（如 <code>InjectionMetadata</code>）减少重复解析。</li></ul><h2 id="SpringMVC-工作流程"><a href="#SpringMVC-工作流程" class="headerlink" title="SpringMVC 工作流程"></a>SpringMVC 工作流程</h2><p><strong>核心组件</strong></p><ol><li><strong>DispatcherServlet</strong>：前置控制器，是整个流程控制的<strong>核心</strong>，控制其他组件的执行，进行统一调度，降低组件之间的耦合性，相当于总指挥。</li><li><strong>Handler</strong>：处理器，完成具体的业务逻辑，相当于 Servlet 或 Action。</li><li><strong>HandlerMapping</strong>：DispatcherServlet 接收到请求之后，通过 HandlerMapping 将不同的请求映射到不同的 Handler。</li><li><strong>HandlerInterceptor</strong>：处理器拦截器，是一个接口，如果需要完成一些拦截处理，可以实现该接口。</li><li><strong>HandlerExecutionChain</strong>：处理器执行链，包括两部分内容：Handler 和 HandlerInterceptor（系统会有一个默认的 HandlerInterceptor，如果需要额外设置拦截，可以添加拦截器）。</li><li><strong>HandlerAdapter</strong>：处理器适配器，Handler 执行业务方法之前，需要进行一系列的操作，包括表单数据的验证、数据类型的转换、将表单数据封装到 JavaBean 等，这些操作都是由 HandlerApater 来完成，开发者只需将注意力集中业务逻辑的处理上，DispatcherServlet 通过 HandlerAdapter 执行不同的 Handler。</li><li><strong>ModelAndView</strong>：装载了模型数据和视图信息，作为 Handler 的处理结果，返回给 DispatcherServlet。</li><li><strong>ViewResolver</strong>：视图解析器，DispatcheServlet 通过它将逻辑视图解析为物理视图，最终将渲染结果响应给客户端。</li></ol><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-e29a122b-db07-48b8-8289-7251032e87a1.png" alt="三分恶面渣逆袭：Spring MVC的工作流程"></p><h2 id="AOP-哪些情况下会失效"><a href="#AOP-哪些情况下会失效" class="headerlink" title="AOP 哪些情况下会失效"></a>AOP 哪些情况下会失效</h2><p><strong>AOP 生效的关键条件</strong></p><table><thead><tr><th align="left">条件</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">目标对象是 Spring Bean</td><td align="left">需通过容器获取实例</td></tr><tr><td align="left">方法需为 public</td><td align="left">非 public 方法无法被代理</td></tr><tr><td align="left">避免类内部自调用</td><td align="left">必须通过代理对象调用方法</td></tr><tr><td align="left">非 final 类&#x2F;方法</td><td align="left">CGLIB 要求方法可被重写</td></tr><tr><td align="left">正确配置切点</td><td align="left">表达式需匹配到目标方</td></tr></tbody></table><h2 id="spring-bean是线程安全的吗"><a href="#spring-bean是线程安全的吗" class="headerlink" title="spring bean是线程安全的吗"></a>spring bean是线程安全的吗</h2><p>Spring Bean 的线程安全性<strong>不是由 Spring 框架本身保证的</strong>，而是<strong>取决于 Bean 的作用域（Scope）和你如何编写该 Bean 的代码</strong>。</p><p><strong>作用域：</strong></p><ul><li><strong>单例（Singleton） - 默认作用域：</strong> 这是最常用的作用域。Spring IoC 容器在整个应用中只创建该 Bean 的一个实例。<strong>这个单例实例会被所有请求它的线程共享。</strong><ul><li><strong>线程安全风险：</strong> 如果这个单例 Bean 是<strong>有状态的（Stateful）</strong>，即它包含可变的成员变量（字段），那么多个线程同时访问和修改这些状态时，<strong>就极有可能发生竞态条件（Race Condition）和数据不一致的问题，导致线程不安全。</strong></li><li><strong>线程安全条件：</strong> 如果这个单例 Bean 是<strong>无状态的（Stateless）</strong>，即它<strong>不包含任何可变的成员变量</strong>，或者它只包含 <code>final</code> 或不可变对象（如 <code>String</code>、<code>Integer</code> 等）作为成员变量，并且其所有方法都是基于传入参数进行计算而不依赖或修改内部状态，那么它就是<strong>线程安全的</strong>。这是编写线程安全单例 Bean 的最佳实践。</li></ul></li><li><strong>原型（Prototype）：</strong> 每次请求该 Bean 时，Spring 容器都会创建一个全新的实例。因此，每个线程通常操作的是自己的 Bean 实例。<ul><li><strong>线程安全：</strong> <strong>通常被认为是线程安全的</strong>，因为状态不共享。但是，如果某个线程将它的原型 Bean 实例引用传递给另一个线程，并且这个 Bean 是有状态的，那么这两个线程操作同一个实例时，同样会导致线程安全问题。</li></ul></li><li><strong>请求（Request）、会话（Session）、应用（Application）、WebSocket（WebSocket）：</strong> 这些作用域主要用于 Web 应用。<code>Request</code> 作用域为每个 HTTP 请求创建一个新实例，<code>Session</code> 作用域为每个用户会话创建一个实例，等等。在这些作用域内，单个实例通常只被一个线程（处理该请求&#x2F;会话的线程）访问，因此<strong>在该作用域定义的边界内通常是线程安全的</strong>。但跨请求&#x2F;会话共享这些 Bean 的引用会导致问题。</li></ul><p><strong>代码设计：</strong></p><ul><li><strong>无状态设计：</strong> 这是实现线程安全最推荐的方式。确保你的 Bean（尤其是单例 Bean）<strong>不包含任何可变的成员变量</strong>。所有操作所需的数据都通过方法参数传入。</li><li><strong>使用局部变量：</strong> 在方法内部使用局部变量是线程安全的，因为每个线程都有自己的方法调用栈。</li><li><strong>使用同步（Synchronization）：</strong> 如果 Bean 必须有状态，你需要使用同步机制（如 <code>synchronized</code> 关键字、<code>ReentrantLock</code>、<code>Atomic</code> 类等）来保护对共享可变状态的访问。但这会增加复杂性和可能降低性能。</li><li><strong>使用并发集合：</strong> 如果需要共享集合，优先使用 <code>java.util.concurrent</code> 包下的线程安全集合类（如 <code>ConcurrentHashMap</code>, <code>CopyOnWriteArrayList</code> 等）。</li><li><strong>使用 ThreadLocal：</strong> 对于需要为每个线程保存独立状态的情况（例如，用户身份验证信息），可以考虑使用 <code>ThreadLocal</code>。但需要非常小心地管理其生命周期，避免内存泄漏（尤其是在使用线程池时）。</li></ul><p><strong>示例（危险的单例）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 默认是 Singleton</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsafeCounterService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 可变状态！危险！</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++; <span class="comment">// 非原子操作，多线程下会出错</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例（安全的单例 - 无状态）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeCalculatorService</span> &#123;</span><br><span class="line">    <span class="comment">// 没有成员变量 -&gt; 无状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b; <span class="comment">// 只操作参数和局部变量，线程安全</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例（安全的单例 - 使用 Atomic 类）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeCounterService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>); <span class="comment">// 使用线程安全的原子类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count.incrementAndGet(); <span class="comment">// 原子操作，线程安全</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h1><h2 id="什么是SPI机制"><a href="#什么是SPI机制" class="headerlink" title="什么是SPI机制"></a>什么是SPI机制</h2><p><strong>SPI</strong> 是 Java 提供的一种<strong>服务发现机制</strong>，通过<strong>接口与实现解耦</strong>实现动态扩展。核心流程如下：</p><ol><li><strong>定义服务接口</strong>（如 <code>PaymentService</code>）</li><li><strong>提供实现类</strong>（如 <code>AlipayService</code>, <code>WechatPayService</code>）</li><li><strong>注册实现</strong>：在 <code>META-INF/services/</code> 下创建以接口全限定名命名的文件，写入实现类全限定名</li><li><strong>动态加载</strong>：通过 <code>ServiceLoader</code> 加载所有注册的实现</li></ol><p><strong>优势：</strong></p><ul><li><strong>开闭原则</strong>：新增实现无需修改核心代码</li><li><strong>解耦</strong>：接口与实现分离</li><li><strong>可插拔</strong>：通过配置文件动态替换实现</li></ul><p><strong>Java SPI 完整 Demo</strong></p><ol><li>定义服务接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PaymentService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">double</span> amount)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>实现服务接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AlipayService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AlipayService</span> <span class="keyword">implements</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[支付宝] 支付: ¥&quot;</span> + amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WechatPayService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WechatPayService</span> <span class="keyword">implements</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[微信支付] 支付: ¥&quot;</span> + amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>注册服务实现</li></ol><p>创建资源文件：<br><code>src/main/resources/META-INF/services/com.example.PaymentService</code><br>内容：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.example.AlipayService</span><br><span class="line">com.example.WechatPayService</span><br></pre></td></tr></table></figure><ol start="4"><li>使用 SPI 加载服务</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPIDemo.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.ServiceLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SPIDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 加载所有 PaymentService 实现</span></span><br><span class="line">        ServiceLoader&lt;PaymentService&gt; services = </span><br><span class="line">            ServiceLoader.load(PaymentService.class);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;=== 发现 &quot;</span> + getServiceCount(services) + <span class="string">&quot; 个支付服务 ===&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用所有实现</span></span><br><span class="line">        <span class="keyword">for</span> (PaymentService service : services) &#123;</span><br><span class="line">            service.pay(<span class="number">100.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getServiceCount</span><span class="params">(ServiceLoader&lt;PaymentService&gt; services)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (PaymentService ignored : services) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>项目结构</li></ol><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">├── main/</span><br><span class="line">│   ├── java/</span><br><span class="line">│   │   ├── com/example/</span><br><span class="line">│   │   │   ├── PaymentService.java</span><br><span class="line">│   │   │   ├── AlipayService.java</span><br><span class="line">│   │   │   ├── WechatPayService.java</span><br><span class="line">│   │   │   └── SPIDemo.java</span><br><span class="line">│   │</span><br><span class="line">│   └── resources/</span><br><span class="line">│       └── META-INF/services/</span><br><span class="line">│           └── com.example.PaymentService  &lt;-- 关键配置文件</span><br></pre></td></tr></table></figure><ol start="6"><li>运行结果</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">=== 发现 2 个支付服务 ===</span><br><span class="line">[支付宝] 支付: ¥100.0</span><br><span class="line">[微信支付] 支付: ¥100.0</span><br></pre></td></tr></table></figure><p><strong>关键点解析：</strong></p><ol><li><strong>配置文件路径</strong>：<code>META-INF/services/接口全限定名</code></li><li><strong>文件内容</strong>：实现类的全限定名（每行一个）</li><li><strong>ServiceLoader</strong>：核心加载工具，实现懒加载</li><li><strong>迭代顺序</strong>：按配置文件中定义的顺序加载</li></ol><p><strong>实际应用场景：</strong></p><ul><li>JDBC 驱动加载（<code>DriverManager</code>）</li><li>日志门面（SLF4J）</li><li>序列化框架（Jackson）</li><li>Spring Boot 自动配置</li></ul><blockquote><p>通过 SPI 机制，Java 实现了真正的面向接口编程，使系统具备高度可扩展性，符合「开闭原则」。</p></blockquote><h2 id="Java的SPI机制有什么问题"><a href="#Java的SPI机制有什么问题" class="headerlink" title="Java的SPI机制有什么问题"></a>Java的SPI机制有什么问题</h2><ol><li><strong>效率低下（全量加载）</strong>：<ul><li><code>ServiceLoader</code> 在加载一个接口的实现时，会<strong>遍历并实例化</strong> <code>META-INF/services/</code> 目录下对应配置文件中的所有实现类。</li><li><strong>问题：</strong> 如果某个扩展点有很多实现（或者某些实现类初始化成本很高），但实际运行时只需要用到其中一个或几个，这种全量加载会造成<strong>不必要的资源消耗（内存、CPU）和启动延迟</strong>。</li></ul></li><li><strong>缺乏按需获取能力（不灵活）</strong>：<ul><li>Java SPI 只能获取所有实现，然后由调用者遍历查找需要的那个。没有内置的机制根据名称、参数或其他条件直接获取特定的实现实例。</li><li><strong>问题：</strong> 使用起来不够方便和直观，需要额外的筛选逻辑。</li></ul></li><li><strong>不支持依赖注入</strong>：<ul><li>通过 SPI 加载的实现类实例，其构造函数或成员变量如果依赖其他对象，需要调用者手动设置。</li><li><strong>问题：</strong> 在复杂的框架中，扩展点实现类可能需要依赖框架内部的核心组件（如配置中心、注册中心、序列化器等），手动管理这些依赖非常繁琐且容易出错，破坏了扩展点的封装性。</li></ul></li><li><strong>不支持扩展点自适应&#x2F;IoC&#x2F;AOP</strong>：<ul><li>Java SPI 是静态的，加载哪个实现在配置文件中是写死的。它无法根据运行时的参数（如方法参数、URL 参数、配置项）动态选择不同的实现。</li><li><strong>问题：</strong> 缺乏动态性，难以实现更高级的功能如适配器、包装器（AOP）、条件选择等。</li></ul></li><li><strong>配置不友好（无名称标识）</strong>：<ul><li>配置文件里直接写实现类的全限定名。没有为每个实现定义一个易于理解和使用的名称（Key）。</li><li><strong>问题：</strong> 配置和引用不够直观，容易出错，不利于通过配置中心动态修改。</li></ul></li><li><strong>缺乏生命周期管理</strong>：<ul><li>Java SPI 没有提供标准的初始化和销毁回调机制。</li></ul></li></ol><h2 id="Dubbo-SPI"><a href="#Dubbo-SPI" class="headerlink" title="Dubbo SPI"></a>Dubbo SPI</h2><p>Dubbo 设计了一套功能更强大、更灵活的 SPI 机制（核心在 <code>org.apache.dubbo.common.extension</code> 包），完美解决了上述问题：</p><ol><li><strong>按需加载（核心改进）</strong>：<ul><li>Dubbo SPI 不会一次性加载和实例化所有实现类。</li><li>它维护了一个映射关系：<code>扩展点名称 (Key) -&gt; 实现类全限定名</code>。</li><li>只有当通过名称 (<code>key</code>) 明确请求某个扩展点时，才会加载并实例化对应的实现类。<strong>大大提高了效率和资源利用率，加快了启动速度。</strong></li></ul></li><li><strong>支持扩展点命名与配置化</strong>：<ul><li>配置文件路径：<code>META-INF/dubbo/</code> 或 <code>META-INF/dubbo/internal/</code> 或 <code>META-INF/services/</code>（兼容 Java SPI），文件名为接口全限定名。</li><li>文件内容格式：<code>key=implementation.class.name</code> (例如：<code>dubbo=org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol</code>)。这为每个实现赋予了明确的标识符 (<code>key</code>)。</li></ul></li><li>**强大的依赖注入 (IoC)**：<ul><li>Dubbo SPI 在实例化扩展点实现时，会自动扫描其 setter 方法。</li><li>如果 setter 方法的参数类型是另一个<strong>已知的扩展点类型</strong>，Dubbo 会自动注入该扩展点的<strong>适配实例</strong>（通常是自适应扩展点实例，见下一点）。</li><li>也支持注入框架内部的核心组件（如 <code>ApplicationModel</code>, <code>ModuleModel</code>, <code>ScopeModel</code> 等）。</li><li><strong>优势：</strong> 解耦扩展点实现与框架内部依赖，开发者只需关注业务逻辑，依赖由框架自动注入。</li></ul></li><li>**自适应扩展点 (Adaptive Extension - 核心特性)**：<ul><li><strong>概念：</strong> 一种特殊的扩展点，它本身通常不包含具体逻辑，而是一个<strong>动态生成的代理</strong>（编译时生成或运行时生成）。</li><li><strong>作用：</strong> 在<strong>方法被调用时</strong>，根据传入的<strong>运行时参数</strong>（通常是包含配置信息的 <code>URL</code> 对象或 <code>@Adaptive</code> 注解指定的参数），动态决定将调用<strong>委托</strong>给哪个真正的扩展点实现 (<code>key</code> 对应的实现)。</li><li><strong>实现方式：</strong><ul><li><strong>编译时生成：</strong> Dubbo 编译器会为标记了 <code>@Adaptive</code> 注解的接口方法生成代理类代码（如 <code>Protocol$Adaptive</code>）。</li><li><strong>运行时生成：</strong> 如果接口没有任何方法标记 <code>@Adaptive</code>，Dubbo 会查找该接口的默认实现（通过 <code>@SPI</code> 的 <code>value</code> 指定）。如果需要在运行时根据方法参数选择，也可以在具体实现类的方法上使用 <code>@Adaptive</code>（较少见）。</li></ul></li><li><strong>优势：</strong> 实现了真正的运行时动态扩展选择。例如，<code>Protocol</code> 接口的自适应扩展点，根据 URL 中的 <code>protocol</code> 参数值 (<code>dubbo</code>, <code>hessian</code>, <code>http</code>, <code>injvm</code> 等）决定使用哪个具体的协议实现。这是 Dubbo 高度可扩展性的基石。</li></ul></li><li>**自动包装 (Wrapper - AOP)**：<ul><li>如果扩展点实现类的构造函数接受<strong>单个参数</strong>且是该扩展点接口类型，Dubbo 会识别它为 Wrapper 类。</li><li>在加载真正的扩展点实现（称为 <code>instance</code>）时，Dubbo 会像“洋葱”一样，用所有找到的 Wrapper 类<strong>层层包裹</strong>这个 <code>instance</code>：<code>new Wrapper1(new Wrapper2(new Wrapper3(instance)))</code>。</li><li><strong>作用：</strong> 在不修改原始实现类代码的前提下，实现 AOP 功能。Wrapper 可以在调用真正实现的前后添加逻辑，如日志记录、监控统计、权限校验、失败重试、负载均衡（部分策略）等。Dubbo 自身的很多功能（如 Filter Chain）都是通过 Wrapper 机制实现的。</li></ul></li><li>**自动激活扩展点 (Activate)**：<ul><li>通过 <code>@Activate</code> 注解标记扩展点实现。</li><li>可以根据给定的条件（如 URL 中的特定参数值、消费者&#x2F;提供者端角色）<strong>自动激活并组合</strong>一组符合条件的扩展点实现。</li><li><strong>典型应用：</strong> Dubbo 的 Filter 链。开发者可以方便地添加自定义 Filter，并通过 <code>@Activate</code> 注解控制它在哪些条件下自动生效（如所有调用、特定分组、特定服务等）。</li></ul></li><li><strong>支持默认扩展点和覆盖</strong>：<ul><li>在 <code>@SPI</code> 注解中可以指定默认扩展点的 <code>key</code> (如 <code>@SPI(&quot;dubbo&quot;)</code>)。</li><li>Dubbo 支持通过配置（系统属性、外部配置）覆盖默认实现或已加载的实现。</li></ul></li><li><strong>缓存优化</strong>：<ul><li>Dubbo 对加载的扩展点定义、实例（单例或原型）、自适应扩展点实例等进行了细致的缓存管理，避免重复加载和创建，提升性能。</li></ul></li></ol><p><strong>总结对比表</strong></p><table><thead><tr><th align="left">特性</th><th align="left">Java SPI</th><th align="left">Dubbo SPI</th><th align="left">Dubbo 改进点&#x2F;优势</th></tr></thead><tbody><tr><td align="left"><strong>加载方式</strong></td><td align="left">全量加载并实例化所有实现</td><td align="left"><strong>按需加载</strong>，仅在使用时加载并实例化指定 <code>key</code></td><td align="left"><strong>高效、节省资源、启动快</strong></td></tr><tr><td align="left"><strong>标识与配置</strong></td><td align="left">仅实现类全名</td><td align="left"><code>key=implementation.class.name</code></td><td align="left"><strong>配置灵活、可读性好、易于通过 <code>key</code> 引用</strong></td></tr><tr><td align="left"><strong>依赖注入 (IoC)</strong></td><td align="left">不支持</td><td align="left"><strong>强有力支持</strong>，自动注入其他扩展点或框架组件</td><td align="left"><strong>解耦、简化扩展开发、增强封装性</strong></td></tr><tr><td align="left"><strong>动态扩展选择</strong></td><td align="left">不支持</td><td align="left"><strong>自适应扩展点 (Adaptive)</strong></td><td align="left"><strong>运行时根据参数动态选择实现，核心灵活性来源</strong></td></tr><tr><td align="left"><strong>AOP&#x2F;包装</strong></td><td align="left">不支持</td><td align="left"><strong>自动包装 (Wrapper)</strong></td><td align="left"><strong>无侵入添加公共逻辑 (Filter, 监控, 校验等)</strong></td></tr><tr><td align="left"><strong>条件激活</strong></td><td align="left">不支持</td><td align="left"><code>@Activate</code> <strong>自动激活</strong></td><td align="left"><strong>简化扩展组合，按条件动态启用扩展链 (如 Filter)</strong></td></tr><tr><td align="left"><strong>默认实现与覆盖</strong></td><td align="left">无明确机制</td><td align="left"><code>@SPI(&quot;defaultKey&quot;)</code> + 配置覆盖</td><td align="left"><strong>灵活指定和修改默认行为</strong></td></tr><tr><td align="left"><strong>缓存</strong></td><td align="left">基础缓存</td><td align="left"><strong>精细化的多级缓存管理</strong></td><td align="left"><strong>性能优化</strong></td></tr><tr><td align="left"><strong>生命周期</strong></td><td align="left">无</td><td align="left">(间接通过 Spring 等或自定义实现)</td><td align="left">Dubbo SPI 本身未强定义，但常与其他生命周期管理集成</td></tr></tbody></table><p><strong>结论：</strong></p><p>Dubbo 的 SPI 机制并非对 Java SPI 的简单替换，而是为了解决 Java SPI 在<strong>效率、灵活性、动态性、依赖管理、功能增强（AOP）</strong> 等方面的严重不足，为构建高度可扩展、高性能、易于集成的分布式服务框架量身打造的一套强大的扩展点加载与管理体系。Dubbo 自身的几乎所有核心组件（Protocol, Cluster, LoadBalance, Serialization, Transport, Registry, Monitor, Filter 等）都通过这套 SPI 机制实现，这也是 Dubbo 能够保持强大生命力和高度可定制性的关键设计之一。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> JPA </tag>
            
            <tag> 日志框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习&amp;面试-消息队列</title>
      <link href="/post/688e2513.html"/>
      <url>/post/688e2513.html</url>
      
        <content type="html"><![CDATA[<h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><ul><li><strong>Kafka&#x2F;RocketMQ&#x2F;RabbitMQ:</strong> 深入理解其核心概念（Topic&#x2F;Queue, Producer, Consumer, Broker, Partition&#x2F;Sharding）、消息存储机制（Kafka 的 Log Segment, RocketMQ 的 Commit Log）、高可用与可靠性保证（副本机制、ACK 机制、事务消息）、顺序消息、延迟消息、消息积压处理策略。理解选型考量。</li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><strong>Topic</strong> 是消息发布的类别或主题。</li><li><strong>Partition</strong>：一个 <strong>Topic</strong> 被划分为一个或多个 <strong>Partition</strong>，分布在不同的 Broker 上。</li><li><strong>Replica</strong>：每个 <strong>Partition</strong> 可以有多个 <strong>Replica</strong> (副本)。其中一个 Replica 是 <strong>Leader</strong>，负责读写；其他是 <strong>Follower</strong>，只负责从 Leader 同步数据。Replica 也分布在不同的 Broker 上，提供容错能力。</li><li><strong>Consumer Group (CG):</strong> 一组 Consumer 实例的集合，它们共同消费一个或多个 Topic。组内消费实例<strong>协作消费</strong>订阅 Topic 的所有 Partition。一个 Partition 只能被组内<strong>一个</strong> Consumer 实例消费，实现负载均衡。</li><li><strong>Rebalance (重平衡):</strong> 当以下情况发生时，Kafka 会重新分配 CG 内 Consumer 负责的 Partition：<ul><li>组内 Consumer 数量变化 (新 Consumer 加入、Consumer 崩溃或主动离开)。</li><li>订阅的 Topic Partition 数量变化 (如 Topic 被修改增加了 Partition)。</li><li>订阅的 Topic 本身变化。</li><li><strong>影响:</strong> Rebalance 期间，整个 CG 会<strong>短暂停止消费</strong>，直到分配完成。频繁或长时间的 Rebalance 会影响消费进度和系统稳定性。</li></ul></li></ul><ol><li>消息堆积处理策略</li><li>RocketMQ事务消息流程</li><li>Broker选举机制对比（Kafka vs RocketMQ）</li></ol><h2 id="Kafka-如何实现高吞吐量"><a href="#Kafka-如何实现高吞吐量" class="headerlink" title="Kafka 如何实现高吞吐量"></a>Kafka 如何实现高吞吐量</h2><ul><li><strong>顺序读写磁盘:</strong> 消息按顺序追加到 Partition 文件末尾，充分利用磁盘顺序 I&#x2F;O 的高性能（远高于随机 I&#x2F;O）。</li><li><strong>Page Cache:</strong> 利用操作系统 Page Cache 缓存数据，减少直接磁盘访问。</li><li><strong>零拷贝 (Zero-Copy):</strong> 使用 <code>sendfile</code> 和 <code>mmap</code> 等技术，减少数据在用户空间和内核空间之间的拷贝次数，降低 CPU 开销和上下文切换。</li><li><strong>批量处理 (Batching):</strong> Producer 批量发送消息，Broker 批量写入磁盘和批量发送给 Consumer，减少网络和 I&#x2F;O 开销。</li><li><strong>消息压缩:</strong> Producer 端可配置压缩算法 (Snappy, LZ4, Gzip, Zstd)，减少网络传输和磁盘存储开销。</li><li><strong>Partition 并行:</strong> Topic 被分成多个 Partition，分布在多个 Broker 上，读写操作可以并行发生在不同 Partition，充分利用多 Broker、多磁盘、多核 CPU。</li></ul><h2 id="Producer-的-acks-不同取值的含义"><a href="#Producer-的-acks-不同取值的含义" class="headerlink" title="Producer 的 acks 不同取值的含义"></a>Producer 的 <code>acks</code> 不同取值的含义</h2><ul><li><code>acks=0</code>: Producer 发送消息后<strong>不等待</strong> Broker 的任何确认。<strong>最高吞吐，最低延迟，最低可靠性</strong> (可能丢失数据)。</li><li><code>acks=1</code>: Producer 发送消息后，等待 <strong>Leader 副本成功写入本地日志</strong> 的确认。<strong>折中方案</strong>。Leader 故障但数据未同步到 Follower 时可能丢失数据。</li><li><code>acks=all</code> <strong>(或</strong> <code>acks=-1</code><strong>)</strong>: Producer 发送消息后，等待 <strong>Leader 收到消息并确认该消息已被当前 ISR 集合中的所有副本成功写入本地日志</strong>。<strong>最高可靠性</strong>，最低丢失风险，但延迟最高，吞吐可能最低。需要配合 <code>min.insync.replicas</code> 参数使用。</li></ul><h2 id="如何保证消息不丢失"><a href="#如何保证消息不丢失" class="headerlink" title="如何保证消息不丢失"></a>如何保证消息不丢失</h2><p>消息丢失可能发生在生产者、Broker 或消费者环节：</p><ol><li><strong>生产者发送消息时丢失：</strong><ul><li><strong>原因：</strong><ul><li><strong>异步发送 + 不处理回调：</strong> 生产者使用异步发送（<code>send()</code> 返回 Future）但未正确处理回调（<code>Future.get()</code> 或 <code>Callback</code>），网络抖动或 Broker 暂时不可用导致发送失败，但生产者不知情。</li><li><strong><code>acks</code> 配置过低：</strong> <code>acks=0</code>（生产者不等待任何确认）或 <code>acks=1</code>（只等待 Leader 写入本地日志）时，如果 Leader 刚写入就挂掉且数据未同步到 Follower，新 Leader 可能没有这条消息。</li></ul></li><li><strong>解决方案：</strong><ul><li><strong>使用同步发送或正确处理异步回调：</strong> 调用 <code>future.get()</code> 阻塞等待结果，或在 <code>Callback</code> 中检查异常并实现重试逻辑（注意幂等性）。</li><li><strong>设置 <code>acks=all</code>：</strong> 要求 Leader 收到消息后，必须等待所有 <strong>ISR (In-Sync Replica)</strong> 列表中的 Follower 都成功复制了消息后才向生产者发送确认。这是防止生产者端丢失的最强保证。</li><li><strong>配置合理的 <code>retries</code> 和 <code>retry.backoff.ms</code>：</strong> 对于可重试的异常（如网络问题、<code>NOT_ENOUGH_REPLICAS</code>），生产者应自动重试。增大重试次数和重试间隔。</li><li><strong>启用生产者幂等性：</strong> 设置 <code>enable.idempotence=true</code>。这会自动设置 <code>acks=all</code>，并引入生产者 ID 和序列号，防止在重试时因网络问题导致 Broker 收到重复消息（解决了重试可能导致重复的问题，但主要目标是保证精确一次生产语义的基础）。</li></ul></li></ul></li><li><strong>Broker 存储消息时丢失：</strong><ul><li><strong>原因：</strong><ul><li><strong>副本数量不足且 Leader 挂掉：</strong> 假设 <code>replication.factor=1</code>（只有 Leader 副本），如果该 Broker 磁盘损坏或永久宕机，消息永久丢失。即使 <code>replication.factor&gt;1</code>，但如果 <code>min.insync.replicas=1</code> 且 <code>acks=all</code>，只要有一个副本（Leader）写入成功就算成功，如果该 Leader 立刻挂掉且数据未同步到其他副本，消息也会丢失。</li><li><strong>不干净的 Leader 选举：</strong> 当所有 ISR 副本都不可用时（例如全挂了），如果 <code>unclean.leader.election.enable=true</code>，Kafka 会从非 ISR（可能落后很多）的副本中选举新 Leader。这个新 Leader 会丢失掉它未复制到的所有消息。</li></ul></li><li><strong>解决方案：</strong><ul><li><strong>设置足够的 <code>replication.factor</code>：</strong> 至少设置为 3。这是生产环境的标准配置，确保即使一个 Broker 永久故障，数据也不丢失。</li><li><strong>设置 <code>min.insync.replicas</code>：</strong> 通常设置为 <code>replication.factor - 1</code>（例如 RF&#x3D;3 时 min.isr&#x3D;2）。这定义了当生产者使用 <code>acks=all</code> 时，Leader 必须等待多少个 ISR 副本成功写入后才返回确认。结合 <code>acks=all</code> 和 <code>min.insync.replicas</code>，可以确保写入成功的消息至少存在于 <code>min.insync.replicas</code> 个副本上，大大提高了数据持久性。</li><li><strong>设置 <code>unclean.leader.election.enable=false</code>：</strong> <strong>强烈建议生产环境关闭！</strong> 这阻止了从非 ISR 副本选举 Leader，宁可让分区不可用（影响可用性），也要保证数据一致性（不丢失已确认的消息）。需要通过监控和运维手段快速恢复 ISR 副本以保证可用性。</li></ul></li></ul></li><li><strong>消费者拉取消息时丢失：</strong><ul><li><strong>原因：</strong><ul><li><strong>自动提交偏移量 + 消息处理失败：</strong> 消费者默认或在处理消息前自动提交偏移量。如果消息在处理过程中（例如业务逻辑出错、消费者崩溃）失败，但偏移量已经提交，那么这条消息对于该消费者组来说就“丢失”了（因为下次拉取会从已提交的偏移量之后开始）。虽然消息还在 Broker 上，但没有消费者会再处理它。</li></ul></li><li><strong>解决方案：</strong><ul><li><strong>关闭自动提交，采用手动提交偏移量：</strong> 设置 <code>enable.auto.commit=false</code>。</li><li><strong>在处理完消息后手动提交偏移量：</strong> 在业务逻辑成功执行完毕后，再调用 <code>consumer.commitSync()</code> 或 <code>consumer.commitAsync()</code> 提交偏移量。这保证了“至少一次”语义（消息可能被处理多次，但至少处理一次）。</li><li><strong>注意提交的原子性：</strong> 尽量保证处理单条消息后立即提交其偏移量。批量处理时，需要在成功处理完一个批次后再提交该批次中最后一条消息的偏移量。如果处理失败，不要提交偏移量，这样消费者重启后会重新拉取失败的消息。</li><li><strong>处理好再平衡：</strong> 在消费者发生再平衡（Consumer Rebalance - 消费者加入或离开组）时，确保在失去分区所有权前提交已处理消息的偏移量。监听 <code>ConsumerRebalanceListener</code> 接口，在 <code>onPartitionsRevoked</code> 方法中进行提交。</li></ul></li></ul></li></ol><h2 id="如何解决消息重复消费的问题"><a href="#如何解决消息重复消费的问题" class="headerlink" title="如何解决消息重复消费的问题"></a>如何解决消息重复消费的问题</h2><p>消息重复消费主要发生在消费者端：</p><ol><li><strong>原因：</strong><ul><li><strong>消费者处理成功但提交偏移量失败：</strong> 这是最常见的原因。消费者成功处理了消息，但在提交偏移量时失败（例如网络问题、消费者崩溃、再平衡）。当消费者恢复或新消费者接管分区后，会从上一次成功提交的偏移量开始消费，导致已处理但未提交偏移量的消息被再次处理。</li><li><strong>生产者重试导致消息重复写入：</strong> 在未启用幂等性时，生产者发送消息后未收到 Broker 确认（可能 Broker 已写入但确认丢失），生产者重试可能导致 Broker 收到两条相同的消息（具有不同的偏移量）。</li><li><strong>消费者再平衡：</strong> 再平衡过程中，如果消费者在提交偏移量前被撤销分区，且新消费者在旧消费者完成处理前接管，可能导致消息被不同消费者重复处理（尤其是处理时间较长时）。</li><li><strong>消费者 Seek：</strong> 手动将消费者偏移量重置到之前的位置会导致重复消费。</li></ul></li><li><strong>解决方案：</strong><ul><li><strong>启用生产者幂等性：</strong> 设置 <code>enable.idempotence=true</code>。这是解决生产者重试导致 Broker 端消息重复的根本方法。它确保单个生产者会话内发送到同一分区的消息是幂等的。</li><li><strong>启用 Kafka 的事务：</strong> 对于需要跨 Kafka Topic 和外部系统（如数据库）保证“精确一次”语义的场景，需要使用 Kafka 事务 API。生产者使用事务发送消息，消费者在事务内读取消息并提交偏移量（设置 <code>isolation.level=read_committed</code>）。这需要外部系统也支持事务性参与（通常通过两阶段提交或事务性出站）。</li><li><strong>消费者端实现幂等性：</strong> <strong>这是最常用、最灵活、适用范围最广的解决方案！</strong> 既然 Kafka 消费者端默认是“至少一次”语义，那么就需要你的消费逻辑能够容忍重复。核心思想是让处理操作本身具有幂等性：<ul><li><strong>唯一标识：</strong> 在消息体中携带一个全局唯一的业务标识符（如订单ID、支付流水号）。</li><li><strong>状态检查：</strong> 在处理消息前，先根据这个唯一标识去检查目标系统（通常是数据库）中是否已经存在相同标识的处理结果。</li><li><strong>幂等操作：</strong> 如果存在，则跳过处理或执行更新操作（确保更新操作本身也是幂等的，例如 <code>UPDATE table SET status=&#39;paid&#39; WHERE order_id=123 AND status=&#39;unpaid&#39;</code>）。如果不存在，则正常处理。</li><li><strong>数据库唯一约束：</strong> 在数据库表中，利用唯一键约束来防止重复插入是最有效的手段。尝试插入带有唯一标识的记录，如果违反唯一约束则视为重复消息，进行更新或忽略。</li></ul></li></ul></li></ol><h2 id="Kafka-如何保证消息的顺序性"><a href="#Kafka-如何保证消息的顺序性" class="headerlink" title="Kafka 如何保证消息的顺序性"></a>Kafka 如何保证消息的顺序性</h2><ul><li><strong>Kafka 仅保证单个 Partition 内消息的严格顺序 (FIFO)。</strong> 这是由其追加写入和单线程消费分区的特性保证的。</li><li><strong>无法保证跨 Partition 的消息全局顺序。</strong></li><li><strong>需要全局顺序怎么办？</strong> 将所有需要保证顺序的消息发送到<strong>同一个 Partition</strong>。通常通过为这些消息指定<strong>相同的 Key</strong> 来实现 (Producer 根据 Key 的哈希值决定 Partition)。</li><li><strong>需要分区顺序怎么办？</strong> 确保同一个 Key 的消息总是发到同一个 Partition (同样通过 Key 哈希)，则该 Key 相关的消息在该 Partition 内是顺序的。</li></ul><h2 id="ISR-机制及其在-Leader-选举中的作用"><a href="#ISR-机制及其在-Leader-选举中的作用" class="headerlink" title="ISR 机制及其在 Leader 选举中的作用"></a>ISR 机制及其在 Leader 选举中的作用</h2><p><strong>ISR (In-Sync Replicas):</strong> 指与 Partition Leader 副本<strong>保持同步</strong>的 Follower 副本集合。Leader 维护 ISR 列表。</p><p><strong>同步标准:</strong> Follower 副本在 <code>replica.lag.time.max.ms</code> 时间内成功从 Leader 拉取到最新数据。</p><p><strong>Leader 选举:</strong> 当 Leader 副本所在 Broker 宕机时，Controller 会<strong>从当前 ISR 集合中选择一个副本</strong>作为新的 Leader。这是为了保证新 Leader 拥有最新的已提交数据，避免数据丢失或不一致。</p><h2 id="Zookeeper-和-KRaft-的区别，为什么-Kafka-要去-Zookeeper-化"><a href="#Zookeeper-和-KRaft-的区别，为什么-Kafka-要去-Zookeeper-化" class="headerlink" title="Zookeeper 和 KRaft 的区别，为什么 Kafka 要去 Zookeeper 化"></a>Zookeeper 和 KRaft 的区别，为什么 Kafka 要去 Zookeeper 化</h2><ul><li><strong>Zookeeper (ZK)：</strong> 是 Kafka 2.7 及之前版本的核心外部依赖。负责：<ul><li>Broker 注册与发现</li><li>Controller 选举</li><li>Topic 配置存储</li><li>ACL 权限存储</li><li>(旧版) Consumer Offset 存储</li></ul></li><li><strong>KRaft：</strong> 是 Kafka 内部实现的基于 Raft 共识协议的元数据管理系统，从 Kafka 2.8 (预览) &#x2F; 3.0+ (生产可用) 开始引入，旨在完全取代 Zookeeper。</li><li><strong>去 ZK 化原因 (KRaft 优势)：</strong><ul><li><strong>简化架构与部署：</strong> 移除外部依赖，Kafka 自包含，部署、配置、监控更简单。</li><li><strong>提升性能与可伸缩性：</strong> 元数据操作直接在 Kafka 协议上处理，减少一次网络跳转和序列化开销。KRaft 设计上能更好地支持大规模集群（数万个 Partition）。</li><li><strong>更强的元数据一致性模型：</strong> KRaft 使用 Raft 强一致性协议管理元数据状态机。</li><li><strong>更直接的运维：</strong> 所有操作通过 Kafka API 或 <code>kafka-metadata-shell</code> 完成，无需单独管理 ZK。</li><li><strong>统一安全模型：</strong> 元数据通信复用 Kafka 的安全机制 (SSL&#x2F;SASL)，无需单独配置 ZK 安全。</li><li><strong>现状：</strong> KRaft 已成为生产推荐模式，新集群应优先使用 KRaft。Zookeeper 模式在逐步淘汰。</li></ul></li></ul><h2 id="什么是-Consumer-Lag"><a href="#什么是-Consumer-Lag" class="headerlink" title="什么是 Consumer Lag"></a>什么是 Consumer Lag</h2><ul><li><strong>定义：</strong> Consumer Lag 指 Consumer Group 在某个 Partition 上<strong>最新提交的 Offset</strong> 与 <strong>Partition 当前最新消息的 Offset (LEO)</strong> 之间的差值。即 <strong>未消费的消息数量</strong>。</li><li><strong>监控重要性：</strong> Lag 是衡量消费健康状况的关键指标。持续增长的 Lag 意味着消费速度跟不上生产速度，可能导致延迟和数据积压</li><li><strong>原因：</strong><ul><li>消费者处理能力不足 (CPU, 内存, 逻辑复杂, I&#x2F;O 慢)。</li><li>消费者实例数量不足 (Partition 数 &gt; Consumer 实例数)。</li><li>下游系统故障或慢。</li><li>消费者代码 Bug 或配置问题 (如 <code>max.poll.records</code> 太大导致单次处理时间过长)。</li><li>网络问题。</li></ul></li><li><strong>处理：</strong><ul><li><strong>监控:</strong> 使用 Kafka 自带工具 (<code>kafka-consumer-groups.sh</code>)，JMX 指标，或第三方监控系统 (Prometheus+Grafana, Confluent Control Center)。</li><li><strong>扩容：</strong> 增加 Consumer Group 内的 Consumer 实例数 (确保 &lt;&#x3D; Partition 数)。</li><li><strong>优化消费者：</strong> 提升单 Consumer 处理能力 (优化代码逻辑、异步处理、批处理、调优 JVM)。</li><li><strong>调整参数：</strong> 适当增加 <code>fetch.min.bytes</code>, <code>fetch.max.wait.ms</code> 提高拉取效率；调整 <code>max.poll.records</code> 避免单次处理过多消息超时；检查 <code>session.timeout.ms</code> 和 <code>max.poll.interval.ms</code> 避免误判离线触发 Rebalance。</li><li><strong>排查下游依赖。</strong></li></ul></li></ul><h2 id="异步、削峰、解耦"><a href="#异步、削峰、解耦" class="headerlink" title="异步、削峰、解耦"></a>异步、削峰、解耦</h2><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p><strong>核心思想</strong>：将耗时的操作从主流程中剥离，通过消息队列<strong>延后执行</strong>，避免阻塞主线程。<br><strong>场景举例</strong>：<br>用户注册后需要：</p><ol><li>写入数据库（10ms）</li><li>发送欢迎邮件（100ms）</li><li>初始化用户画像（200ms）</li></ol><ul><li><p><strong>无消息队列（同步）</strong>：<br>用户需等待所有步骤完成（310ms），响应缓慢。</p><p>plaintext</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户 → 注册 → [ 写库10ms → 发邮件100ms → 初始化画像200ms ] → 返回结果（310ms）</span><br></pre></td></tr></table></figure></li><li><p><strong>使用消息队列（异步）</strong>：<br>主流程仅处理核心逻辑（写库），其他操作通过消息队列异步执行：</p><p>plaintext</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用户 → 注册 → [ 写库10ms ] → 返回结果（10ms）</span><br><span class="line">              ↓</span><br><span class="line">          消息队列 → [ 发邮件 | 初始化画像 ]（后台异步执行）</span><br></pre></td></tr></table></figure></li></ul><p><strong>优势</strong>：<br>✅ 用户快速获得响应（10ms）<br>✅ 避免非关键任务阻塞核心流程<br>✅ 提升系统吞吐量</p><hr><h3 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h3><p><strong>核心思想</strong>：用消息队列作为<strong>缓冲层</strong>，吸收突发流量，保护下游系统不被压垮。<br><strong>场景举例</strong>：<br>电商秒杀活动，瞬间涌入10万请求，但数据库仅能处理1万&#x2F;秒。</p><ul><li><p><strong>无消息队列</strong>：<br>数据库直接被打崩，请求超时，用户看到错误页面。</p><p>plaintext</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10万请求 → 数据库（崩溃）</span><br></pre></td></tr></table></figure></li><li><p><strong>使用消息队列</strong>：<br>请求先进入消息队列排队，数据库按处理能力消费：</p><p>plaintext</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10万请求 → 消息队列（蓄洪池） → 数据库按1万/秒处理</span><br></pre></td></tr></table></figure></li></ul><p><strong>优势</strong>：<br>✅ 避免下游系统（如数据库）因突发流量崩溃<br>✅ 平滑流量波动，将瞬时高峰转为匀速消费<br>✅ 结合重试机制提升系统容错性</p><hr><h3 id="系统解耦"><a href="#系统解耦" class="headerlink" title="系统解耦"></a>系统解耦</h3><p><strong>核心思想</strong>：通过消息队列<strong>切断服务间的直接依赖</strong>，服务只需关心消息格式，互不感知存在。<br><strong>场景举例</strong>：<br>订单系统需要通知：库存系统扣库存、积分系统加积分、物流系统创建运单。</p><ul><li><p><strong>强耦合架构</strong>：<br>订单系统需直接调用其他系统的API：</p><p>plaintext</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">订单系统 → 调用 → [库存系统、积分系统、物流系统]</span><br></pre></td></tr></table></figure><p><strong>问题</strong>：<br>❌ 任一系统故障导致订单失败<br>❌ 新增一个通知（如短信系统）需修改订单系统代码</p></li><li><p><strong>消息队列解耦</strong>：<br>订单系统只发一条消息到队列，下游系统各自订阅：</p><p>plaintext</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">订单系统 → 消息队列（订单创建事件）</span><br><span class="line">                 ↓</span><br><span class="line">   库存系统  积分系统  物流系统  （各自独立消费）</span><br></pre></td></tr></table></figure></li></ul><p><strong>优势</strong>：<br>✅ 订单系统无需知道下游是谁<br>✅ 新增消费者（如短信系统）无需修改订单代码<br>✅ 下游故障不影响主流程（消息堆积在队列）</p><h2 id="什么是死信队列"><a href="#什么是死信队列" class="headerlink" title="什么是死信队列"></a>什么是死信队列</h2><p>死信队列（Dead Letter Queue，简称 <strong>DLQ</strong>）是消息队列系统（如 RabbitMQ、Kafka、ActiveMQ、AWS SQS 等）中的一个<strong>核心容错机制</strong>。它的核心作用在于处理那些<strong>无法被正常消费或传递的消息</strong>，你可以把它想象成一个专门收容“失败任务”的隔离区。</p><p>简单来说，当一个消息在系统中“死掉”（无法被成功处理）时，它就会被转移到这个特殊的队列（DLQ）中，而不是被直接丢弃或无限次重试导致系统阻塞。</p><p><strong>消息为什么会“死”（进入死信队列）？</strong></p><p>通常有以下几种常见原因：</p><ol><li><strong>消息被拒绝且未重新入队：</strong><ul><li>消费者在处理消息时遇到无法处理的错误（如业务逻辑错误、数据格式不合法、依赖服务不可用等）。</li><li>消费者显式地发送了否定确认（NACK）并且设置了 <code>requeue=false</code>（或者在某些系统中是显式拒绝），表示此消息不应再放回原队列尝试消费。</li></ul></li><li><strong>消息过期（TTL 过期）：</strong><ul><li>消息在队列中等待的时间超过了预设的生存时间（Time-To-Live， TTL）。</li><li>消息在等待投递给消费者时超过了其预设的 TTL（某些系统支持）。</li></ul></li><li><strong>队列达到最大长度限制：</strong><ul><li>当目标队列已满（达到了配置的最大消息数量限制），新到达的消息无法入队时，这些消息可能会被转移到 DLQ（取决于配置）。</li></ul></li><li><strong>投递失败次数超限：</strong><ul><li>消息被消费者多次尝试消费（例如，配置了重试机制），但均告失败，达到了最大重试次数上限。此时系统会认为该消息无法被成功处理，将其放入 DLQ。</li></ul></li></ol><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h1 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h1><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习&amp;面试-数据存储</title>
      <link href="/post/32511a71.html"/>
      <url>/post/32511a71.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><ul><li><strong>SQL 优化:</strong> 深入理解执行计划（EXPLAIN）、索引原理（B+树, 哈希, 覆盖索引, 最左前缀）、锁机制（行锁、表锁、间隙锁、MVCC）、事务隔离级别实现原理。</li><li><strong>分库分表:</strong> 理解分片策略（水平&#x2F;垂直）、路由算法、分布式 ID 生成方案（Snowflake 等）、面临的挑战（跨库查询、事务）。</li><li><strong>NoSQL 选型:</strong> 了解 MongoDB, Elasticsearch, Cassandra 等适用场景和核心特性。</li></ul><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="当OFFSET值很大时（如LIMIT-100000-10），为什么查询会变慢"><a href="#当OFFSET值很大时（如LIMIT-100000-10），为什么查询会变慢" class="headerlink" title="当OFFSET值很大时（如LIMIT 100000, 10），为什么查询会变慢"></a>当<code>OFFSET</code>值很大时（如<code>LIMIT 100000, 10</code>），为什么查询会变慢</h3><ul><li><p><strong>原因</strong>：MySQL需先扫描并跳过<code>offset + limit</code>行，再返回结果。</p></li><li><p><strong>优化方案</strong>：</p><ol><li><p><strong>使用索引覆盖扫描</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">&gt;=</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> orders <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">100000</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>记录上一页最后一条数据的ID</strong>（推荐）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">&gt;</span> last_seen_id  <span class="comment">-- 上一页最后一条记录的ID</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>子查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> orders </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">&gt;=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> id <span class="keyword">FROM</span> orders <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">10000</span>, <span class="number">1</span></span><br><span class="line">) </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id </span><br><span class="line">LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="分页时为什么必须搭配ORDER-BY"><a href="#分页时为什么必须搭配ORDER-BY" class="headerlink" title="分页时为什么必须搭配ORDER BY"></a>分页时为什么必须搭配<code>ORDER BY</code></h3><ul><li><p>缺少<code>ORDER BY</code>时，MySQL返回结果的顺序不确定（可能因索引、存储引擎变化），导致分页结果混乱。</p></li><li><p><strong>正确写法</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span> LIMIT <span class="number">0</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="都有哪些类型索引"><a href="#都有哪些类型索引" class="headerlink" title="都有哪些类型索引"></a>都有哪些类型索引</h3><h3 id="什么是回表、覆盖索引、最左前缀原则和索引下推"><a href="#什么是回表、覆盖索引、最左前缀原则和索引下推" class="headerlink" title="什么是回表、覆盖索引、最左前缀原则和索引下推"></a>什么是回表、覆盖索引、最左前缀原则和索引下推</h3><p><strong>回表</strong>：查询需要的字段没有全部包含在索引中，需要根据索引找到主键，再从主键索引中找到完整数据才能获取所需字段。</p><p><strong>覆盖索引</strong>：查询所需的字段都包含在索引中，无需回表操作。</p><p><strong>最左前缀原则</strong>：复合索引 <code>(a, b, c)</code> 的查询条件必须从最左列开始，且不能跳过中间列才能命中索引。</p><h3 id="InnoDB索引结构"><a href="#InnoDB索引结构" class="headerlink" title="InnoDB索引结构"></a>InnoDB索引结构</h3><p>B树结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">       [10 | 20]</span><br><span class="line">      /    |     \</span><br><span class="line">[5|8]  [12|15|18]  [25|30]</span><br></pre></td></tr></table></figure><p>特征：</p><ul><li>所有节点都存储完整数据</li><li>每个节点最多包涵 m-1 个键值和 m 个子节点</li></ul><p>B+树结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">               [15]</span><br><span class="line">              /    \</span><br><span class="line">     [10|15]          [20|25]</span><br><span class="line">     /     \          /     \ </span><br><span class="line">[10|...]→[15|...]→[20|...]→[25|...]（叶子节点链表）</span><br></pre></td></tr></table></figure><p>特征：</p><ul><li>只有叶子节点存储完整数据，内部节点只存储索引</li><li>叶子节点通过双向链表连接，支持高效范围查询</li><li>相同磁盘页可以存储更多索引，提高查询效率</li></ul><p><strong>InnoDB选择B+树的7大关键原因</strong></p><table><thead><tr><th align="left"><strong>对比维度</strong></th><th align="left"><strong>B树</strong></th><th align="left"><strong>B+树</strong></th><th align="left"><strong>InnoDB优势体现</strong></th></tr></thead><tbody><tr><td align="left"><strong>数据存储位置</strong></td><td align="left">所有节点存储数据</td><td align="left">仅叶子节点存储数据</td><td align="left">减少磁盘IO次数</td></tr><tr><td align="left"><strong>树高度</strong></td><td align="left">较高（数据分散存储）</td><td align="left">较低（内部节点纯索引）</td><td align="left">3层B+树可支撑千万级数据</td></tr><tr><td align="left"><strong>范围查询</strong></td><td align="left">需要回溯父节点</td><td align="left">通过叶子链表顺序扫描</td><td align="left"><code>WHERE id &gt; 100</code> 效率提升10倍+</td></tr><tr><td align="left"><strong>全表扫描</strong></td><td align="left">需遍历整棵树</td><td align="left">直接顺序遍历叶子节点链表</td><td align="left">全表扫描速度接近顺序读</td></tr><tr><td align="left"><strong>磁盘利用率</strong></td><td align="left">节点包含数据导致存储键值数少</td><td align="left">单页可存储更多键值（高分支因子）</td><td align="left">相同数据量减少30%-50%树高度</td></tr><tr><td align="left"><strong>数据更新代价</strong></td><td align="left">可能引起复杂结构调整</td><td align="left">插入删除多数情况只需局部调整</td><td align="left">支持更高并发写入</td></tr><tr><td align="left"><strong>缓存命中率</strong></td><td align="left">热点数据分散在不同层级</td><td align="left">叶子节点集中存储所有数据</td><td align="left">Buffer Pool利用率提升40%+</td></tr></tbody></table><h3 id="为什么MongoDB使用B树而MySQL用B-树"><a href="#为什么MongoDB使用B树而MySQL用B-树" class="headerlink" title="为什么MongoDB使用B树而MySQL用B+树"></a>为什么MongoDB使用B树而MySQL用B+树</h3><p>MongoDB面向文档存储，需快速获取整个文档（B树的内部节点存储完整数据，可以减少寻址次数）</p><p>MySQL侧重范围查询和事务处理（B+树的顺序访问特性更优秀）</p><h3 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h3><ul><li>前缀索引优化</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> <span class="keyword">ADD</span> INDEX (name(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><ul><li>覆盖索引优化</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建包含所有查询字段的索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_cover <span class="keyword">ON</span> orders(user_id, status, create_time);</span><br></pre></td></tr></table></figure><h3 id="为什么有时索引会失效或选错索引"><a href="#为什么有时索引会失效或选错索引" class="headerlink" title="为什么有时索引会失效或选错索引"></a>为什么有时索引会失效或选错索引</h3><p>索引失效的常见场景：</p><ul><li>违反最左前缀原则</li><li>对索引列进行运算或函数操作</li><li>使用 <code>or</code> 连接非索引列</li><li>索引列存在大量重复值，如性别</li><li>使用 <code>like &#39;%地址&#39;</code></li></ul><p>选错索引的常见原因：</p><ul><li><p>统计信息不准确：优化器依赖的统计信息（如 <code>cardinality</code>）过时，误判索引效率。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 表数据分布已变化，但统计信息未更新</span><br><span class="line">ANALYZE TABLE users; -- 手动更新统计信息</span><br></pre></td></tr></table></figure></li><li><p>索引覆盖不足：索引未覆盖查询所需字段，导致回表成本过高。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 索引 (a) 无法覆盖 SELECT *</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用覆盖索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">table</span> <span class="keyword">ADD</span> INDEX idx_a_b_c (a, b, c);</span><br></pre></td></tr></table></figure></li></ul><h3 id="组合索引-a-b-c-在查询-WHERE-b-1-AND-c-2-ORDER-BY-a-中的使用情况"><a href="#组合索引-a-b-c-在查询-WHERE-b-1-AND-c-2-ORDER-BY-a-中的使用情况" class="headerlink" title="组合索引 (a, b, c) 在查询 WHERE b=1 AND c=2 ORDER BY a 中的使用情况"></a>组合索引 <code>(a, b, c)</code> 在查询 <code>WHERE b=1 AND c=2 ORDER BY a</code> 中的使用情况</h3><p><strong>WHERE 条件 (<code>b=1 AND c=2</code>)</strong></p><ul><li>由于缺少最左列 <code>a</code>，无法直接使用索引的<strong>快速查找</strong>（B+Tree 的有序性在跳过 <code>a</code> 后失效）。</li><li>但优化器可能选择 <strong>全索引扫描 (Full Index Scan)</strong> 或 <strong>索引范围扫描</strong>：<ul><li>遍历整个索引 <code>(a, b, c)</code> 的叶子节点。</li><li>逐行检查 <code>b=1 AND c=2</code> 的条件（类似全表扫描，但扫描的是索引而非数据行）。</li></ul></li></ul><p><strong>ORDER BY a</strong></p><ul><li>✅ <strong>索引天然按 <code>a</code> 排序</strong>：<br>组合索引 <code>(a, b, c)</code> 本身按 <code>a</code> 升序排列（若 <code>a</code> 相同，再按 <code>b</code>、<code>c</code> 排）。<br>→ 因此 <code>ORDER BY a</code> <strong>可直接利用索引顺序，避免额外的排序操作</strong>（避免 <code>Filesort</code>）。</li></ul><p><strong>索引覆盖 (Covering Index)</strong></p><ul><li>如果查询的列<strong>全部包含在索引中</strong>（如 <code>SELECT a, b, c</code>），则：<br>✅ 引擎只需扫描索引，<strong>无需回表</strong>查数据行（更快）。</li></ul><h2 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h2><h3 id="慢SQL优化全流程"><a href="#慢SQL优化全流程" class="headerlink" title="慢SQL优化全流程"></a>慢SQL优化全流程</h3><p><strong>阶段1：问题定位与数据采集</strong></p><ul><li>开启慢日志查询</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 动态开启（重启失效）</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log <span class="operator">=</span> <span class="string">&#x27;ON&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> long_query_time <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">-- 阈值设为1秒</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log_file <span class="operator">=</span> <span class="string">&#x27;/var/log/mysql/slow.log&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 永久配置（my.cnf）</span><br><span class="line">[mysqld]</span><br><span class="line">slow_query_log = 1</span><br><span class="line">long_query_time = 1</span><br><span class="line">log_queries_not_using_indexes = 1  -- 记录未走索引的查询</span><br></pre></td></tr></table></figure><ul><li>实时监测工具</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前运行中的慢查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.PROCESSLIST </span><br><span class="line"><span class="keyword">WHERE</span> <span class="type">TIME</span> <span class="operator">&gt;</span> <span class="number">2</span> <span class="keyword">AND</span> COMMAND <span class="operator">=</span> <span class="string">&#x27;Query&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用Percona Toolkit抓取问题SQL</span></span><br><span class="line">pt<span class="operator">-</span>query<span class="operator">-</span>digest <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysql<span class="operator">/</span>slow.log</span><br></pre></td></tr></table></figure><ul><li>关键性能指标</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">重点监控项：</span><br><span class="line">- QPS/TPS波动</span><br><span class="line">- CPU使用率（特别是%sys）</span><br><span class="line">- 锁等待时间(Innodb_row_lock_time_avg)</span><br><span class="line">- 缓冲池命中率(Innodb_buffer_pool_reads)</span><br></pre></td></tr></table></figure><p>Q：<code>IN</code> 和 <code>EXISTS</code> 的区别</p><p>当使用 <code>IN</code> 时，MySQL 会首先执行子查询，然后将子查询的结果集用于外部查询的条件。这意味着子查询的结果集需要全部加载到内存中。</p><p>而 <code>EXISTS</code> 会对外部查询的每一行，执行一次子查询。如果子查询返回任何行，则 <code>EXISTS</code> 条件为真。<code>EXISTS</code> 关注的是子查询是否返回行，而不是返回的具体值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- IN 的临时表可能成为性能瓶颈</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> user_id <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> amount <span class="operator">&gt;</span> <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- EXISTS 可以利用关联索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users u</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> orders o </span><br><span class="line">            <span class="keyword">WHERE</span> o.user_id <span class="operator">=</span> u.id <span class="keyword">AND</span> o.amount <span class="operator">&gt;</span> <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><code>IN</code> 适用于子查询结果集较小的情况。如果子查询返回大量数据，<code>IN</code> 的性能可能会下降，因为它需要将整个结果集加载到内存。</p><p>而 EXISTS 适用于子查询结果集可能很大的情况。由于 <code>EXISTS</code> 只需要判断子查询是否返回行，而不需要加载整个结果集，因此在某些情况下性能更好，特别是当子查询可以使用索引时。</p><p><strong>NULL值陷</strong></p><p><code>IN</code>: 如果子查询的结果集中包含 <code>NULL</code> 值，可能会导致意外的结果。例如，<code>WHERE column IN (subquery)</code>，如果 <code>subquery</code> 返回 <code>NULL</code>，则 <code>column IN (subquery)</code> 永远不会为真，除非 <code>column</code> 本身也为 <code>NULL</code>。</p><p><code>EXISTS</code>: 对 <code>NULL</code> 值的处理更加直接。<code>EXISTS</code> 只是检查子查询是否返回行，不关心行的具体值，因此不受 <code>NULL</code> 值的影响。</p><h3 id="为什么有时只查询一行但是很慢"><a href="#为什么有时只查询一行但是很慢" class="headerlink" title="为什么有时只查询一行但是很慢"></a>为什么有时只查询一行但是很慢</h3><ol><li>数据库表中数据量增加：随着表中数据量的增加，查询一行的时间可能会变得更长。</li><li>索引失效：如果查询条件中使用的列没有索引，或者索引失效（例如索引统计信息过期或者索引损坏），数据库可能会执行全表扫描或者其他低效的查询方法，从而导致查询一行的性能下降。</li><li>查询复杂度增加：如果查询的复杂度增加，例如涉及到多个表的联接、子查询、聚合函数等，查询一行的性能可能会受到影响。</li><li>数据库服务器负载增加：如果数据库服务器负载增加，例如同时有大量的查询和写入操作，数据库的性能可能会下降，从而导致查询一行变得很慢。</li></ol><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务的基本特性和隔离级别"><a href="#事务的基本特性和隔离级别" class="headerlink" title="事务的基本特性和隔离级别"></a>事务的基本特性和隔离级别</h3><p>事务保证一组操作要么全部成功，要么全部失败。在 MySQL 中，事务支持是在引擎层实现的。</p><table><thead><tr><th>基本特性</th><th>说明</th></tr></thead><tbody><tr><td>原子性（<code>atomicity</code>）</td><td>事务中的操作要么全都执行，要么都不执行</td></tr><tr><td>一致性（<code>consistency</code>）</td><td>事务的执行要保证数据的完整性和一致性</td></tr><tr><td>隔离性（<code>isolation</code>）</td><td>事务的执行互不干扰</td></tr><tr><td>持久性（<code>durability</code>）</td><td>事务一旦提交，对数据的修改就永久保存到数据库中，不可撤销</td></tr></tbody></table><table><thead><tr><th>事务可能引发的问题</th><th>说明</th></tr></thead><tbody><tr><td>脏读</td><td>A 事务读取 B 事务尚未提交的修改</td></tr><tr><td>不可重复读</td><td>A 事务多次读取同一数据，结果前后不一致</td></tr><tr><td>幻读</td><td>A 事务多次读取，数据总量前后不一致</td></tr></tbody></table><table><thead><tr><th>隔离级别</th><th>说明</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td><code>read uncommitted</code></td><td>一个事务执行过程中，能看到其他未提交事务做的变更</td><td>✓</td><td>✓</td><td>✓</td></tr><tr><td><code>read committed</code></td><td>一个事务执行过程中，能看到其他已提交事务做的变更（MySQL 会在每个 SQL 语句开始执行时创建一个视图）</td><td></td><td>✓</td><td>✓</td></tr><tr><td><code>repeatable read</code></td><td>一个事务执行过程中，其他事务的变更对它不可见（MySQL 会在事务启动时创建一个视图，整个事务执行期间都使用这个视图）</td><td></td><td></td><td>✓</td></tr><tr><td><code>serializable</code></td><td>事务串行执行，隔离级别最高，不会出现上面所说的问题，但相应的效率也最低</td><td></td><td></td><td></td></tr></tbody></table><h3 id="MVCC实现原理"><a href="#MVCC实现原理" class="headerlink" title="MVCC实现原理"></a><code>MVCC</code>实现原理</h3><ul><li><code>Undo log</code>：每条数据维护多个历史版本</li><li><code>ReadView</code>：快照</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ReadView结构：</span><br><span class="line">&#123;</span><br><span class="line">  creator_trx_id: 150,      -- 当前事务ID</span><br><span class="line">  m_ids: [100, 120, 140],   -- 活跃事务ID列表</span><br><span class="line">  min_trx_id: 100,          -- 最小活跃事务ID</span><br><span class="line">  max_trx_id: 150           -- 预分配最大事务ID</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可见性判断规则</strong>：</p><ol><li>数据版本<code>trx_id</code> &lt; <code>min_trx_id</code> → 可见</li><li><code>trx_id</code>在<code>m_ids</code>中 → 不可见</li><li><code>trx_id</code> &gt;&#x3D; <code>max_trx_id</code> → 不可见</li></ol><p>InnoDB默认会为每行数据生成两个隐藏列：</p><ul><li><code>DB_TRX_ID</code>：最后修改该行的事务ID</li><li><code>DB_ROLL_PTR</code>：指向<code>Undo Log</code>的回滚指针</li></ul><p>不同隔离级别下<code>ReadView</code>的生成时机：</p><ul><li><code>READ COMMITTED(RC)</code>：每次<code>SELECT</code>都会创建新的<code>ReadView</code></li><li><code>REPEATABLE READ(RR)</code>：事务中第一次<code>SELECT</code>时创建<code>ReadView</code></li></ul><h3 id="什么是间隙锁和临键锁"><a href="#什么是间隙锁和临键锁" class="headerlink" title="什么是间隙锁和临键锁"></a>什么是间隙锁和临键锁</h3><p><strong>间隙锁（<code>Gap Lock</code>）</strong></p><p>锁定记录之间的间隙，不锁定记录本身。防止幻读。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 表数据：5, 10, 15</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">10</span> <span class="keyword">AND</span> id <span class="operator">&lt;</span> <span class="number">20</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>这条语句会锁定区间 <code>(10,15)</code>、<code>(15,+∞)</code>，在事务执行期间，其他事务无法在这两个区间插入数据</p><p><strong>临键锁（<code>Next-Key Lock</code>）</strong></p><p>锁定记录本身及之前的间隙。同时防止幻读和不可重复读。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 事务A执行：</span><br><span class="line">SELECT * FROM users WHERE id &gt; 15 AND id &lt; 25 FOR UPDATE;</span><br><span class="line">-- 假设存在id=20的记录，临键锁会锁定：(15,20],(20,+∞)</span><br></pre></td></tr></table></figure><h3 id="什么是两阶段提交"><a href="#什么是两阶段提交" class="headerlink" title="什么是两阶段提交"></a>什么是两阶段提交</h3><p>两阶段提交的核心目的之一，就是为了协调 <strong>redo log (InnoDB 引擎层)</strong> 和 <strong>binlog (Server 层)</strong> 这两种位于不同层次、有各自内存 buffer 和刷盘策略的日志，在 <strong>刷盘时机</strong> 上保持一致，确保崩溃恢复后数据状态一致。</p><ol><li><strong>Prepare 阶段 (InnoDB):</strong> 将事务的 redo log 写入 redo log buffer <strong>并刷盘</strong>（根据 <code>innodb_flush_log_at_trx_commit</code>，通常此时已强制刷盘），标记状态为 <code>PREPARE</code>。<strong>此时 redo log 在磁盘上持久化了“这个事务准备修改什么”。</strong></li><li><strong>Write &amp; Sync Binlog 阶段 (Server):</strong> 将事务的 binlog 事件写入 binlog cache <strong>并刷盘</strong>（根据 <code>sync_binlog</code>，通常此时也强制刷盘）。<strong>此时 binlog 在磁盘上持久化了“这个事务执行了什么操作”。</strong></li><li><strong>Commit 阶段 (InnoDB):</strong> 在 redo log 中写入一个 <code>COMMIT</code> 标记（通常只需写 redo log buffer，不一定立刻刷盘，因为前两步已保证关键信息持久化）。<strong>标记事务在引擎层正式提交。</strong></li></ol><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h3 id="什么是分库分表"><a href="#什么是分库分表" class="headerlink" title="什么是分库分表"></a>什么是分库分表</h3><ol><li><strong>分库 (Database Sharding):</strong><ul><li><strong>概念：</strong> 将一个数据库中的数据，按照某种规则（如用户ID、订单日期、地理位置等）分散到多个<strong>物理上独立</strong>的数据库实例中。</li><li><strong>目的：</strong><ul><li><strong>分担写负载&#x2F;读负载：</strong> 多个数据库实例可以同时处理写入和读取请求，显著提升整体吞吐量。</li><li><strong>突破单机连接数限制：</strong> 每个数据库实例有自己的连接池。</li><li><strong>提高可用性：</strong> 一个数据库实例故障，不影响其他实例上的服务（需要配合高可用方案）。</li><li><strong>资源隔离：</strong> 不同业务模块或不同类型的数据可以部署到不同的数据库集群，互不影响。</li></ul></li></ul></li><li><strong>分表 (Table Sharding&#x2F;Partitioning):</strong><ul><li><strong>概念：</strong> 将一张表中的数据，按照某种规则（通常是基于某个字段的值，如用户ID、时间戳、哈希值等）分散到<strong>同一个数据库实例内</strong>的多张结构相同的表中，或者分散到<strong>不同数据库实例</strong>的多张表中（此时是分库分表的结合）。</li><li><strong>目的：</strong><ul><li><strong>解决单表数据量过大问题：</strong> 这是最核心的驱动力。单表数据量过大（如数千万、上亿行）会导致索引树变得非常深，查询效率急剧下降，DDL操作（如加索引、修改表结构）耗时极长且可能锁表，数据备份恢复困难。</li><li><strong>提升查询效率：</strong> 针对特定分片键的查询，可以快速定位到具体的分片表，避免扫描全量数据。</li><li><strong>减少锁竞争：</strong> 写操作分散到多张表，减少了锁争用的概率。</li></ul></li></ul></li></ol><h3 id="常见拆分维度"><a href="#常见拆分维度" class="headerlink" title="常见拆分维度"></a>常见拆分维度</h3><ul><li><strong>水平拆分 (Horizontal Sharding&#x2F;Partitioning):</strong><ul><li>按行拆分。将表中的不同行记录分散到不同的库&#x2F;表。</li><li>拆分规则：基于某个字段的值（分片键），如：<ul><li><strong>范围分片：</strong> 按时间范围（如按月、按年）、按ID范围（如 1-100万在表1，100万-200万在表2）。</li><li><strong>哈希分片：</strong> 对分片键进行哈希运算，根据哈希值取模或其他算法分配到不同库表。能较均匀分布数据，但范围查询困难。</li><li><strong>地理位置分片：</strong> 按用户或业务所属地区。</li><li><strong>业务分片：</strong> 按业务线、租户ID等。</li></ul></li></ul></li><li><strong>垂直拆分 (Vertical Sharding&#x2F;Partitioning):</strong><ul><li>按列拆分。将一张宽表的不同列拆分到不同的库&#x2F;表中。</li><li>通常用于：<ul><li>将访问频率高的列和访问频率低的列（如大文本、BLOB）分开。</li><li>将核心业务字段和扩展字段分开。</li><li>将不同业务模块的字段拆分到独立的库或表中（这通常也属于分库的范畴）。</li></ul></li></ul></li></ul><h3 id="分库分表带来的挑战"><a href="#分库分表带来的挑战" class="headerlink" title="分库分表带来的挑战"></a>分库分表带来的挑战</h3><ul><li><strong>分布式事务：</strong> 跨库&#x2F;跨表的操作难以保证强一致性，需要使用分布式事务解决方案（如2PC, 3PC, TCC, Saga, 本地消息表等），增加了复杂性和性能开销。</li><li><strong>跨库&#x2F;跨表JOIN：</strong> 原本简单的JOIN查询变得非常困难且低效，通常需要业务层处理（多次查询+内存JOIN）或使用异构索引（如Elasticsearch）。</li><li><strong>全局唯一主键：</strong> 单机自增ID不再适用，需要分布式ID生成方案（Snowflake, UUID, Redis, 数据库号段等）。</li><li><strong>分片键选择：</strong> 分片键的选择至关重要，直接影响数据分布均匀性、查询效率、扩容难易度。一旦选定，后期修改成本极高。</li><li><strong>扩容复杂性：</strong> 水平扩容（增加分片节点）通常涉及数据迁移，需要精心设计，可能影响服务。</li><li><strong>运维复杂度：</strong> 需要管理更多的数据库实例和表，监控、备份、升级、故障排查等运维工作量和复杂度成倍增加。</li><li><strong>SQL限制：</strong> 部分SQL语句（如未带分片键的条件查询、复杂子查询、排序分页）可能无法高效执行或需要改写。</li></ul><h3 id="多大的数据量需要考虑分库分表"><a href="#多大的数据量需要考虑分库分表" class="headerlink" title="多大的数据量需要考虑分库分表"></a>多大的数据量需要考虑分库分表</h3><p><strong>这是一个非常常见但也非常难给出绝对数字的问题。没有放之四海而皆准的阈值，需要综合考量多个因素：</strong></p><ol><li><strong>数据量 (最核心因素)：</strong><ul><li><strong>单表行数：</strong> 这是最直观的指标。业界经验值通常认为：<ul><li><code>百万级别 (1M+)</code>：需要开始关注单表性能，优化索引和SQL。</li><li><code>千万级别 (10M+)</code>：性能瓶颈开始显现（如复杂查询变慢、count(<em>)慢、DDL操作耗时）。*<em>这是需要认真评估是否需要分表的重要信号区。</em></em></li><li><code>亿级别 (100M+)</code>：<strong>绝大多数情况下，单表已难以支撑高效操作，强烈建议进行分表。</strong> 索引维护成本、查询效率、维护操作（备份、迁移、加字段）都成为严重问题。</li></ul></li><li><strong>表数据大小：</strong> 即使行数不多，但如果单行数据非常大（如包含大文本、BLOB字段），导致单表数据文件巨大（如几十GB甚至上百GB），也会严重影响性能（特别是全表扫描、备份恢复）和磁盘IO，需要考虑垂直拆分或分表。</li></ul></li><li><strong>并发访问量 (QPS&#x2F;TPS)：</strong><ul><li>即使数据量不大，但<strong>极高的并发读写请求</strong>也可能压垮单库单表（连接数耗尽、CPU&#x2F;IO瓶颈、锁竞争激烈）。</li><li>如果单库实例的连接数、CPU利用率、磁盘IO持续在高位（如&gt;70%），且优化SQL和索引效果有限，就需要考虑分库来分担负载。</li></ul></li><li><strong>硬件配置：</strong><ul><li>使用顶配的SSD、大内存、多核CPU的数据库服务器，能支撑的单表数据量和并发量远高于普通配置的机器。评估是否需要分库分表时，要基于当前和未来规划的实际硬件水平。</li></ul></li><li><strong>业务复杂度和查询模式：</strong><ul><li>业务逻辑简单，查询模式固定（总是通过高效索引访问），单表能支撑的数据量会更大。</li><li>业务复杂，涉及多表关联、复杂查询、聚合、排序分页等操作，即使数据量不大，也可能因为查询效率低下而需要提前考虑拆分。</li></ul></li><li><strong>增长速度：</strong><ul><li>数据量增长<strong>非常快</strong>的业务（如日增百万级记录），即使当前数据量不大，也需要提前规划分库分表方案，避免未来被动。</li></ul></li><li><strong>可用性和扩展性要求：</strong><ul><li>对系统可用性要求极高（如金融核心系统），需要避免单点故障，分库本身（配合主从复制）能提高可用性。</li><li>明确知道业务未来会快速增长，需要系统具备水平扩展能力，分库分表是核心手段。</li></ul></li></ol><p><strong>总结判断标准</strong>（经验法则，非绝对）</p><ol><li><strong>预警信号 (开始认真评估)：</strong><ul><li>单表行数逼近或超过 <code>500万 - 1000万</code>。</li><li>单表数据文件大小达到 <code>几十GB</code>。</li><li>关键业务查询响应时间明显变长（&gt;几百毫秒），且优化空间有限。</li><li>DDL操作（如加索引、改字段）耗时过长（&gt;分钟级），影响业务。</li><li>数据库服务器CPU、IO、连接数等关键指标持续高位（&gt;70%）。</li><li>数据量或并发量预计在未来6-12个月内会增长数倍。</li></ul></li><li><strong>强烈建议实施：</strong><ul><li>单表行数超过 <code>5000万 - 1亿</code>。</li><li>单表数据文件大小达到 <code>数百GB</code>。</li><li>数据库性能瓶颈成为业务发展的明显阻碍。</li><li>高并发场景下，频繁出现锁超时、连接池耗尽等问题。</li></ul></li></ol><p><strong>重要建议</strong></p><ol><li><strong>不要过早优化：</strong> 分库分表带来巨大复杂性。在数据量和并发量真正成为瓶颈之前，优先使用更简单的手段：<ul><li><strong>硬件升级：</strong> 提升CPU、内存、换SSD。</li><li><strong>数据库优化：</strong> 优化慢查询SQL、合理设计索引、调整数据库参数。</li><li><strong>读写分离：</strong> 用主库写，多个从库读，分担读负载。</li><li><strong>缓存：</strong> 使用Redis、Memcached等缓存热点数据，减少数据库访问。</li><li><strong>归档&#x2F;清理：</strong> 将历史冷数据迁移到归档库或删除。</li><li><strong>数据库分区 (Partitioning)：</strong> 如果数据库本身支持（如MySQL的Partitioning），可以在单库内进行水平分区，管理比单表大得多的数据量，比应用层分表简单很多。但分区不能解决单库资源瓶颈（CPU&#x2F;IO&#x2F;连接数）和写负载问题。</li></ul></li><li><strong>精心设计：</strong> 一旦决定分库分表，必须投入精力做好设计，尤其是<strong>分片键的选择</strong>、<strong>拆分规则</strong>、<strong>分布式ID</strong>、<strong>分布式事务方案</strong>、<strong>数据迁移和扩容方案</strong>。前期设计失误会导致后期维护成本剧增。</li><li><strong>选择合适的中间件：</strong> 使用成熟的数据库中间件（如ShardingSphere, MyCat, Vitess等）可以大大简化分库分表的开发和管理工作，它们帮你处理路由、分布式事务、跨库查询等难题。</li></ol><p><strong>结论：</strong> 分库分表是解决海量数据和高并发问题的终极手段之一，但其复杂性极高。触发点通常是单表数据量达到<strong>千万级（10M+）并伴随性能瓶颈</strong>，或<strong>高并发导致单库资源耗尽</strong>。务必优先尝试更简单的优化方案，并在真正需要时，进行充分评估和精心设计。没有固定的“多大必须分”的数字，必须结合具体业务场景、数据特性、硬件配置和增长预期综合判断。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="char-100-和-varchar-100-的区别"><a href="#char-100-和-varchar-100-的区别" class="headerlink" title="char(100) 和 varchar(100) 的区别"></a>char(100) 和 varchar(100) 的区别</h3><p><strong>核心区别总结</strong></p><table><thead><tr><th align="left"><strong>特性</strong></th><th align="left"><code>CHAR(100)</code></th><th align="left"><code>VARCHAR(100)</code></th></tr></thead><tbody><tr><td align="left"><strong>类型名称</strong></td><td align="left">定长字符串</td><td align="left">变长字符串</td></tr><tr><td align="left"><strong>存储方式</strong></td><td align="left">始终占用 100 字符空间（不足补空格）</td><td align="left">按实际字符数存储 + 额外长度开销</td></tr><tr><td align="left"><strong>存储 “abc” 的占用</strong></td><td align="left">100 字节（固定）</td><td align="left">3 字节 + 1~2 字节长度开销 ≈ 4 字节</td></tr><tr><td align="left"><strong>空格处理</strong></td><td align="left">插入时会自动补空格，查询时自动去除</td><td align="left">保留原始空格，不自动补齐</td></tr><tr><td align="left"><strong>查询速度</strong></td><td align="left">更快（定长，直接定位）</td><td align="left">稍慢（需计算位置）</td></tr><tr><td align="left"><strong>适用场景</strong></td><td align="left">长度固定的数据（如国家代码、MD5）</td><td align="left">长度不固定的数据（如用户名、地址）</td></tr></tbody></table><h3 id="为什么不建议使用-text-作为字段类型"><a href="#为什么不建议使用-text-作为字段类型" class="headerlink" title="为什么不建议使用 text 作为字段类型"></a>为什么不建议使用 text 作为字段类型</h3><ol><li><p><strong>性能影响</strong>：</p><p>- <strong>查询性能</strong>：<code>TEXT</code>字段通常比定长或较短的变长字符串（如<code>VARCHAR</code>）占用更多空间。当查询需要读取或排序这些字段时，由于数据量大，I&#x2F;O操作和内存消耗会增加，从而降低查询速度。</p><p>- <strong>临时表和排序</strong>：如果查询涉及对<code>TEXT</code>字段进行排序或分组，MySQL等数据库可能会使用磁盘临时表而非内存临时表，因为内存临时表有大小限制，这会导致性能下降。</p></li><li><p><strong>内存使用</strong>：</p><p>- 数据库在读取行时，通常会将整行数据加载到内存中（尤其是使用InnoDB引擎时，会读取整个页）。如果表中包含多个<code>TEXT</code>字段，即使查询不需要这些字段，也可能导致内存浪费，因为行数据可能被部分读取（但InnoDB的页大小固定，一页可能包含多行，所以大字段会减少一页中存放的行数，增加I&#x2F;O次数）。</p></li><li><p><strong>索引限制</strong>：</p><p>- 在MySQL中，对于<code>TEXT</code>类型（以及<code>BLOB</code>类型）的字段，如果要在其上创建索引，必须指定前缀长度（即只对字段的前N个字符建立索引）。这可能导致索引无法完全覆盖字段内容，影响索引效率。</p><p>- 此外，<code>TEXT</code>字段不能作为主键（或唯一索引的完整字段）使用，因为可能会超过索引的最大长度限制。</p></li><li><p><strong>存储空间</strong>：</p><p>- <code>TEXT</code>类型的数据存储在行外（off-page），即实际数据存储在单独的区域，而行数据中只存储指向实际数据的指针。这会导致额外的I&#x2F;O操作（因为需要访问两个地方才能获取完整数据），尤其是在使用<code>SELECT *</code>查询时。</p></li><li><p><strong>默认值问题</strong>：</p><p>- 在MySQL中，<code>TEXT</code>字段不能有默认值（除了MySQL 8.0.13之后支持对<code>TEXT</code>类型设置默认值为表达式，但直接的字面量默认值仍不被允许）。这可能导致应用层需要处理空值的情况。</p></li><li><p><strong>不必要的灵活性</strong>：</p><p>- 使用<code>TEXT</code>类型可能会允许存储非常大的数据，但实际业务可能并不需要这么大的存储。如果字段实际存储的内容都很短（例如，一个简介字段通常只有几百个字符），那么使用<code>VARCHAR</code>更为合适，因为<code>VARCHAR</code>在存储短字符串时效率更高。</p></li></ol><p><strong>建议的替代方案</strong>：</p><p>- 如果字符串长度有限且可预估（例如，小于65535字节），优先使用<code>VARCHAR(n)</code>，其中<code>n</code>为最大预期长度。</p><p>- 对于非常大的文本数据（如文章内容），确实需要使用<code>TEXT</code>类型时，考虑将其单独存放在一张表中，与原表通过外键关联，避免大字段影响主表的查询效率。</p><p>- 在查询时避免使用<code>SELECT *</code>，只选择需要的字段，特别是避免不必要的<code>TEXT</code>字段。</p><h3 id="查询语句的执行顺序"><a href="#查询语句的执行顺序" class="headerlink" title="查询语句的执行顺序"></a>查询语句的执行顺序</h3><p>MySQL 分为 server 层和存储引擎层。</p><p>server 层涵盖 MySQL 大多数核心功能（如存储过程、触发器、视图等）和所有内置函数（如日期、时间、数学函数等）。</p><p>存储引擎层负责数据的存储和提取。</p><p><code>from</code> -&gt; <code>where</code> -&gt; <code>group by</code> -&gt; <code>having</code> -&gt; <code>select</code> -&gt; <code>distinct</code> -&gt; <code>order by</code> -&gt; <code>limit</code></p><img src="/post/32511a71/1726212535664-4bb3f3ff-704a-4706-84c8-a046a8486657.webp" class="" title="img"><h3 id="一条查询语句的执行流程"><a href="#一条查询语句的执行流程" class="headerlink" title="一条查询语句的执行流程"></a>一条查询语句的执行流程</h3><h3 id="一条更新语句的执行过程"><a href="#一条更新语句的执行过程" class="headerlink" title="一条更新语句的执行过程"></a>一条更新语句的执行过程</h3><p>一条 <code>UPDATE</code> 语句在 MySQL（尤其是 InnoDB 存储引擎）中的执行过程是一个涉及多个组件（解析器、优化器、执行引擎、存储引擎、缓冲池、日志系统、锁机制等）协同工作的复杂过程。下面是其核心步骤的详细分解：</p><ol><li><strong>连接与请求接收</strong></li></ol><ul><li>客户端应用程序（如 Java 程序、MySQL CLI）通过连接器建立与 MySQL 服务器的连接。</li><li>服务器验证用户身份和权限。</li><li>客户端发送 <code>UPDATE</code> SQL 语句到服务器。</li></ul><ol start="2"><li><strong>解析与优化（Server 层）</strong></li></ol><ul><li><strong>解析器：</strong><ul><li>进行词法分析：识别 <code>UPDATE</code>、表名、<code>SET</code>、列名、<code>=</code>、值、<code>WHERE</code> 等关键字和标识符。</li><li>进行语法分析：检查语句是否符合 SQL 语法规则，构建抽象语法树。</li></ul></li><li><strong>预处理器：</strong><ul><li>检查表和列是否存在。</li><li>解析名称和别名。</li><li>检查用户是否有执行 <code>UPDATE</code> 的权限。</li></ul></li><li><strong>优化器：</strong><ul><li><strong>关键步骤！</strong> 基于统计信息（表大小、索引分布、基数等）选择它认为最高效的执行计划。</li><li>决定：<ul><li>使用哪个索引（主键索引、二级索引）来定位需要更新的行。这是影响速度的关键因素。</li><li>是否可以使用索引条件下推。</li><li>是否需要进行全表扫描（如果 <code>WHERE</code> 条件无法有效利用索引）。</li></ul></li><li>生成具体的执行计划。</li></ul></li></ul><ol start="3"><li><strong>执行引擎调用存储引擎（Server 层 -&gt; 存储引擎层）</strong></li></ol><ul><li>执行引擎根据优化器选择的执行计划，调用存储引擎（InnoDB）提供的接口来执行实际的数据查找和修改操作。</li></ul><ol start="4"><li><strong>InnoDB 存储引擎内部处理</strong></li></ol><ul><li><strong>缓冲池查找：</strong><ul><li>执行引擎告知 InnoDB 要更新哪些行（通过 <code>WHERE</code> 条件定位）。</li><li>InnoDB 首先在 <strong>Buffer Pool（缓冲池）</strong> 中查找这些行所在的数据页。</li><li>如果数据页不在 Buffer Pool 中，则从磁盘上的 <code>.ibd</code> 数据文件中将其加载到 Buffer Pool。</li></ul></li><li><strong>写 Undo Log：</strong><ul><li><strong>关键步骤！</strong> 在修改 Buffer Pool 中的数据页<strong>之前</strong>，InnoDB 会先将这行数据的旧版本（修改前的状态）写入 <strong>Undo Log（回滚日志）</strong>。</li><li><strong>目的：</strong><ul><li>支持事务回滚：如果事务需要回滚，可以用 Undo Log 中的旧数据覆盖修改。</li><li>实现 MVCC：其他并发事务如果需要读取这行数据的旧版本（基于它们的 Read View），可以通过 Undo Log 链找到。</li></ul></li><li>Undo Log 存储在 Undo Tablespaces 中。</li></ul></li><li><strong>修改 Buffer Pool：</strong><ul><li>将 Buffer Pool 中对应的数据页中的行数据更新为新值。</li><li>此时数据页变成<strong>脏页</strong>（内存中的数据与磁盘数据不一致）。</li></ul></li><li><strong>写 Redo Log Buffer：</strong><ul><li><strong>关键步骤！</strong> 在脏页刷盘<strong>之前</strong>，InnoDB 会先把对数据页所做的物理修改（字节级别的变化）记录到内存中的 <strong>Redo Log Buffer（重做日志缓冲区）</strong>。</li><li><strong>目的：</strong> 保证事务的持久性。即使系统崩溃，重启后也能根据 Redo Log 重做未持久化的修改。</li></ul></li><li><strong>处理二级索引（如果涉及）：</strong><ul><li>如果更新的列包含在二级索引中，或者更新影响了索引列的值（如 <code>UPDATE users SET username=&#39;new&#39; WHERE id=1</code>，且 <code>username</code> 上有索引），则需要更新对应的二级索引页。</li><li>更新二级索引页同样遵循“写 Undo Log -&gt; 修改 BP -&gt; 写 Redo Log Buffer”的过程。</li><li>如果启用 <strong>Change Buffer</strong>，对于非唯一的二级索引的更新操作（INSERT&#x2F;DELETE&#x2F;UPDATE），可能不会立即加载索引页到 BP，而是先将变更记录到 Change Buffer 中，等到后续需要读取该索引页时再合并操作，从而减少随机 I&#x2F;O。</li></ul></li></ul><ol start="5"><li><strong>事务提交（关键步骤！）</strong></li></ol><ul><li>当用户显式执行 <code>COMMIT</code> 或自动提交开启时，事务进入提交阶段。</li><li><strong>Write Redo Log：</strong><ul><li><strong>两阶段提交的核心第一步：</strong> 将 Redo Log Buffer 中与该事务相关的所有日志记录<strong>顺序、快速</strong>地写入（<code>write()</code> 系统调用）磁盘上的 <strong>Redo Log File（通常是 <code>ib_logfile0</code>, <code>ib_logfile1</code>）</strong>。此时数据可能还在内存（Buffer Pool）。</li><li><strong><code>fsync()</code>：</strong> 为了确保日志真正落盘（防止操作系统缓存丢失），通常需要调用 <code>fsync()</code>（或配置决定的类似机制）强制将文件系统缓存中的日志数据刷到物理磁盘。<strong>这是保证持久性（D）的关键点，也是相对耗时的操作。</strong></li></ul></li><li><strong>写 Binlog（如果启用）：</strong><ul><li>在写入 Redo Log <strong>之后</strong>（在组提交优化下顺序可能不同，但逻辑上 Redo Prepare 在 Binlog 之前），Server 层会将更新操作的逻辑语句或行变更写入 <strong>Binlog（二进制日志）</strong>。Binlog 用于主从复制和数据恢复。</li><li>同样需要 <code>fsync()</code> 确保 Binlog 落盘（取决于 <code>sync_binlog</code> 配置）。</li></ul></li><li><strong>Redo Log Commit：</strong><ul><li><strong>两阶段提交的核心第二步：</strong> 在 Binlog 成功写入并 <code>fsync()</code> 后，InnoDB 在 Redo Log 中写入一个特殊的 <strong>Commit Record</strong>，标记该事务<strong>已提交</strong>。</li><li>再次 <code>fsync()</code> Redo Log（如果配置需要）。</li></ul></li><li><strong>释放锁：</strong> 事务提交后，InnoDB 释放该事务持有的所有锁（行锁、间隙锁等）。</li><li><strong>返回成功：</strong> 向客户端返回执行成功的消息。</li></ul><ol start="6"><li><strong>后台刷脏页</strong></li></ol><ul><li><strong>非同步操作！</strong> 提交成功<strong>并不保证</strong>脏页立即写入磁盘数据文件（<code>.ibd</code>）。写入 Redo Log 已经保证了持久性。</li><li>InnoDB 有后台线程（Page Cleaner Thread）负责在以下时机将脏页异步刷新回磁盘：<ul><li>当 Buffer Pool 中脏页比例过高时（由 <code>innodb_max_dirty_pages_pct</code> 等参数控制）。</li><li>当系统空闲时。</li><li>当 Redo Log 空间即将用完时（需要回收旧的 Redo Log 空间，这要求对应的脏页必须先刷盘）。</li><li>关闭数据库时。</li></ul></li><li>刷脏页时，会利用 Doublewrite Buffer 机制来避免部分写失败导致的数据页损坏。</li></ul><p><strong>关键点与注意事项</strong></p><ol><li><strong>Buffer Pool 核心作用：</strong> 所有数据读写都发生在内存（Buffer Pool），极大提升性能。</li><li><strong>WAL 机制：</strong> Write-Ahead Logging (Redo Log) 是保证持久性和崩溃恢复的核心。先写日志（顺序写，快），后刷脏页（随机写，慢）。</li><li><strong>两阶段提交：</strong> 协调 Redo Log 和 Binlog 的写入，保证这两个关键日志在崩溃时状态一致，是数据一致性和主从复制的基石。</li><li><strong>Undo Log 与 MVCC：</strong> Undo Log 支持回滚和实现非锁定读（MVCC），是多版本并发控制的关键。</li><li><strong>Change Buffer：</strong> 优化非唯一二级索引更新的利器，减少随机 I&#x2F;O。</li><li><strong>锁机制：</strong> InnoDB 在查找和更新行时会加锁（行锁、间隙锁等），以保证事务的隔离性。锁在事务提交或回滚时释放。</li><li><strong>异步刷盘：</strong> 数据文件（.ibd）的写入是异步的，依赖于 Redo Log 保证持久性。</li><li><strong>性能瓶颈：</strong> <code>UPDATE</code> 性能受索引使用、锁竞争、Redo Log&#x2F;Binlog 刷盘策略、磁盘 I&#x2F;O 能力等因素影响。</li></ol><h3 id="EXPLAIN-字段说明"><a href="#EXPLAIN-字段说明" class="headerlink" title="EXPLAIN 字段说明"></a><code>EXPLAIN</code> 字段说明</h3><p>通常<code>EXPALIN</code>查询语句的输出如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="comment">// 每个select语句对应一个唯一的id</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询类型：</span></span><br><span class="line"><span class="comment">     * SIMPLE：不包含UNION或子查询的select（连接查询的每个查询都是simple查询）</span></span><br><span class="line"><span class="comment">     * PRIMARY：最外层查询</span></span><br><span class="line"><span class="comment">     * UNION</span></span><br><span class="line"><span class="comment">     * ...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="attr">&quot;select_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SIMPLE&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;users&quot;</span><span class="punctuation">,</span> <span class="comment">// 要查询的表</span></span><br><span class="line">    <span class="attr">&quot;partitions&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span> <span class="comment">// 分区信息</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 针对单表的访问方法：</span></span><br><span class="line"><span class="comment">     * system：当表中只有一条记录，并且该表使用的存储引擎的统计数据是精确的，访问方法就是system</span></span><br><span class="line"><span class="comment">     * constant：根据主键或唯一索引列与常数进行等值匹配时，访问方法就是const</span></span><br><span class="line"><span class="comment">     * eq_ref：连接查询中对被驱动表的主键或不允许为NULL的唯一索引进行等值查询时，访问方法就是eq_ref</span></span><br><span class="line"><span class="comment">     * ref：通过普通二级索引列与常量进行等值匹配时，对该表的访问方法就是 ref</span></span><br><span class="line"><span class="comment">     * ref_or_null：select * from single_table where key1 = &#x27;abc&#x27; or key1 is NULL;</span></span><br><span class="line"><span class="comment">     * index_merge：使用多个索引进行等值匹配</span></span><br><span class="line"><span class="comment">     * unique_subquery：在子查询中使用主键或不允许存储NULL值的唯一二级索引进行等值匹配</span></span><br><span class="line"><span class="comment">     * index_subquery：在子查询中使用普通二级索引进行等值匹</span></span><br><span class="line"><span class="comment">     * range：利用索引进行范围查询</span></span><br><span class="line"><span class="comment">     * index：当可以使用索引覆盖，但需要扫描全部索引记录</span></span><br><span class="line"><span class="comment">     * all：全表扫描</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ref&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;possible_keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;idx_composite&quot;</span><span class="punctuation">,</span> <span class="comment">// 可能使用的索引</span></span><br><span class="line">    <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;idx_composite&quot;</span><span class="punctuation">,</span> <span class="comment">// 实际使用的索引</span></span><br><span class="line">    <span class="attr">&quot;key_len&quot;</span><span class="punctuation">:</span> <span class="string">&quot;208&quot;</span><span class="punctuation">,</span> <span class="comment">// 实际使用的索引长度</span></span><br><span class="line">    <span class="attr">&quot;ref&quot;</span><span class="punctuation">:</span> <span class="string">&quot;const&quot;</span><span class="punctuation">,</span> <span class="comment">// 使用索引列等值查询时，与索引列进行等值匹配的对象信息</span></span><br><span class="line">    <span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="comment">// 预估需要读取的记录行数</span></span><br><span class="line">    <span class="attr">&quot;filtered&quot;</span><span class="punctuation">:</span> <span class="number">100.0</span><span class="punctuation">,</span> <span class="comment">// 过滤后剩余记录行数百分比</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 额外信息：</span></span><br><span class="line"><span class="comment">     * Using index：使用覆盖索引</span></span><br><span class="line"><span class="comment">     * Using index condition：使用索引条件下推</span></span><br><span class="line"><span class="comment">     * Using where：需要在server层判断条件是否成立</span></span><br><span class="line"><span class="comment">     * Using join buffer：执行连接查询时，被驱动表不能有效利用索引加快访问速度时，会分配一块内存用来保存被驱动表的查询结果，</span></span><br><span class="line"><span class="comment">       利用join buffer可以减少访问被驱动表的次数</span></span><br><span class="line"><span class="comment">     * Using filesort：</span></span><br><span class="line"><span class="comment">     * Using temporary</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="attr">&quot;Extra&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Using index&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><h3 id="为什么InnoDB不保存表的总行数"><a href="#为什么InnoDB不保存表的总行数" class="headerlink" title="为什么InnoDB不保存表的总行数"></a>为什么InnoDB不保存表的总行数</h3><p>与MyISAM保存表的总行数不同，InnoDB统计行数需要扫描全表，因为MVCC，同一时刻多个查询返回的行数可能不一致。</p><p>对于需要经常统计表的行数的解决办法：</p><ul><li>在缓存（如 Redis）中保存计数</li><li>在 MySQL 中保存计数</li></ul><h3 id="count-、count-1-、count-id-、count-字段-有什么区别"><a href="#count-、count-1-、count-id-、count-字段-有什么区别" class="headerlink" title="count(*)、count(1)、count(id)、count(字段)有什么区别"></a><code>count(*)、count(1)、count(id)、count(字段)</code>有什么区别</h3><table><thead><tr><th><strong>语法</strong></th><th><strong>统计逻辑</strong></th><th><strong>是否包含 NULL</strong></th></tr></thead><tbody><tr><td><code>COUNT(*)</code></td><td>统计所有行（包括所有列），即使所有字段都为 <code>NULL</code> 也会计数</td><td><strong>包含</strong></td></tr><tr><td><code>COUNT(1)</code></td><td>统计所有行（<code>1</code> 是常量表达式，与列无关）</td><td><strong>包含</strong></td></tr><tr><td><code>COUNT(id)</code></td><td>统计 <code>id</code> 列中 <strong>非 NULL</strong> 的行数（<code>id</code> 是主键或普通列）</td><td><strong>不包含 NULL</strong></td></tr><tr><td><code>COUNT(某个字段)</code></td><td>统计该字段中 <strong>非 NULL</strong> 的行数（如果字段允许 <code>NULL</code>）</td><td><strong>不包含 NULL</strong></td></tr></tbody></table><p>性能：<code>count(字段)</code> &lt; <code>count(主键)</code> &lt; <code>count(1)</code> ≈ <code>count(*)</code></p><p><code>count(主键/字段)</code> 的效率更低的原因是需要解析数据行，并拷贝要返回的字段值。</p><h3 id="InnoDB和MyISAM的区别"><a href="#InnoDB和MyISAM的区别" class="headerlink" title="InnoDB和MyISAM的区别"></a>InnoDB和MyISAM的区别</h3><table><thead><tr><th></th><th>MyISAM</th><th>InnoDB</th></tr></thead><tbody><tr><td>锁</td><td>表级锁</td><td>行级锁</td></tr><tr><td>事务支持</td><td>不支持</td><td>支持</td></tr><tr><td>索引结构</td><td>B树</td><td>B+树</td></tr><tr><td>全文检索</td><td>支持</td><td>5.5版本后支持</td></tr></tbody></table><p>总体来说，如果需要支持事务、外键约束和高并发访问，那么InnoDB是更好的选择。如果需要进行全文检索，那么MyISAM是更好的选择。但是需要注意的是，MySQL 5.5版本之后，InnoDB已经支持了全文检索。</p><h3 id="为什么不建议使用text类型"><a href="#为什么不建议使用text类型" class="headerlink" title="为什么不建议使用text类型"></a>为什么不建议使用<code>text</code>类型</h3><p>在数据库设计中，文本类型字段（如MySQL中的TEXT，PostgreSQL中的TEXT等）通常用于存储大量文本数据。虽然它们可以存储大量数据，但在某些情况下不建议使用，原因如下：</p><ol><li><strong>性能问题</strong>：TEXT类型通常存储在数据库的主表之外（比如在MySQL的InnoDB中，TEXT和BLOB类型在记录较大时可能存储在溢出页），这可能导致额外的磁盘I&#x2F;O。当查询中包含TEXT字段时，可能需要访问多个页，从而降低查询速度。</li><li><strong>内存使用</strong>：在处理查询时，数据库可能会为TEXT字段分配大量内存，尤其是当使用临时表或排序时。这可能导致内存使用过高，影响数据库性能。</li><li><strong>索引限制</strong>：对于TEXT类型，通常不能直接创建索引（除非指定前缀索引），而且前缀索引可能不够精确。在MySQL中，对TEXT列建立索引必须指定前缀长度，这可能导致索引效率不高。</li><li><strong>默认值问题</strong>：在某些数据库系统中（如MySQL 5.6之前的版本），TEXT字段不能有默认值。虽然较新的版本已经支持，但仍有其他限制。</li><li><strong>存储空间</strong>：TEXT类型通常占用更多存储空间，因为数据库可能会为这些字段分配额外的空间以应对可能的增长。</li><li><strong>复制和恢复</strong>：由于TEXT字段可能包含大量数据，在数据库复制（如主从复制）和备份恢复过程中，可能会增加网络传输和I&#x2F;O负担，导致延迟。</li><li><strong>查询优化</strong>：优化器在处理包含TEXT字段的查询时可能会选择效率较低的执行计划，因为无法准确估计TEXT字段的大小。</li><li><strong>排序和分组</strong>：如果查询需要对TEXT字段进行排序或分组，由于数据量大，可能会使用磁盘临时表，导致性能下降。</li><li><strong>应用场景不匹配</strong>：很多时候，开发者使用TEXT类型存储的数据实际上可能是一个有限长度的字符串（如地址、描述等），此时使用VARCHAR（有长度限制）更为合适，因为VARCHAR在存储和性能上通常更高效。</li></ol><p>当然，如果确实需要存储大文本（如文章内容、日志等），那么使用TEXT类型是合理的。但在不需要存储大文本的情况下，应优先选择VARCHAR等类型，并设置合适的长度限制。</p><p><strong>总结</strong>：在不需要存储大文本时，使用TEXT类型可能会带来性能、存储和功能上的限制，因此建议仅在必要时使用。</p><p><strong>建议</strong></p><table><thead><tr><th align="left"><strong>场景</strong></th><th align="left"><strong>推荐类型</strong></th></tr></thead><tbody><tr><td align="left">短文本（&lt; 255 字符）</td><td align="left"><code>VARCHAR(n)</code></td></tr><tr><td align="left">中等文本（&lt; 64KB）</td><td align="left"><code>VARCHAR(65535)</code></td></tr><tr><td align="left">超大文本（&gt; 64KB）</td><td align="left"><code>TEXT</code>（或分表存储）</td></tr></tbody></table><h3 id="redo-log、binlog有什么区别"><a href="#redo-log、binlog有什么区别" class="headerlink" title="redo log、binlog有什么区别"></a>redo log、binlog有什么区别</h3><table><thead><tr><th align="left"><strong>特性</strong></th><th align="left"><strong>Redo Log (重做日志)</strong></th><th align="left"><strong>Binlog (二进制日志)</strong></th></tr></thead><tbody><tr><td align="left"><strong>所属层级</strong></td><td align="left"><strong>InnoDB 存储引擎层</strong></td><td align="left"><strong>MySQL Server 层</strong></td></tr><tr><td align="left"><strong>主要目的</strong></td><td align="left"><strong>崩溃恢复</strong>：确保事务的持久性 (Durability)</td><td align="left"><strong>数据复制与恢复</strong>：主从复制、时间点恢复</td></tr><tr><td align="left"><strong>日志类型</strong></td><td align="left"><strong>物理日志</strong>：记录页面的物理修改</td><td align="left"><strong>逻辑日志</strong>：记录导致数据变化的 SQL 语句或行变化</td></tr><tr><td align="left"><strong>内容</strong></td><td align="left">在某个数据页上做了什么修改 (物理操作)</td><td align="left">执行了什么 SQL 语句 (Statement) 或哪些行被修改 (Row)</td></tr><tr><td align="left"><strong>写入时机</strong></td><td align="left"><strong>持续写入</strong>：事务进行中</td><td align="left"><strong>事务提交后</strong>：事务完成时才写入</td></tr><tr><td align="left"><strong>写入方式</strong></td><td align="left"><strong>顺序写入</strong> (循环文件)</td><td align="left"><strong>追加写入</strong> (文件序列)</td></tr><tr><td align="left"><strong>生命周期</strong></td><td align="left">数据刷盘后可覆盖 (循环使用)</td><td align="left">可长期保存 (需手动或策略清理)</td></tr><tr><td align="left"><strong>刷盘策略</strong></td><td align="left"><code>innodb_flush_log_at_trx_commit</code></td><td align="left"><code>sync_binlog</code></td></tr><tr><td align="left"><strong>必需性</strong></td><td align="left">InnoDB 必需，无法关闭</td><td align="left">可选择开启</td></tr><tr><td align="left"><strong>格式</strong></td><td align="left">InnoDB 私有格式</td><td align="left"><code>STATEMENT</code>, <code>ROW</code>, <code>MIXED</code></td></tr><tr><td align="left"><strong>使用场景</strong></td><td align="left">数据库崩溃后自动恢复未刷盘的数据</td><td align="left">主从复制、增量备份、时间点恢复、数据审计</td></tr></tbody></table><p><strong>日志内容与类型：</strong></p><ul><li><strong>Redo Log (物理日志):</strong> 记录的是物理级别的更改。它描述的是“在某个数据页 (Page) 上的某个偏移量处做了什么修改”。例如：“在表空间 ID 为 X，页号 Y 的数据页上，偏移量 Z 开始的 4 个字节被修改为值 0x12345678”。它不关心具体的 SQL 语句是什么，只关心数据页的物理变化。这种日志体积通常较小且高效。</li><li><strong>Binlog (逻辑日志):</strong> 记录的是逻辑级别的操作。根据 binlog 格式 (<code>STATEMENT</code>, <code>ROW</code>, <code>MIXED</code>) 的不同，它记录的内容也不同：<ul><li><code>STATEMENT</code>: 记录原始的 SQL 语句本身（如 <code>UPDATE users SET balance=100 WHERE id=5;</code>）。</li><li><code>ROW</code>: 记录被修改的行在修改前和修改后的数据（或仅修改后的数据，取决于配置）。例如，记录 <code>id=5</code> 的这行数据，<code>balance</code> 字段从 <code>50</code> 改成了 <code>100</code>。</li><li><code>MIXED</code>: 混合模式，默认使用 <code>STATEMENT</code>，但在某些可能引起主从不一致（如使用非确定性函数 <code>UUID()</code>, <code>NOW()</code>）的情况下自动切换到 <code>ROW</code>。逻辑日志更易于人类理解和用于复制，但 <code>ROW</code> 模式在批量操作时可能产生大量日志。</li></ul></li></ul><p><strong>写入时机：</strong></p><ul><li><strong>Redo Log:</strong> 在事务执行过程中 <strong>持续写入</strong>。当事务修改数据时，首先会在内存中的 Buffer Pool 修改数据页（产生脏页），同时会生成对应的 redo log 记录并 <strong>顺序、近乎实时地写入 redo log buffer</strong>，然后根据策略（<code>innodb_flush_log_at_trx_commit</code>）刷写到磁盘上的 redo log 文件。<strong>事务提交时，必须确保其对应的 redo log 已按策略持久化到磁盘</strong>，这是保证持久性的关键。</li><li><strong>Binlog:</strong> 是在事务 <strong>提交完成之前</strong>，但在确保 redo log 已持久化之后（见两阶段提交）<strong>一次性写入</strong>。事务提交时，MySQL Server 层将事务涉及的所有 binlog 事件按顺序写入 binlog cache，然后根据策略 (<code>sync_binlog</code>) 刷写到磁盘上的 binlog 文件。<strong>只有 binlog 成功写入并持久化（根据策略），事务才被认为最终提交成功</strong>。</li></ul><p><strong>持久化策略 (刷盘控制)：</strong></p><ul><li><strong>Redo Log:</strong> 由参数 <code>innodb_flush_log_at_trx_commit</code> 控制：<ul><li><code>0</code>: 每秒写入并刷盘一次（可能丢失最多1秒的事务）。</li><li><code>1</code>: <strong>默认且最安全</strong>。每次事务提交时写入并刷盘（保证崩溃后不丢数据）。</li><li><code>2</code>: 每次事务提交时写入 OS 缓存，每秒刷盘一次（MySQL 进程崩溃不丢数据，OS 崩溃可能丢失最多1秒的事务）。</li></ul></li><li><strong>Binlog:</strong> 由参数 <code>sync_binlog</code> 控制：<ul><li><code>0</code>: 依赖 OS 刷新，MySQL 不主动刷盘（性能最好，风险最高）。</li><li><code>1</code>: <strong>默认且安全</strong>。每次事务提交后都刷盘（保证 binlog 不丢失）。</li><li><code>N</code> (N&gt;1): 每 N 个事务提交后刷盘一次（折中方案）。</li></ul></li></ul><p><strong>两阶段提交 (2PC - Two-Phase Commit)：</strong><br>为了保证 redo log 和 binlog 逻辑上的一致性（即：一个事务在 redo log 中 prepare 了，那么在 binlog 中必须完整存在；反之，如果一个事务在 binlog 中存在，那么在 redo log 中必须 commit），InnoDB 和 MySQL Server 层使用了 <strong>两阶段提交</strong> 机制：</p><ol><li><strong>Prepare 阶段：</strong> InnoDB 将事务的 redo log 写入磁盘并标记为 <code>PREPARE</code> 状态。此时事务在引擎层已“准备就绪”。</li><li><strong>Write &amp; Sync Binlog 阶段：</strong> MySQL Server 将事务的 binlog 写入磁盘（根据 <code>sync_binlog</code> 策略决定是否刷盘）。</li><li><strong>Commit 阶段 (InnoDB)：</strong> 如果 binlog 写入成功，MySQL Server 通知 InnoDB。InnoDB 将 redo log 中该事务的状态标记为 <code>COMMIT</code>（这是一个非常快速的标记操作）。此时事务在引擎层正式提交。如果 binlog 写入失败，则通知 InnoDB 回滚该事务。<br>这个机制确保了：即使数据库在提交过程中崩溃，恢复时也能根据 redo log 和 binlog 的状态决定事务是提交还是回滚，从而保证数据在主库和从库上的一致性。</li></ol><h3 id="什么是刷盘"><a href="#什么是刷盘" class="headerlink" title="什么是刷盘"></a>什么是刷盘</h3><p>“刷盘”是数据库领域一个极其重要的操作，指的是 <strong>将内存中的数据强制写入（并确保同步到）物理磁盘存储设备的过程</strong>。</p><ul><li><strong>刷盘做了什么？</strong><ul><li><strong>写入 (Write)：</strong> 操作系统将内存缓冲区（如 redo log buffer, binlog cache）中的数据复制到磁盘驱动器的 <strong>操作系统缓存 (OS Page Cache)</strong> 中。这一步通常很快，因为只是内存间的拷贝。</li><li><strong>同步&#x2F;刷新 (Sync &#x2F; Flush &#x2F; Fsync)：</strong> <strong>这才是“刷盘”的核心和代价所在！</strong> 它要求操作系统 <strong>强制</strong> 将操作系统缓存中特定文件的数据 <strong>真正写入物理磁盘的存储介质</strong>（如 SSD&#x2F;HDD 的闪存颗粒&#x2F;盘片）上，并等待磁盘确认写入完成。这个操作涉及到物理 I&#x2F;O，速度相对内存操作慢几个数量级，是数据库操作的主要性能瓶颈之一。<code>fsync()</code> 是 Unix&#x2F;Linux 系统中用来执行这个强制同步操作的标准系统调用。</li></ul></li><li><strong>刷盘策略的权衡：</strong> 因为 <code>fsync()</code> 非常慢：<ul><li>如果每次事务提交都强制刷盘 (<code>fsync</code>)，能最大程度保证数据不丢失（安全性最高），但性能最差（吞吐量低，延迟高）。</li><li>如果累积多个事务或隔一段时间再刷盘，性能会提升（吞吐量高，延迟低），但如果在刷盘间隔内发生崩溃，未刷盘的数据就会丢失（安全性降低）。</li><li>数据库通过参数（如 <code>innodb_flush_log_at_trx_commit</code>, <code>sync_binlog</code>）让你在这两者之间进行 <strong>权衡（Trade-off）</strong>。</li></ul></li></ul><h3 id="buffer-pool和change-buffer有什么区别"><a href="#buffer-pool和change-buffer有什么区别" class="headerlink" title="buffer pool和change buffer有什么区别"></a>buffer pool和change buffer有什么区别</h3><p>在 MySQL 的 InnoDB 存储引擎中，<strong>Change Buffer</strong> 和 <strong>Buffer Pool</strong> 都是核心的内存结构，用于优化性能，但它们解决的问题和运作方式截然不同：</p><p><strong>1. Buffer Pool (缓冲池)</strong></p><ul><li><strong>本质：</strong> <strong>数据库的主内存缓存区域</strong>。它是 InnoDB 用于缓存从磁盘读取的<strong>数据页（Data Pages）和索引页（Index Pages）</strong> 的地方。</li><li><strong>目的：</strong> <strong>减少磁盘 I&#x2F;O</strong>。当 InnoDB 需要访问数据（无论是读取还是修改）时，它首先检查所需的数据页是否已经在 Buffer Pool 中。如果在（缓存命中），就直接在内存中操作，速度极快。如果不在（缓存未命中），就需要从磁盘读取相应的页加载到 Buffer Pool 中，然后再进行操作。</li><li><strong>作用对象：</strong> <strong>所有类型的数据页</strong>。包括：<ul><li>包含表行数据的页（数据页）。</li><li>包含索引（主键索引、二级索引）条目的页（索引页）。</li><li>系统页、Undo 页等。</li></ul></li><li><strong>工作原理：</strong><ul><li><strong>读操作：</strong> 优先从 Buffer Pool 读取，未命中则读磁盘并加载。</li><li><strong>写操作 (DML: INSERT, UPDATE, DELETE)：</strong><ol><li>修改发生在 Buffer Pool 中的<strong>脏页（Dirty Page）</strong>（已被修改但尚未写回磁盘的页）。</li><li>修改会写入 Redo Log（重做日志）以保证持久性。</li><li><strong>不是立即写回磁盘！</strong> Buffer Pool 中的脏页会在后台由专门的线程（如 <code>InnoDB Master Thread</code>）或根据特定策略（如 LRU 淘汰、检查点触发、Buffer Pool 空间不足时）<strong>异步刷新（Flush）</strong> 到磁盘的数据文件（.ibd 文件）。</li></ol></li></ul></li><li><strong>关键特性：</strong><ul><li><strong>核心缓存机制：</strong> 对数据库的整体性能（尤其是读性能）至关重要。</li><li><strong>管理策略：</strong> 使用 LRU（最近最少使用）等算法管理页的换入换出。</li><li><strong>大小可配置：</strong> 通过 <code>innodb_buffer_pool_size</code> 参数设置，通常是服务器总内存的 50%-80%。</li><li><strong>监控指标：</strong> <code>Innodb_buffer_pool_read_requests</code> (总请求数), <code>Innodb_buffer_pool_reads</code> (物理磁盘读次数)，命中率 &#x3D; <code>(1 - Innodb_buffer_pool_reads / Innodb_buffer_pool_read_requests) * 100%</code>。</li></ul></li></ul><p><strong>2. Change Buffer (更改缓冲区，旧称 Insert Buffer)</strong></p><ul><li><strong>本质：</strong> <strong>一种特殊的缓存结构，用于优化对非唯一二级索引的写操作（INSERT, UPDATE, DELETE）</strong>。它物理上<strong>是 Buffer Pool 的一部分</strong>，但逻辑功能独立。</li><li><strong>目的：</strong> <strong>减少对非唯一二级索引的随机磁盘 I&#x2F;O。</strong> 当修改操作（尤其是 INSERT 和 UPDATE）涉及到非唯一的二级索引时，如果对应的索引页<strong>不在 Buffer Pool</strong> 中，传统的做法是必须先将该索引页从磁盘读入 Buffer Pool 才能修改。Change Buffer 允许 InnoDB <strong>将这次修改“缓冲”下来</strong>，而不是立即去磁盘加载那个索引页。</li><li><strong>作用对象：</strong> <strong>仅限于非唯一二级索引（Non-Unique Secondary Index）</strong> 的修改操作。它不处理：<ul><li>主键索引（聚簇索引）的修改（直接在 Buffer Pool 中的页上修改）。</li><li>唯一索引的修改（需要立即检查唯一性约束，必须加载索引页）。</li><li>数据页本身的修改（在 Buffer Pool 中进行）。</li></ul></li><li><strong>工作原理：</strong><ul><li>当发生影响非唯一二级索引的 DML 操作时：<ol><li>检查目标索引页是否已在 Buffer Pool 中。</li><li><strong>如果在：</strong> 直接在内存中的索引页上进行修改。</li><li><strong>如果不在：</strong> <strong>将这次修改操作（包含索引列值、行标识等信息）记录到 Change Buffer 中</strong>，而不是去磁盘加载索引页。修改操作本身也会记录到 Redo Log。</li></ol></li><li><strong>后续操作（Merge 合并）：</strong><ul><li>当<strong>稍后</strong>需要读取这个被修改的索引页（例如通过 SELECT 使用该索引、后台 Purge 线程、Checkpoint 检查点、Server 空闲、Change Buffer 满、关闭数据库时），InnoDB 会先将该索引页从磁盘加载到 Buffer Pool。</li><li>加载完成后，InnoDB 会查找 Change Buffer 中所有针对这个<strong>已加载页</strong>的待处理修改记录。</li><li>将这些修改记录<strong>应用（Merge）</strong> 到新加载到内存的索引页上，使该索引页在内存中达到最新状态。</li><li>此时，被 Merge 的索引页变成了脏页，之后会由 Buffer Pool 的刷新机制写回磁盘。</li></ul></li></ul></li><li><strong>关键特性：</strong><ul><li><strong>写优化：</strong> 核心价值在于将潜在的多次随机磁盘 I&#x2F;O（加载索引页）<strong>延迟并合并</strong>。对于写密集型应用，特别是涉及大量非唯一二级索引插入&#x2F;更新的场景（如批量导入数据），性能提升显著（可能快数倍甚至十倍）。</li><li><strong>内存效率：</strong> 存储修改记录通常比缓存整个索引页占用空间小得多。</li><li><strong>适用场景限制：</strong> 只对非唯一二级索引有效。</li><li><strong>大小可配置：</strong> 通过 <code>innodb_change_buffer_max_size</code> 设置它占 Buffer Pool 总大小的百分比（默认 25%）。</li><li><strong>监控指标：</strong> <code>Ibuf: size</code>, <code>Ibuf: free list len</code>, <code>Ibuf: inserts</code>, <code>Ibuf: merged ops</code>, <code>Ibuf: merges</code> (在 <code>SHOW ENGINE INNODB STATUS</code> 输出中)。</li></ul></li></ul><p><strong>核心区别总结表</strong></p><table><thead><tr><th align="left">特性</th><th align="left">Buffer Pool (缓冲池)</th><th align="left">Change Buffer (更改缓冲区)</th></tr></thead><tbody><tr><td align="left"><strong>核心作用</strong></td><td align="left"><strong>数据库主内存缓存，缓存数据页和索引页</strong></td><td align="left"><strong>优化对非唯一二级索引的写操作</strong></td></tr><tr><td align="left"><strong>主要目的</strong></td><td align="left"><strong>减少磁盘读 I&#x2F;O (提升读性能)</strong></td><td align="left"><strong>减少磁盘随机写 I&#x2F;O (提升写性能，尤其非唯一索引插入&#x2F;更新)</strong></td></tr><tr><td align="left"><strong>作用对象</strong></td><td align="left"><strong>所有类型的数据页</strong> (数据页、索引页、系统页等)</td><td align="left"><strong>仅限非唯一二级索引页</strong>的修改操作</td></tr><tr><td align="left"><strong>操作类型</strong></td><td align="left"><strong>读 &amp; 写</strong> (修改发生在缓冲池中的脏页上)</td><td align="left"><strong>仅写</strong> (缓冲修改操作本身)</td></tr><tr><td align="left"><strong>修改处理位置</strong></td><td align="left">直接在内存中的目标页上修改</td><td align="left">将修改操作记录在 Change Buffer 中</td></tr><tr><td align="left"><strong>与磁盘交互</strong></td><td align="left">缓存页未命中时需读磁盘加载；脏页异步刷回磁盘</td><td align="left">避免立即加载不在内存的索引页；修改操作在 Merge 时才应用到内存页</td></tr><tr><td align="left"><strong>关键过程</strong></td><td align="left">LRU 管理、脏页刷新</td><td align="left">Merge (合并) - 将缓冲的修改应用到后来加载的索引页上</td></tr><tr><td align="left"><strong>物理位置</strong></td><td align="left">独立的内存区域</td><td align="left"><strong>物理上是 Buffer Pool 的一部分</strong></td></tr><tr><td align="left"><strong>配置参数</strong></td><td align="left"><code>innodb_buffer_pool_size</code></td><td align="left"><code>innodb_change_buffer_max_size</code></td></tr><tr><td align="left"><strong>典型优化场景</strong></td><td align="left">读密集型查询、热点数据访问</td><td align="left">写密集型操作、大量非唯一索引插入&#x2F;更新、批量导入</td></tr></tbody></table><p><strong>简单类比：</strong></p><ul><li><strong>Buffer Pool 像一个图书馆的阅览区：</strong> 把常用的书（数据页）从书库（磁盘）拿出来放在桌子上（内存），方便你（数据库线程）快速翻阅（读取）和做笔记（修改）。桌子空间有限，不常用的书会被放回书库。</li><li><strong>Change Buffer 像阅览区管理员的一个便签本：</strong> 当你（数据库线程）想在一本<strong>不在阅览区桌上</strong>的、属于某个特定类别（非唯一二级索引）的书上添加一条新信息（INSERT）或者修改一条信息（UPDATE）时，管理员不会马上去书库找那本厚厚的书搬出来放桌上让你改一页。而是让你把要添加&#x2F;修改的内容写在便签上（记录到 Change Buffer）。等以后有人需要看那本书（或管理员整理时），管理员才去书库把书拿出来放到桌上（加载索引页到 Buffer Pool），然后把便签上所有关于这本书的修改（Merge）贴到书里对应的位置（应用修改到内存页）。这样避免了频繁跑书库拿书只为改一个小地方。</li></ul><p><strong>总结：</strong></p><ul><li><strong>Buffer Pool 是基础缓存层，目标是加速对数据的访问（读和写），核心是管理数据页在内存中的驻留。</strong></li><li><strong>Change Buffer 是建立在 Buffer Pool 之上的一个针对特定场景（非唯一二级索引写）的高级优化，核心思想是延迟和合并对索引页的修改操作，以减少昂贵的随机磁盘 I&#x2F;O。</strong></li></ul><p>理解这两者的区别和协作对于深入掌握 InnoDB 的工作原理和进行 MySQL 性能调优至关重要。Buffer Pool 的命中率直接影响整体性能，而合理利用 Change Buffer 可以显著提升涉及非唯一索引的写入效率。</p><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><ul><li><strong>Redis:</strong> 深入理解数据类型及适用场景、持久化机制（RDB&#x2F;AOF）、内存淘汰策略、集群模式（主从、哨兵、Cluster）、分布式锁实现（Redlock 争议及替代方案）、缓存穿透&#x2F;击穿&#x2F;雪崩解决方案、与数据库一致性策略。了解底层数据结构（SDS, 跳跃表, 字典, 压缩列表等）。</li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="Redis-有哪些数据类型，分别用于哪些场景"><a href="#Redis-有哪些数据类型，分别用于哪些场景" class="headerlink" title="Redis 有哪些数据类型，分别用于哪些场景"></a>Redis 有哪些数据类型，分别用于哪些场景</h3><p><strong>String（字符串）</strong></p><ul><li><strong>描述</strong>：最基本的数据类型，可存储文本、二进制数据（如图片）、数字（整数或浮点数）。</li><li><strong>典型场景</strong>：<ul><li><strong>缓存</strong>：存储用户会话信息（Session）、HTML片段、API响应等。</li><li><strong>计数器</strong>：网站访问量、点赞数、库存数量（利用 <code>INCR/DECR</code>）。</li><li><strong>分布式锁</strong>：通过 <code>SET key value NX EX</code> 实现简单锁。</li><li><strong>位操作（Bitmaps）</strong>：利用 <code>SETBIT</code>, <code>GETBIT</code>, <code>BITCOUNT</code> 等命令实现用户在线状态、签到记录、布隆过滤器等（本质上是操作字符串的位）。</li></ul></li></ul><p><strong>List（列表）</strong></p><ul><li><strong>描述</strong>：有序的字符串集合，元素可重复。按照插入顺序排序，可在头部(<code>LPUSH</code>)或尾部(<code>RPUSH</code>)插入元素。</li><li><strong>典型场景</strong>：<ul><li><strong>消息队列（简单版）</strong>：生产者 <code>LPUSH</code> 消息，消费者 <code>RPOP</code>&#x2F;<code>BRPOP</code> 消息（FIFO）。也可实现栈（LIFO）。</li><li><strong>最新消息&#x2F;动态流（Timeline）</strong>：<code>LPUSH</code> 最新内容，<code>LRANGE</code> 获取最近 N 条。</li><li><strong>记录操作日志</strong>。</li></ul></li></ul><p><strong>Set（集合）</strong></p><ul><li><strong>描述</strong>：无序的字符串集合，元素<strong>不可重复</strong>，支持集合运算（交集、并集、差集）。</li><li><strong>典型场景</strong>：<ul><li><strong>标签（Tagging）</strong>：存储文章、商品的标签（自动去重）。</li><li><strong>共同关注&#x2F;好友（社交关系）</strong>：利用 <code>SINTER</code> 求交集。</li></ul></li></ul><p><strong>Hash（哈希 &#x2F; 字典）</strong></p><ul><li><strong>描述</strong>：键值对集合，用于存储对象（如用户信息）。<code>field-value</code> 映射表。</li><li><strong>典型场景</strong>：<ul><li><strong>存储对象</strong>：用户信息（<code>user:1000 &#123;name: &quot;Alice&quot;, age: 30, email: ...&#125;</code>）、商品详情、配置项。</li><li><strong>频繁修改部分属性的对象</strong>：如只更新用户积分，避免读取整个字符串再写回。</li></ul></li></ul><p><strong>Sorted Set（有序集合 &#x2F; ZSet）</strong></p><ul><li><strong>描述</strong>：Set 的升级版，元素<strong>唯一</strong>，但每个元素关联一个 <code>score</code>（分数）。元素<strong>按 <code>score</code> 排序</strong>（从小到大）。<code>score</code> 可相同，此时按元素字典序排序。</li><li><strong>典型场景</strong>：<ul><li><strong>排行榜</strong>：游戏积分榜（<code>score</code> 为积分）、热搜榜（<code>score</code> 为热度值）。<code>ZREVRANGE</code> 获取 Top N。</li></ul></li></ul><p><strong>Bitmaps</strong></p><ul><li><strong>本质</strong>：String 类型的位操作扩展。</li><li><strong>场景</strong>：极省空间的布尔值统计（用户在线状态、每日签到、活跃用户统计、布隆过滤器）。</li></ul><p><strong>HyperLogLog（HLL）</strong></p><ul><li><strong>本质</strong>：特殊的 String 类型。</li><li><strong>场景</strong>：海量数据的去重计数（网站 UV、独立 IP 访问数、搜索词去重统计），不需要精确结果时。</li></ul><p><strong>Geospatial（地理空间）</strong></p><ul><li><strong>本质</strong>：基于 Sorted Set（ZSet）实现，<code>member</code> 是位置标识符，<code>score</code> 是经度+纬度编码成的 52 位整数（GeoHash）。</li><li><strong>场景</strong>：附近的人&#x2F;地点（如滴滴打车）、基于位置的服务（LBS）、地理围栏。</li></ul><p><strong>Streams</strong></p><ul><li><strong>描述</strong>：Redis 5.0 引入。为<strong>消息队列</strong>设计的功能更完善的数据类型。类似 Kafka 或 RabbitMQ 的 topic。</li><li><strong>场景</strong>：<strong>可靠的消息队列</strong>、事件溯源（Event Sourcing）、实时数据管道。</li></ul><h3 id="Redis为什么快？单线程如何处理高并发？"><a href="#Redis为什么快？单线程如何处理高并发？" class="headerlink" title="Redis为什么快？单线程如何处理高并发？"></a>Redis为什么快？单线程如何处理高并发？</h3><p>对于Redis的高性能设计，我的理解主要得益于以下几点：</p><ul><li><p>内存操作：Redis数据存储在内存，相比于磁盘数据库，减少了IO开销</p></li><li><p>高效的数据结构：Redis针对不同场景设计了不同的数据结构，优化了空间和访问效率</p></li><li><p>单线程：Redis使用单线程处理命令，避免了多线程之间的竞争和上下文切换的开销</p></li><li><p>IO多路复用：Redis基于epoll&#x2F;kqueue实现了非阻塞的网络模型，通过事件机制循环处理请求</p></li></ul><h3 id="Redis和MySQL的区别"><a href="#Redis和MySQL的区别" class="headerlink" title="Redis和MySQL的区别"></a>Redis和MySQL的区别</h3><table><thead><tr><th></th><th>Redis</th><th>MySQL</th></tr></thead><tbody><tr><td>数据结构</td><td>非结构化</td><td>结构化</td></tr><tr><td>持久化</td><td>可选持久化</td><td>默认持久化</td></tr><tr><td>事务支持</td><td>简单支持</td><td>支持完整的ACID</td></tr><tr><td>扩展性</td><td>通过分片水平扩展</td><td>复杂，需分库分表或中间件</td></tr><tr><td>数据一致性</td><td>最终一致性</td><td>强一致性</td></tr></tbody></table><p>总结：</p><ul><li>当需要复杂查询和事务支持，对数据一致性要求较高，需要长期持久化存储的场景，选择MySQL</li><li>当需要超高性能和灵活数据类型，对数据的一致性要求不那么高，且容忍一定的数据丢失的情况下，选择Redis</li></ul><h3 id="Redis和memchahed的区别"><a href="#Redis和memchahed的区别" class="headerlink" title="Redis和memchahed的区别"></a>Redis和memchahed的区别</h3><table><thead><tr><th></th><th>Redis</th><th>Memcached</th></tr></thead><tbody><tr><td>数据类型</td><td>丰富的数据类型：string、hash、list等</td><td>只支持string</td></tr><tr><td>持久化</td><td>支持（RDB、AOF）</td><td>不支持</td></tr><tr><td>事务</td><td>简单支持（MULTI&#x2F;EXEC）</td><td>不支持</td></tr><tr><td>分布式</td><td>支持，集群自动分片</td><td>依赖客户端一致性哈希或第三方工具实现分布式</td></tr><tr><td>命令</td><td>支持丰富的命令</td><td>仅支持SET、GET、ADD、DELTE等基础操作</td></tr><tr><td>内存占用</td><td>复杂数据结构可能导致内存消耗较高</td><td>内存利用率高，但灵活性较低</td></tr></tbody></table><p>总结：</p><ul><li>需要复杂数据结构、持久化、事务支持和高可用性的场景，选择Redis</li><li>追求极致的性能和简单性，数据结构简单且无需持久化的场景，可以选择Memcached</li></ul><h3 id="Redis-IO多路复用"><a href="#Redis-IO多路复用" class="headerlink" title="Redis IO多路复用"></a>Redis IO多路复用</h3><p>常见的 I&#x2F;O 多路复用机制包括 select、poll 和 epoll 等。</p><table><thead><tr><th>特性</th><th><code>select</code></th><th><code>poll</code></th><th><code>epoll</code></th></tr></thead><tbody><tr><td>文件描述符限制</td><td>受 <code>FD_SETSIZE</code> 限制</td><td>无限制</td><td>无限制</td></tr><tr><td>时间复杂度</td><td>O(n)</td><td>O(n)</td><td>O(1)</td></tr><tr><td>数据复制</td><td>需要</td><td>需要</td><td>不需要</td></tr><tr><td>工作方式</td><td>线性扫描</td><td>线性扫描</td><td>事件通知</td></tr><tr><td>内核支持</td><td>所有 UNIX 系统</td><td>所有 UNIX 系统</td><td>Linux 2.6 及以上版本</td></tr><tr><td>适用场景</td><td>少量连接</td><td>中等连接</td><td>大量并发连接</td></tr></tbody></table><p><img src="https://cdn.tobebetterjavaer.com/stutymore/redis-20240918114125.png" alt="有盐先生：IO 多路复用"></p><h3 id="Redis-6-0-多线程"><a href="#Redis-6-0-多线程" class="headerlink" title="Redis 6.0 多线程"></a>Redis 6.0 多线程</h3><p>在 Redis 6.0 中，多线程主要用来处理网络 IO 操作，命令解析和执行仍然是单线程完成，这样既可以发挥多核 CPU 的优势，又能避免锁和上下文切换带来的性能损耗。</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/redis-b7b24e25-d2dc-4457-994f-95bdb3674b8e.png" alt="三分恶面渣逆袭：Redis6.0多线程"></p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">Redis核心知识脑图</span><br><span class="line">├── 数据结构篇</span><br><span class="line">│   ├── 基础数据结构</span><br><span class="line">│   │   ├── String</span><br><span class="line">│   │   │   ├── 二进制安全</span><br><span class="line">│   │   │   ├── 应用场景：缓存、计数器</span><br><span class="line">│   │   ├── List</span><br><span class="line">│   │   │   ├── 双向链表/ziplist</span><br><span class="line">│   │   │   ├── 应用场景：队列、栈</span><br><span class="line">│   │   ├── Hash</span><br><span class="line">│   │   │   ├── field-value结构</span><br><span class="line">│   │   │   ├── 应用场景：对象存储</span><br><span class="line">│   │   ├── Set</span><br><span class="line">│   │   │   ├── 无序唯一集合</span><br><span class="line">│   │   │   ├── 应用场景：标签系统</span><br><span class="line">│   │   └── Sorted Set</span><br><span class="line">│   │       ├── 带权重的Set</span><br><span class="line">│   │       └── 应用场景：排行榜</span><br><span class="line">│   └── 高级数据结构</span><br><span class="line">│       ├── HyperLogLog</span><br><span class="line">│       │   └── 基数统计（误差0.81%）</span><br><span class="line">│       ├── Bitmap</span><br><span class="line">│       │   └── 位操作（日活统计）</span><br><span class="line">│       ├── Geospatial</span><br><span class="line">│       │   └── 地理位置计算</span><br><span class="line">│       └── Streams</span><br><span class="line">│           └── 消息队列（类似Kafka）</span><br><span class="line">│</span><br><span class="line">└── 内存管理篇</span><br><span class="line">    ├── 内存分配</span><br><span class="line">    │   ├── 使用jemalloc库</span><br><span class="line">    │   └── 预分配策略</span><br><span class="line">    ├── 内存回收</span><br><span class="line">    │   ├── 惰性删除（访问时检查过期）</span><br><span class="line">    │   └── 定期删除（随机抽查）</span><br><span class="line">    ├── 内存优化</span><br><span class="line">    │   ├── 编码优化</span><br><span class="line">    │   │   ├── ziplist（小数据量）</span><br><span class="line">    │   │   ├── intset（整数集合）</span><br><span class="line">    │   ├── 共享对象（0-9999整数池）</span><br><span class="line">    │   └── 内存碎片处理</span><br><span class="line">    │       ├── info memory查看碎片率</span><br><span class="line">    │       └── 重启消除碎片</span><br><span class="line">    ├── 淘汰策略</span><br><span class="line">    │   ├── volatile-lru</span><br><span class="line">    │   ├── allkeys-lru</span><br><span class="line">    │   ├── volatile-lfu（4.0+）</span><br><span class="line">    │   ├── allkeys-random</span><br><span class="line">    │   └── noeviction（默认）</span><br><span class="line">    └── 内存监控</span><br><span class="line">        ├── info memory命令</span><br><span class="line">        ├── used_memory_human</span><br><span class="line">        └── CONFIG SET调整参数</span><br></pre></td></tr></table></figure><h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="什么是缓存穿透-雪崩-击穿，对应的解决方案是什么"><a href="#什么是缓存穿透-雪崩-击穿，对应的解决方案是什么" class="headerlink" title="什么是缓存穿透&#x2F;雪崩&#x2F;击穿，对应的解决方案是什么"></a>什么是缓存穿透&#x2F;雪崩&#x2F;击穿，对应的解决方案是什么</h3><p><strong>缓存穿透</strong>是指查询数据库中不存在的数据，导致请求每次都穿过缓存查询数据库。</p><p>解决方案：</p><ul><li><strong>布隆过滤器（Bloom Filter）</strong></li></ul><p>服务启动时加载全量有效key，标记数据是否存在；新增数据时同步更新过滤器</p><p>缺点：存在一定的误判率</p><ul><li><strong>缓存空值</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getData</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> redis.get(key);</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> NullValue) &#123; <span class="comment">// 空值标记</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    value = db.query(key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        redis.setex(key, <span class="number">300</span>, <span class="keyword">new</span> <span class="title class_">NullValue</span>()); <span class="comment">// 缓存空值5分钟</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redis.setex(key, <span class="number">3600</span>, value); <span class="comment">// 正常缓存1小时</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>增强请求参数的复杂度，避免被猜测，同时做好数据的基础格式校验</li></ul><p><strong>缓存雪崩</strong>是指<strong>大量key</strong>同时失效，导致大量请求都去查询数据库，造成数据库压力骤增。</p><p>解决方案：</p><ul><li><strong>差异化过期时间</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基础过期时间，1小时</span></span><br><span class="line"><span class="type">int</span> <span class="variable">baseExpire</span> <span class="operator">=</span> <span class="number">3600</span>;</span><br><span class="line"><span class="comment">// 随机0-5分钟</span></span><br><span class="line"><span class="type">int</span> <span class="variable">randomExpire</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">300</span>);</span><br><span class="line">redis.setex(key, baseExpire + randomExpire, value);</span><br></pre></td></tr></table></figure><ul><li><strong>永不过期+异步更新</strong></li><li><strong>添加降级限流策略</strong></li><li><strong>添加多级缓存</strong></li></ul><p><strong>缓存击穿</strong>是指某个<strong>热点key</strong>失效的瞬间，有大量请求同时访问这个key，导致所有请求都去查询数据库。</p><p>解决方案：</p><ul><li><strong>互斥锁</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> Redission.getLock(<span class="string">&quot;PREFIX:&quot;</span> + key);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lock.tryLock(<span class="number">3</span>, <span class="number">30</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">        <span class="comment">// 查库并重建缓存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>逻辑过期</strong></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;真实数据&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;expire_ts&quot;</span><span class="punctuation">:</span> <span class="number">1672502400</span> <span class="comment">// 逻辑过期时间戳</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>处理流程：</p><ol><li>判断逻辑过期时间<ol><li>未过期，直接返回数据</li><li>已过期，创建子线程，异步重建缓存</li></ol></li></ol><table><thead><tr><th>解决方案</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>互斥锁</td><td>实现简单；保证一致性；无需消耗额外内存</td><td>线程需等待，影响性能</td></tr><tr><td>逻辑过期</td><td>线程无需等待，性能较好</td><td>存在不一致性；消耗额外内存；实现复杂</td></tr></tbody></table><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>布隆过滤器（Bloom Filter）是一种空间高效、快速判断某个元素是否存在于集合中的数据结构。它由布隆于1970年提出，主要用于大规模数据集合的快速查找和去重。</p><p>布隆过滤器的基本思想是使用多个独立的哈希函数将元素映射到一个位数组（或称为布隆过滤器的位向量）中，并将这些位数组初始化为0。当要插入一个元素时，通过这些哈希函数计算得到的多个哈希值对应的位都被设置为1。当要查询一个元素是否存在时，同样通过这些哈希函数计算得到的多个哈希值对应的位都被检查，如果其中有任意一个位为0，则表示元素一定不存在；如果所有位都为1，则表示元素可能存在，但并不一定存在，可能会存在一定的误判率。</p><p>布隆过滤器的优点是占用空间小，插入和查询操作的时间复杂度都是O(k)，其中k是哈希函数的数量。此外，布隆过滤器可以处理非常大的数据集合，而且对于插入和查询操作的响应速度非常快。然而，布隆过滤器的缺点是存在一定的误判率，即在查询时可能会出现”误判为存在”的情况，因此在使用时需要注意选择合适的哈希函数数量和位数组大小，以及合理设置误判率的阈值。</p><p>布隆过滤器在实际应用中有很多用途，例如在数据库、缓存、网络路由器、爬虫等领域中都有广泛的应用，特别是在处理大规模数据集合时，可以显著减少存储和查询的开销。但需要注意的是，布隆过滤器并不适用于所有情况，因为它存在一定的误判率，并且无法删除已插入的元素，因此在选择使用时需要根据具体应用场景进行评估。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.BitSet;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BloomFilter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BitSet bitArray;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> m; <span class="comment">// 位数组的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> k; <span class="comment">// 哈希函数的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BloomFilter</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.m = m;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        <span class="built_in">this</span>.bitArray = <span class="keyword">new</span> <span class="title class_">BitSet</span>(m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] hash(String data) &#123;</span><br><span class="line">        <span class="type">int</span>[] hashValues = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">MessageDigest</span> <span class="variable">md</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;SHA-256&quot;</span>);</span><br><span class="line">            <span class="type">byte</span>[] hashBytes = md.digest(data.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">                hashValues[i] = Math.abs((<span class="type">int</span>) (hashBytes[(i * <span class="number">4</span>) % hashBytes.length]) % m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hashValues;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] hashValues = hash(data);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> hashValue : hashValues) &#123;</span><br><span class="line">            bitArray.set(hashValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">query</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] hashValues = hash(data);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> hashValue : hashValues) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!bitArray.get(hashValue)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建布隆过滤器，位数组大小为100，哈希函数数量为3</span></span><br><span class="line">        <span class="type">BloomFilter</span> <span class="variable">bloomFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BloomFilter</span>(<span class="number">100</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入元素</span></span><br><span class="line">        bloomFilter.insert(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        bloomFilter.insert(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        bloomFilter.insert(<span class="string">&quot;cherry&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询元素是否存在</span></span><br><span class="line">        System.out.println(bloomFilter.query(<span class="string">&quot;apple&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(bloomFilter.query(<span class="string">&quot;grape&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓存淘汰策略"><a href="#缓存淘汰策略" class="headerlink" title="缓存淘汰策略"></a>缓存淘汰策略</h3><table><thead><tr><th align="left"><strong>数据范围</strong></th><th align="left"><strong>策略</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left"><strong>所有Key</strong></td><td align="left"><code>allkeys-lru</code></td><td align="left">从所有Key中淘汰最近最少使用的</td></tr><tr><td align="left"></td><td align="left"><code>allkeys-lfu</code></td><td align="left">从所有Key中淘汰最不经常使用的（Redis 4.0+）</td></tr><tr><td align="left"></td><td align="left"><code>allkeys-random</code></td><td align="left">从所有Key中随机淘汰</td></tr><tr><td align="left"><strong>过期Key</strong></td><td align="left"><code>volatile-lru</code></td><td align="left">从设置了过期时间的Key中淘汰最近最少使用的</td></tr><tr><td align="left"></td><td align="left"><code>volatile-lfu</code></td><td align="left">从设置了过期时间的Key中淘汰最不经常使用的</td></tr><tr><td align="left"></td><td align="left"><code>volatile-random</code></td><td align="left">从设置了过期时间的Key中随机淘汰</td></tr><tr><td align="left"></td><td align="left"><code>volatile-ttl</code></td><td align="left">淘汰剩余存活时间（TTL）最短的Key</td></tr><tr><td align="left"><strong>不淘汰</strong></td><td align="left"><code>noeviction</code>（默认）</td><td align="left">内存不足时拒绝写入，返回错误</td></tr></tbody></table><h3 id="缓存与数据的更新策略"><a href="#缓存与数据的更新策略" class="headerlink" title="缓存与数据的更新策略"></a>缓存与数据的更新策略</h3><p><strong>方案一：先删缓存 → 更新数据库 → 重建缓存</strong></p><p><strong>问题风险</strong>：</p><ol><li><strong>并发脏读（严重问题）</strong><ul><li>线程A删除缓存后，尚未更新数据库</li><li>线程B读取缓存未命中，<strong>从数据库读到旧值</strong>并重建缓存</li><li>线程A更新数据库后，缓存中遗留<strong>旧数据</strong>（直到下次更新&#x2F;过期）<br><em>👉 缓存与数据库长期不一致</em></li></ul></li><li><strong>缓存击穿压力</strong><ul><li>删除缓存后，大量请求瞬间穿透到数据库（尤其热点数据）</li><li>若重建缓存慢，可能导致数据库雪崩</li></ul></li></ol><p><strong>方案二：先更新数据库 → 删除缓存（推荐方案）</strong></p><p><strong>问题风险：</strong></p><ol><li><strong>极小概率的旧数据残留</strong><ul><li>线程A读缓存<strong>命中旧值</strong>（此时缓存未失效）</li><li>线程B更新数据库并<strong>删除缓存</strong></li><li>线程A仍使用旧数据（短暂不一致，通常毫秒级）<br><em>👉 概率低，且旧数据很快被淘汰</em></li></ul></li><li><strong>缓存删除失败</strong><ul><li>数据库更新成功，但缓存删除失败 → <strong>永久不一致</strong><br><em>👉 需引入重试或补偿机制</em></li></ul></li></ol><p><strong>业界通用方案：Cache-Aside + 延迟双删</strong></p><p>结合可靠性设计，核心流程：</p><img src="/post/32511a71/image-20250807221917345.png" class="" title="image-20250807221917345"><p><strong>关键优化措施</strong>：</p><ol><li><strong>延迟双删 (Double Delete)</strong><ul><li>更新数据库后<strong>立即删除缓存</strong></li><li><strong>额外启动异步任务</strong>（如延迟500ms）<strong>再次删除缓存</strong><br><em>👉 解决并发导致的旧数据重建问题</em></li></ul></li><li><strong>缓存操作失败重试</strong><ul><li>将删除操作发到<strong>消息队列</strong>（如Kafka&#x2F;RabbitMQ）</li><li>消费失败自动重试，直至成功<br><em>👉 确保最终一致性</em></li></ul></li><li><strong>短过期时间兜底</strong><ul><li>所有缓存设置 <strong>TTL（如1-5秒）</strong><br><em>👉 即使双删失败，旧数据也会快速过期</em></li></ul></li></ol><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="RDB和AOF持久化原理及优劣对比"><a href="#RDB和AOF持久化原理及优劣对比" class="headerlink" title="RDB和AOF持久化原理及优劣对比"></a>RDB和AOF持久化原理及优劣对比</h3><p>RDB，存储某一时刻内存中所有的数据，触发命令<code>save</code>、<code>bgsave</code>，主进程<code>fork</code>子进程，阻塞。</p><p>触发条件：</p><ol><li>客户端发送<code>shutdown</code></li><li>从节点要进行全量复制</li><li>达到<code>redis.conf</code>文件中配置的条件</li><li>客户端执行<code>flushall</code>（生成空的<code>dump.rdb</code>，慎用）</li></ol><p>不能频繁生成 RBD 快照，原因：</p><ul><li>多次 RDB 会竞争磁盘带宽</li><li><code>fork</code> 子进程会阻塞主进程</li></ul><p>写时复制<code>copy-on-write</code>：</p><ul><li><strong>共享内存初始化</strong>：子进程刚创建时，<strong>与父进程共享全部内存页</strong>，此时内存占用几乎无额外开销。</li><li><strong>写操作触发复制</strong>：若父进程收到写请求（修改数据），操作系统会<strong>将被修改的内存页复制一份</strong>，父进程在副本上修改，子进程仍读取原始页。</li><li><strong>子进程视角固定</strong>：子进程看到的数据始终是 <code>fork()</code> 瞬间的状态，确保快照一致性。</li></ul><p>AOF，所有写命令追加到 <code>aof_buf</code>，刷盘策略由 <code>appendfsync</code> 决定。</p><p>如果有 AOF 文件，加载 AOF；否则，加载 RDB 文件。AOF 最多丢失 1s 数据。</p><p>AOF重写是直接为当前内存的数据生成对应命令，并不是读取旧AOF文件进行命令合并</p><ul><li>父子进程写同一个文件会产生竞争问题，影响父进程的性能。</li><li>如果AOF重写过程中失败了，相当于污染了原本的AOF文件，无法做恢复数据使用</li></ul><p>修复已损害的AOF文件：<code>redis-check-aof --fix appendonly.aof</code></p><table><thead><tr><th></th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>启动加载优先级</td><td>低</td><td>高</td></tr><tr><td>体积</td><td>小</td><td>大</td></tr><tr><td>恢复速度</td><td>慢</td><td>快</td></tr></tbody></table><p>总结：RDB适合用作数据备份，AOF适合用作数据恢复。</p><h3 id="全量同步和增量同步的区别"><a href="#全量同步和增量同步的区别" class="headerlink" title="全量同步和增量同步的区别"></a>全量同步和增量同步的区别</h3><p>全量同步：master生成当前内存中所有数据的RDB文件，将RDB发送给slave。在此过程中，master将新的命令记录在<code>repl_backlog</code>中，后续再发送给slave。</p><p>执行时机：</p><ol><li>slave第一次连接到master</li><li>slave宕机太久，导致它在<code>repl_backlog</code>中的<code>offset</code>已经被覆盖掉了</li></ol><p>增量同步：salve将自己的<code>offset</code>发送到master，master将<code>repl_backlog</code>中<code>offset</code>之后的命令发送给slave</p><p>执行时机：</p><ol><li>slave断开重连之后，<code>repl_backlog</code>中的<code>offset</code>尚未被覆盖</li></ol><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="Redis分布式锁实现"><a href="#Redis分布式锁实现" class="headerlink" title="Redis分布式锁实现"></a>Redis分布式锁实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.ValueOperations;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisDistributedLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_KEY</span> <span class="operator">=</span> <span class="string">&quot;myLock&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LOCK_EXPIRE_TIME</span> <span class="operator">=</span> <span class="number">5000</span>; <span class="comment">// 锁过期时间，单位毫秒</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisDistributedLock</span><span class="params">(RedisTemplate&lt;String, String&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">acquireLock</span><span class="params">()</span> &#123;</span><br><span class="line">        ValueOperations&lt;String, String&gt; valueOperations = redisTemplate.opsForValue();</span><br><span class="line">        <span class="comment">// 尝试获取分布式锁</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">result</span> <span class="operator">=</span> valueOperations.setIfAbsent(LOCK_KEY, <span class="string">&quot;locked&quot;</span>); <span class="comment">// RedisTemplate 的 setIfAbsent 方法，如果键不存在则设置键值对并返回 true，否则返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span> &amp;&amp; result) &#123;</span><br><span class="line">            <span class="comment">// 成功获取到锁，设置锁的过期时间</span></span><br><span class="line">            redisTemplate.expire(LOCK_KEY, LOCK_EXPIRE_TIME, TimeUnit.MILLISECONDS); <span class="comment">// 设置键的过期时间，单位毫秒</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">releaseLock</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.delete(LOCK_KEY); <span class="comment">// 删除键</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用分布式锁的业务逻辑</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBusinessWithLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acquireLock()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获得分布式锁后执行业务逻辑</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Acquired lock, do business logic...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>); <span class="comment">// 模拟业务处理时间</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                releaseLock(); <span class="comment">// 业务处理完成后释放锁</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Released lock.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 未获得分布式锁，执行其他逻辑</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Failed to acquire lock, do other logic...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 RedisTemplate 实例并设置连接信息</span></span><br><span class="line">        RedisTemplate&lt;String, String&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置 Redis 连接工厂、序列化方式等</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="type">RedisDistributedLock</span> <span class="variable">distributedLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisDistributedLock</span>(redisTemplate);</span><br><span class="line">        distributedLock.doBusinessWithLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>竞争条件（Race Condition）：在多个客户端同时尝试获取锁时，可能会出现竞争条件，导致多个客户端都成功获得锁，从而引发并发访问资源的问题。</li><li>死锁（Deadlock）：如果某个持有锁的客户端在业务处理期间发生异常或崩溃，导致没有释放锁的操作，可能会出现死锁的情况，导致其他客户端无法获得锁。</li><li>锁过期（Lock Expiration）：为了避免死锁，通常会给锁设置过期时间，但如果业务处理时间较长，超过了锁的过期时间，可能会导致其他客户端误认为锁已经释放，从而引发并发访问资源的问题。</li><li>锁的重入性（Lock Reentrancy）：在某些场景下，同一个客户端可能需要多次获取同一个锁，例如嵌套的业务处理逻辑。如果分布式锁没有支持锁的重入性，可能会导致同一个客户端无法在业务处理期间重新获取锁，从而引发死锁或并发访问资源的问题。</li><li>性能开销（Performance Overhead）：使用分布式锁可能会增加系统的性能开销，例如频繁的锁获取和锁释放操作，以及锁的管理和维护。如果锁的使用不当，可能会影响系统的性能和响应时间。</li></ol><h3 id="如何避免误释放锁"><a href="#如何避免误释放锁" class="headerlink" title="如何避免误释放锁"></a>如何避免误释放锁</h3><p>为了防止误删其他锁，可以通过<code>key</code>对应的<code>value</code>来判断。为了保证操作的原子性（先比较<code>value</code>，再删除<code>key</code>），可以通过Lua脚本来执行。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 释放锁时，先比较锁对应的 value 值是否相等，避免锁的误释放</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="如何实现锁续期"><a href="#如何实现锁续期" class="headerlink" title="如何实现锁续期"></a>如何实现锁续期</h3><p>在 Redis 中实现分布式锁时，续期（即锁的自动延期）是一个常见的需求，尤其是在锁的持有时间可能超过最初设定的过期时间时。常见的解决方案是使用一个后台线程（或定时任务）定期检查锁是否仍然被持有，如果是，则延长锁的过期时间。这种机制通常被称为“<strong>看门狗</strong>”（Watchdog）机制。</p><p>基于 Redis 的分布式锁续期的基本思路：</p><ol><li><strong>获取锁时设置过期时间</strong>：在获取锁时，通常会设置一个过期时间（例如30秒），以防止客户端崩溃导致锁无法释放。</li><li><strong>启动一个续期线程</strong>：当成功获取锁后，启动一个后台线程，该线程定期（例如，每隔过期时间的1&#x2F;3时间）去检查锁是否还存在，如果存在，则延长锁的过期时间。</li><li><strong>续期操作</strong>：续期操作实际上就是重新设置锁的过期时间。在Redis中，可以使用<code>PEXPIRE</code>命令（以毫秒为单位）或<code>EXPIRE</code>命令（以秒为单位）来重新设置过期时间。</li><li><strong>释放锁时停止续期</strong>：当业务逻辑执行完毕，释放锁的时候，需要同时停止续期线程，以避免不必要的续期操作。</li></ol><p>需要注意的是，续期操作必须保证原子性，即在检查锁是否仍然由当前客户端持有之后，再执行续期。可以使用Lua脚本来保证原子性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">if</span> set lock_key my_random_value NX PX <span class="number">30000</span>:</span><br><span class="line">    <span class="comment">// 锁获取成功</span></span><br><span class="line">    <span class="comment">// 启动一个看门狗线程，每10秒执行一次续期</span></span><br><span class="line">    watchdog = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (lockIsHeld) &#123;</span><br><span class="line">            sleep(<span class="number">10000</span>); <span class="comment">// 10秒</span></span><br><span class="line">            <span class="comment">// 使用Lua脚本续期：如果锁的值还是my_random_value，则重新设置为30秒</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then &quot;</span> +</span><br><span class="line">                           <span class="string">&quot;return redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]) &quot;</span> +</span><br><span class="line">                           <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                           <span class="string">&quot;return 0 &quot;</span> +</span><br><span class="line">                           <span class="string">&quot;end&quot;</span>;</span><br><span class="line">            redis.eval(script, lock_key, my_random_value, <span class="number">30000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    watchdog.start();</span><br><span class="line">    <span class="comment">// 执行业务逻辑</span></span><br><span class="line">    doBusiness();</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="comment">// 先停止看门狗线程</span></span><br><span class="line">    lockIsHeld = <span class="literal">false</span>;</span><br><span class="line">    watchdog.join();</span><br><span class="line">    <span class="comment">// 然后释放锁，使用Lua脚本来保证原子性</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">releaseScript</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then &quot;</span> +</span><br><span class="line">                           <span class="string">&quot;return redis.call(&#x27;del&#x27;, KEYS[1]) &quot;</span> +</span><br><span class="line">                           <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                           <span class="string">&quot;return 0 &quot;</span> +</span><br><span class="line">                           <span class="string">&quot;end&quot;</span>;</span><br><span class="line">    redis.eval(releaseScript, lock_key, my_random_value);</span><br></pre></td></tr></table></figure><p>在实际应用中，可以使用一些成熟的库，例如Redisson，它已经内置了看门狗机制来自动续期。在Redisson中，获取锁后，它会启动一个定时任务来定期续期，直到锁被释放或持有锁的客户端宕机。</p><p>使用Redisson的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RedissonClient</span> <span class="variable">redisson</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redisson.getLock(<span class="string">&quot;myLock&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取锁，并设置尝试加锁时间和锁自动释放时间，但是Redisson的看门狗机制会在获取锁成功后自动续期</span></span><br><span class="line">    lock.lock(); <span class="comment">// 默认情况下，看门狗会每30/3=10秒续期一次，将锁的过期时间重置为30秒</span></span><br><span class="line">    <span class="comment">// 执行业务逻辑</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="在-Redis-中绑定-CPU-核"><a href="#在-Redis-中绑定-CPU-核" class="headerlink" title="在 Redis 中绑定 CPU 核"></a>在 Redis 中绑定 CPU 核</h3><p>在 Redis 中绑定 CPU 核（CPU 亲和性）可以通过以下方法实现，以优化性能并减少上下文切换。以下是详细步骤：</p><p><strong>方法 1：通过 Redis 配置文件绑定</strong></p><p>Redis 从 <strong>6.0 版本</strong>开始支持 <code>server_cpulist</code> 配置项，可直接在配置文件中指定 CPU 核。</p><ol><li><p><strong>修改 <code>redis.conf</code> 文件</strong>：</p><p>bash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 绑定 Redis 到 CPU 核心 0 和 1（逗号分隔）</span><br><span class="line">server_cpulist 0-1</span><br></pre></td></tr></table></figure><ul><li>格式支持：<code>0</code>（单个核心）、<code>0-3</code>（范围）、<code>0,2,4</code>（逗号分隔列表）。</li></ul></li><li><p><strong>重启 Redis 生效</strong>：</p><p>bash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /path/to/redis.conf</span><br></pre></td></tr></table></figure></li></ol><p><strong>方法 2：使用 <code>taskset</code> 命令绑定</strong></p><p>通过 Linux 的 <code>taskset</code> 工具直接绑定 Redis 进程到指定 CPU 核。</p><ol><li><p><strong>启动 Redis 时绑定</strong>：</p><p>bash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskset -c 0,1 ./redis-server /path/to/redis.conf</span><br></pre></td></tr></table></figure><ul><li><code>-c 0,1</code> 表示绑定到核心 0 和 1。</li></ul></li><li><p><strong>对已运行的 Redis 进程绑定</strong>：</p><p>bash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskset -cp 0,1 &lt;redis_pid&gt;</span><br></pre></td></tr></table></figure></li></ol><p><strong>方法 3：通过 Systemd 服务绑定</strong></p><p>如果 Redis 以 Systemd 服务运行，可在服务文件中添加 <code>CPUAffinity</code> 配置。</p><ol><li><p><strong>编辑 Redis 的 systemd 服务文件</strong>：</p><p>bash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl edit redis.service</span><br></pre></td></tr></table></figure></li><li><p><strong>添加 CPU 亲和性配置</strong>：</p><p>ini</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">CPUAffinity=0 1</span><br></pre></td></tr></table></figure></li><li><p><strong>重启服务生效</strong>：</p><p>bash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart redis</span><br></pre></td></tr></table></figure></li></ol><p><strong>方法 4：使用 Cgroups (高级)</strong></p><p>通过 Linux 控制组 (<code>cgroups</code>) 精细化控制 CPU 资源。</p><ol><li><p><strong>创建 cgroup</strong>：</p><p>bash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cgcreate -g cpuset:redis</span><br></pre></td></tr></table></figure></li><li><p><strong>分配 CPU 核心和内存节点</strong>：</p><p>bash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 0-1 &gt; /sys/fs/cgroup/cpuset/redis/cpuset.cpus</span><br><span class="line">echo 0 &gt; /sys/fs/cgroup/cpuset/redis/cpuset.mems</span><br></pre></td></tr></table></figure></li><li><p><strong>启动 Redis 并加入 cgroup</strong>：</p><p>bash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cgexec -g cpuset:redis ./redis-server /path/to/redis.conf</span><br></pre></td></tr></table></figure></li></ol><p><strong>验证绑定是否生效</strong></p><p>bash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看 Redis 进程 PID</span><br><span class="line">ps -ef | grep redis-server</span><br><span class="line"></span><br><span class="line"># 检查进程的 CPU 亲和性</span><br><span class="line">taskset -cp &lt;redis_pid&gt;</span><br><span class="line"></span><br><span class="line"># 或查看 /proc 文件系统</span><br><span class="line">cat /proc/&lt;redis_pid&gt;/status | grep Cpus_allowed</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ol><li><p><strong>NUMA 架构</strong>：若服务器有多个 CPU 插槽，建议配合 <code>numactl</code> 工具绑定内存节点。</p><p>bash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numactl --cpunodebind=0 --membind=0 ./redis-server</span><br></pre></td></tr></table></figure></li><li><p><strong>性能测试</strong>：绑定 CPU 可能提升缓存命中率，但需根据实际负载测试效果。</p></li><li><p><strong>超线程</strong>：物理核与逻辑核（如 <code>0</code> 和 <code>4</code> 可能是同一物理核的超线程）需区分，避免误绑。</p></li></ol><hr><p>通过上述方法，可有效将 Redis 实例绑定到指定 CPU 核，优化性能并减少资源争用。</p><h1 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h1><h2 id="Elasticsearch-的核心概念"><a href="#Elasticsearch-的核心概念" class="headerlink" title="Elasticsearch 的核心概念"></a><strong>Elasticsearch 的核心概念</strong></h2><ul><li><strong>文档：</strong> 数据的基本单位，通常是 JSON 格式。相当于数据库中的一行记录。</li><li><strong>索引：</strong> 具有相似特征的文档集合。相当于数据库中的一个表。一个索引对应一个或多个分片。</li><li><strong>类型：</strong> (7.x 之前) 索引内部的逻辑分区，允许在同一索引中存储不同类型的文档（如 <code>user</code>, <code>product</code>）。(<strong>注意：</strong> 在 7.x 中类型被废弃，8.x 中完全移除。现在一个索引通常只包含一种文档类型)。</li><li><strong>分片：</strong> 索引被水平分割成的子集。每个分片本身就是一个功能完整且独立的“索引”。<ul><li><strong>主分片：</strong> 存储文档数据和处理索引&#x2F;更新操作。索引创建时指定数量，后续不可更改（除非 Reindex）。</li><li><strong>副本分片：</strong> 主分片的拷贝。提供高可用性（主分片故障时副本可提升为主）和读取吞吐量（查询可负载均衡到所有副本）。</li></ul></li><li><strong>节点：</strong> 运行中的 Elasticsearch 实例。</li><li><strong>集群：</strong> 一个或多个节点协同工作的集合，共同持有整个数据并提供联合索引和搜索能力。</li><li><strong>倒排索引：</strong> ES 实现快速全文搜索的核心数据结构。它存储了词项（Token）到包含该词项的文档 ID 列表的映射。相比传统数据库的正排索引（文档 ID 到字段值），它更擅长回答“哪些文档包含某个词？”的问题。</li></ul><h2 id="什么是倒排索引？为什么它对搜索很重要？"><a href="#什么是倒排索引？为什么它对搜索很重要？" class="headerlink" title="什么是倒排索引？为什么它对搜索很重要？"></a><strong>什么是倒排索引？为什么它对搜索很重要？</strong></h2><ul><li><strong>定义：</strong> 倒排索引是一种将文档中的词项（Token）映射到包含该词项的文档列表的数据结构。它包含两个核心部分：<ul><li><strong>词项字典：</strong> 包含所有不重复的词项（Token），通常按字典序排序。</li><li><strong>倒排列表：</strong> 对于每个词项，记录包含该词项的所有文档 ID 列表（Postings List），以及词项在文档中出现的位置（Position）、频率（Term Frequency）等信息（用于相关性评分）。</li></ul></li><li><strong>重要性：</strong><ul><li><strong>快速定位：</strong> 直接通过词项找到包含它的文档，避免了扫描所有文档。</li><li><strong>高效布尔查询：</strong> AND&#x2F;OR&#x2F;NOT 操作可以通过对倒排列表进行交&#x2F;并&#x2F;差集运算高效完成。</li><li><strong>相关性评分基础：</strong> TF-IDF、BM25 等经典评分模型严重依赖倒排索引中存储的词频（TF）、文档频率（DF&#x2F;IDF）信息。</li><li><strong>支持短语查询：</strong> 利用存储的位置信息，可以精确查找相邻出现的词组。</li></ul></li></ul><h2 id="分片（Shard）和副本（Replica）是什么"><a href="#分片（Shard）和副本（Replica）是什么" class="headerlink" title="分片（Shard）和副本（Replica）是什么"></a>分片（Shard）和副本（Replica）是什么</h2><p>分片是索引的物理组成部分（一个 Lucene 索引），用于<strong>水平分割数据</strong>，使索引可以分布在多个节点上，实现<strong>水平扩展和并行处理</strong>。</p><p>副本是主分片的完整拷贝，作用是<strong>提供高可用性</strong>（主分片故障时副本可接管）和<strong>提高查询吞吐量&#x2F;性能</strong>（查询可以在副本上执行，分担负载）。主分片数量在索引创建时指定且后续不可变，副本数量可以动态调整。</p><h2 id="Elasticsearch-如何保证写入数据的可靠性？"><a href="#Elasticsearch-如何保证写入数据的可靠性？" class="headerlink" title="Elasticsearch 如何保证写入数据的可靠性？"></a>Elasticsearch 如何保证写入数据的可靠性？</h2><ul><li><strong>事务日志：</strong> 所有写入操作在写入内存缓冲区（In-memory Buffer）的同时，会立即追加写入到事务日志（Translog）中。Translog 是持久化的。</li><li><strong>Refresh：</strong> 定期（默认 1 秒）将内存缓冲区中的内容生成一个新的、可搜索的 Lucene 段（Segment），并清空缓冲区。这个过程使新写入的数据对搜索可见。<strong>注意：</strong> 此时数据还在操作系统的文件系统缓存（Page Cache）中，并未物理刷盘（<code>fsync</code>）。</li><li><strong>Flush：</strong> 定期（默认 30 分钟，或 Translog 大小达到阈值）执行以下操作：<ol><li>触发一次 Refresh，将所有在内存缓冲区中的数据生成新的段。</li><li>将文件系统缓存中的段数据物理 <code>fsync</code> 到磁盘。</li><li>清空（截断）旧的、已持久化的 Translog。</li></ol></li><li><strong>副本机制：</strong> 写入操作在主分片执行成功后，必须等待所有配置的副本分片也写入成功才返回客户端确认（除非使用 <code>wait_for_active_shards</code> 降低要求）。这确保了数据冗余。</li><li><strong>故障恢复：</strong> 节点重启时，会重放 Translog 中尚未刷盘的操作来恢复数据。副本分片的存在保证了主分片丢失时数据不丢。</li></ul><h2 id="解释一下-Elasticsearch-中的-refresh-和-flush-操作的区别"><a href="#解释一下-Elasticsearch-中的-refresh-和-flush-操作的区别" class="headerlink" title="解释一下 Elasticsearch 中的 refresh 和 flush 操作的区别"></a>解释一下 Elasticsearch 中的 <code>refresh</code> 和 <code>flush</code> 操作的区别</h2><ul><li><strong><code>refresh</code>：</strong><ul><li><strong>目的：</strong> 使新写入的数据对搜索可见。</li><li><strong>操作：</strong> 将内存缓冲区中的文档生成新的、可搜索的 Lucene 段（Segment）。段写入文件系统缓存（Page Cache），<strong>不</strong>立即 <code>fsync</code> 到磁盘。</li><li><strong>频率：</strong> 默认每秒一次（可通过 <code>index.refresh_interval</code> 配置）。</li><li><strong>开销：</strong> 相对较低，因为只写入 Page Cache。频繁 Refresh 会产生大量小段，增加合并（Merge）压力。</li></ul></li><li><strong><code>flush</code>：</strong><ul><li><strong>目的：</strong> 将文件系统缓存中的数据安全持久化到磁盘，并清理 Translog。</li><li><strong>操作：</strong><ol><li>执行一次 Refresh（确保所有数据都在段里）。</li><li>调用 <code>fsync</code> 将文件系统缓存中的所有段数据强制写入磁盘存储设备。</li><li>清空（截断）当前 Translog（因为数据已安全落盘）。</li></ol></li><li><strong>触发条件：</strong><ul><li>定时（默认 30 分钟，<code>index.translog.sync_interval</code> &#x2F; <code>index.translog.durability</code>）。</li><li>Translog 大小达到阈值（默认 512MB，<code>index.translog.flush_threshold_size</code>）。</li><li>显式调用 <code>_flush</code> API。</li></ul></li><li><strong>开销：</strong> 相对较高，因为涉及磁盘 I&#x2F;O (<code>fsync</code>)。</li></ul></li></ul><h2 id="集群状态-Yellow-或-Red-意味着什么？如何排查"><a href="#集群状态-Yellow-或-Red-意味着什么？如何排查" class="headerlink" title="集群状态 Yellow 或 Red 意味着什么？如何排查?"></a>集群状态 Yellow 或 Red 意味着什么？如何排查?</h2><ul><li><strong>Yellow：</strong><ul><li><strong>含义：</strong> 所有主分片都已分配，但<strong>至少有一个副本分片没有分配</strong>。</li><li><strong>常见原因：</strong><ul><li>节点数量不足（例如，索引配置了 <code>number_of_replicas=1</code>，但集群只有一个节点）。</li><li>新创建的索引副本分片正在初始化（短暂状态）。</li><li>有节点故障，导致部分副本分片丢失（但主分片还在）。</li></ul></li><li><strong>影响：</strong> 高可用性降低（丢失一个节点可能导致数据丢失&#x2F;不可用），查询吞吐量可能下降（副本少）。</li><li><strong>排查：</strong> <code>GET _cluster/allocation/explain</code> API 查看未分配分片的具体原因；检查节点数、节点状态、磁盘空间、分片分配设置。</li></ul></li><li><strong>Red：</strong><ul><li><strong>含义：</strong> <strong>至少有一个主分片没有分配</strong>（可能连带其副本也缺失）。</li><li><strong>常见原因：</strong><ul><li>持有主分片的节点永久丢失，且没有可用的副本分片可以提升为主分片。</li><li>磁盘空间不足导致分片无法分配。</li><li>配置错误（如分片分配规则 exclude 了所有节点）。</li></ul></li><li><strong>影响：</strong> <strong>数据部分丢失或完全不可用！</strong> 涉及该主分片的索引和搜索操作都会失败。</li><li><strong>排查：</strong> 紧急！立即检查 <code>_cluster/health</code> 和 <code>_cat/shards?v</code> 确认哪些索引&#x2F;分片是 <code>red</code>。使用 <code>GET _cluster/allocation/explain</code> 分析未分配原因。检查节点状态、磁盘空间、日志。可能需要从备份恢复或手动分配分片（风险操作）。</li></ul></li><li><strong>目标：</strong> 始终追求 <code>Green</code> 状态。</li></ul><h2 id="解释一下什么是脑裂（Split-Brain）问题？Elasticsearch-如何防止脑裂？"><a href="#解释一下什么是脑裂（Split-Brain）问题？Elasticsearch-如何防止脑裂？" class="headerlink" title="解释一下什么是脑裂（Split-Brain）问题？Elasticsearch 如何防止脑裂？"></a>解释一下什么是脑裂（Split-Brain）问题？Elasticsearch 如何防止脑裂？</h2><ul><li><strong>定义：</strong> 在分布式系统中，当网络分区（Network Partition）发生时，集群的不同部分（节点组）可能无法互相通信。如果每个部分都认为自己是唯一可用的部分并选举出新的主节点，就会导致集群分裂成两个或多个独立运作的“脑”，各自接受写入操作，造成<strong>数据不一致</strong>和<strong>冲突</strong>。</li><li><strong>ES 防止机制：</strong> 主要通过 <strong><code>discovery.zen.minimum_master_nodes</code></strong> 设置（在 7.x 之前显式配置）或 <strong><code>cluster.initial_master_nodes</code></strong> + <strong>Quorum</strong> 机制（7.x+ 尤其是基于 Raft 的选举）：<ul><li><strong>核心思想：</strong> 确保只有拥有<strong>多数</strong>（Quorum, &gt; N&#x2F;2）<strong>主节点资格节点</strong>的节点组才能成功选举主节点或维持主节点。假设有 <code>N</code> 个主节点资格节点：<ul><li>设置 <code>discovery.zen.minimum_master_nodes = (N/2) + 1</code> （例如，3节点集群设为2）。</li><li>在 7.x+ 中，使用 <code>cluster.initial_master_nodes</code> 列出初始主节点，新选举协议自动确保需要多数投票。</li></ul></li><li><strong>效果：</strong> 在网络分区时，任何节点组如果包含的主节点资格节点数不足多数（&lt;&#x3D; N&#x2F;2），就无法选举新主节点或维持现有主节点状态（因为它无法获得多数确认），从而<strong>无法提供服务或接受写操作</strong>，避免了“双主”导致的脑裂。只有拥有多数节点的分区才能正常运作。</li></ul></li></ul><h2 id="什么是映射爆炸？如何避免？"><a href="#什么是映射爆炸？如何避免？" class="headerlink" title="什么是映射爆炸？如何避免？"></a>什么是映射爆炸？如何避免？</h2><ul><li><strong>定义：</strong> 当索引中包含大量<strong>唯一</strong>字段（通常是动态映射产生的）时，导致集群状态（Cluster State）变得极其庞大（可能超过数百MB甚至GB），主节点在广播和维持集群状态时压力巨大，严重影响集群稳定性和性能。</li><li><strong>原因：</strong> 常见于索引了类似日志数据，其中每个文档都有大量不同的、不可预测的字段（如包含用户ID或请求ID的字段名）。</li><li><strong>避免：</strong><ul><li><strong>严格控制动态映射：</strong> 设置 <code>&quot;dynamic&quot;: &quot;strict&quot;</code>（禁止未知字段）或 <code>&quot;dynamic&quot;: &quot;false&quot;</code>（忽略未知字段，但不索引）。优先使用<strong>显式映射</strong>。</li><li><strong>使用 <code>flattened</code> 类型：</strong> 将整个 JSON 对象映射为单个 <code>flattened</code> 字段，避免为每个内部键创建独立字段。适用于不需要独立查询&#x2F;聚合的元数据。</li><li><strong>使用 <code>object</code>&#x2F;<code>nested</code> 但限制深度：</strong> 使用 <code>index.mapping.depth.limit</code> 控制嵌套深度。</li><li><strong>字段别名：</strong> 如果不同来源的字段语义相同，用别名统一映射到一个字段。</li><li><strong>合理的索引设计：</strong> 避免将差异巨大的文档类型塞进同一个索引。</li></ul></li></ul><h2 id="什么情况下你会考虑使用-keyword-类型而不是-text-类型？"><a href="#什么情况下你会考虑使用-keyword-类型而不是-text-类型？" class="headerlink" title="什么情况下你会考虑使用 keyword 类型而不是 text 类型？"></a>什么情况下你会考虑使用 <code>keyword</code> 类型而不是 <code>text</code> 类型？</h2><ul><li>使用 <code>keyword</code> 类型当：<ul><li>需要<strong>精确匹配</strong>（e.g., 状态码、标签、ID、枚举值）。</li><li>需要<strong>聚合</strong>（Aggregations - Terms, Significant Terms）。</li><li>需要<strong>排序</strong>（Sorting）。</li><li>不需要全文分词搜索。</li></ul></li><li>使用 <code>text</code> 类型当：<ul><li>字段内容是需要被<strong>全文搜索</strong>的自然语言文本（e.g., 邮件正文、产品描述）。</li><li>需要被<strong>分词器</strong>处理（Tokenization, Normalization）。</li></ul></li><li><strong>注意：</strong> 通常对同一个字段会同时定义 <code>text</code>（用于搜索）和 <code>keyword</code>（用于聚合&#x2F;排序）多字段（Multi-fields）。</li></ul><h2 id="为什么需要段合并（Segment-Merging）？它有什么优缺点？"><a href="#为什么需要段合并（Segment-Merging）？它有什么优缺点？" class="headerlink" title="为什么需要段合并（Segment Merging）？它有什么优缺点？"></a>为什么需要段合并（Segment Merging）？它有什么优缺点？</h2><ul><li><strong>为什么需要：</strong> 频繁的 refresh 会产生大量小的 Lucene 段。小段过多会降低查询性能（需要打开更多文件句柄）且占用更多资源（文件描述符、内存）。删除操作只是标记文档为删除，空间不会立即释放。</li><li><strong>优点：</strong><ul><li>减少段数量，<strong>提升查询速度</strong>（减少文件打开和搜索范围）。</li><li><strong>真正删除</strong>被标记删除的文档，<strong>回收磁盘空间</strong>。</li><li>合并过程中优化索引结构（如压缩）。</li></ul></li><li><strong>缺点：</strong><ul><li>是 <strong>I&#x2F;O 和 CPU 密集型操作</strong>，在合并期间可能<strong>显著影响集群性能</strong>（写入延迟、查询延迟增加）。</li><li>需要额外的临时磁盘空间。</li></ul></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>学习&amp;面试-Java</title>
      <link href="/post/7992e236.html"/>
      <url>/post/7992e236.html</url>
      
        <content type="html"><![CDATA[<h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><h3 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8"></a>Java 8</h3><h4 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统方式</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Runnable 1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda 方式</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">r2</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Runnable 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">r1.run();  <span class="comment">// 输出: Runnable 1</span></span><br><span class="line">r2.run();  <span class="comment">// 输出: Runnable 2</span></span><br></pre></td></tr></table></figure><h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>只有一个抽象方法的接口，可用 <code>@FunctionalInterface</code> 注解标记</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MathOperation</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">operate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MathOperation</span> <span class="variable">add</span> <span class="operator">=</span> (a, b) -&gt; a + b;</span><br><span class="line">        System.out.println(add.operate(<span class="number">5</span>, <span class="number">3</span>));  <span class="comment">// 输出: 8</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>简化 Lambda 表达式，直接引用已有方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda 表达式</span></span><br><span class="line">names.forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法引用</span></span><br><span class="line">names.forEach(System.out::println);  <span class="comment">// 输出所有元素</span></span><br></pre></td></tr></table></figure><h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><p>在接口中提供默认实现，避免破坏现有实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一辆车!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">Vehicle</span> &#123;&#125;  <span class="comment">// 无需实现print方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Car</span>().print();  <span class="comment">// 输出: 我是一辆车!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h4><p>函数式处理集合数据（过滤、映射、归约等）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求所有偶数的平方和</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers.stream()</span><br><span class="line">        .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        .map(n -&gt; n * n)</span><br><span class="line">        .reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"></span><br><span class="line">System.out.println(sum);  <span class="comment">// 输出: 20 (2^2 + 4^2)</span></span><br></pre></td></tr></table></figure><h4 id="Optional-类"><a href="#Optional-类" class="headerlink" title="Optional 类"></a>Optional 类</h4><p>优雅处理 <code>null</code> 值，避免 <code>NullPointerException</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; name = Optional.ofNullable(getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存在时输出，不存在输出默认值</span></span><br><span class="line">System.out.println(name.orElse(<span class="string">&quot;Unknown&quot;</span>));  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全使用方法引用</span></span><br><span class="line">name.ifPresent(System.out::println);  </span><br><span class="line"></span><br><span class="line">String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Math.random() &gt; <span class="number">0.5</span> ? <span class="string">&quot;Alice&quot;</span> : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="新的日期时间-API"><a href="#新的日期时间-API" class="headerlink" title="新的日期时间 API"></a>新的日期时间 API</h4><p>解决旧 <code>java.util.Date</code> 线程安全问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前日期和时间</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">System.out.println(<span class="string">&quot;当前时间: &quot;</span> + now);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日期操作</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.of(<span class="number">2023</span>, Month.JANUARY, <span class="number">1</span>);</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">nextWeek</span> <span class="operator">=</span> date.plusWeeks(<span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;下周日期: &quot;</span> + nextWeek);  <span class="comment">// 2023-01-08</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算时间差</span></span><br><span class="line"><span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(LocalTime.NOON, LocalTime.now());</span><br><span class="line">System.out.println(<span class="string">&quot;距中午过去秒数: &quot;</span> + duration.getSeconds());</span><br></pre></td></tr></table></figure><h3 id="Java-11"><a href="#Java-11" class="headerlink" title="Java 11"></a>Java 11</h3><h4 id="局部变量类型推断增强"><a href="#局部变量类型推断增强" class="headerlink" title="局部变量类型推断增强"></a>局部变量类型推断增强</h4><p>允许在Lambda表达式中使用<code>var</code>声明参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaVarExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; names = List.of(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在Lambda中使用var声明参数</span></span><br><span class="line">        names.forEach((<span class="keyword">var</span> name) -&gt; System.out.println(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="新的字符串方法"><a href="#新的字符串方法" class="headerlink" title="新的字符串方法"></a>新的字符串方法</h4><p>新增<code>isBlank()</code>、<code>lines()</code>、<code>strip()</code>、<code>repeat()</code>等方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringMethodsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// isBlank(): 检查空或空白</span></span><br><span class="line">        System.out.println(<span class="string">&quot; &quot;</span>.isBlank()); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// lines(): 分割为行流</span></span><br><span class="line">        <span class="string">&quot;Line1\nLine2&quot;</span>.lines().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// strip(): 去除首尾空白（比trim()更智能）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;  Hello  &quot;</span>.strip()); <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// repeat(): 重复字符串</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Java&quot;</span>.repeat(<span class="number">3</span>)); <span class="comment">// &quot;JavaJavaJava&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="标准HTTP客户端"><a href="#标准HTTP客户端" class="headerlink" title="标准HTTP客户端"></a>标准HTTP客户端</h4><p>替代旧<code>HttpURLConnection</code>，支持HTTP&#x2F;2和WebSocket。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.http.HttpClient;</span><br><span class="line"><span class="keyword">import</span> java.net.http.HttpRequest;</span><br><span class="line"><span class="keyword">import</span> java.net.http.HttpResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpClientDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClient.newHttpClient();</span><br><span class="line">        <span class="type">HttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> HttpRequest.newBuilder()</span><br><span class="line">                .uri(URI.create(<span class="string">&quot;https://httpbin.org/get&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送同步请求</span></span><br><span class="line">        HttpResponse&lt;String&gt; response = </span><br><span class="line">            client.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;Status: &quot;</span> + response.statusCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;Body: &quot;</span> + response.body());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文件读写简化"><a href="#文件读写简化" class="headerlink" title="文件读写简化"></a>文件读写简化</h4><p>新增<code>readString()</code>和<code>writeString()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReadWriteDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 写入文件</span></span><br><span class="line">        Files.writeString(path, <span class="string">&quot;Hello Java 11!&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读取文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> Files.readString(path);</span><br><span class="line">        System.out.println(content); <span class="comment">// &quot;Hello Java 11!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="集合转数组的便捷方法"><a href="#集合转数组的便捷方法" class="headerlink" title="集合转数组的便捷方法"></a>集合转数组的便捷方法</h4><p><code>Collection.toArray(IntFunction)</code>简化数组转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionToArrayDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 直接传入数组构造函数引用</span></span><br><span class="line">        String[] array = list.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (String s : array) &#123;</span><br><span class="line">            System.out.println(s); <span class="comment">// 输出A, B, C</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java-17"><a href="#Java-17" class="headerlink" title="Java 17"></a>Java 17</h3><h4 id="模式匹配-instanceof"><a href="#模式匹配-instanceof" class="headerlink" title="模式匹配 instanceof"></a>模式匹配 <code>instanceof</code></h4><p>简化类型检查和转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="string">&quot;Hello Java 17&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) obj;</span><br><span class="line">    System.out.println(s.toLowerCase());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法：自动类型转换</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">    System.out.println(s.toLowerCase()); <span class="comment">// 直接使用变量 s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文本块"><a href="#文本块" class="headerlink" title="文本块"></a>文本块</h4><p>简化多行字符串处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧写法（需手动换行和转义）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">oldHtml</span> <span class="operator">=</span> <span class="string">&quot;&lt;html&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;  &lt;body&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;     &lt;p&gt;Hello&lt;/p&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;  &lt;/body&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;/html&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法：文本块（自动保留格式）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">newHtml</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                &lt;html&gt;</span></span><br><span class="line"><span class="string">                  &lt;body&gt;</span></span><br><span class="line"><span class="string">                    &lt;p&gt;Hello Java 17&lt;/p&gt;</span></span><br><span class="line"><span class="string">                  &lt;/body&gt;</span></span><br><span class="line"><span class="string">                &lt;/html&gt;</span></span><br><span class="line"><span class="string">                &quot;&quot;&quot;</span>;</span><br><span class="line">System.out.println(newHtml);</span><br></pre></td></tr></table></figure><h4 id="伪随机数生成器-API"><a href="#伪随机数生成器-API" class="headerlink" title="伪随机数生成器 API"></a>伪随机数生成器 API</h4><p>统一随机数生成器接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.random.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 选择算法（如 L32X64MixRandom）</span></span><br><span class="line">        <span class="type">RandomGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> RandomGeneratorFactory.of(<span class="string">&quot;L32X64MixRandom&quot;</span>).create();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成随机数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">randomNum</span> <span class="operator">=</span> generator.nextInt(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Random: &quot;</span> + randomNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java-21"><a href="#Java-21" class="headerlink" title="Java 21"></a>Java 21</h3><h4 id="虚拟线程"><a href="#虚拟线程" class="headerlink" title="虚拟线程"></a>虚拟线程</h4><p>轻量级线程，显著提升并发性能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">var</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;</span><br><span class="line">    IntStream.range(<span class="number">0</span>, <span class="number">10_000</span>).forEach(i -&gt; </span><br><span class="line">        executor.submit(() -&gt; &#123;</span><br><span class="line">            Thread.sleep(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125; <span class="comment">// 自动等待所有线程结束</span></span><br></pre></td></tr></table></figure><h4 id="结构化并发"><a href="#结构化并发" class="headerlink" title="结构化并发"></a>结构化并发</h4><p>简化多线程任务管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">var</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;</span><br><span class="line">    Future&lt;String&gt; user  = scope.fork(() -&gt; fetchUser());</span><br><span class="line">    Future&lt;Integer&gt; order = scope.fork(() -&gt; fetchOrder());</span><br><span class="line"></span><br><span class="line">    scope.join();          <span class="comment">// 等待所有任务</span></span><br><span class="line">    scope.throwIfFailed(); <span class="comment">// 异常传播</span></span><br><span class="line"></span><br><span class="line">    System.out.println(user.resultNow() + <span class="string">&quot;: &quot;</span> + order.resultNow());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><ul><li><strong>精通 Java 8+ 特性:</strong> Lambda 表达式、Stream API（并行流原理与陷阱）、Optional、新的日期时间 API、接口默认&#x2F;静态方法、方法引用等。理解其设计思想和内部机制。</li></ul><h3 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h3><h4 id="和equals的区别"><a href="#和equals的区别" class="headerlink" title="==和equals的区别"></a><code>==</code>和<code>equals</code>的区别</h4><p><code>==</code> 用于比较基本数据类型的值或对象引用的内存地址，<code>equals</code> 用户比较对象内容。</p><h4 id="equals和hashCode为什么要同时重写"><a href="#equals和hashCode为什么要同时重写" class="headerlink" title="equals和hashCode为什么要同时重写"></a><code>equals</code>和<code>hashCode</code>为什么要同时重写</h4><p><strong><code>Object</code>类的规范</strong>明确规定：如果两个对象通过<code>equals()</code>方法比较是相等的，那么它们的<code>hashCode()</code><strong>必须</strong>返回相同的值。</p><p>未重写的<code>hasoCode()</code>默认返回内存地址，如果只重写了<code>equals()</code>，两个对象<code>a</code>和<code>b</code>满足<code>a.equals(b) == true</code>，但<code>a.hashCode() != b.hashCode()</code>，基于哈希的集合如（<code>HashMap</code>, <code>HashSet</code>）会存储多个逻辑相等的对象。</p><p>因此重写<code>equals()</code>同时也要重写<code>hashCode()</code>，推荐实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(name, age); <span class="comment">// 包含所有equals中使用的字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异常的层次结构"><a href="#异常的层次结构" class="headerlink" title="异常的层次结构"></a>异常的层次结构</h4><p><code>Throwable</code>：所有异常和错误的父类</p><p><code>Error</code>：<strong>系统级严重问题</strong>，应用程序通常无法恢复。如<code>OutOfMemoryError</code>、<code>StackOverflowError</code>：、<code>VirtualMachineError</code></p><p><code>Exception</code>：<strong>程序可处理的异常</strong>，分为两类：</p><ul><li><p><strong>Checked Exceptions（受检异常）</strong><br>编译器强制要求处理（必须<code>try-catch</code>或<code>throws</code>）<br>✅ <strong>典型代表</strong>：<code>IOException</code>、<code>SQLException</code>、<code>ClassNotFoundException</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须处理IOException的示例</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Files.readString(Path.of(<span class="string">&quot;file.txt&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123; <span class="comment">// 必须捕获</span></span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>RuntimeException</code>（运行时异常&#x2F;非受检异常）</strong><br>编译器不强制处理，通常由<strong>编程逻辑错误</strong>引起<br>⚠️ <strong>典型代表</strong>：<code>NullPointerException</code>、<code>IndexOutOfBoundsException</code>、<code>IllegalArgumentException</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可选的运行时异常处理</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  System.out.println(str.length()); <span class="comment">// 抛出NullPointerException</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// 非强制捕获</span></span><br><span class="line">  System.out.println(<span class="string">&quot;逻辑错误！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><img src="/post/7992e236/image-20250720163023390.png" class="" title="image-20250720163023390"><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="为什么需要泛型"><a href="#为什么需要泛型" class="headerlink" title="为什么需要泛型"></a>为什么需要泛型</h4><p>泛型（Generics）是现代编程语言中一项极其重要的特性，它的出现主要是为了解决<strong>类型安全</strong>、<strong>代码复用</strong>两大问题。</p><p>📍 1. <strong>类型安全（Type Safety）</strong></p><ul><li><strong>问题：</strong> 在没有泛型之前，容器类可以存放任何类型的对象。当你从容器中取出对象时，你需要进行强制类型转换 (<code>(String) myList.get(0)</code>)。</li><li><strong>风险：</strong> 如果容器里不小心放入了错误的类型（比如你期望是 <code>String</code>，但实际放入了 <code>Integer</code>），这个错误在<strong>编译时不会被发现</strong>，只有在<strong>运行时进行强制转换时</strong>才会抛出 <code>ClassCastException</code>，导致程序崩溃。</li><li><strong>泛型解决方案：</strong> 泛型允许你在<strong>声明</strong>容器时就指定它只能存放特定类型（如 <code>List&lt;String&gt;</code>）。编译器会在<strong>编译时</strong>严格检查你放入容器的对象类型是否匹配。如果尝试放入错误类型，编译器会直接报错，阻止潜在的类型错误运行到生产环境。使用泛型容器（如 <code>List&lt;String&gt;</code>）后，当你从容器中获取元素时（如 <code>String s = myList.get(0);</code>），<strong>编译器会自动知道返回的是 <code>String</code> 类型，不需要任何强制转换</strong>。代码更简洁，更安全。</li></ul><p>♻ 2. <strong>代码复用（Code Reuse）</strong></p><ul><li><strong>问题：</strong> 编写一个算法（比如排序、搜索、比较），你希望它能作用于多种不同类型的对象（整数、字符串、自定义对象等）。没有泛型时，你需要为每种类型重写算法，或者使用 <code>Object</code> 并伴随类型检查和转换。</li><li><strong>泛型解决方案：</strong> 泛型允许你编写<strong>类型无关的算法</strong>。你可以定义一个操作在类型参数 <code>T</code> 上的方法或类（例如 <code>public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code>）。只要类型 <code>T</code> 满足算法所需的基本条件（比如实现了 <code>Comparable</code> 接口），同一个算法代码就可以安全地应用于各种不同的数据类型。</li></ul><h4 id="什么是泛型擦除"><a href="#什么是泛型擦除" class="headerlink" title="什么是泛型擦除"></a>什么是泛型擦除</h4><p>泛型擦除（Type Erasure）是 <strong>Java 泛型实现的核心机制</strong>，它指编译器在编译阶段<strong>移除所有泛型类型信息</strong>，将其替换为原始类型（Raw Type）或边界类型（Bound Type），并在必要时插入强制类型转换。这一设计主要是为了<strong>兼容旧版本的 Java（JDK 5 之前）</strong>，确保泛型代码能与非泛型遗留代码互操作。</p><p><strong>一、泛型擦除的核心规则</strong></p><ol><li><p><strong>类型参数替换为边界类型</strong></p><ul><li>若类型参数有上限（如 <code>&lt;T extends Number&gt;</code>），<code>T</code> 被替换为<strong>边界类型</strong>（<code>Number</code>）。</li><li>若无明确上限（如 <code>&lt;T&gt;</code>），<code>T</code> 被替换为 <code>Object</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123; <span class="built_in">this</span>.value = value; &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后（擦除后）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object value;         <span class="comment">// T → Object</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Object value)</span> &#123; <span class="built_in">this</span>.value = value; &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">()</span> &#123; <span class="keyword">return</span> value; &#125; <span class="comment">// 返回 Object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>在调用处插入强制类型转换</strong><br>编译器在<strong>使用泛型的地方</strong>自动添加类型转换代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line">Box&lt;String&gt; box = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();</span><br><span class="line">box.set(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> box.get(); <span class="comment">// 无需显式转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后（擦除后）</span></span><br><span class="line"><span class="type">Box</span> <span class="variable">box</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Box</span>();</span><br><span class="line">box.set(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) box.get(); <span class="comment">// 编译器插入 (String) 强制转换</span></span><br></pre></td></tr></table></figure></li><li><p><strong>保证类型安全的桥接方法（Bridge Methods）</strong><br>当泛型类继承或实现接口时，编译器会生成<strong>合成方法</strong>确保多态性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译前</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T other)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String other)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后（擦除后）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="comment">// 编译器生成的桥接方法（保持多态）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object other)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> compareTo((String) other); <span class="comment">// 调用实际方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际编写的泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String other)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>二、泛型擦除导致的关键限制</strong></p><ol><li><p><strong>无法使用基本类型作为类型参数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 编译错误！不能使用 int</span></span><br><span class="line">List&lt;<span class="type">int</span>&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br><span class="line"><span class="comment">// 必须使用包装类</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br></pre></td></tr></table></figure></li><li><p><strong>无法获取泛型具体类型的 <code>Class</code> 对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// ❌ 编译错误！List&lt;String&gt;.class 不存在</span></span><br><span class="line">Class&lt;?&gt; clazz = list.getClass(); </span><br><span class="line"><span class="comment">// 输出：java.util.ArrayList（无法得知是 List&lt;String&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>无法创建泛型数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 编译错误！</span></span><br><span class="line">T[] array = <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">10</span>]; </span><br><span class="line"><span class="comment">// 替代方案：使用反射或 ArrayList</span></span><br></pre></td></tr></table></figure></li><li><p><strong>方法签名冲突（重载失效）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 编译错误！擦除后都是 void print(List list)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;String&gt; list)</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;Integer&gt; list)</span> &#123; ... </span><br></pre></td></tr></table></figure></li></ol><p><strong>三、如何绕过擦除的限制？</strong></p><ol><li><p><strong>类型令牌（Type Token）</strong><br>通过传递 <code>Class&lt;T&gt;</code> 对象保留类型信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Box</span><span class="params">(Class&lt;T&gt; type)</span> &#123; <span class="built_in">this</span>.type = type; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInstance</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type.isInstance(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>反射 API（Reflection）</strong><br>运行时获取泛型参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取泛型类的泛型类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassGenericReflection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建具有具体类型的Box实例</span></span><br><span class="line">        Box&lt;String&gt; stringBox = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;String&gt;() &#123;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取实际泛型参数</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Type</span> <span class="variable">genericSuperclass</span> <span class="operator">=</span> stringBox.getClass().getGenericSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (genericSuperclass <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) genericSuperclass;</span><br><span class="line">            <span class="keyword">final</span> Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">            <span class="keyword">if</span> (actualTypeArguments.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;泛型参数: &quot;</span> + actualTypeArguments[<span class="number">0</span>]); <span class="comment">// 输出: class java.lang.String</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取泛型字段的泛型类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldGenericReflection</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Box&lt;String&gt; stringBox;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> FieldGenericReflection.class.getDeclaredField(<span class="string">&quot;stringBox&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Type</span> <span class="variable">genericType</span> <span class="operator">=</span> field.getGenericType();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (genericType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) genericType;</span><br><span class="line">            <span class="keyword">final</span> Type[] arguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">            <span class="keyword">if</span> (arguments.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Box的泛型参数: &quot;</span> + arguments[<span class="number">0</span>]); <span class="comment">// class java.lang.String</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取泛型方法形参的类型参数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParameterGenericReflection</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(List&lt;Box&lt;String&gt;&gt; boxes)</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> Processor.class.getMethod(<span class="string">&quot;process&quot;</span>, List.class);</span><br><span class="line">        <span class="keyword">final</span> Type[] parameterTypes = method.getGenericParameterTypes();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Type parameterType : parameterTypes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parameterType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">ParameterizedType</span> <span class="variable">pt</span> <span class="operator">=</span> (ParameterizedType) parameterType;</span><br><span class="line">                System.out.println(<span class="string">&quot;参数类型：&quot;</span> + pt.getRawType());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> Type[] typeArguments = pt.getActualTypeArguments();</span><br><span class="line">                <span class="keyword">for</span> (Type typeArgument : typeArguments) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (typeArgument <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="type">ParameterizedType</span> <span class="variable">nestedPt</span> <span class="operator">=</span> (ParameterizedType) typeArgument;</span><br><span class="line">                        System.out.println(<span class="string">&quot;嵌套类型：&quot;</span> + nestedPt.getRawType());</span><br><span class="line">                        <span class="keyword">final</span> Type[] nestedTypeArguments = nestedPt.getActualTypeArguments();</span><br><span class="line">                        <span class="keyword">if</span> (nestedTypeArguments.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;嵌套泛型参数：&quot;</span> + nestedTypeArguments[<span class="number">0</span>]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取泛型方法返回值的类型参数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReturnTypeGenericReflection</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Integer&gt; <span class="title function_">getMappings</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> ReturnTypeGenericReflection.class.getMethod(<span class="string">&quot;getMappings&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Type</span> <span class="variable">returnType</span> <span class="operator">=</span> method.getGenericReturnType();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (returnType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) returnType;</span><br><span class="line">            <span class="keyword">final</span> Type[] typeArguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; typeArguments.length; i++) &#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">&quot;第%d个泛型参数：%s&quot;</span>, i + <span class="number">1</span>, typeArguments[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="泛型的上下限及应用场景"><a href="#泛型的上下限及应用场景" class="headerlink" title="泛型的上下限及应用场景"></a>泛型的上下限及应用场景</h4><p>泛型的<strong>上限（Upper Bound）</strong> 和<strong>下限（Lower Bound）</strong> 是用于<strong>约束类型参数范围</strong>的关键机制，主要解决泛型代码需要<strong>限制可接受的类型</strong>或<strong>支持更灵活的子类型关系</strong>的问题。以下是详细解释：</p><p><strong>一、泛型的上限（Upper Bound）</strong></p><p>定义：限制类型参数必须是<strong>某个类&#x2F;接口本身或其子类</strong>。<br>语法：<code>&lt;T extends 类/接口&gt;</code> 或 <code>&lt;? extends 类/接口&gt;</code>（通配符形式）。</p><p><strong>核心作用</strong></p><ol><li><p><strong>确保类型具备某些能力</strong><br>要求类型 <code>T</code> 必须实现特定接口（如 <code>Comparable</code>）或继承特定类，从而在泛型代码中安全调用其方法。<br><strong>示例</strong>：要求类型必须可比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T 必须是实现了 Comparable 接口的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; T <span class="title function_">max</span><span class="params">(T a, T b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.compareTo(b) &gt; <span class="number">0</span> ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可安全调用 a.compareTo(b)</span></span><br></pre></td></tr></table></figure></li><li><p><strong>安全访问数据（只读不写）</strong><br>在通配符 <code>? extends T</code> 中，表示“某个 <code>T</code> 的子类型”，此时容器<strong>只能读取数据</strong>（返回 <code>T</code> 类型），<strong>不能写入数据</strong>（除 <code>null</code> 外）。<br><strong>示例</strong>：安全读取数字集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">printNumbers</span><span class="params">(List&lt;? extends Number&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Number n : list) &#123;</span><br><span class="line">        System.out.println(n);  <span class="comment">// ✅ 可读</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// list.add(10); ❌ 编译错误！无法写入（除 null 外）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>典型场景</strong></p><ul><li>定义泛型类&#x2F;方法时，约束类型参数的能力（如 <code>T extends Runnable</code>）。</li><li>作为方法参数时，安全接收<strong>某种子类型的集合</strong>（生产者场景）。</li></ul><p><strong>二、泛型的下限（Lower Bound）</strong></p><p>定义：限制类型参数必须是<strong>某个类&#x2F;接口本身或其父类</strong>。<br>语法：<code>&lt;? super 类/接口&gt;</code>（仅通配符形式）。</p><p><strong>核心作用</strong></p><ol><li><p><strong>支持安全写入数据</strong><br>表示“某个 <code>T</code> 的父类型”，此时容器<strong>可以写入 <code>T</code> 及其子类型对象</strong>，但读取时只能视为 <code>Object</code>。<br><strong>示例</strong>：向集合添加元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addNumbers</span><span class="params">(List&lt;? <span class="built_in">super</span> Integer&gt; list)</span> &#123;</span><br><span class="line">    list.add(<span class="number">10</span>);     <span class="comment">// ✅ 可写入 Integer</span></span><br><span class="line">    list.add(<span class="number">1000L</span>);  <span class="comment">// ❌ 错误！Long 不是 Integer 的子类</span></span><br><span class="line">    <span class="comment">// Object obj = list.get(0);  // 读取时只能视为 Object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>实现灵活的子类型兼容</strong><br>允许方法接收比预期更宽泛的容器（如需要 <code>List&lt;Number&gt;</code> 时，也可传入 <code>List&lt;Object&gt;</code>）。</p></li></ol><p><strong>典型场景</strong></p><ul><li><p>向泛型容器<strong>写入数据</strong>（消费者场景）。</p></li><li><p>配合 <code>Comparator</code> 等接口实现类型灵活的API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可接收 Person 或其父类的 Comparator</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;Person&gt; list, Comparator&lt;? <span class="built_in">super</span> Person&gt; comparator)</span> &#123;</span><br><span class="line">    Collections.sort(list, comparator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>三、关键对比：<code>extends</code> vs <code>super</code></strong></p><table><thead><tr><th align="left"><strong>特性</strong></th><th align="left"><strong>上限 (<code>? extends T</code>)</strong></th><th align="left"><strong>下限 (<code>? super T</code>)</strong></th></tr></thead><tbody><tr><td align="left"><strong>类型范围</strong></td><td align="left"><code>T</code> 或其<strong>子类型</strong></td><td align="left"><code>T</code> 或其<strong>父类型</strong></td></tr><tr><td align="left"><strong>数据读取</strong></td><td align="left">✅ 返回 <code>T</code> 类型</td><td align="left">❌ 只能视为 <code>Object</code></td></tr><tr><td align="left"><strong>数据写入</strong></td><td align="left">❌ 禁止（除 <code>null</code>）</td><td align="left">✅ 可写入 <code>T</code> <strong>及其子类</strong></td></tr><tr><td align="left"><strong>设计意图</strong></td><td align="left"><strong>生产者</strong>（Producer）只提供数据</td><td align="left"><strong>消费者</strong>（Consumer）只消费数据</td></tr><tr><td align="left"><strong>经典口诀</strong></td><td align="left"><strong>PECS</strong> (Producer-Extends, Consumer-Super)</td><td align="left"></td></tr></tbody></table><p><strong>四、实际应用：PECS 原则</strong></p><p>在泛型编程中，遵循 <strong>PECS（Producer-Extends, Consumer-Super）</strong> 原则：</p><ul><li><strong>生产者（Producer）</strong>：产生 <code>T</code> 的对象 → 用 <code>&lt;? extends T&gt;</code></li><li><strong>消费者（Consumer）</strong>：消费 <code>T</code> 的对象 → 用 <code>&lt;? super T&gt;</code></li></ul><p><strong>示例</strong>：Java 集合工具类 <code>Collections.copy()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(</span></span><br><span class="line"><span class="params">    List&lt;? <span class="built_in">super</span> T&gt; dest,    // 消费者：写入目标集合</span></span><br><span class="line"><span class="params">    List&lt;? extends T&gt; src    // 生产者：读取源集合</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; src.size(); i++) &#123;</span><br><span class="line">        dest.set(i, src.get(i));  <span class="comment">// ✅ 安全读写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h4 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h4><p>在程序运行期间动态获取类或对象信息以及动态调用对象方法的功能称为 Java 的反射机制。</p><p><strong>优点：</strong>动态、灵活。IOC、AOP设计的基石。</p><p><strong>缺点：</strong>性能开销大、破坏封装、实现复杂。</p><p><strong>反射的实际应用场景</strong></p><ul><li><strong>框架开发：</strong> 是几乎所有 Java 框架的核心（如 Spring, Hibernate, MyBatis, JUnit）。<ul><li><strong>Spring IOC：</strong> 通过反射读取配置（XML 或注解），动态创建 Bean 实例，注入依赖。</li><li><strong>Spring AOP：</strong> 动态代理（JDK Proxy 或 CGLIB）底层依赖反射调用目标方法。</li><li><strong>Hibernate&#x2F;MyBatis：</strong> 将数据库结果集映射到 Java 对象时，通过反射设置对象的属性值。</li></ul></li><li><strong>注解处理：</strong> 在运行时通过反射读取类、方法、字段上的注解信息，并根据注解执行特定逻辑（如 JUnit 查找 <code>@Test</code> 方法）。</li><li><strong>动态代理：</strong> JDK 动态代理 (<code>java.lang.reflect.Proxy</code>) 的核心就是利用反射调用被代理对象的方法。</li><li><strong>通用工具库：</strong> 如 Apache Commons BeanUtils, Jackson&#x2F;Gson (JSON 序列化&#x2F;反序列化)，通过反射操作对象的属性。</li><li><strong>IDE 和开发工具：</strong> 代码提示、调试器、反编译工具等利用反射获取类的结构信息。</li></ul><h4 id="如何获取一个类的-Class-对象"><a href="#如何获取一个类的-Class-对象" class="headerlink" title="如何获取一个类的 Class 对象"></a>如何获取一个类的 <code>Class</code> 对象</h4><ol><li><code>Class clazz = instance.getClass();</code> (通过对象实例获取)</li><li><code>Class clazz = ClassName.class;</code> (通过类字面常量 <code>.class</code> 获取)</li><li><code>Class clazz = Class.forName(&quot;fully.qualified.ClassName&quot;);</code> (通过完整类名字符串获取，常用，可能抛出 <code>ClassNotFoundException</code>)</li><li>(对于基本类型和数组) <code>Class clazz = int.class;</code> &#x2F; <code>Class clazz = String[].class;</code></li></ol><h4 id="如何通过反射创建一个类的实例"><a href="#如何通过反射创建一个类的实例" class="headerlink" title="如何通过反射创建一个类的实例"></a>如何通过反射创建一个类的实例</h4><p><strong>使用 <code>Class.newInstance()</code>（已过时）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) clazz.newInstance(); <span class="comment">// 调用无参构造器</span></span><br></pre></td></tr></table></figure><p><strong>使用 <code>Constructor.newInstance()</code> (推荐)：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getConstructor(String.class, <span class="type">int</span>.class); <span class="comment">// 获取特定参数类型的构造器</span></span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) constructor.newInstance(<span class="string">&quot;arg1&quot;</span>, <span class="number">42</span>); <span class="comment">// 传入参数创建实例</span></span><br></pre></td></tr></table></figure><p><code>clazz.newInstance()</code>只能调用无参构造器，在 Java 9 开始被标记为 <code>@Deprecated(since=&quot;9&quot;)</code>，推荐使用 <code>Constructor.newInstance()</code>。</p><h4 id="Class-forName-和-ClassLoader-loadClass-的区别"><a href="#Class-forName-和-ClassLoader-loadClass-的区别" class="headerlink" title="Class.forName() 和 ClassLoader.loadClass() 的区别"></a><code>Class.forName()</code> 和 <code>ClassLoader.loadClass()</code> 的区别</h4><ul><li><code>Class.forName(String name)</code>：<ul><li>默认会触发类的<strong>加载、链接（验证、准备）、初始化</strong>（执行 <code>&lt;clinit&gt;</code> 静态初始化块）。</li><li>有一个重载方法 <code>Class.forName(String name, boolean initialize, ClassLoader loader)</code> 可以控制是否初始化 (<code>initialize</code>) 和指定类加载器 (<code>loader</code>)。</li></ul></li><li><code>ClassLoader.loadClass(String name)</code>：<ul><li>只触发类的<strong>加载</strong>和<strong>链接（验证、准备）</strong> 阶段，<strong>不会执行初始化</strong> (<code>&lt;clinit&gt;</code>)。只有首次主动使用时（如创建实例、访问静态字段&#x2F;方法）才会初始化。</li></ul></li></ul><h4 id="如何防止反射破坏单例模式"><a href="#如何防止反射破坏单例模式" class="headerlink" title="如何防止反射破坏单例模式"></a><strong>如何防止反射破坏单例模式</strong></h4><p><strong>使用枚举实现单例 (推荐)：</strong> 枚举的单例实现是《Effective Java》作者 Josh Bloch 强烈推荐的方式。JVM 从根本上保证了枚举类型的构造器只会被调用一次，且反射 API 被设计为<strong>不能通过反射创建枚举实例</strong>（<code>Constructor.newInstance()</code> 方法内部会检查并阻止）。这是最安全、简洁的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE; <span class="comment">// 唯一的单例实例</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单例的业务方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Singleton instance is working...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单例的业务属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ++counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取单例实例</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> Singleton.INSTANCE;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用业务方法</span></span><br><span class="line">        singleton.doSomething();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用业务属性</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Counter: &quot;</span> + singleton.incrementAndGet());</span><br><span class="line">        System.out.println(<span class="string">&quot;Counter: &quot;</span> + singleton.incrementAndGet());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 验证单例性</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">anotherInstance</span> <span class="operator">=</span> Singleton.INSTANCE;</span><br><span class="line">        System.out.println(<span class="string">&quot;Same instance? &quot;</span> + (singleton == anotherInstance));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">Singleton instance is working...</span><br><span class="line">Counter: <span class="number">1</span></span><br><span class="line">Counter: <span class="number">2</span></span><br><span class="line">Same instance? <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>动态代理是一种在运行时生成代理对象的机制，它在不改变原有代码的情况下，通过代理对象对原有对象进行增强、扩展或限制等操作。</p><p>在 Java 中，动态代理主要有两种实现方式：<strong>基于接口的动态代理</strong>和<strong>基于类的动态代理</strong>。其中，基于接口的动态代理使用 Java 自带的 java.lang.reflect.Proxy 类实现，而基于类的动态代理则需要使用第三方库，如 CGLIB 或 ByteBuddy 等。</p><p><strong>基于接口的动态代理</strong></p><p>基于接口的动态代理要求目标对象必须实现一个或多个接口，动态代理对象会实现这些接口。在创建动态代理对象时，需要提供一个实现了 InvocationHandler 接口的代理处理器对象，它会在代理对象方法调用时被回调。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloImpl</span> <span class="keyword">implements</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HelloHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before method invocation&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;After method invocation&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloImpl</span>();</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">proxy</span> <span class="operator">=</span> (Hello) Proxy.newProxyInstance(</span><br><span class="line">            hello.getClass().getClassLoader(),</span><br><span class="line">            hello.getClass().getInterfaces(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">HelloHandler</span>(hello)</span><br><span class="line">        );</span><br><span class="line">        proxy.sayHello(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基于类的动态代理</strong></p><p>基于类的动态代理则不要求目标对象必须实现接口，而是通过创建目标对象的子类来实现代理。在创建动态代理对象时，需要提供一个实现了 MethodInterceptor 接口的拦截器对象，它会在代理对象方法调用时被回调。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before method invocation&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;After method invocation&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(Hello.class);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">HelloInterceptor</span>());</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">proxy</span> <span class="operator">=</span> (Hello) enhancer.create();</span><br><span class="line">        proxy.sayHello(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><p>Java 集合框架主要包括 <code>Collection</code> 和 <code>Map</code> 两大接口体系。<code>Collection</code> 主要有 <code>List</code>、<code>Set</code>、<code>Queue</code> 几个核心子接口。</p><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="什么是-fail-fast-机制"><a href="#什么是-fail-fast-机制" class="headerlink" title="什么是 fail-fast 机制"></a><strong>什么是 <code>fail-fast</code> 机制</strong></h4><ul><li>一种<strong>错误检测机制</strong>。当使用迭代器 (<code>Iterator</code>) 遍历集合时，如果<strong>在遍历过程中（除了通过迭代器自身的 <code>remove()</code> 方法外）集合结构被修改</strong>（添加、删除元素），会立即抛出 <code>ConcurrentModificationException</code>。</li><li><strong>实现原理</strong>：集合内部维护一个 <code>modCount</code> (修改计数器)。创建迭代器时，会将当前的 <code>modCount</code> 记录为 <code>expectedModCount</code>。在迭代过程中，每次调用 <code>next()</code>、<code>remove()</code> 等方法前都会检查 <code>modCount == expectedModCount</code>。如果不相等，说明有其他线程或本线程其他操作修改了集合结构，抛出异常。</li><li><strong>目的</strong>：快速失败，避免在不确定状态下继续操作导致更难以预料的结果。<strong>它不能保证并发修改一定被检测到，主要用于单线程环境下的错误检测</strong>。</li></ul><h4 id="fail-fast-和-fail-safe-的区别"><a href="#fail-fast-和-fail-safe-的区别" class="headerlink" title="fail-fast 和 fail-safe 的区别"></a><strong><code>fail-fast</code> 和 <code>fail-safe</code> 的区别</strong></h4><ul><li><strong><code>fail-fast</code><strong>：直接在原集合上操作。迭代时检测到并发修改就</strong>立即抛异常</strong>。代表：<code>ArrayList</code>, <code>HashMap</code> 等非并发集合的迭代器。</li><li><strong><code>fail-safe</code> (Concurrent Modification Tolerance)<strong>：</strong>不在原集合上操作</strong>，而是基于原集合的<strong>快照 (snapshot)</strong> 或 <strong>只读视图</strong> 进行迭代。迭代过程中原集合的修改不会影响迭代器，不会抛异常。代表：<code>ConcurrentHashMap</code>, <code>CopyOnWriteArrayList</code> 的迭代器。</li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a><code>List</code></h3><h4 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a><code>ArrayList</code>的扩容机制</h4><ul><li>使用 <code>Object[] elementData</code> 存储元素。</li><li>创建时如果未指定大小，初始容量为 <strong>0</strong> (JDK 1.8+) 或 <strong>10</strong> (旧版本，需确认具体版本)，第一次添加元素时扩容到 <strong>10</strong>。</li><li>当添加元素时发现容量不足（<code>size + 1 &gt; elementData.length</code>），触发扩容， <strong>新容量是原容量的1.5倍</strong>。</li><li>创建一个新的更大的数组，将旧数组元素<strong>复制</strong>到新数组。</li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a><code>Set</code></h3><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a><code>Map</code></h3><h4 id="HashMap-的实现原理"><a href="#HashMap-的实现原理" class="headerlink" title="HashMap 的实现原理"></a><code>HashMap</code> 的实现原理</h4><p><strong>JDK7：数组 + 链表</strong></p><ul><li><strong>扩容</strong>：创建新数组 (通常是原数组长度的 <strong>2倍</strong>)，遍历所有元素，<strong>重新计算每个元素在新数组中的位置</strong> (<code>rehash</code>)，将元素转移到新数组。<strong>头插法会导致扩容时链表元素顺序反转</strong>。</li></ul><p><strong>JDK8：数组 + 链表 &#x2F; 红黑树</strong></p><p><strong>主要改进</strong>：</p><ul><li><strong>尾插法</strong>：解决 JDK7 头插法多线程下可能导致死循环的问题（未解决线程安全问题）。</li><li><strong>链表转红黑树</strong>：当链表长度 <strong>&gt;&#x3D; 8 (TREEIFY_THRESHOLD)</strong> 且 <strong>数组长度 &gt;&#x3D; 64 (MIN_TREEIFY_CAPACITY)</strong> 时，链表转换为红黑树，提高长链表的查找效率 (O(n) -&gt; O(log n))。</li><li><strong>优化哈希算法</strong>：<code>(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，高位参与运算，减少哈希冲突。</li><li><strong>扩容</strong>：根据 <code>(e.hash &amp; oldCap) == 0</code> 将链表拆分成两个子链表，结果为 0 的节点保持原索引位置 <code>i</code>，结果不为 0 的节点放到新位置 <code>i + oldCap</code>，避免全量 <code>rehash</code>，提升了效率。</li></ul><h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h2><h3 id="字节流与字符流的区别"><a href="#字节流与字符流的区别" class="headerlink" title="字节流与字符流的区别"></a>字节流与字符流的区别</h3><ul><li><strong>字节流</strong>：<code>InputStream</code>&#x2F;<code>OutputStream</code>，处理二进制数据（如图片、视频），核心类如 <code>FileInputStream</code>。</li><li><strong>字符流</strong>：<code>Reader</code>&#x2F;<code>Writer</code>，处理文本数据（自动处理编码），核心类如 <code>FileReader</code>、<code>InputStreamReader</code>。</li><li><strong>关键点</strong>：字符流底层依赖字节流 + 编码转换（如 <code>InputStreamReader</code> 是字节到字符的桥梁）。</li></ul><p><strong>为什么要有字符流？</strong></p><ul><li>直接操作字符更高效，避免手动处理编码（如 UTF-8 转码），解决乱码问题。</li></ul><h3 id="BIO、NIO、AIO的区别"><a href="#BIO、NIO、AIO的区别" class="headerlink" title="BIO、NIO、AIO的区别"></a>BIO、NIO、AIO的区别</h3><table><thead><tr><th align="left"><strong>特性</strong></th><th align="left">传统 IO</th><th align="left">NIO</th></tr></thead><tbody><tr><td align="left"><strong>模型</strong></td><td align="left">阻塞式（Blocking）</td><td align="left">非阻塞式（Non-blocking）</td></tr><tr><td align="left"><strong>数据单位</strong></td><td align="left">流（Stream）</td><td align="left">缓冲区（Buffer） + 通道（Channel）</td></tr><tr><td align="left"><strong>多路复用</strong></td><td align="left">不支持</td><td align="left">Selector 轮询机制</td></tr></tbody></table><h3 id="NIO-三大核心组件"><a href="#NIO-三大核心组件" class="headerlink" title="NIO 三大核心组件"></a>NIO 三大核心组件</h3><ul><li><strong>Buffer</strong>：数据容器（如 <code>ByteBuffer</code>），支持 <code>flip()</code>、<code>clear()</code> 等操作。</li><li><strong>Channel</strong>：双向数据传输通道（如 <code>FileChannel</code>、<code>SocketChannel</code>）。</li><li><strong>Selector</strong>：单线程监听多个 Channel 事件（<code>OP_READ</code>、<code>OP_WRITE</code>）。</li></ul><h3 id="五大IO模型"><a href="#五大IO模型" class="headerlink" title="五大IO模型"></a>五大IO模型</h3><p><strong>1. 阻塞 I&#x2F;O 模型 (Blocking I&#x2F;O)</strong></p><p><strong>特点</strong>：线程发起 I&#x2F;O 操作后会被挂起，直到操作完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器端</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>)) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 阻塞直到客户端连接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">clientSocket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> clientSocket.getInputStream()) &#123;</span><br><span class="line">                <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="comment">// 阻塞直到数据到达</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> in.read(buffer);</span><br><span class="line">                <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">                System.out.println(<span class="string">&quot;Received: &quot;</span> + data);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 非阻塞 I&#x2F;O 模型 (Non-blocking I&#x2F;O)</strong></p><p><strong>特点</strong>：线程立即返回结果，通过轮询检查就绪状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器端</span></span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">serverChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">serverChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">serverChannel.configureBlocking(<span class="literal">false</span>); <span class="comment">// 设置为非阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 立即返回，可能为 null</span></span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> serverChannel.accept();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (clientChannel != <span class="literal">null</span>) &#123;</span><br><span class="line">        clientChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 非阻塞读取</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> clientChannel.read(buffer);</span><br><span class="line">        <span class="keyword">if</span> (bytesRead &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[buffer.limit()];</span><br><span class="line">            buffer.get(data);</span><br><span class="line">            System.out.println(<span class="string">&quot;Received: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 可执行其他任务</span></span><br><span class="line">        Thread.sleep(<span class="number">100</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. I&#x2F;O 多路复用模型 (I&#x2F;O Multiplexing)</strong></p><p><strong>特点</strong>：使用单个线程管理多个 I&#x2F;O 通道</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器端</span></span><br><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">serverChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">serverChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">serverChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 阻塞直到有就绪事件</span></span><br><span class="line">    selector.select();</span><br><span class="line">    </span><br><span class="line">    Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; iter = selectedKeys.iterator();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            <span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> server.accept();</span><br><span class="line">            client.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            client.read(buffer);</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">// 处理数据...</span></span><br><span class="line">        &#125;</span><br><span class="line">        iter.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 信号驱动 I&#x2F;O 模型 (Signal-driven I&#x2F;O)</strong></p><p><strong>特点</strong>：通过信号通知 I&#x2F;O 就绪状态（Java 不直接支持）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* C语言示例（Java无直接对应API） */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigio_handler</span><span class="params">(<span class="type">int</span> signo)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理I/O就绪事件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    signal(SIGIO, sigio_handler);</span><br><span class="line">    fcntl(sockfd, F_SETOWN, getpid());</span><br><span class="line">    fcntl(sockfd, F_SETFL, O_ASYNC | O_NONBLOCK);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. 异步 I&#x2F;O 模型 (Asynchronous I&#x2F;O)</strong></p><p><strong>特点</strong>：I&#x2F;O 操作完成后自动通知，无需等待</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器端</span></span><br><span class="line"><span class="type">AsynchronousServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> </span><br><span class="line">    AsynchronousServerSocketChannel.open().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步接受连接</span></span><br><span class="line">server.accept(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, Void&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(AsynchronousSocketChannel client, Void attachment)</span> &#123;</span><br><span class="line">        server.accept(<span class="literal">null</span>, <span class="built_in">this</span>); <span class="comment">// 继续接受新连接</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 异步读取数据</span></span><br><span class="line">        client.read(buffer, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, Void&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer bytesRead, Void attachment)</span> &#123;</span><br><span class="line">                buffer.flip();</span><br><span class="line">                <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[buffer.limit()];</span><br><span class="line">                buffer.get(data);</span><br><span class="line">                System.out.println(<span class="string">&quot;Async received: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, Void attachment)</span> &#123;</span><br><span class="line">                exc.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, Void attachment)</span> &#123;</span><br><span class="line">        exc.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>各模型对比总结</strong></p><table><thead><tr><th align="left">模型</th><th align="left">阻塞阶段</th><th align="left">Java 实现</th><th align="left">优点</th><th align="left">缺点</th></tr></thead><tbody><tr><td align="left"><strong>阻塞 I&#x2F;O</strong></td><td align="left">等待数据到达和复制</td><td align="left"><code>Socket</code>, <code>ServerSocket</code></td><td align="left">编程简单</td><td align="left">线程资源浪费</td></tr><tr><td align="left"><strong>非阻塞 I&#x2F;O</strong></td><td align="left">无（但需轮询）</td><td align="left">NIO <code>configureBlocking(false)</code></td><td align="left">单线程管理多连接</td><td align="left">轮询消耗 CPU</td></tr><tr><td align="left"><strong>I&#x2F;O 多路复用</strong></td><td align="left">等待事件通知</td><td align="left">NIO <code>Selector</code></td><td align="left">高效管理大量连接</td><td align="left">编程较复杂</td></tr><tr><td align="left"><strong>信号驱动 I&#x2F;O</strong></td><td align="left">无（但需处理信号）</td><td align="left">Java 不支持</td><td align="left">减少轮询开销</td><td align="left">编程复杂，信号队列溢出</td></tr><tr><td align="left"><strong>异步 I&#x2F;O</strong></td><td align="left">无（完全异步）</td><td align="left">NIO.2 <code>AsynchronousChannel</code></td><td align="left">真正非阻塞，资源利用率高</td><td align="left">编程模型复杂</td></tr></tbody></table><h3 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h3><ul><li>单Reactor单线程</li><li>单Reactor多线程</li><li>主从Reactor多线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleReactor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Reactor</span>(<span class="number">8083</span>)).start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Reactor服务器启动，监听端口: 8083&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Reactor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Selector selector;</span><br><span class="line">        <span class="keyword">final</span> ServerSocketChannel serverSocket;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">workerPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        Reactor(<span class="type">int</span> port) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            serverSocket = ServerSocketChannel.open();</span><br><span class="line">            serverSocket.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port));</span><br><span class="line">            serverSocket.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册ACCEPT事件到Selector</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">SelectionKey</span> <span class="variable">sk</span> <span class="operator">=</span> serverSocket.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            sk.attach(<span class="keyword">new</span> <span class="title class_">Acceptor</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                    <span class="comment">// 阻塞等待事件</span></span><br><span class="line">                    selector.select();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();</span><br><span class="line">                    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                        <span class="comment">// 分发事件</span></span><br><span class="line">                        dispatch(it.next());</span><br><span class="line">                        it.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(SelectionKey key)</span> &#123;</span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">handler</span> <span class="operator">=</span> (Runnable) key.attachment();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">                handler.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Acceptor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                    <span class="keyword">if</span> (client != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 创建业务处理器</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Handler</span>(selector, client, workerPool);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Handler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="comment">// 最大输入数据</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_IN</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> SocketChannel socket;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> SelectionKey sk;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService workerPool;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">ByteBuffer</span> <span class="variable">input</span> <span class="operator">=</span> ByteBuffer.allocate(MAX_IN);</span><br><span class="line">        <span class="keyword">private</span> <span class="type">ByteBuffer</span> <span class="variable">output</span> <span class="operator">=</span> ByteBuffer.allocate(MAX_IN);</span><br><span class="line"></span><br><span class="line">        Handler(Selector selector, SocketChannel socket, ExecutorService workerPool) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="built_in">this</span>.socket = socket;</span><br><span class="line">            <span class="built_in">this</span>.workerPool = workerPool;</span><br><span class="line">            socket.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册READ事件</span></span><br><span class="line">            sk = socket.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            <span class="comment">// 绑定handler</span></span><br><span class="line">            sk.attach(<span class="built_in">this</span>);</span><br><span class="line">            <span class="comment">// 唤醒selector</span></span><br><span class="line">            selector.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (sk.isReadable()) &#123;</span><br><span class="line">                    read();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sk.isWritable()) &#123;</span><br><span class="line">                    write();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                closeConnection();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            input.clear();</span><br><span class="line">            <span class="comment">// 读操作依然在Reactor主线程</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> socket.read(input);</span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 业务处理另起线程</span></span><br><span class="line">                workerPool.execute(<span class="keyword">new</span> <span class="title class_">Processor</span>(<span class="keyword">new</span> <span class="title class_">String</span>(input.array(), <span class="number">0</span>, n)));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                closeConnection();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            output.flip();</span><br><span class="line">            <span class="comment">// 写操作依然在Reactor主线</span></span><br><span class="line">            socket.write(output);</span><br><span class="line">            <span class="keyword">if</span> (!output.hasRemaining()) &#123;</span><br><span class="line">                <span class="comment">// 写完后重新注册读事件</span></span><br><span class="line">                sk.interestOps(SelectionKey.OP_READ);</span><br><span class="line">            &#125;</span><br><span class="line">            output.compact();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">closeConnection</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sk.cancel();</span><br><span class="line">                socket.close();</span><br><span class="line">                System.out.println(<span class="string">&quot;连接关闭：&quot;</span> + socket.getRemoteAddress());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Processor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> String request;</span><br><span class="line"></span><br><span class="line">            Processor(String request) &#123;</span><br><span class="line">                <span class="built_in">this</span>.request = request;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟业务操作</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> request.toUpperCase(Locale.ROOT);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 注意：非Reactor线程操作，需要同步</span></span><br><span class="line">                <span class="keyword">synchronized</span> (output) &#123;</span><br><span class="line">                    output.put(response.getBytes());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 注册写事件</span></span><br><span class="line">                    sk.interestOps(SelectionKey.OP_WRITE);</span><br><span class="line">                &#125;</span><br><span class="line">                sk.selector().wakeup();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReactorClient</span> &#123;</span><br><span class="line">    <span class="comment">// 客户端数量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CLIENT_COUNT</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    <span class="comment">// 每个客户端请求次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REQUEST_PER_CLIENT</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SERVER_HOST</span> <span class="operator">=</span> <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SERVER_PORT</span> <span class="operator">=</span> <span class="number">8083</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(CLIENT_COUNT);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; CLIENT_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">clientId</span> <span class="operator">=</span> i;</span><br><span class="line">            pool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; REQUEST_PER_CLIENT; j++) &#123;</span><br><span class="line">                        sendRequest(clientId, j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        latch.await();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">duration</span> <span class="operator">=</span> System.currentTimeMillis() - start;</span><br><span class="line">        System.out.printf(<span class="string">&quot;\n测试完成! 总请求: %d, 耗时: %dms, QPS: %.1f\n&quot;</span>,</span><br><span class="line">            CLIENT_COUNT * REQUEST_PER_CLIENT,</span><br><span class="line">            duration,</span><br><span class="line">            CLIENT_COUNT * REQUEST_PER_CLIENT * <span class="number">1000.0</span> / duration);</span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendRequest</span><span class="params">(<span class="type">int</span> clientId, <span class="type">int</span> requestId)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">SocketChannel</span> <span class="variable">socket</span> <span class="operator">=</span> SocketChannel.open()) &#123;</span><br><span class="line">            <span class="comment">// 连接服务器</span></span><br><span class="line">            socket.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(SERVER_HOST, SERVER_PORT));</span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> String.format(<span class="string">&quot;Client-%d_Req-%d&quot;</span>, clientId, requestId);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送请求</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            socket.write(buffer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接收响应</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">ByteBuffer</span> <span class="variable">response</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            socket.read(response);</span><br><span class="line">            response.flip();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印结果（实际压力测试应注释掉）</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;Client-%d 收到响应: %s\n&quot;</span>,</span><br><span class="line">                clientId,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>(response.array(), <span class="number">0</span>, response.limit()));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加延迟模拟真实场景</span></span><br><span class="line">            Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="select、poll、epoll的区别"><a href="#select、poll、epoll的区别" class="headerlink" title="select、poll、epoll的区别"></a><code>select</code>、<code>poll</code>、<code>epoll</code>的区别</h3><h2 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h2><ul><li><strong>深入并发编程:</strong> 彻底掌握 <code>java.util.concurrent</code> 包 (<code>ExecutorService</code>, <code>ThreadPoolExecutor</code>, <code>Future</code>, <code>CompletableFuture</code>, <code>ConcurrentHashMap</code>, <code>ReentrantLock</code>, <code>StampedLock</code>, <code>Semaphore</code>, <code>CountDownLatch</code>, <code>CyclicBarrier</code>, <code>Phaser</code>)。理解 Java 内存模型（JMM）、Happens-Before 原则、volatile、synchronized 的底层实现（偏向锁、轻量级锁、重量级锁、锁升级过程）、CAS、AQS 框架。能诊断和解决死锁、活锁、线程饥饿、上下文切换开销高等复杂并发问题。</li></ul><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="线程池关键参数"><a href="#线程池关键参数" class="headerlink" title="线程池关键参数"></a>线程池关键参数</h4><ul><li><code>corePoolSize</code>：核心线程数。即使线程空闲，也会保留在线程池中（除非设置 <code>allowCoreThreadTimeOut</code>）。</li><li><code>maximumPoolSize</code>：线程池允许的最大线程数。</li><li><code>keepAliveTime</code>：当线程数超过 <code>corePoolSize</code> 时，多余的空闲线程在终止前等待新任务的最长时间。</li><li><code>unit</code>：<code>keepAliveTime</code> 的时间单位。</li><li><code>workQueue</code>：用于保存等待执行任务的阻塞队列（如 <code>LinkedBlockingQueue</code>, <code>ArrayBlockingQueue</code>, <code>SynchronousQueue</code>）。</li><li><code>threadFactory</code>：用于创建新线程的工厂（可定制线程名、优先级、守护状态等）。</li><li><code>handler</code>：当线程池和队列都饱和时，新提交任务的拒绝策略（<code>RejectedExecutionHandler</code> 的实现）。</li></ul><h4 id="常见的拒绝策略"><a href="#常见的拒绝策略" class="headerlink" title="常见的拒绝策略"></a>常见的拒绝策略</h4><ul><li><code>AbortPolicy</code>（默认）：直接抛出 <code>RejectedExecutionException</code> 异常。</li><li><code>CallerRunsPolicy</code>：由提交任务的线程（调用 <code>execute</code> 方法的线程）自己执行该任务。</li><li><code>DiscardPolicy</code>：静默丢弃被拒绝的任务，不做任何处理。</li><li><code>DiscardOldestPolicy</code>：丢弃队列中最前面的任务（等待最久的），然后尝试重新提交当前任务。</li><li>自定义策略：实现 <code>RejectedExecutionHandler</code> 接口定义自己的逻辑（如记录日志、持久化任务等）。</li></ul><h4 id="任务提交到线程池的工作流程"><a href="#任务提交到线程池的工作流程" class="headerlink" title="任务提交到线程池的工作流程"></a>任务提交到线程池的工作流程</h4><ol><li>提交一个新任务。</li><li>当前线程数 &lt; <code>corePoolSize</code>，创建新线程执行任务（即使有空闲核心线程）。</li><li>当前线程数 &gt;&#x3D; <code>corePoolSize</code>，将任务放入 <code>workQueue</code>。</li><li>队列已满，且当前线程数 &lt; <code>maximumPoolSize</code>，创建新线程执行任务。</li><li>队列已满，且当前线程数 &gt;&#x3D; <code>maximumPoolSize</code>，触发拒绝策略 (<code>handler</code>) 处理该任务。</li><li>当一个线程空闲时间超过 <code>keepAliveTime</code>：<ul><li>大于 <code>corePoolSize</code> 的空闲线程会被终止。</li><li>如果 <code>allowCoreThreadTimeOut</code> 为 <code>true</code>，核心线程空闲超时也会被终止。</li></ul></li></ol><h4 id="shutdown-和shutdownNow-有什么区别"><a href="#shutdown-和shutdownNow-有什么区别" class="headerlink" title="shutdown()和shutdownNow()有什么区别"></a><code>shutdown()</code>和<code>shutdownNow()</code>有什么区别</h4><ul><li><code>shutdown()</code>：温和关闭。不再接受新任务，但会执行完已提交的任务（包括队列中的）。</li><li><code>shutdownNow()</code>：尝试立即停止所有正在执行的任务，暂停处理等待的任务，并返回等待执行的任务列表。通过调用线程的 <code>interrupt()</code> 方法尝试中断任务（如果任务不响应中断，则无法停止）。</li></ul><h4 id="线程池的execute-和submit（）有什么区别"><a href="#线程池的execute-和submit（）有什么区别" class="headerlink" title="线程池的execute()和submit（）有什么区别"></a>线程池的<code>execute()</code>和<code>submit（）</code>有什么区别</h4><p><code>void execute(Runnable command)</code> 主要用来提交不需要返回值的异步任务。</p><p><code>submit</code> 主要用来提交需要返回值的异步任务。</p><h4 id="线程池异常的处理方法"><a href="#线程池异常的处理方法" class="headerlink" title="线程池异常的处理方法"></a>线程池异常的处理方法</h4><ul><li><strong>使用Future对象捕获异常</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExceptionHandling</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">workerTask</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务 &quot;</span> + n + <span class="string">&quot; 开始执行&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">400</span>) + <span class="number">100</span>); <span class="comment">// 100-500ms随机睡眠</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 随机抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">Random</span>().nextDouble() &lt; <span class="number">0.3</span>) &#123; <span class="comment">// 30%的概率抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;任务 &quot;</span> + n + <span class="string">&quot; 执行出错&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;任务 &quot;</span> + n + <span class="string">&quot; 完成&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        List&lt;Future&lt;String&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 提交任务到线程池</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            Future&lt;String&gt; future = executor.submit(() -&gt; workerTask(taskId));</span><br><span class="line">            futures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理完成的任务</span></span><br><span class="line">        <span class="keyword">for</span> (Future&lt;String&gt; future : futures) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get(); <span class="comment">// 获取结果，如果有异常会在这里抛出</span></span><br><span class="line">                System.out.println(<span class="string">&quot;成功: &quot;</span> + result);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;捕获到异常: &quot;</span> + e.getCause().getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>使用UncaughtExceptionHandler</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ExceptionHandlingThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadFactory</span> <span class="variable">defaultFactory</span> <span class="operator">=</span> Executors.defaultThreadFactory();</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> defaultFactory.newThread(r);</span><br><span class="line">            thread.setUncaughtExceptionHandler((t, e) -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 &quot;</span> + t.getName() + <span class="string">&quot; 中未捕获的异常: &quot;</span> + e.getMessage());</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">worker</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;任务 &quot;</span> + n + <span class="string">&quot; 出错了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;任务 &quot;</span> + n + <span class="string">&quot; 完成&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">ExceptionHandlingThreadFactory</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> worker(taskId);</span><br><span class="line">                    System.out.println(result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">// 异常会被UncaughtExceptionHandler处理</span></span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            executor.awaitTermination(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;所有任务处理完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程池示例"><a href="#线程池示例" class="headerlink" title="线程池示例"></a>线程池示例</h4><h5 id="批量数据处理-可扩容线程池-无界-有界队列"><a href="#批量数据处理-可扩容线程池-无界-有界队列" class="headerlink" title="批量数据处理 (可扩容线程池 + 无界&#x2F;有界队列)"></a>批量数据处理 (可扩容线程池 + 无界&#x2F;有界队列)</h5><ul><li><strong>场景描述：</strong> 需要处理一个包含大量数据（如百万条记录）的文件或数据库查询结果集。可以将每条记录的处理作为一个任务。</li><li><strong>线程池选择：</strong> 使用 <code>corePoolSize</code> 较小，<code>maximumPoolSize</code> 较大的线程池，配合无界队列（如果内存充足且任务量可控）或有界队列。允许在任务突增时创建更多线程加速处理。</li><li><strong>拒绝策略：</strong> 如果使用有界队列，根据业务重要性选择（如 <code>AbortPolicy</code> 记录日志后跳过，或 <code>CallerRunsPolicy</code> 让主线程处理）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BatchDataProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CORE_POOL_SIZE</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors(); <span class="comment">// 比如等于CPU核心数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_POOL_SIZE</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">QUEUE_CAPACITY</span> <span class="operator">=</span> <span class="number">10000</span>; <span class="comment">// 有界队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">KEEP_ALIVE_TIME</span> <span class="operator">=</span> <span class="number">60L</span>; <span class="comment">// 空闲线程60秒后回收</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">batchExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            CORE_POOL_SIZE,</span><br><span class="line">            MAX_POOL_SIZE,</span><br><span class="line">            KEEP_ALIVE_TIME,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NamedThreadFactory</span>(<span class="string">&quot;BatchProcessor-&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy() <span class="comment">// 队列满时抛出异常，外层需要捕获处理</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processLargeDataset</span><span class="params">(List&lt;DataRecord&gt; records)</span> &#123;</span><br><span class="line">        List&lt;Future&lt;?&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (DataRecord record : records) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 使用submit可以获取Future，便于后续检查完成状态或异常</span></span><br><span class="line">                Future&lt;?&gt; future = batchExecutor.submit(() -&gt; processSingleRecord(record));</span><br><span class="line">                futures.add(future);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">                <span class="comment">// 处理被拒绝的任务 (如记录日志、放入重试队列等)</span></span><br><span class="line">                log.error(<span class="string">&quot;Task rejected for record: &quot;</span> + record.getId(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有提交的任务完成 (简单等待)</span></span><br><span class="line">        <span class="keyword">for</span> (Future&lt;?&gt; future : futures) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                future.get(); <span class="comment">// 阻塞等待任务完成，捕获可能的ExecutionException</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                <span class="comment">// 处理任务执行中的异常</span></span><br><span class="line">                log.error(<span class="string">&quot;Error processing task&quot;</span>, e.getCause()); <span class="comment">// 获取原始异常</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processSingleRecord</span><span class="params">(DataRecord record)</span> &#123;</span><br><span class="line">        <span class="comment">// ... 处理单条记录的复杂逻辑 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="synchronized-实现原理"><a href="#synchronized-实现原理" class="headerlink" title="synchronized 实现原理"></a><code>synchronized</code> 实现原理</h4><p><code>synchronized</code> 关键字在 Java 中的底层实现依赖于 <strong>JVM 对象头、Monitor 监视器锁以及锁升级机制</strong>。</p><p><strong>对象头与 Mark Word</strong></p><ul><li><p>每个 Java 对象在内存中分为三部分：</p><ul><li><strong>对象头（Header）</strong>：存储锁状态、GC 年龄等元数据。<ul><li><strong>Mark Word</strong>（对象头的核心部分）：<strong>锁状态的变化直接体现在 Mark Word 的比特位组合上。</strong></li></ul></li><li>实例数据（Instance Data）：对象字段值。</li></ul></li><li><p>对齐填充（Padding）：保证内存对齐。</p></li></ul><p><strong>Monitor 的核心结构</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectMonitor</span> &#123;</span><br><span class="line">    <span class="type">void</span>*     _header;      <span class="comment">// 存储 Mark Word 的备份</span></span><br><span class="line">    <span class="type">void</span>*     _owner;       <span class="comment">// 持有锁的线程（如：Thread*）</span></span><br><span class="line">    <span class="type">intptr_t</span>  _count;       <span class="comment">// 重入次数</span></span><br><span class="line">    ObjectWaiter* _WaitSet; <span class="comment">// 调用 wait() 后进入等待队列</span></span><br><span class="line">    ObjectWaiter* _EntryList; <span class="comment">// 阻塞等待锁的线程队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>锁升级机制</strong></p><p>为提高性能，从 java1.6 开始采用渐进式锁升级策略：</p><p><strong>偏向锁（Biased Locking）</strong></p><ul><li><strong>目标</strong>：减少无竞争时的开销。</li><li><strong>流程</strong>：<ul><li>首次加锁时，通过 CAS 将 Mark Word 的锁标志置为 <code>101</code>（偏向锁），并写入当前线程 ID。</li><li>后续同一线程进入同步块时，只需检查线程 ID 匹配即可直接执行（零开销）。</li></ul></li><li><strong>撤销</strong>：当其他线程尝试获取锁时，撤销偏向锁（Stop-The-World 操作）。</li></ul><p><strong>轻量级锁（Lightweight Locking）</strong></p><ul><li><strong>目标</strong>：避免短时阻塞的线程切换开销。</li><li><strong>流程</strong>：<ol><li>在栈帧中创建 <strong>锁记录（Lock Record）</strong>。</li><li>通过 CAS 将 Mark Word 复制到锁记录，并尝试将 Mark Word 替换为指向锁记录的指针。</li><li>成功则获得锁；失败则自旋（循环尝试）一定次数。</li></ol></li><li><strong>自旋失败后升级为重量级锁</strong>。</li></ul><p><strong>重量级锁（Heavyweight Locking）</strong></p><ul><li>当竞争激烈时，最终升级为重量级锁。</li><li>线程通过操作系统互斥量（mutex）阻塞，进入内核态，性能开销最大。</li></ul><img src="/post/7992e236/image-20250725195316321.png" class="" title="image-20250725195316321"><h4 id="ReentrantLock-实现原理"><a href="#ReentrantLock-实现原理" class="headerlink" title="ReentrantLock 实现原理"></a><code>ReentrantLock</code> 实现原理</h4><p><code>ReentrantLock</code> 基于 **AbstractQueuedSynchronizer (AQS)**。AQS 提供了一个框架，用于构建依赖先进先出 (FIFO) 等待队列的阻塞锁和相关同步器（如信号量、倒计时门栓等）。</p><ol><li><strong>核心组件 - AQS：</strong><ul><li><code>state</code> (volatile int)： 表示锁的状态。0 表示锁空闲，&gt;0 表示被持有（通常是持有线程的重入次数）。</li><li><code>exclusiveOwnerThread</code> (Thread)： 记录当前持有独占锁（如 ReentrantLock）的线程。</li><li><strong>CLH 队列 (变体的 FIFO 队列)：</strong> 由 <code>Node</code> 节点构成的双向链表，用于管理等待获取锁的线程。每个节点代表一个等待线程。</li></ul></li><li><strong>获取锁 (lock() &#x2F; tryLock())：</strong><ul><li><strong>非公平模式 (默认)：</strong><ol><li>线程直接尝试通过 CAS (Compare-And-Swap) 操作将 <code>state</code> 从 0 设置为 1（尝试快速获取）。</li><li>如果成功，设置 <code>exclusiveOwnerThread</code> 为当前线程。</li><li>如果失败（锁已被持有）：<ul><li>如果当前线程就是持有锁的线程（重入），则直接将 <code>state</code> 加 1。</li><li>否则，创建一个代表当前线程的 <code>Node</code> 节点，通过 CAS 操作将其安全地加入到 CLH 队列的尾部。</li><li>进入自旋或阻塞状态（通常通过 <code>LockSupport.park()</code>），等待前驱节点释放锁后唤醒。</li></ul></li></ol></li><li><strong>公平模式：</strong><ol><li>检查 CLH 队列中是否有等待时间比自己长的线程。</li><li>如果有，则直接将自己加入队列尾部排队。</li><li>如果没有，才尝试通过 CAS 获取锁（后续步骤与非公平模式失败后的步骤相同）。</li><li>公平模式保证了严格按照线程请求锁的顺序（FIFO）来授予锁，避免了线程饥饿，但通常吞吐量低于非公平模式。</li></ol></li></ul></li><li><strong>释放锁 (unlock())：</strong><ol><li>检查当前线程是否是锁的持有者（防止非法释放）。</li><li>将 <code>state</code> 减 1（对于重入锁，需要释放多次直到 <code>state</code> 为 0）。</li><li>如果 <code>state</code> 减到 0：<ul><li>设置 <code>exclusiveOwnerThread</code> 为 <code>null</code>。</li><li>唤醒 CLH 队列中下一个等待的线程（如果存在）。</li></ul></li></ol></li><li><strong>可重入性：</strong><ul><li>通过 <code>state</code> 变量记录重入次数。每次持有锁的线程再次获取锁，<code>state</code> 就加 1。每次释放锁，<code>state</code> 就减 1。只有减到 0 时，锁才真正被释放。</li></ul></li></ol><h4 id="ReentrantLock-与-synchronized-的区别"><a href="#ReentrantLock-与-synchronized-的区别" class="headerlink" title="ReentrantLock 与 synchronized 的区别"></a><code>ReentrantLock</code> 与 <code>synchronized</code> 的区别</h4><table><thead><tr><th align="left">特性</th><th align="left"><code>ReentrantLock</code></th><th align="left"><code>synchronized</code></th></tr></thead><tbody><tr><td align="left"><strong>灵活性</strong></td><td align="left"><strong>高</strong>：支持尝试获取锁(<code>tryLock</code>)、超时获取(<code>tryLock(time)</code>)、可中断获取(<code>lockInterruptibly</code>)、公平锁</td><td align="left"><strong>低</strong>：获取锁只有阻塞一种方式，不支持超时和公平性控制</td></tr><tr><td align="left"><strong>公平性</strong></td><td align="left"><strong>可配置</strong>：构造函数可指定公平锁(<code>true</code>)或非公平锁(<code>false</code>)</td><td align="left"><strong>仅非公平锁</strong></td></tr><tr><td align="left"><strong>等待条件</strong></td><td align="left"><strong>支持多个条件队列</strong>：一个锁可关联多个 <code>Condition</code> 对象，实现更精细的线程等待&#x2F;唤醒</td><td align="left"><strong>仅一个隐式条件队列</strong>：每个对象关联一个内置锁，只有一个 <code>wait()</code>&#x2F;<code>notify()</code>&#x2F;<code>notifyAll()</code> 队列</td></tr><tr><td align="left"><strong>中断响应</strong></td><td align="left"><strong>支持</strong>：<code>lockInterruptibly()</code> 方法允许在等待锁时响应中断</td><td align="left"><strong>不支持</strong>：在等待内置锁 (<code>synchronized</code> 块) 时，线程无法响应中断</td></tr></tbody></table><p><strong>总结与选择建议</strong></p><ul><li><strong>优先考虑 <code>synchronized</code>：</strong> 在大多数不需要 <code>ReentrantLock</code> 高级特性的场景下，优先使用 <code>synchronized</code>。理由：<ul><li>语法简洁清晰，不易出错（自动释放锁）。</li><li>JVM 持续优化，性能优异且稳定。</li><li>是 Java 语言的核心特性，代码可读性更高，开发者更熟悉。</li></ul></li><li><strong>考虑使用 <code>ReentrantLock</code>：</strong> 当你的需求超出了 <code>synchronized</code> 的能力范围时：<ul><li><strong>需要尝试获取锁 (<code>tryLock</code>) 或超时获取锁。</strong></li><li><strong>需要可中断地等待一个锁 (<code>lockInterruptibly</code>)。</strong></li><li><strong>需要实现公平锁策略 (避免线程饥饿)。</strong></li><li><strong>需要多个等待&#x2F;通知条件 (<code>Condition</code>)。</strong></li><li><strong>需要在同一个锁上跨越多个方法进行加锁和解锁操作（虽然 <code>synchronized</code> 通过嵌套或方法调用也能实现，但 <code>ReentrantLock</code> 的控制粒度更灵活）。</strong></li></ul></li></ul><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a><code>ThreadLocal</code></h3><p>ThreadLocal 是 Java 中一个用于实现<strong>线程局部变量</strong>的工具类。它为每个使用该变量的线程提供了一个独立的变量副本，从而实现了线程间的数据隔离。</p><p><strong>核心原理：</strong></p><ol><li><p><strong>Thread 类中的 ThreadLocalMap：</strong></p><ul><li><code>Thread</code> 有一个类型为 <code>ThreadLocal.ThreadLocalMap</code>的私有成员变量 <code>threadLocals</code>。</li><li><code>ThreadLocalMap</code> 是一个定制的、类似 <code>HashMap</code> 的结构，专门用于存储线程局部变量。键是 <code>ThreadLocal</code> ，值是该线程对应的变量副本。</li></ul></li><li><p><strong>ThreadLocal 的操作机制：</strong></p><ul><li><p><strong><code>set(T value)</code>：</strong> 当调用 <code>threadLocal.set(value)</code> 时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 用当前ThreadLocal作为key存储值</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createMap(t, value); <span class="comment">// 首次使用创建Map</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>get()</code>：</strong> 当调用 <code>threadLocal.get()</code> 时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread(); <span class="comment">// 1. 获取当前线程</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);    <span class="comment">// 2. 获取线程的ThreadLocalMap</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 3. 用当前ThreadLocal实例作为key查找Entry</span></span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (T)e.value; <span class="comment">// 4. 返回找到的值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue(); <span class="comment">// 5. 找不到时初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>remove()</code>：</strong> 当调用 <code>threadLocal.remove()</code> 时：</p><ol><li>获取当前线程的 <code>threadLocals</code>。</li><li>如果 <code>threadLocals</code> 不为 <code>null</code>，则从中移除以当前 <code>ThreadLocal</code> 实例为键的条目。</li></ol></li></ul></li><li><p><strong>关键点：</strong></p><ul><li><p><strong>数据存储位置：</strong> 变量副本实际存储在<strong>线程对象</strong>内部的 <code>ThreadLocalMap</code> 里，而不是存储在 <code>ThreadLocal</code> 对象本身。<code>ThreadLocal</code> 只是一个访问这些副本的工具和键。</p></li><li><p><strong>键的引用：</strong> <code>ThreadLocalMap</code> 中的键 (<code>ThreadLocal</code> 对象) 是<strong>弱引用</strong>。这是为了在 <code>ThreadLocal</code> 实例本身不再被强引用时（比如被 GC 回收了），<code>ThreadLocalMap</code> 中的键能自动被 GC 回收，避免内存泄漏（键部分）。</p></li><li><p><strong>值的引用：</strong> <code>ThreadLocalMap</code> 中的值是<strong>强引用</strong>。这就是为什么如果 <code>ThreadLocal</code> 被回收了（键变 <code>null</code>），但线程（尤其是线程池中的线程）长期存活，且没有调用 <code>remove()</code> 方法，那么值对象会一直被 <code>ThreadLocalMap</code> 的条目强引用着，导致值对象无法被回收，造成<strong>内存泄漏</strong>（值部分）。</p></li><li><p><strong>内存泄漏风险：</strong> 这是使用 <code>ThreadLocal</code> 最大的隐患。主要发生在：</p><ul><li>使用了<strong>线程池</strong>（线程复用，生命周期长）。</li><li>在 <code>ThreadLocal</code> 中存储了<strong>大对象</strong>。</li><li>在任务执行完毕后，<strong>没有调用 <code>threadLocal.remove()</code></strong> 来清理当前线程的副本。</li></ul><img src="/post/7992e236/image-20250807001016383.png" class="" title="image-20250807001016383"></li><li><p><strong>继承性：</strong> <code>ThreadLocal</code> 本身不支持变量从父线程传递给子线程。如果需要这种能力，可以使用 <code>InheritableThreadLocal</code>。</p></li></ul></li></ol><img src="/post/7992e236/image-20250725210437363.png" class="" title="image-20250725210437363"><p><strong>示例1：存储用户信息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserContextHolder</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个ThreadLocal变量，用于存储用户ID。通常声明为private static final</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; currentUser = ThreadLocal.withInitial(() -&gt; <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 设置当前线程的用户ID</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setCurrentUser</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">        currentUser.set(userId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前线程的用户ID</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getCurrentUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currentUser.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清除当前线程的用户ID（重要！避免内存泄漏）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        currentUser.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在拦截器或过滤器中设置和清除</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> &#123;</span><br><span class="line">        <span class="comment">// 从请求中获取用户信息（比如token解析）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> ...; </span><br><span class="line">        UserContextHolder.setCurrentUser(userId);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> &#123;</span><br><span class="line">        <span class="comment">// 请求处理完成后，清除ThreadLocal，防止内存泄漏</span></span><br><span class="line">        UserContextHolder.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例2：事务管理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionContextHolder</span> &#123;</span><br><span class="line">    <span class="comment">// 存储当前线程的事务连接</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Connection&gt; currentConnection = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> currentConnection.get();</span><br><span class="line">        <span class="keyword">if</span> (conn == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果没有，则从连接池获取一个新的连接，并设置到ThreadLocal</span></span><br><span class="line">            conn = DataSourceUtils.getConnection(); <span class="comment">// 假设的工具类</span></span><br><span class="line">            currentConnection.set(conn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bindConnection</span><span class="params">(Connection conn)</span> &#123;</span><br><span class="line">        currentConnection.set(conn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unbindConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        currentConnection.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionManager</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> TransactionContextHolder.getConnection();</span><br><span class="line">        conn.setAutoCommit(<span class="literal">false</span>); <span class="comment">// 开启事务</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> TransactionContextHolder.getConnection();</span><br><span class="line">        conn.commit();</span><br><span class="line">        TransactionContextHolder.unbindConnection(); <span class="comment">// 提交后移除连接，并释放到连接池</span></span><br><span class="line">        DataSourceUtils.releaseConnection(conn); <span class="comment">// 假设的工具类，将连接归还连接池</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...类似commit，回滚事务并清理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JUC集合"><a href="#JUC集合" class="headerlink" title="JUC集合"></a>JUC集合</h3><h4 id="ConcurrentHashMap-的实现原理"><a href="#ConcurrentHashMap-的实现原理" class="headerlink" title="ConcurrentHashMap 的实现原理"></a><code>ConcurrentHashMap</code> 的实现原理</h4><p>ConcurrentHashMap 是 Java 并发编程中至关重要的数据结构。它在 Java 7 和 Java 8 中经历了重大的重构，核心目标都是提高并发性能、减少竞争、优化内存和计算开销。以下是它们的实现差异和 Java 8 的优化：</p><p><strong>Java 7 实现 (基于分段锁 - Segment Locking)</strong></p><ol><li><strong>核心结构：</strong><ul><li><strong>Segment 数组：</strong> <code>ConcurrentHashMap</code> 内部维护一个固定大小的 <code>Segment</code> 数组（默认为 16）。每个 <code>Segment</code> 本质上是一个独立的、线程安全的哈希表（类似于一个小的 <code>ReentrantReadWriteLock</code> 或 <code>ReentrantLock</code> 保护的 <code>HashMap</code>）。</li><li><strong>Segment 继承 ReentrantLock：</strong> 每个 <code>Segment</code> 类继承自 <code>ReentrantLock</code>，这意味着每个段拥有自己独立的锁。</li><li><strong>HashEntry 数组：</strong> 每个 <code>Segment</code> 内部维护一个 <code>HashEntry</code> 数组（桶数组）。<code>HashEntry</code> 是链表节点，包含 <code>final</code> 的 <code>key</code>、<code>hash</code>、<code>volatile</code> 的 <code>value</code> 和指向下一个节点的 <code>next</code> 指针。<code>value</code> 的 <code>volatile</code> 保证了可见性。</li><li><strong>锁粒度：</strong> 锁的粒度是 <strong>段（Segment）</strong>。对同一个段的修改操作（如 <code>put</code>, <code>remove</code>）需要获取该段的锁。不同段上的操作可以并发执行。</li></ul></li><li><strong>关键操作原理：</strong><ul><li><strong><code>put(key, value)</code>：</strong><ol><li>根据 <code>key</code> 的 <code>hash</code> 计算它属于哪个 <code>Segment</code> (通常用高位哈希位)。</li><li>获取该 <code>Segment</code> 的锁。</li><li>在 <code>Segment</code> 内部的 <code>HashEntry</code> 数组中找到对应的桶（链表头）。</li><li>遍历链表查找是否已存在相同 <code>key</code>：<ul><li>存在：更新 <code>value</code> (利用 <code>volatile</code> 写)。</li><li>不存在：将新 <code>HashEntry</code> 节点插入链表头部。</li></ul></li><li>释放 <code>Segment</code> 的锁。</li></ol></li><li><strong><code>get(key)</code>：</strong><ol><li>根据 <code>key</code> 的 <code>hash</code> 计算它属于哪个 <code>Segment</code>。</li><li><strong>不需要获取锁！</strong></li><li>根据 <code>hash</code> 定位到该 <code>Segment</code> 内部 <code>HashEntry</code> 数组中的桶。</li><li>遍历链表（<code>HashEntry.next</code>）查找匹配的 <code>key</code>。</li><li>依赖 <code>HashEntry.value</code> 的 <code>volatile</code> 读保证看到最新值。</li></ol></li><li><strong><code>size()</code>：</strong><ul><li>实现相对低效。尝试不加锁地遍历所有 <code>Segment</code>，累加各 <code>Segment</code> 的 <code>modCount</code> (修改计数器) 和 <code>count</code> (元素数量)。</li><li>如果连续两次累加过程中发现总的 <code>modCount</code> 没有变化，说明没有发生并发修改，返回累加的 <code>size</code>。</li><li>如果多次尝试后 <code>modCount</code> 总在变化（高并发），则最终会<strong>强制锁住所有 <code>Segment</code></strong> 再进行统计，性能开销很大。</li></ul></li><li><strong>扩容 (Rehashing)：</strong><ul><li>发生在 <code>Segment</code> 内部。当某个 <code>Segment</code> 的元素数量超过阈值时，仅对该 <code>Segment</code> 内部的 <code>HashEntry</code> 数组进行扩容（通常翻倍），并重新分配链表元素。扩容时需要持有该 <code>Segment</code> 的锁。</li></ul></li></ul></li><li><strong>Java 7 实现的优缺点：</strong><ul><li><strong>优点：</strong> 相比锁住整个 <code>HashMap</code>，分段锁显著提高了并发度（最多允许等于 <code>Segment</code> 数量的线程并发写）。读操作完全无锁，非常快。</li><li><strong>缺点：</strong><ul><li><strong>锁粒度不够细：</strong> 如果大量写操作恰好落在同一个 <code>Segment</code> 上，该段会成为瓶颈。<code>Segment</code> 数量在创建后固定，无法动态调整。</li><li><strong><code>size()</code> 和 <code>containsValue()</code> 低效：</strong> 统计全表或全值操作可能需要全局锁，开销大。</li><li><strong>内存开销：</strong> <code>Segment</code> 数组本身和每个 <code>Segment</code> 的结构（锁、计数等）带来额外内存消耗。</li><li><strong>链表查询效率：</strong> 冲突严重时，长链表遍历影响 <code>get</code> 性能。</li></ul></li></ul></li></ol><p><strong>Java 8 实现 (基于 CAS + <code>synchronized</code> + 红黑树)</strong></p><p>Java 8 对 <code>ConcurrentHashMap</code> 进行了彻底重构，摒弃了分段锁模型，采用了更细粒度的锁和现代并发技术。</p><ol><li><p><strong>核心结构：</strong></p><ul><li><strong>Node 数组 (Table)：</strong> 只有一个 <code>volatile Node[] table</code>。<code>Node</code> 是链表节点或树节点（<code>TreeNode</code>）的基础类，包含 <code>final</code> 的 <code>key</code> 和 <code>hash</code>，<code>volatile</code> 的 <code>value</code> 和 <code>volatile</code> 的 <code>next</code> 指针（用于链表）。</li><li><strong>链表转红黑树：</strong> 当单个桶（链表）中的元素数量超过阈值（默认为 8）<strong>且</strong> 当前 <code>table</code> 的长度大于等于最小树化容量（<code>MIN_TREEIFY_CAPACITY</code>，默认为 64）时，该链表会被转换为 <strong><code>TreeNode</code></strong> 组成的红黑树。这大大提高了高冲突桶的查询效率（O(n) -&gt; O(log n)）。</li><li><strong>锁粒度：</strong> 锁的粒度细化到 <strong>单个桶（桶的头节点）</strong>。使用 <code>synchronized</code> 块锁定桶的头节点。</li><li><strong>CAS (Compare-And-Swap)：</strong> 大量使用 CAS 操作进行无锁化的状态更新（如 <code>tabAt</code>, <code>casTabAt</code> 访问和修改 <code>table</code> 数组元素；<code>setTabAt</code> 保证 <code>volatile</code> 写），以及 <code>sizeCtl</code> 等控制变量的更新。</li><li><strong>ForwardingNode：</strong> 一个特殊的 <code>Node</code> 子类，在扩容（<code>resize</code>）过程中使用。当桶被迁移完毕，会放置一个 <code>ForwardingNode</code> 作为标记，并指向新表。其他线程遇到这个节点时，知道正在扩容，会协助扩容或在新表中查找。</li><li><strong>CounterCell：</strong> 用于高效、无竞争地统计元素总数 (<code>size()</code>)，避免全局锁。基于类似 <code>LongAdder</code> 的思想。</li></ul></li><li><p><strong>关键操作原理 (体现优化)：</strong></p><ul><li><strong><code>put(key, value)</code>：</strong><ol><li>计算 <code>key</code> 的 <code>hash</code> (优化了扰动函数)。</li><li>如果 <code>table</code> 未初始化，则初始化（使用 <code>sizeCtl</code> 和 CAS 控制并发初始化）。</li><li>根据 <code>hash</code> 定位到 <code>table</code> 中的桶 <code>i</code>。</li><li><strong>无锁尝试 (CAS)：</strong> 如果桶 <code>i</code> 为空 (<code>null</code>)，尝试用 CAS 将新节点放入桶 <code>i</code>。成功则结束。</li><li><strong>特殊状态处理：</strong> 如果桶 <code>i</code> 的头节点是 <code>ForwardingNode</code>，表示正在扩容，当前线程会<strong>协助扩容</strong> (<code>helpTransfer</code>)。</li><li><strong>锁定头节点 (<code>synchronized</code>)：</strong> 如果桶 <code>i</code> 不为空且不是 <code>ForwardingNode</code>，则使用 <code>synchronized</code> <strong>锁定该桶的头节点</strong>。<ul><li>如果头节点是链表节点：遍历链表查找 <code>key</code>，存在则更新 <code>value</code>；不存在则添加到链表尾部（Java 8 改为尾插法，避免死循环隐患）。</li><li>如果头节点是树节点 (<code>TreeNode</code>)：调用红黑树的插入方法。</li></ul></li><li>检查是否需要树化（链表长度 &gt;&#x3D; 8）或解树化（树节点数 &lt;&#x3D; 6）。</li><li>释放 <code>synchronized</code> 锁。</li><li>检查是否需要扩容（元素总数超过阈值）。</li></ol></li><li><strong><code>get(key)</code>：</strong><ol><li>计算 <code>key</code> 的 <code>hash</code>。</li><li>根据 <code>hash</code> 定位到 <code>table</code> 中的桶。</li><li><strong>完全无锁！</strong></li><li>如果桶的头节点就是匹配项，直接返回。</li><li>如果头节点 <code>hash &lt; 0</code>，说明是特殊节点：<ul><li>如果是 <code>ForwardingNode</code>，则去新表 <code>nextTable</code> 中查找。</li><li>如果是 <code>TreeBin</code> (红黑树的包装节点，<code>hash</code> 固定为 <code>-2</code>)，则调用树节点的 <code>find</code> 方法查找。</li></ul></li><li>否则，遍历链表查找。</li><li>依赖 <code>Node.value</code> 的 <code>volatile</code> 读保证可见性。</li></ol></li><li><strong><code>size()</code>：</strong><ul><li><strong>不再需要全局锁！</strong></li><li>尝试直接读取 <code>baseCount</code>（一个基础计数器，通过 CAS 更新）。</li><li>如果存在并发竞争（<code>CounterCell</code> 数组不为空），则累加 <code>baseCount</code> 和所有 <code>CounterCell</code> 中的值。<code>CounterCell</code> 通过 <code>@sun.misc.Contended</code> 避免伪共享。</li><li>结果是一个<strong>估计值</strong>（<code>sumCount()</code>），因为在累加过程中可能有线程在更新。但对于大多数并发场景，这个估计值足够精确且开销极低。</li></ul></li><li><strong>扩容 (Transfer)：</strong><ul><li><strong>多线程协同扩容：</strong> 这是 Java 8 <code>ConcurrentHashMap</code> 最精妙的优化之一。</li><li>当需要扩容时，会创建一个新表 <code>nextTable</code>（通常是原表的两倍）。</li><li>不是由一个线程完成所有迁移，而是将迁移任务划分为多个**小段 (stride)**。</li><li>第一个触发扩容的线程初始化迁移并设置 <code>transferIndex</code> 指向迁移范围的末尾。</li><li>后续进行写操作的线程（<code>put</code>, <code>remove</code>）如果发现正在扩容（遇到 <code>ForwardingNode</code>），会<strong>主动协助迁移</strong>一部分桶（领取一段 <code>stride</code> 的任务），然后再执行自己的操作。<code>get</code> 或只读操作不会协助。</li><li>使用 <code>ForwardingNode</code> 标记已迁移的桶，引导查找操作到新表。</li><li>迁移完成一个桶后，用 <code>ForwardingNode</code> 替换原桶中的节点。</li><li>所有桶迁移完成后，用 <code>nextTable</code> 替换 <code>table</code>。</li></ul></li></ul></li><li><p><strong>Java 8 的主要优化总结：</strong></p><table><thead><tr><th align="left">特性</th><th align="left">Java 7</th><th align="left">Java 8</th><th align="left">优化点</th></tr></thead><tbody><tr><td align="left"><strong>锁机制</strong></td><td align="left">分段锁 (<code>Segment</code>, 继承 <code>ReentrantLock</code>)</td><td align="left"><strong>桶级别锁 (<code>synchronized</code>)</strong> + <strong>CAS</strong></td><td align="left"><strong>锁粒度更细</strong> (桶 vs 段)，<strong>CAS 无锁化</strong>初始化、计数等，**<code>synchronized</code> 在 JVM 层面持续优化**</td></tr><tr><td align="left"><strong>数据结构</strong></td><td align="left"><strong>数组 + 链表</strong> (仅 <code>HashEntry</code>)</td><td align="left"><strong>数组 + 链表 + 红黑树</strong> (<code>Node</code> &#x2F; <code>TreeNode</code>)</td><td align="left"><strong>树化大幅提升高冲突桶的查询效率</strong> (O(n) -&gt; O(log n))</td></tr><tr><td align="left"><strong><code>size()</code></strong></td><td align="left">可能锁全表，低效</td><td align="left"><strong>无锁 (<code>baseCount</code> + <code>CounterCell</code>)</strong>, <strong>高并发下高性能、近似值</strong></td><td align="left"><strong>避免全局锁，基于分片计数</strong>，读性能极大提升</td></tr><tr><td align="left"><strong>扩容</strong></td><td align="left">段内扩容，独立进行</td><td align="left"><strong>多线程协同扩容 (协助迁移)</strong></td><td align="left"><strong>利用并发加速扩容</strong>，减少扩容带来的停顿</td></tr><tr><td align="left"><strong>内存开销</strong></td><td align="left">较高 (<code>Segment</code> 数组及结构)</td><td align="left"><strong>更低</strong> (单一 <code>Node</code> 数组，树节点仅在需要时创建)</td><td align="left">结构更精简</td></tr><tr><td align="left"><strong>读操作</strong></td><td align="left">无锁 (<code>volatile</code> value)</td><td align="left"><strong>完全无锁</strong> (利用 <code>volatile</code> 和特殊节点 <code>find</code> 方法)</td><td align="left">读性能极高且稳定</td></tr><tr><td align="left"><strong>哈希计算</strong></td><td align="left">多次哈希</td><td align="left"><strong>优化扰动函数 (简化一次位运算)</strong></td><td align="left">计算开销略降</td></tr><tr><td align="left"><strong><code>ForwardingNode</code></strong></td><td align="left">无</td><td align="left"><strong>有</strong>，用于标记迁移状态和引导查找</td><td align="left"><strong>实现无锁读和协助扩容的关键</strong></td></tr><tr><td align="left"><strong><code>CounterCell</code></strong></td><td align="left">无</td><td align="left"><strong>有</strong>，用于分片计数</td><td align="left"><strong>实现高效无锁 <code>size()</code> 的核心</strong></td></tr></tbody></table></li></ol><p><strong>核心优化思想：</strong></p><ol><li><strong>更细粒度的锁：</strong> 从段锁到桶锁，显著减少锁竞争。</li><li><strong>无锁化：</strong> 广泛使用 CAS 进行轻量级状态更新（初始化、计数），读操作完全无锁。</li><li><strong>数据结构升级：</strong> 引入红黑树解决哈希冲突恶化导致的性能问题。</li><li><strong>操作并行化：</strong> 多线程协同扩容，将扩容压力分摊，极大缩短扩容时间。</li><li><strong>分离计数：</strong> 使用 <code>CounterCell</code> 分片计数消除 <code>size()</code> 的瓶颈。</li><li><strong>利用现代 JVM 优化：</strong> 依赖 JVM 对 <code>synchronized</code> 的持续优化（偏向锁、轻量级锁、锁消除、锁膨胀），使其在低竞争场景下性能接近 CAS。</li></ol><p><strong>结论：</strong></p><p>Java 8 的 <code>ConcurrentHashMap</code> 实现是一次巨大的飞跃。它通过采用桶级别 <code>synchronized</code>、CAS、红黑树、多线程协同扩容、分片计数 (<code>CounterCell</code>) 和 <code>ForwardingNode</code> 等关键技术，在锁粒度、并发度、查询效率（尤其是高冲突时）、扩容速度、<code>size()</code> 计算效率和内存开销等方面都带来了显著的优化。它更好地适应了现代多核处理器和高并发场景的需求，是 Java 并发容器库中的典范之作。Java 7 的分段锁实现在当时是巨大的进步，但已被更先进的设计所取代。</p><h4 id="为什么-ConcurrentHashMap-比-Hashtable-效率高"><a href="#为什么-ConcurrentHashMap-比-Hashtable-效率高" class="headerlink" title="为什么 ConcurrentHashMap 比 Hashtable 效率高"></a><strong>为什么 <code>ConcurrentHashMap</code> 比 <code>Hashtable</code> 效率高</strong></h4><ul><li><strong>锁粒度</strong>：<ul><li><code>Hashtable</code>：<strong>全局锁</strong>。锁住整个表，一次只允许一个线程操作。</li><li><code>ConcurrentHashMap</code> (JDK7)：分段锁。锁住一个段，不同段操作可并发。</li><li><code>ConcurrentHashMap</code> (JDK8)：桶锁 (头节点锁)。锁粒度更细，冲突概率更低，并发度更高。</li></ul></li><li><strong>无锁读</strong>：<ul><li><code>Hashtable</code>：读操作也需要获取锁。</li><li><code>ConcurrentHashMap</code> (JDK7 &amp; JDK8)：<strong>读操作完全无锁</strong> (JDK7 利用 volatile value，JDK8 利用 volatile val&#x2F;next 和 Unsafe 的原子读)，极大提升读性能。</li></ul></li></ul><h3 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h3><h4 id="CompletableFuture的原理与应用"><a href="#CompletableFuture的原理与应用" class="headerlink" title="CompletableFuture的原理与应用"></a><code>CompletableFuture</code>的原理与应用</h4><p><code>CompletableFuture</code> 是 Java 8 引入的核心并发工具类（位于 <code>java.util.concurrent</code> 包），它代表一个<strong>异步计算的结果</strong>。它不仅是对传统 <code>Future</code> 接口的增强，更是一个强大的<strong>异步编程框架</strong>，支持显式地完成计算、链式组合多个异步任务、处理结果和异常，是实现响应式、非阻塞编程的关键组件。</p><p><strong>一、核心原理</strong></p><ol><li><strong>异步执行与结果容器：</strong><ul><li>它本质上是一个<strong>容器</strong>，用于承载将来某个时刻计算完成的结果（或异常）。</li><li>计算任务通常被提交给 <code>Executor</code>（线程池）在后台线程中执行，避免阻塞调用线程。</li><li>创建时结果未知，计算完成后结果被设置（<code>complete(result)</code> 或 <code>completeExceptionally(throwable)</code>）。</li></ul></li><li><strong>显式完成：</strong><ul><li>与传统 <code>Future</code> 只能被动等待不同，<code>CompletableFuture</code> 可以被<strong>主动完成</strong>。</li><li>任何拥有该对象引用的线程都可以调用 <code>complete()</code> 或 <code>completeExceptionally()</code> 手动设置结果或异常。这是实现超时控制、外部事件触发完成等场景的基础。</li></ul></li><li><strong>链式组合与回调 (CompletionStage)：</strong><ul><li><code>CompletableFuture</code> 实现了 <code>CompletionStage</code> 接口，这是其强大能力的核心。</li><li><code>CompletionStage</code> 定义了丰富的链式方法（<code>thenApply</code>, <code>thenAccept</code>, <code>thenRun</code>, <code>thenCompose</code>, <code>thenCombine</code>, <code>handle</code>, <code>whenComplete</code>, <code>exceptionally</code> 等）。</li><li>这些方法允许你<strong>声明式地</strong>描述：“<strong>当当前阶段完成时，接下来应该做什么</strong>”。回调函数（lambda 表达式或方法引用）会被挂接到当前阶段的完成事件上。</li><li>每个链式调用都会返回一个<strong>新的 <code>CompletionStage</code>（通常是另一个 <code>CompletableFuture</code>）</strong>，代表下一个异步步骤。这形成了<strong>异步任务流水线</strong>。</li></ul></li><li><strong>依赖关系与内部状态机：</strong><ul><li>当多个 <code>CompletableFuture</code> 通过 <code>thenXxx</code> 方法链接起来时，后续阶段依赖于前驱阶段的完成。</li><li><code>CompletableFuture</code> 内部维护一个<strong>状态机</strong>（如 <code>NEW</code>, <code>COMPLETING</code>, <code>NORMAL</code>, <code>EXCEPTIONAL</code>, <code>CANCELLED</code>）和一个<strong>依赖栈</strong>（指向所有依赖于它完成的后续阶段）。</li><li>当一个阶段完成时，它会遍历其依赖栈，<strong>尝试触发所有后续阶段</strong>的执行（可能立即执行，也可能提交到线程池）。</li></ul></li><li><strong>非阻塞与事件驱动：</strong><ul><li>整个流程是<strong>非阻塞</strong>的。调用 <code>thenXxx</code> 只是注册回调，并不等待前驱完成。主线程可以继续执行其他任务。</li><li>执行由<strong>完成事件驱动</strong>：前驱完成 -&gt; 触发回调 -&gt; 执行回调逻辑 -&gt; 完成后继 -&gt; 触发后继的回调…。</li></ul></li><li><strong>组合多个 Future：</strong><ul><li>提供 <code>allOf()</code>, <code>anyOf()</code> 等静态方法，用于组合多个独立的 <code>CompletableFuture</code>：<ul><li><code>allOf(futures...)</code>: 创建一个新的 Future，当<strong>所有</strong>输入 Future 完成时（无论成功失败），它才完成（本身无结果，需手动获取各Future结果）。</li><li><code>anyOf(futures...)</code>: 创建一个新的 Future，当<strong>任意一个</strong>输入 Future 完成时（无论成功失败），它就完成（结果是最先完成的那个Future的结果）。</li></ul></li></ul></li><li><strong>线程池控制：</strong><ul><li>默认情况下，链式调用中后续任务的执行线程由前驱任务的完成线程执行（通常是执行前驱任务的线程或调用 <code>complete</code> 的线程）。</li><li>可以使用带有 <code>Executor</code> 参数的变体方法（如 <code>thenApplyAsync(func, executor)</code>）<strong>显式指定</strong>后续任务在特定的线程池中执行，避免线程饥饿或控制资源。</li></ul></li></ol><p><strong>二、主要应用场景</strong></p><ol><li><p><strong>异步任务编排与流水线：</strong> 将复杂的业务逻辑拆分成多个异步步骤，按顺序或条件链式执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; fetchUserData(userId), ioPool) <span class="comment">// 步骤1：IO操作</span></span><br><span class="line">    .thenApply(userData -&gt; processData(userData))              <span class="comment">// 步骤2：CPU密集型处理（默认同线程或ForkJoinPool）</span></span><br><span class="line">    .thenApplyAsync(processedData -&gt; saveToDB(processedData), dbPool) <span class="comment">// 步骤3：另一个IO操作，指定DB线程池</span></span><br><span class="line">    .thenAccept(savedResult -&gt; sendNotification(savedResult))  <span class="comment">// 步骤4：最终处理</span></span><br><span class="line">    .exceptionally(ex -&gt; &#123;                                     <span class="comment">// 统一异常处理</span></span><br><span class="line">        log.error(<span class="string">&quot;Pipeline failed&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> handleFailure(ex);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>并行执行与结果聚合：</strong> 同时发起多个独立任务，等所有&#x2F;任意一个完成后再处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;ResultA&gt; futureA = CompletableFuture.supplyAsync(() -&gt; serviceA.call());</span><br><span class="line">CompletableFuture&lt;ResultB&gt; futureB = CompletableFuture.supplyAsync(() -&gt; serviceB.call());</span><br><span class="line">CompletableFuture&lt;ResultC&gt; futureC = CompletableFuture.supplyAsync(() -&gt; serviceC.call());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等所有任务完成</span></span><br><span class="line">CompletableFuture&lt;Void&gt; allFutures = CompletableFuture.allOf(futureA, futureB, futureC);</span><br><span class="line">allFutures.thenRun(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 手动获取各个结果（此时肯定已完成）</span></span><br><span class="line">    <span class="type">ResultA</span> <span class="variable">a</span> <span class="operator">=</span> futureA.join(); <span class="comment">// 或 get() (需处理异常)</span></span><br><span class="line">    <span class="type">ResultB</span> <span class="variable">b</span> <span class="operator">=</span> futureB.join();</span><br><span class="line">    <span class="type">ResultC</span> <span class="variable">c</span> <span class="operator">=</span> futureC.join();</span><br><span class="line">    aggregateResults(a, b, c);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等任意一个任务完成</span></span><br><span class="line">CompletableFuture&lt;Object&gt; anyFuture = CompletableFuture.anyOf(futureA, futureB, futureC);</span><br><span class="line">anyFuture.thenAccept(result -&gt; handleFirstResult(result));</span><br></pre></td></tr></table></figure></li><li><p><strong>结果转换与处理：</strong> 使用 <code>thenApply</code> 将上一步的结果转换成另一种形式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;123&quot;</span>);</span><br><span class="line">CompletableFuture&lt;Integer&gt; intFuture = future.thenApply(Integer::parseInt);</span><br></pre></td></tr></table></figure></li><li><p><strong>副作用操作：</strong> 使用 <code>thenAccept</code> 消费结果但不产生新结果（如日志、发送消息），或使用 <code>thenRun</code> 执行不依赖结果的动作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">future.thenAccept(result -&gt; System.out.println(<span class="string">&quot;Result: &quot;</span> + result));</span><br><span class="line">future.thenRun(() -&gt; cleanupResources());</span><br></pre></td></tr></table></figure></li><li><p><strong>组合异步任务：</strong></p><ul><li><code>thenCompose(Function&lt;T, CompletionStage&lt;U&gt;&gt;)</code>: <strong>扁平化</strong>组合。当前 Future 完成后，用其结果作为输入，<strong>启动并返回另一个 Future</strong> (避免嵌套 <code>CompletableFuture&lt;CompletableFuture&lt;U&gt;&gt;</code>)。</li><li><code>thenCombine(CompletionStage&lt;U&gt;, BiFunction&lt;T, U, V&gt;)</code>: 等待<strong>当前 Future 和另一个 Future</strong> 都完成，然后用两者的结果执行一个函数，返回新的 Future。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thenCompose 示例 (获取用户后获取订单)</span></span><br><span class="line">CompletableFuture&lt;User&gt; userFuture = getUserAsync(userId);</span><br><span class="line">CompletableFuture&lt;Order&gt; orderFuture = userFuture.thenCompose(user -&gt; getOrdersAsync(user));</span><br><span class="line"></span><br><span class="line"><span class="comment">// thenCombine 示例 (并行计算价格和库存，然后组合)</span></span><br><span class="line">CompletableFuture&lt;Price&gt; priceFuture = getPriceAsync(productId);</span><br><span class="line">CompletableFuture&lt;Inventory&gt; inventoryFuture = getInventoryAsync(productId);</span><br><span class="line">CompletableFuture&lt;ProductInfo&gt; productInfoFuture = priceFuture.thenCombine(inventoryFuture,</span><br><span class="line">    (price, inventory) -&gt; <span class="keyword">new</span> <span class="title class_">ProductInfo</span>(price, inventory));</span><br></pre></td></tr></table></figure></li><li><p><strong>异常处理：</strong></p><ul><li><code>exceptionally(Function&lt;Throwable, T&gt;)</code>: 捕获异常并提供一个<strong>恢复值</strong>，返回一个正常完成的 Future。</li><li><code>handle(BiFunction&lt;T, Throwable, U&gt;)</code>: 无论正常完成还是异常，都会被调用。可以检查结果或异常，并返回一个新结果（或抛出新异常）。</li><li><code>whenComplete(BiConsumer&lt;T, Throwable&gt;)</code>: 类似 <code>handle</code>，但它是消费者（不改变结果），用于记录日志、清理等，返回一个结果类型相同的 Future（异常会传播）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">future.exceptionally(ex -&gt; defaultValue) <span class="comment">// 异常时提供默认值</span></span><br><span class="line">     .handle((result, ex) -&gt; &#123;</span><br><span class="line">         <span class="keyword">if</span> (ex != <span class="literal">null</span>) &#123; <span class="keyword">return</span> fallback; &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123; <span class="keyword">return</span> transform(result); &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">     .whenComplete((result, ex) -&gt; &#123;</span><br><span class="line">         <span class="keyword">if</span> (ex != <span class="literal">null</span>) log.error(<span class="string">&quot;Oops&quot;</span>, ex);</span><br><span class="line">         <span class="keyword">else</span> metrics.recordSuccess();</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>超时控制 (Java 9+):</strong> 使用 <code>orTimeout(timeout, timeUnit)</code> 或 <code>completeOnTimeout(value, timeout, timeUnit)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = someLongRunningTask()</span><br><span class="line">    .orTimeout(<span class="number">5</span>, TimeUnit.SECONDS) <span class="comment">// 超时抛出 TimeoutException</span></span><br><span class="line">    .exceptionally(ex -&gt; (ex <span class="keyword">instanceof</span> TimeoutException) ? <span class="string">&quot;Timed out&quot;</span> : <span class="string">&quot;Other error&quot;</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;String&gt; future = someLongRunningTask()</span><br><span class="line">    .completeOnTimeout(<span class="string">&quot;Fallback Value&quot;</span>, <span class="number">5</span>, TimeUnit.SECONDS); <span class="comment">// 超时提供默认值</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>三、关键优势</strong></p><ol><li><strong>非阻塞异步：</strong> 提高系统吞吐量和响应性。</li><li><strong>声明式 &amp; 链式编程：</strong> 代码更简洁、易读、易维护，接近同步代码的风格（避免回调地狱）。</li><li><strong>强大的组合能力：</strong> 轻松编排复杂异步工作流（顺序、并行、聚合、条件）。</li><li><strong>灵活的异常处理：</strong> 提供多种方式处理异步管道中的错误。</li><li><strong>显式完成控制：</strong> 支持手动设置结果，适应更多场景（如超时、外部事件）。</li><li><strong>线程池集成：</strong> 可精细控制任务执行位置。</li></ol><p><strong>四、注意事项与最佳实践</strong></p><ol><li><strong>避免阻塞：</strong> 不要在 <code>CompletableFuture</code> 的回调方法（如 <code>thenApply</code>, <code>thenAccept</code> 内部）执行长时间阻塞操作，这会卡住执行线程（可能是公共的 ForkJoinPool 线程）。使用 <code>thenApplyAsync</code> 等带 <code>Executor</code> 的方法将阻塞操作提交到专用线程池。</li><li><strong>线程池选择：</strong><ul><li>CPU 密集型任务：考虑使用 <code>ForkJoinPool.commonPool()</code> (默认) 或固定大小线程池（线程数 ≈ CPU 核心数）。</li><li>IO 密集型任务：<strong>务必使用</strong> 足够大的缓存线程池（如 <code>Executors.newCachedThreadPool()</code>）或专门配置的线程池，避免线程饥饿。<strong>强烈推荐为不同资源（如DB、HTTP）使用独立线程池。</strong></li></ul></li><li><strong>异常传播：</strong> 理解异常在链式调用中的传播机制。如果某个阶段抛出异常且未被捕获（如 <code>exceptionally</code>），后续依赖它的 <code>thenApply</code>&#x2F;<code>thenAccept</code> 等<strong>不会被执行</strong>，异常会传递到链的末端或等待 <code>get()</code>&#x2F;<code>join()</code> 时抛出。使用 <code>handle</code>&#x2F;<code>whenComplete</code>&#x2F;<code>exceptionally</code> 妥善处理。</li><li><strong>结果获取：</strong><ul><li><code>get()</code>: 阻塞等待结果，需处理 <code>InterruptedException</code> 和 <code>ExecutionException</code>（封装了原始异常）。</li><li><code>join()</code>: 类似 <code>get()</code>，但抛出未经检查的 <code>CompletionException</code>（其 <code>getCause()</code> 是原始异常）。通常在链的末端或明确知道会很快完成时使用。</li><li><strong>尽量使用回调</strong>（<code>thenAccept</code>, <code>thenApply</code>, <code>whenComplete</code>）而非阻塞获取，以保持非阻塞性。</li></ul></li><li><strong>资源清理：</strong> 使用 <code>whenComplete</code> 或 <code>handle</code> 确保资源（如文件句柄、网络连接）在任务完成（无论成功失败）后被正确关闭。</li><li><strong>避免过度嵌套：</strong> 虽然链式调用避免回调地狱，但深度嵌套仍可能降低可读性。考虑将复杂步骤抽取成独立方法。</li><li><strong>取消传播：</strong> <code>CompletableFuture.cancel(true)</code> 会尝试中断当前正在执行的任务，但<strong>不会自动取消它依赖的或依赖它的其他 Future</strong>。需要手动设计取消逻辑。</li></ol><p><strong>总结</strong></p><p><code>CompletableFuture</code> 是 Java 现代异步编程的基石。它通过<strong>链式组合</strong>、<strong>非阻塞回调</strong>和<strong>显式完成</strong>机制，提供了强大而优雅的方式来构建复杂、高效的异步应用程序。深入理解其原理（状态机、依赖管理）和熟练掌握其 API（<code>supplyAsync</code>, <code>thenXxx</code>, <code>handle</code>, <code>allOf</code>, <code>anyOf</code>, <code>thenCompose</code>, <code>thenCombine</code>, 异常处理）是编写高性能、高响应性 Java 服务的关键。合理使用线程池和遵循最佳实践（避免阻塞回调、妥善处理异常、管理资源）至关重要。</p><h4 id="CompletableFuture-和传统的-Future-有什么区别"><a href="#CompletableFuture-和传统的-Future-有什么区别" class="headerlink" title="CompletableFuture 和传统的 Future 有什么区别"></a><strong><code>CompletableFuture</code> 和传统的 <code>Future</code> 有什么区别</strong></h4><ul><li>考察点：理解其核心优势（链式编程、组合能力、手动完成、异常处理）。</li><li>期望回答：<code>Future</code> 仅支持阻塞获取结果或轮询，无法组合；<code>CompletableFuture</code> 实现了 <code>CompletionStage</code>，支持非阻塞回调、任务链式组合、手动设置结果&#x2F;异常、更强大的异常处理。</li></ul><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h3><p>内存区域（堆、栈、方法区&#x2F;元空间、程序计数器、本地方法栈）及其作用。</p><h4 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h4><table><thead><tr><th><strong>内存区域</strong></th><th><strong>描述</strong></th><th><strong>线程共享性</strong></th><th><strong>异常触发条件</strong></th></tr></thead><tbody><tr><td><strong>程序计数器（PC）</strong></td><td>记录当前线程执行的字节码指令地址，线程私有，唯一无OOM的区域。</td><td>线程私有</td><td>无（不会抛出内存相关异常）</td></tr><tr><td><strong>虚拟机栈（Java Stack）</strong></td><td>存储方法调用的栈帧（局部变量表、操作数栈、动态链接、方法出口等），线程私有。</td><td>线程私有</td><td><code>StackOverflowError</code>（栈深度溢出） <code>OutOfMemoryError</code>（无法扩展栈空间）</td></tr><tr><td><strong>本地方法栈（Native Stack）</strong></td><td>为Native方法（如C&#x2F;C++实现的方法）提供栈空间，线程私有。</td><td>线程私有</td><td>同虚拟机栈</td></tr><tr><td><strong>堆（Heap）</strong></td><td>存放对象实例和数组，所有线程共享，是垃圾回收的主要区域。</td><td>线程共享</td><td><code>OutOfMemoryError</code>（堆内存不足）</td></tr><tr><td><strong>方法区（Method Area）</strong></td><td>存储类信息、常量、静态变量、即时编译器代码等数据。JDK 8后由元空间（Metaspace）实现。</td><td>线程共享</td><td><code>OutOfMemoryError</code>（元空间&#x2F;方法区内存不足）</td></tr></tbody></table><h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><p>类加载机制（加载、验证、准备、解析、初始化）、类加载器（双亲委派模型及打破场景）、字节码指令。</p><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><p>垃圾收集算法（标记-清除、标记-整理、复制）和主流垃圾收集器（Serial, Parallel, CMS, G1, ZGC, Shenandoah）的工作原理、优缺点、适用场景和调优参数。</p><table><thead><tr><th>算法</th><th>步骤</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>标记-清除（Mark-Sweep）</strong></td><td>1. <strong>标记</strong>：遍历所有对象，标记存活对象。 2. <strong>清除</strong>：回收未被标记的对象（垃圾）。</td><td><strong>优点</strong>：实现简单，不需要移动对象。 <strong>缺点</strong>：产生内存碎片，可能触发频繁的 Full GC。</td><td>1. 老年代回收（如 CMS 收集器的初始阶段）。 2. 对内存碎片不敏感的场景，或短期运行的应用程序。</td></tr><tr><td><strong>复制算法（Copying）</strong></td><td>1. 将内存分为两块（From 和 To），对象分配在 From 区。 2. 标记存活对象，将其复制到 To 区。 3. 清空 From 区，交换 From 和 To 的角色。</td><td><strong>优点</strong>：无内存碎片，回收高效。 <strong>缺点</strong>：内存利用率低（需预留一半空间）。</td><td>1. 新生代回收（如 Serial、ParNew、Parallel Scavenge 等收集器）。 2. 适用于对象存活率低的场景（如新生代 Eden 区）。</td></tr><tr><td><strong>标记-整理（Mark-Compact）</strong></td><td><strong>标记</strong>：遍历所有对象，标记存活对象。 <strong>整理</strong>：将存活对象向内存一端移动，清理边界外的空间。</td><td><strong>优点</strong>：避免内存碎片，适合长期运行的系统。 <strong>缺点</strong>：移动对象需要时间，导致停顿较长（STW）。</td><td>1. 老年代回收（如 Serial Old、Parallel Old 收集器）。 2. 对内存敏感且需要避免碎片的场景（如大数据应用）。</td></tr></tbody></table><h3 id="性能监控与调优"><a href="#性能监控与调优" class="headerlink" title="性能监控与调优"></a>性能监控与调优</h3><p>熟练使用 <code>jps</code>, <code>jstat</code>, <code>jmap</code>, <code>jstack</code>, <code>jcmd</code>, <code>jconsole</code>, <code>VisualVM</code>, 以及更强大的 <code>Java Flight Recorder</code> 和 <code>Mission Control</code>。理解 GC 日志分析。掌握常见性能问题（内存泄漏、OOM、CPU 飙高、线程阻塞）的诊断思路和工具链。</p><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><p>类加载的过程包括了<strong>加载、验证、准备、解析、初始化</strong>五个阶段。</p><h4 id="哪些场景会触发类的加载"><a href="#哪些场景会触发类的加载" class="headerlink" title="哪些场景会触发类的加载"></a>哪些场景会触发类的加载</h4><ul><li>类的实例化</li><li>访问类的静态成员</li><li>调用类的静态方法</li><li><code>Class.forName()</code>、<code>ClassLoader.loadClass()</code>等反射方法</li><li>加载子类时会加载父类</li></ul><h4 id="Class-forName-和ClassLoader-loadClass-有什么区别"><a href="#Class-forName-和ClassLoader-loadClass-有什么区别" class="headerlink" title="Class.forName()和ClassLoader.loadClass()有什么区别"></a><code>Class.forName()</code>和<code>ClassLoader.loadClass()</code>有什么区别</h4><ul><li><code>Class.forName()</code>: 将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li><li><code>ClassLoader.loadClass()</code>: 只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li><li><code>Class.forName(name, initialize, loader)</code>带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。</li></ul><h4 id="类加载器的层次结构"><a href="#类加载器的层次结构" class="headerlink" title="类加载器的层次结构"></a>类加载器的层次结构</h4><p>类加载器层级结构：</p><table><thead><tr><th><strong>类加载器</strong></th><th><strong>加载路径</strong></th><th><strong>父加载器</strong></th></tr></thead><tbody><tr><td><strong>Bootstrap ClassLoader</strong></td><td><code>JRE/lib/rt.jar</code>等核心库</td><td>无（顶级加载器）</td></tr><tr><td><strong>Extension ClassLoader</strong></td><td><code>JRE/lib/ext</code>目录下扩展库</td><td>Bootstrap</td></tr><tr><td><strong>Application ClassLoader</strong></td><td>应用类路径（ClassPath）</td><td>Extension</td></tr><tr><td><strong>自定义ClassLoader</strong></td><td>用户自定义路径</td><td>Application</td></tr></tbody></table><h4 id="什么是双亲委派模型"><a href="#什么是双亲委派模型" class="headerlink" title="什么是双亲委派模型"></a>什么是双亲委派模型</h4><p>双亲委派模型（Parent Delegation Model）是Java类加载机制中的一种设计模式，用于控制类的加载顺序和避免类的重复加载。在双亲委派模型中，类加载器会按照一定的顺序进行类的加载，并将加载请求委派给父类加载器，只有在父类加载器找不到类的情况下，才会由子类加载器进行加载。</p><p><strong>双亲委派模型的优点</strong></p><ol><li>避免类的重复加载：由于类加载器会先委派给父类加载器进行加载，所以可以避免同一个类被多个类加载器重复加载，从而节省内存和提高性能。</li><li>安全性：核心类库通常由启动类加载器加载，而自定义类通常由应用程序类加载器加载，这样可以保证核心类库的安全性，防止被恶意代码替代。</li><li>模块化：通过使用不同的类加载器，可以实现类的模块化和隔离，从而在复杂的应用程序中实现类的共享和复用。</li></ol><p><strong>双亲委派模型的缺点</strong></p><ol><li>灵活性受限：双亲委派模型限制了类加载器的灵活性，可能导致在某些特定的场景中无法实现自定义的类加载行为。例如，在某些需要在运行时动态生成类或加载非标准格式的类文件的场景中，双亲委派模型可能会受限。</li><li>不适合某些类加载场景：在某些场景中，双亲委派模型可能并不适合，例如在OSGi（Open Service Gateway Initiative）等动态模块化系统中，需要实现更为复杂的类加载策略，而双亲委派模型可能不足以满足需求。</li><li>类冲突：在某些情况下，由于双亲委派模型的存在，可能会导致类的冲突问题。例如，如果应用程序中存在多个版本的同一个类，并且使用了不同的类加载器加载，可能会导致类加载冲突，从而导致程序出现错误或异常。</li><li>性能开销：由于每次类加载都会委派给父类加载器，这可能导致多层级的类加载链，从而增加了类加载的时间和性能开销。特别是在某些大型复杂的应用程序中，可能会出现类加载性能瓶颈。</li></ol><p><strong>如何打破双亲委派模型</strong></p><p>在Java中，可以通过以下几种方式来打破双亲委派模型，实现自定义的类加载行为：</p><ol><li>自定义类加载器：可以继承java.lang.ClassLoader类，并实现自定义的类加载逻辑，从而绕过双亲委派模型。<strong>通过重写ClassLoader的loadClass()方法，可以在类加载过程中自定义加载规则</strong>，例如先尝试自定义加载，如果失败再委派给父类加载器。</li><li>使用Java的扩展类加载器：<strong>Java的扩展类加载器（Extension ClassLoader）并不遵循双亲委派模型，它在加载Java扩展库时不会委派给父类加载器</strong>。因此，可以将自定义的类放置在Java扩展库中，并使用扩展类加载器加载这些类，从而实现对双亲委派模型的绕过。</li><li>使用线程上下文类加载器：Java中的线程上下文类加载器（Thread Context ClassLoader）是一种特殊的类加载器，可以在程序运行时动态设置，从而在某个特定线程中绕过双亲委派模型。通过设置线程上下文类加载器，可以使特定线程加载指定的类，而不受双亲委派模型的限制。</li></ol><h4 id="loadClass-和-findClass-有什么区别"><a href="#loadClass-和-findClass-有什么区别" class="headerlink" title="loadClass 和 findClass() 有什么区别"></a><code>loadClass</code> 和 <code>findClass()</code> 有什么区别</h4><table><thead><tr><th align="left"><strong>特性</strong></th><th align="left"><code>loadClass()</code></th><th align="left"><code>findClass()</code></th></tr></thead><tbody><tr><td align="left"><strong>职责</strong></td><td align="left">控制加载流程（委派机制）</td><td align="left">实现具体加载逻辑</td></tr><tr><td align="left"><strong>重写必要性</strong></td><td align="left">通常不重写（保持委派模型）</td><td align="left">自定义类加载器时<strong>必须重写</strong></td></tr><tr><td align="left"><strong>双亲委派角色</strong></td><td align="left">实现委派逻辑</td><td align="left">被委派机制调用</td></tr><tr><td align="left"><strong>典型用途</strong></td><td align="left">类加载入口（<code>ClassLoader.loadClass()</code>）</td><td align="left">自定义类加载器时扩展资源获取方式</td></tr></tbody></table><p><strong>最佳实践</strong></p><ol><li><p><strong>自定义类加载器</strong>：<br>只需重写 <code>findClass()</code>（保持双亲委派），<strong>无需</strong>重写 <code>loadClass()</code>。</p><p>java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class CustomLoader extends ClassLoader &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) &#123;</span><br><span class="line">        // 自定义加载逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>破坏双亲委派</strong>：<br>需重写 <code>loadClass()</code>（谨慎使用，如 JDBC&#x2F;JNDI 等场景）。</p></li></ol><img src="/post/7992e236/image-20250725203542235.png" class="" title="image-20250725203542235"><p><code>loadClass()</code> 是框架流程控制者，<code>findClass()</code> 是实际加载逻辑的实现者。自定义类加载优先扩展 <code>findClass()</code>。</p><h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><h4 id="JVM-的新生代划为什么分为一个-Eden-区和两个-Survivor-区"><a href="#JVM-的新生代划为什么分为一个-Eden-区和两个-Survivor-区" class="headerlink" title="JVM 的新生代划为什么分为一个 Eden 区和两个 Survivor 区"></a>JVM 的新生代划为什么分为一个 Eden 区和两个 Survivor 区</h4><p>JVM 的新生代划分为一个 Eden 区和两个 Survivor 区（通常称为 S0 和 S1，或者 From Survivor 和 To Survivor），主要是为了<strong>高效地管理短暂存活的对象，并优化垃圾回收（尤其是 Minor GC）的性能</strong>。这种设计核心在于利用了<strong>复制算法</strong>的优势，同时解决了复制算法在单块 Survivor 空间下的主要问题。</p><p>以下是详细的原因分析：</p><ol><li><strong>利用分代假说（Generational Hypothesis）</strong>：<ul><li>绝大多数对象都是“朝生夕死”的，在分配后很快变得不可达。</li><li>Eden 区是对象<strong>诞生</strong>的地方。几乎所有新对象都在 Eden 区分配。</li><li>将新生代的大部分空间分配给 Eden 区（默认比例通常是 8:1:1），可以容纳大量新创建的对象，减少频繁触发 Minor GC。</li></ul></li><li><strong>高效实施复制算法（Copying Algorithm）</strong>：<ul><li>新生代垃圾回收（Minor GC）主要使用<strong>复制算法</strong>。该算法的核心思想是：将存活的对象从一个内存区域复制到另一个空的内存区域，然后一次性清理掉原区域的整个空间。</li><li><strong>优点</strong>：简单高效，没有内存碎片，回收速度快（只需要移动存活对象，不需要扫描和标记死亡对象）。</li><li><strong>关键需求</strong>：复制算法需要一个<strong>完全空闲的目标区域</strong>来接收存活对象。</li></ul></li><li><strong>解决单块 Survivor 空间的问题（核心原因）</strong>：<ul><li>假设只有一个 Survivor 区（S）。一次 Minor GC 后：<ol><li>Eden 区存活的对象需要复制到 S 区。</li><li>此时 S 区可能已经存放了上次 GC 存活下来的对象（年龄小于晋升阈值的）。</li><li>现在需要将 Eden + S 区的所有存活对象都复制到一个地方。如果只有一个 S 区，那么<strong>这个 S 区既是源又是目标</strong>，这显然是不可能的（源数据会被覆盖）。</li></ol></li><li>即使忽略上面的逻辑矛盾，如果只有一个较大的 Survivor 区，每次 GC 时都需要将其中的存活对象和 Eden 的存活对象一起复制到另一个地方（比如老年代），这会：<ul><li><strong>导致对象过早晋升</strong>：很多本应在新生代经历几次 GC 才死亡的对象，因为 Survivor 空间不足（或设计限制）被直接提升到老年代，增加了老年代 GC 的压力。</li><li><strong>降低复制算法效率</strong>：无法利用 Survivor 区来暂存存活对象进行多次筛选。</li><li><strong>增加内存碎片</strong>：如果复制到老年代，老年代使用的通常是标记-清除或标记-整理算法，更容易产生碎片。</li></ul></li></ul></li><li><strong>双 Survivor 区的解决方案（轮转复制）</strong>：<ul><li>设计两个较小的 Survivor 区（S0 和 S1，通常各占新生代的 10%，与 Eden 的 80% 构成 8:1:1）。</li><li>在任何时候，<strong>总有一个 Survivor 区是空的（To Survivor）</strong>。</li><li><strong>Minor GC 过程</strong>：<ol><li><strong>标记</strong>：标记 Eden 区和当前非空的 Survivor 区（From Survivor，假设是 S0）中所有存活的对象。</li><li><strong>复制</strong>：将所有存活的对象<strong>复制</strong>到空的 Survivor 区（To Survivor，假设是 S1）。在复制过程中：<ul><li>对象的<strong>年龄（Age）</strong> 会增加 1。</li><li>如果某个对象的年龄达到了设定的阈值（默认为 15，可通过 <code>-XX:MaxTenuringThreshold</code> 调整），或者 To Survivor 区空间不足以容纳所有存活对象，这些对象会被直接<strong>晋升（Promote）</strong> 到老年代。</li></ul></li><li><strong>清空</strong>：一次性清空 Eden 区和刚刚作为来源的 Survivor 区（S0）。</li><li><strong>角色互换</strong>：现在 S1 成为了存放存活对象的 From Survivor，而清空的 S0 则成为下一次 GC 的 To Survivor（即空的 Survivor）。</li></ol></li><li><strong>关键优势</strong>：<ul><li><strong>始终有空的 To Survivor</strong>：为复制算法提供了必需的目标空间。</li><li><strong>对象年龄增长</strong>：在两个 Survivor 区之间多次复制（Minor GC）的过程，自然地实现了对象年龄的增长，为基于年龄的晋升策略提供了基础。</li><li><strong>延迟晋升</strong>：大部分对象会在 Eden 和 Survivor 区之间经历几次 GC 后被回收掉，只有真正“长寿”的对象才会晋升到老年代，减少了老年代 GC 的压力。</li><li><strong>避免碎片</strong>：复制算法保证了 Survivor 区内总是紧凑排列的存活对象，没有内存碎片。</li><li><strong>高效回收 Eden</strong>：只需简单地清空整个 Eden 区，回收速度极快。</li></ul></li></ul></li><li><strong>空间利用率与权衡</strong>：<ul><li>两个较小的 Survivor 区（各 10%）相比一个较大的 Survivor 区（比如 20%），在空间利用率上似乎有损失（总有 10% 是空的）。</li><li>但这种牺牲是值得的：<ul><li>它换来了复制算法的核心优势（无碎片、高效回收 Eden）。</li><li>它有效实现了基于年龄的对象筛选，大大减少了不必要的晋升。</li><li>空着的那个 Survivor 区是算法运行的必要条件，不能算浪费。</li></ul></li></ul></li></ol><p><strong>总结：</strong></p><p>将新生代划分为一个较大的 Eden 区和两个较小的 Survivor 区（S0 和 S1），是为了完美适配<strong>复制算法</strong>进行高效的 Minor GC：</p><ol><li><strong>Eden 区</strong>：容纳大量新创建的对象，利用“对象朝生夕死”的特性。</li><li><strong>双 Survivor 区（S0 &amp; S1）</strong>：提供轮转机制。<ul><li>确保<strong>始终有一个空的 Survivor（To）</strong> 作为复制算法的目标区域。</li><li>在 Eden 和 From Survivor 的存活对象复制到 To Survivor 的过程中：<ul><li>实现<strong>对象年龄增长</strong>。</li><li>筛选出达到年龄阈值或空间不足的对象<strong>晋升到老年代</strong>。</li></ul></li><li>复制完成后，一次性清空 Eden 和 From Survivor，交换 From&#x2F;To 角色。</li><li>避免了单 Survivor 区的逻辑矛盾、过早晋升和碎片问题。</li></ul></li></ol><p>这种设计是 HotSpot JVM（以及其他许多 JVM）实现高效新生代垃圾回收的基石。虽然现代垃圾收集器（如 G1, ZGC, Shenandoah）在内存布局上有所不同，但它们解决新生代对象管理的核心思想（快速分配、高效回收短暂对象、延迟晋升）仍然是相通的，双 Survivor 区的设计很好地体现了这些原则。</p><h4 id="运行时常量池和字符串常量池有什么区别"><a href="#运行时常量池和字符串常量池有什么区别" class="headerlink" title="运行时常量池和字符串常量池有什么区别"></a>运行时常量池和字符串常量池有什么区别</h4><p>在JVM中，常量池分为两部分：<strong>运行时常量池</strong>和<strong>字符串常量池</strong>（String Pool，也称为String Table）。</p><ul><li><p><strong>运行时常量池</strong>：属于方法区的一部分。在JDK1.7之前，方法区位于永久代（PermGen）中；从JDK1.7开始，字符串常量池被移动到堆中；而到了JDK1.8，永久代被元空间（Metaspace）取代，运行时常量池也随之移到了元空间。但是，元空间并不在虚拟机内存中，而是使用本地内存。</p></li><li><p><strong>字符串常量池</strong>：在JDK1.7之前位于方法区（永久代），从JDK1.7开始被移动到堆中（Heap）。所以，在JDK1.7及之后的版本中，字符串常量池位于堆内存中。</p></li></ul><p>因此，针对不同版本的JDK，常量池的位置有所不同：</p><ul><li><p>JDK1.6及之前：运行时常量池（包括字符串常量池）在方法区（永久代）。</p></li><li><p>JDK1.7：运行时常量池仍在方法区（但方法区开始逐步移除永久代，使用元空间的前身），而字符串常量池被移动到堆中。</p></li><li><p>JDK1.8及之后：运行时常量池在元空间（Metaspace，使用本地内存），字符串常量池在堆中。</p></li></ul><p>StringTable 在 jdk1.6 之前，是方法区中运行时常量池的一部分， jdk1.7 之后移到了堆中。</p><p>在 jdk1.6 之前，full GC 才会触发永久代的垃圾回收，回收效率很低，如果有大量字符串放入 StringTable，容易导致永久代内存溢出。</p><p>StringTable 放入堆中之后，只要有 minor GC，就会触发 StringTable 的垃圾回收，减少了无用字符串常量对内存的占用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk8</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringPool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>); <span class="comment">// s1 指向堆中的 &quot;ab&quot;</span></span><br><span class="line">        s1.intern(); <span class="comment">// 在 StringTable 中放入堆中 &quot;ab&quot; 的地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// s2 存的地址就是 StringTable 中指向堆中 &quot;ab&quot; 的地址，即 s2 也指向堆中的 &quot;ab&quot;</span></span><br><span class="line">        System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jdk6</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringPool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>); <span class="comment">// s1 指向堆中的 &quot;ab&quot;</span></span><br><span class="line">        s1.intern(); <span class="comment">// 在 StringTable 创建 &quot;ab&quot;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// s2 指向 StringTable 中的 &quot;ab&quot;</span></span><br><span class="line">        System.out.println(s1 == s2); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="String-s-new-String-a-new-String-a-一共创建几个对象"><a href="#String-s-new-String-a-new-String-a-一共创建几个对象" class="headerlink" title="String s = new String(&quot;a&quot;) + new String(&quot;a&quot;) 一共创建几个对象"></a><code>String s = new String(&quot;a&quot;) + new String(&quot;a&quot;)</code> 一共创建几个对象</h4><h4 id="什么情况下会触发StackOverflowError和OutOfMemoryError"><a href="#什么情况下会触发StackOverflowError和OutOfMemoryError" class="headerlink" title="什么情况下会触发StackOverflowError和OutOfMemoryError"></a>什么情况下会触发StackOverflowError和OutOfMemoryError</h4><p><strong>触发StackOverflowError</strong></p><ul><li><p><strong>无限递归</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class StackOverflowExample &#123;</span><br><span class="line">    public static void recursiveMethod() &#123;</span><br><span class="line">        recursiveMethod(); // 无限递归调用</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        recursiveMethod(); // 触发StackOverflowError</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次方法调用都会在虚拟机栈中压入新栈帧，超出栈的最大深度限制（默认1MB，可通过<code>-Xss</code>调整）。</p></li><li><p>栈帧过大（局部变量过多或方法操作数栈过深）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void largeMethod() &#123;</span><br><span class="line">    int a1, a2, a3, ..., a10000; // 大量局部变量占用栈空间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单个栈帧占用的内存超过栈容量。</p></li></ul><p><strong>触发OutOfMemoryError</strong></p><ul><li><p><strong>堆内存溢出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 不断创建大对象，耗尽堆内存</span><br><span class="line">List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">while (true) &#123;</span><br><span class="line">    list.add(new byte[1024 * 1024]); // 每次分配1MB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原因</strong>：对象数量超过堆容量（可通过<code>-Xmx</code>和<code>-Xms</code>调整堆大小）。</p><p><strong>典型场景</strong>：内存泄漏（如静态集合未释放对象）或合理内存不足。</p></li><li><p><strong>方法区&#x2F;元空间溢出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 动态生成大量类（如使用CGLIB）</span><br><span class="line">public class MetaspaceOOM &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Enhancer enhancer = new Enhancer();</span><br><span class="line">        enhancer.setSuperclass(OOMObject.class);</span><br><span class="line">        enhancer.setCallback((MethodInterceptor) (obj, method, args1, proxy) -&gt; proxy.invokeSuper(obj, args1));</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            enhancer.create(); // 持续生成代理类</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static class OOMObject &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原因</strong>：加载的类数量或元数据量超过元空间容量（通过<code>-XX:MaxMetaspaceSize</code>设置上限）。</p><p><strong>典型场景</strong>：动态代理框架（如Spring AOP）、反射滥用。</p></li><li><p><strong>虚拟机栈或本地方法栈无法扩展</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 启动大量线程，每个线程的栈空间无法分配</span><br><span class="line">public class ThreadOOM &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                try &#123; Thread.sleep(1000000); &#125; catch (InterruptedException e) &#123;&#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原因</strong>：线程数量过多导致栈总内存超过系统限制（通过<code>-Xss</code>减少单个线程栈大小）。</p></li></ul><p><strong>总结</strong></p><table><thead><tr><th><strong>错误类型</strong></th><th><strong>触发场景</strong></th><th><strong>典型原因</strong></th><th><strong>解决方案</strong></th></tr></thead><tbody><tr><td><strong>StackOverflowError</strong></td><td>递归调用未终止、栈帧过大</td><td>代码逻辑错误</td><td>修复递归终止条件，减少局部变量数量</td></tr><tr><td><strong>OutOfMemoryError</strong></td><td>堆内存不足、元空间溢出、线程数过多</td><td>内存泄漏、配置不当、资源耗尽</td><td>调整JVM参数，优化代码，增加物理内存</td></tr></tbody></table><h4 id="永久代和元空间的区别"><a href="#永久代和元空间的区别" class="headerlink" title="永久代和元空间的区别"></a>永久代和元空间的区别</h4><h4 id="堆内存是怎么细分的"><a href="#堆内存是怎么细分的" class="headerlink" title="堆内存是怎么细分的"></a>堆内存是怎么细分的</h4><h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><h4 id="如何定位内存溢出问题"><a href="#如何定位内存溢出问题" class="headerlink" title="如何定位内存溢出问题"></a>如何定位内存溢出问题</h4><p><strong>快速识别症状</strong></p><ol><li><strong>监控告警</strong>：<ul><li>JVM：<code>Heap usage &gt; 90%</code>，频繁Full GC但回收效果差。</li><li>系统级：<code>top</code>&#x2F;<code>htop</code> 显示进程内存持续增长不释放。</li></ul></li><li><strong>错误日志</strong>：<ul><li><code>java.lang.OutOfMemoryError: Java heap space</code>（堆溢出）</li><li><code>java.lang.OutOfMemoryError: Metaspace</code>（元空间溢出）</li><li><code>java.lang.OutOfMemoryError: Unable to create new native thread</code>（线程数超限）</li></ul></li></ol><p><strong>获取内存快照（Heap Dump）</strong></p><blockquote><p><strong>关键动作：在OOM发生时自动保存Dump，避免重启后丢失现场</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># JVM启动参数添加</span></span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError </span><br><span class="line">-XX:HeapDumpPath=/path/to/dump.hprof</span><br></pre></td></tr></table></figure><p><strong>分析堆转储文件（关键步骤）</strong></p><ol><li><p><strong>Eclipse MAT (Memory Analyzer Tool)</strong></p><ul><li>优势：可视化分析，自动检测泄漏疑点。</li><li>步骤：<ul><li>打开 <code>dump.hprof</code> 文件。</li><li>查看 <strong>Leak Suspects Report</strong>（泄漏嫌疑对象）。</li><li>分析 <strong>Dominator Tree</strong> 找到占用最大的对象。</li><li>检查 <strong>Path to GC Roots</strong> 查看引用链。</li></ul></li></ul></li><li><p><strong>VisualVM</strong></p><ul><li>适用场景：实时监控+离线分析。</li><li>功能：堆转储的 <strong>Classes</strong> 视图按实例数排序，定位异常类。</li></ul></li><li><p><strong>命令行工具（快速排查）</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 检查堆内对象统计</span></span><br><span class="line">jmap -histo:live &lt;pid&gt; | <span class="built_in">head</span> -n 20</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 分析堆转储（文本模式）</span></span><br><span class="line">jhat dump.hprof  <span class="comment"># 访问 http://localhost:7000</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>排查常见内存泄漏场景</strong></p><table><thead><tr><th align="left"><strong>泄漏类型</strong></th><th align="left"><strong>典型代码案例</strong></th><th align="left"><strong>分析线索</strong></th></tr></thead><tbody><tr><td align="left"><strong>集合类泄漏</strong></td><td align="left"><code>static Map</code> 缓存无清理逻辑</td><td align="left">HashMap&#x2F;ArrayList 占主导</td></tr><tr><td align="left"><strong>未关闭资源</strong></td><td align="left">未关闭的 <code>FileInputStream</code>、<code>Connection</code></td><td align="left">Finalizer 队列堆积</td></tr><tr><td align="left"><strong>线程局部变量</strong></td><td align="left"><code>ThreadLocal</code> 未调用 <code>remove()</code></td><td align="left">线程池中ThreadLocal对象累积</td></tr><tr><td align="left"><strong>监听器未注销</strong></td><td align="left">注册后未移除的事件监听器</td><td align="left">监听器对象持有外部引用</td></tr><tr><td align="left"><strong>元空间溢出</strong></td><td align="left">动态生成类（如CGLib）</td><td align="left">Metaspace 使用量持续增长</td></tr></tbody></table><p><strong>案例</strong></p><p>以下是一个高度真实的内存溢出案例，模拟了常见的<strong>缓存无限增长</strong>场景。该案例通过静态Map存储用户数据，并配合后台线程持续加载，同时缺乏过期机制，最终导致堆内存溢出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemoryLeakSimulator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态缓存Map - 典型的内存泄漏根源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Long, UserProfile&gt; USER_CACHE = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟后台缓存加载线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===== 内存泄漏模拟程序启动 =====&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 初始化定时任务：每秒添加100个用户到缓存</span></span><br><span class="line">        executor.scheduleAtFixedRate(() -&gt; loadUsersToCache(), <span class="number">0</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 模拟访问缓存（加速内存增长）</span></span><br><span class="line">        executor.scheduleAtFixedRate(() -&gt; accessCache(), <span class="number">0</span>, <span class="number">300</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 添加JVM关闭钩子（用于资源清理）</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            executor.shutdown();</span><br><span class="line">            System.out.println(<span class="string">&quot;===== 程序关闭 =====&quot;</span>);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟用户数据加载到缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loadUsersToCache</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">userId</span> <span class="operator">=</span> System.nanoTime(); <span class="comment">// 使用时间戳模拟用户ID</span></span><br><span class="line">            USER_CACHE.put(userId, <span class="keyword">new</span> <span class="title class_">UserProfile</span>(</span><br><span class="line">                userId,</span><br><span class="line">                <span class="string">&quot;user-&quot;</span> + UUID.randomUUID(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">50</span>] <span class="comment">// 每个用户分配50KB数据（模拟用户信息）</span></span><br><span class="line">            ));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;【缓存加载】当前缓存用户数: %,d 占用内存: ≈%,dMB\n&quot;</span>,</span><br><span class="line">            USER_CACHE.size(),</span><br><span class="line">            (USER_CACHE.size() * <span class="number">50</span>) / <span class="number">1024</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟缓存访问（增加对象引用复杂度）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">accessCache</span><span class="params">()</span> &#123;</span><br><span class="line">        USER_CACHE.forEach((id, profile) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 模拟业务处理（实际中可能包含复杂逻辑）</span></span><br><span class="line">            <span class="keyword">if</span> (id % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                profile.updateLastAccessTime();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户信息类（包含大对象）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserProfile</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">long</span> userId;</span><br><span class="line">        <span class="keyword">private</span> String userName;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span>[] userData; <span class="comment">// 大对象</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">long</span> lastAccessTime;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">UserProfile</span><span class="params">(<span class="type">long</span> userId, String userName, <span class="type">byte</span>[] userData)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.userId = userId;</span><br><span class="line">            <span class="built_in">this</span>.userName = userName;</span><br><span class="line">            <span class="built_in">this</span>.userData = userData;</span><br><span class="line">            <span class="built_in">this</span>.lastAccessTime = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateLastAccessTime</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.lastAccessTime = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键设计说明（真实漏洞点）</strong>：</p><ol><li><strong>静态Map缓存</strong>（<code>USER_CACHE</code>）<ul><li>生命周期与JVM相同，永远不会被回收</li><li>使用<code>ConcurrentHashMap</code>模拟真实高并发场景</li></ul></li><li><strong>定时加载线程</strong><ul><li>每秒添加100个新用户（约5MB&#x2F;秒）</li><li>每个用户对象包含50KB数据（模拟用户信息、图片等）</li></ul></li><li><strong>缓存访问模式</strong><ul><li>高频访问缓存（每300ms遍历一次）</li><li>更新对象字段（增加GC Roots引用链复杂度）</li></ul></li><li><strong>大对象设计</strong><ul><li><code>byte[1024 * 50]</code> 模拟用户上传的文件&#x2F;图片数据</li><li>对象大小可控（调整数组长度可改变OOM速度）</li></ul></li></ol><p><strong>运行参数配置（加速OOM出现）</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置小堆内存 + OOM时自动dump</span></span><br><span class="line">java -Xms128m -Xmx128m -XX:+HeapDumpOnOutOfMemoryError -jar MemoryLeakSimulator.jar</span><br></pre></td></tr></table></figure><p><strong>预期结果</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">===== 内存泄漏模拟程序启动 =====</span><br><span class="line">【缓存加载】当前缓存用户数: 100 占用内存: ≈4MB</span><br><span class="line">【缓存加载】当前缓存用户数: 200 占用内存: ≈9MB</span><br><span class="line">...</span><br><span class="line">【缓存加载】当前缓存用户数: 2,500 占用内存: ≈122MB</span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid12345.hprof ...</span><br></pre></td></tr></table></figure><p><strong>漏洞分析（MAT工具验证）</strong>：</p><ol><li>打开生成的<code>java_pid12345.hprof</code>文件</li><li>执行 <strong>Leak Suspects Report</strong>：<ul><li>将显示<code>ConcurrentHashMap</code>占用 &gt;90% 内存</li></ul></li><li>查看 <strong>Dominator Tree</strong>：<ul><li>排名第一的是<code>java.util.concurrent.ConcurrentHashMap$Node[]</code></li><li>保留堆栈指向<code>USER_CACHE</code></li></ul></li><li>追踪 <strong>Path to GC Roots</strong>：<ul><li>显示<code>USER_CACHE</code>被<code>static</code>变量持有</li></ul></li></ol><p><strong>真实场景对应</strong>：</p><p>此案例模拟了：</p><ul><li>用户会话缓存未设置TTL</li><li>上传文件缓存未清理</li><li>静态配置中心数据无限累积</li><li>第三方API响应缓存未过期</li></ul><p><strong>修复方案</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用弱引用缓存（自动回收）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Long, WeakReference&lt;UserProfile&gt;&gt; USER_CACHE = </span><br><span class="line">    Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或使用Guava Cache（带过期策略）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Cache&lt;Long, UserProfile&gt; cache = CacheBuilder.newBuilder()</span><br><span class="line">    .maximumSize(<span class="number">1000</span>)</span><br><span class="line">    .expireAfterAccess(<span class="number">10</span>, TimeUnit.MINUTES)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><blockquote><p><strong>重要提示</strong>：在本地运行此代码前，请确保关闭其他重要应用！可通过调整<code>byte[1024 * 50]</code>中的乘数控制OOM速度（例如改为<code>*5</code>可降低内存占用）。</p></blockquote><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><h4 id="如何判断一个对象是否可回收"><a href="#如何判断一个对象是否可回收" class="headerlink" title="如何判断一个对象是否可回收"></a>如何判断一个对象是否可回收</h4><p><strong>引用计数法</strong></p><p><strong>可达性分析法</strong></p><p>在 Java 中 以下对象可作为 GC Roots：</p><ul><li>虚拟机栈中引用的对象</li><li>本地方法栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中的常量引用的对象</li></ul><p>需要注意的是，要宣告一个对象的真正死亡，需要经过两次标记。</p><ol><li><p>从 GC roots 出发，标记不可达的对象</p></li><li><p>对 F-Queue 对列中的对象进行二次标记</p><p>不可达对象如果重写且还未执行 finalize 方法，会被加入到一个名为 F-Queue 的队列中。在 F-Queue 队列中的对象可以重新被赋值给某个引用，这样二次标记时，这些对象将被移出 F-Queue 队列，从而实现自救。</p></li></ol><h4 id="4种引用类型"><a href="#4种引用类型" class="headerlink" title="4种引用类型"></a>4种引用类型</h4><p>JVM 的四种引用类型（强引用、软引用、弱引用、虚引用）决定了对象如何被垃圾回收器（GC）对待，主要服务于<strong>更精细地控制对象生命周期</strong>和<strong>管理内存</strong>的目的。它们的使用场景各有侧重：</p><ol><li><p><strong>强引用 (Strong Reference)</strong></p><ul><li><strong>定义：</strong> 最常见的引用类型。通过 <code>new</code> 关键字创建的对象默认就是强引用。只要强引用存在，垃圾回收器就<strong>绝对不会</strong>回收该对象，即使面临内存不足（OOM）的风险。</li><li><strong>语法：</strong> <code>Object obj = new Object(); // obj 就是一个指向新 Object 实例的强引用</code></li></ul></li><li><p><strong>软引用 (SoftReference)</strong></p><ul><li><p><strong>定义：</strong> 用来描述一些<strong>有用但非必需</strong>的对象。当内存充足时，软引用关联的对象不会被回收；当<strong>内存不足（即将发生 OOM 之前）</strong>，垃圾回收器会尝试回收这些软引用指向的对象。如果回收了软引用对象后内存仍然不足，才会抛出 <code>OutOfMemoryError</code>。</p></li><li><p><strong>语法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">importantObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 原始强引用</span></span><br><span class="line">SoftReference&lt;Object&gt; softRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(importantObj);</span><br><span class="line">importantObj = <span class="literal">null</span>; <span class="comment">// 解除强引用，只剩下软引用</span></span><br><span class="line"><span class="comment">// 稍后尝试获取</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">retrieved</span> <span class="operator">=</span> softRef.get(); <span class="comment">// 如果未被回收，retrieved != null; 如果被回收，retrieved == null</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用场景：</strong></p><ul><li><strong>内存敏感的高速缓存 (Memory-Sensitive Caches)：</strong> 软引用能保证在内存吃紧时自动释放缓存，避免 OOM，同时尽可能利用内存提高缓存命中率。</li></ul></li></ul></li><li><p><strong>弱引用 (WeakReference)</strong></p><ul><li><p><strong>定义：</strong> 用来描述<strong>非必需</strong>对象，比软引用更弱。无论当前内存是否充足，只要垃圾回收器开始工作（并且扫描到这个对象），就会回收掉<strong>仅被弱引用指向</strong>的对象。</p></li><li><p><strong>语法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">tempObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 原始强引用</span></span><br><span class="line">WeakReference&lt;Object&gt; weakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(tempObj);</span><br><span class="line">tempObj = <span class="literal">null</span>; <span class="comment">// 解除强引用，只剩下弱引用</span></span><br><span class="line"><span class="comment">// 强制触发一次 GC (仅示例，生产环境慎用 System.gc())</span></span><br><span class="line">System.gc();</span><br><span class="line"><span class="comment">// 尝试获取</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">retrieved</span> <span class="operator">=</span> weakRef.get(); <span class="comment">// 很大概率 retrieved == null，因为对象已被回收</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>虚引用 (PhantomReference)</strong></p><ul><li><p><strong>定义：</strong> 最弱的一种引用。<strong>无法通过虚引用获取对象实例</strong>（其 <code>get()</code> 方法总是返回 <code>null</code>）。虚引用<strong>必须</strong>与 <code>ReferenceQueue</code> 联合使用。设置虚引用的<strong>唯一目的</strong>是<strong>跟踪对象被垃圾回收的时机</strong>。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象<strong>之后</strong>（此时对象内存已被释放或即将被释放），将这个虚引用加入与之关联的 <code>ReferenceQueue</code> 中。</p></li><li><p><strong>语法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line"><span class="type">Object</span> <span class="variable">phantomObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 原始强引用</span></span><br><span class="line">PhantomReference&lt;Object&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(phantomObj, queue);</span><br><span class="line">phantomObj = <span class="literal">null</span>; <span class="comment">// 解除强引用</span></span><br><span class="line"><span class="comment">// ... 强制 GC 或等待 GC 发生 ...</span></span><br><span class="line"><span class="comment">// 检查队列</span></span><br><span class="line">Reference&lt;?&gt; refFromQueue = queue.poll();</span><br><span class="line"><span class="keyword">if</span> (refFromQueue != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 此时 refFromQueue 就是 phantomRef，表示 phantomObj 已被回收或处于 finalization 状态</span></span><br><span class="line">    <span class="comment">// 可以在这里执行一些资源清理动作（如关闭关联的文件描述符、释放堆外内存等）</span></span><br><span class="line">    <span class="comment">// 注意：此时原对象 phantomObj 已经不可达且内存可能已被回收</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用场景：</strong></p><ul><li><strong>管理堆外内存 (Off-Heap Memory)：</strong> 这是最主要的应用场景。Java NIO 的 <code>DirectByteBuffer</code> 分配堆外内存。<code>DirectByteBuffer</code> 对象本身很小（在堆上），但它关联着一块较大的堆外内存。当 <code>DirectByteBuffer</code> 对象被回收时，需要释放其关联的堆外内存。JVM 使用 <code>Cleaner</code> 类（内部基于 <code>PhantomReference</code>）来监控 <code>DirectByteBuffer</code> 对象。当 <code>DirectByteBuffer</code> 对象被 GC 回收后，<code>Cleaner</code> 的虚引用会被放入队列，触发一个清理线程调用 <code>unsafe.freeMemory</code> 来释放堆外内存。</li></ul></li></ul></li></ol><h4 id="CMS收集器工作原理"><a href="#CMS收集器工作原理" class="headerlink" title="CMS收集器工作原理"></a>CMS收集器工作原理</h4><h4 id="G1收集器工作原理"><a href="#G1收集器工作原理" class="headerlink" title="G1收集器工作原理"></a>G1收集器工作原理</h4><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>问题库</title>
      <link href="/post/7c4f87d.html"/>
      <url>/post/7c4f87d.html</url>
      
        <content type="html"><![CDATA[<h2 id="jpa"><a href="#jpa" class="headerlink" title="jpa"></a>jpa</h2><h3 id="jpa-数组越界异常"><a href="#jpa-数组越界异常" class="headerlink" title="jpa 数组越界异常"></a>jpa 数组越界异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Type</span> &#123;</span><br><span class="line">    A,</span><br><span class="line">    B</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Enumerated</span></span><br><span class="line">    <span class="keyword">private</span> Type type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设表里存在一条数据，<code>type</code> 列的值为2，在使用JPA查询数据这条数据时会报数组越界异常，具体报错如：<code>nested exception is java.lang.ArrayIndexOutOfBoundsException: Index 2 out of bounds for length 2</code></p><p>报错的原因是 <code>Type</code> 的 <code>ordinal</code> 范围是[0, 1]，2不在范围内。</p><h3 id="jpa-缓存问题"><a href="#jpa-缓存问题" class="headerlink" title="jpa 缓存问题"></a>jpa 缓存问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CanvasInstanceDataObject</span> &#123;</span><br><span class="line">    <span class="comment">// 其他字段</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@CreatedDate</span></span><br><span class="line">    <span class="meta">@Column(updatable = false)</span></span><br><span class="line">    <span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span></span><br><span class="line">    <span class="keyword">protected</span> Date createdAt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LastModifiedDate</span></span><br><span class="line">    <span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span></span><br><span class="line">    <span class="keyword">protected</span> Date updatedAt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_canvas_instance` (</span><br><span class="line">  `created_at` datetime(<span class="number">6</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `updated_at` datetime(<span class="number">6</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>问题背景：某张表及其对应的实体类定义如上，代码中执行语句 <code>DataObject dataObject = canvasInstanceGateway.save(dataObject);</code> ，<code>dataObject</code> 的 <code>createdAt</code> 字段格式为 <code>2025-01-03 16:46:51.876</code>，而 <code>updatedAt</code> 为 <code>Mon Jan 06 19:55:43 CST 2025</code> 。</p><p>经查资料发现 JPA 在调用 <code>save</code> 方法保存对象时会将对象缓存在一级缓存中，如果保存之后立即查询该对象，会从缓存中获取数据，而不是从数据库中重新查询。而内存中的 <code>dataObject</code> 的 <code>updatedAt</code> 字段是 <code>Date</code> 类型，只有在真正保存到数据库中，才会序列化为时间戳类型。为了确保从数据库中重新查询数据，需使用 <code>EntityManager</code> 的 <code>clear</code> 方法来清空一级缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CanvasInstanceService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CanvasInstanceRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PersistenceContext</span></span><br><span class="line">    <span class="keyword">private</span> EntityManager entityManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> CanvasInstanceDataObject <span class="title function_">saveAndFindById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="type">CanvasInstanceDataObject</span> <span class="variable">model</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CanvasInstanceDataObject</span>();</span><br><span class="line">        <span class="comment">// 设置 model 的属性</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存到数据库</span></span><br><span class="line">        <span class="type">CanvasInstanceDataObject</span> <span class="variable">savedModel</span> <span class="operator">=</span> repository.save(model);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清空实体管理器的缓存</span></span><br><span class="line">        entityManager.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从数据库中重新查询</span></span><br><span class="line">        <span class="type">CanvasInstanceDataObject</span> <span class="variable">foundModel</span> <span class="operator">=</span> repository.findById(id).orElse(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> foundModel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="jackson"><a href="#jackson" class="headerlink" title="jackson"></a>jackson</h2><h3 id="jackson-序列化空指针异常"><a href="#jackson-序列化空指针异常" class="headerlink" title="jackson 序列化空指针异常"></a>jackson 序列化空指针异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Storage</span> &#123;</span><br><span class="line">    </span><br><span class="line">    String endpoint;</span><br><span class="line"></span><br><span class="line">    String storagePath;</span><br><span class="line"></span><br><span class="line">    String schema;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getRegion</span><span class="params">()</span> &#123;</span><br><span class="line">        String[] parts = endpoint.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用<code>Jackson</code>序列化<code>Storage</code>对象时，如果<code>endpoint</code>为<code>null</code>，会报空指针异常。</p><p>解决方法：修改函数名，如将<code>getRegion</code>改为<code>resolveRegion</code>。</p><h3 id="配置反序列化构造函数"><a href="#配置反序列化构造函数" class="headerlink" title="配置反序列化构造函数"></a>配置反序列化构造函数</h3><p><code>Jackson</code>反序列化默认需要一个无参构造器来创建对象，之后再通过<code>setter</code>方法设置对象的属性值。如果类没有无参构造器，反序列化会失败，如果不想添加无参构造器，可以通过配置让<code>Jackson</code>用其他构造器来反序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonCreator</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="meta">@JsonProperty(&quot;name&quot;)</span> String name, </span></span><br><span class="line"><span class="params">                  <span class="meta">@JsonProperty(&quot;age&quot;)</span> Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h2><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>(redisTemplate))</span><br><span class="line">            .addPathPatterns(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">            .excludePathPatterns(</span><br><span class="line">                <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">            );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动程序会抛出如下异常：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: org.springframework.beans.factory.BeanNotOfRequiredTypeException: Bean named <span class="string">&#x27;redisTemplate&#x27;</span> is expected to be of <span class="built_in">type</span> <span class="string">&#x27;org.springframework.data.redis.core.StringRedisTemplate&#x27;</span> but was actually of <span class="built_in">type</span> <span class="string">&#x27;org.springframework.data.redis.core.RedisTemplate&#x27;</span></span><br></pre></td></tr></table></figure><p>原因是<code>@Resource</code>注解默认按名称注入依赖对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="java-stream"><a href="#java-stream" class="headerlink" title="java stream"></a>java stream</h2><h3 id="Collectors-toMap"><a href="#Collectors-toMap" class="headerlink" title="Collectors.toMap()"></a><code>Collectors.toMap()</code></h3><p>JDK 8 引入了 <code>stream</code>，极大地简化了日常开发中的集合处理，但是如果使用不当，也会带来一些问题，其中 <code>Collectors.toMap()</code> 就需要谨慎使用。下面简单记录一下使用 <code>Collectors.toMap()</code> 过程中遇到的两个问题。</p><p>先准备一个实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题1：key重复"><a href="#问题1：key重复" class="headerlink" title="问题1：key重复"></a>问题1：<code>key</code>重复</h4><p>单元测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testToMapWithDuplicateKey</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;User&gt; users = Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1L</span>, <span class="string">&quot;Tom&quot;</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1L</span>, <span class="string">&quot;Jerry&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Map&lt;Long, String&gt; map = users.stream().collect(Collectors.toMap(User::getId, User::getName));</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试方法会看到如下报错：</p><img src="/post/7c4f87d/image-20241015001026308.png" class="" title="image-20241015001026308"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T, K, V&gt;</span><br><span class="line">BiConsumer&lt;Map&lt;K, V&gt;, T&gt; <span class="title function_">uniqKeysMapAccumulator</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends K&gt; keyMapper,</span></span><br><span class="line"><span class="params">                                                Function&lt;? <span class="built_in">super</span> T, ? extends V&gt; valueMapper)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (map, element) -&gt; &#123;</span><br><span class="line">        <span class="type">K</span> <span class="variable">k</span> <span class="operator">=</span> keyMapper.apply(element);</span><br><span class="line">        <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> Objects.requireNonNull(valueMapper.apply(element));</span><br><span class="line">        <span class="type">V</span> <span class="variable">u</span> <span class="operator">=</span> map.putIfAbsent(k, v);</span><br><span class="line">        <span class="keyword">if</span> (u != <span class="literal">null</span>) <span class="keyword">throw</span> duplicateKeyException(k, u, v);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击进入报错的源码，可以看到如果 <code>key</code> 重复，jdk 默认的处理方式是抛出异常。为了解决这个问题，需要用户自定义处理 <code>key</code> 重复的策略，比如用新值覆盖旧值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testToMapWithDuplicateKey</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;User&gt; users = Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1L</span>, <span class="string">&quot;Tom&quot;</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1L</span>, <span class="string">&quot;Jerry&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Map&lt;Long, String&gt; map = users.stream().collect(Collectors.toMap(User::getId, User::getName, (oldVal, newVal) -&gt; newVal));</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题2：value为null"><a href="#问题2：value为null" class="headerlink" title="问题2：value为null"></a>问题2：<code>value</code>为<code>null</code></h4><p>单元测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testToMapWithNullValue</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;User&gt; users = Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1L</span>, <span class="string">&quot;Tom&quot;</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1L</span>, <span class="literal">null</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Map&lt;Long, String&gt; map = users.stream().collect(Collectors.toMap(User::getId, User::getName, (oldVal, newVal) -&gt; newVal));</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试方法可以看到如下报错：</p><img src="/post/7c4f87d/image-20241015001918076.png" class="" title="image-20241015001918076"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">merge</span><span class="params">(K key, V value,</span></span><br><span class="line"><span class="params">               BiFunction&lt;? <span class="built_in">super</span> V, ? <span class="built_in">super</span> V, ? extends V&gt; remappingFunction)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入源码，可以看到 jdk 在合并 <code>key</code> 相同的元素时，如果 <code>value</code> 为 <code>null</code>，会直接抛出异常。处理这个问题，可以先过滤掉 <code>value</code> 可能为 <code>null</code> 的数据，或返回默认值。</p><p>过滤掉 <code>name</code> 为 <code>null</code> 的数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testToMapWithNullValue</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;User&gt; users = Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1L</span>, <span class="string">&quot;Tom&quot;</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1L</span>, <span class="literal">null</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Map&lt;Long, String&gt; map = users.stream()</span><br><span class="line">        .filter(user -&gt; user.getName() != <span class="literal">null</span>)</span><br><span class="line">        .collect(Collectors.toMap(User::getId, User::getName, (oldVal, newVal) -&gt; newVal));</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>name</code> 为 <code>null</code>，默认返回空字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testToMapWithNullValue</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;User&gt; users = Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1L</span>, <span class="string">&quot;Tom&quot;</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1L</span>, <span class="literal">null</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Map&lt;Long, String&gt; map = users.stream()</span><br><span class="line">        .collect(Collectors.toMap(User::getId, it -&gt; Optional.ofNullable(it.getName()).orElse(<span class="string">&quot;&quot;</span>), (oldVal, newVal) -&gt; newVal));</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rabbitmq"><a href="#rabbitmq" class="headerlink" title="rabbitmq"></a>rabbitmq</h2><h3 id="rabbitmq-启动异常"><a href="#rabbitmq-启动异常" class="headerlink" title="rabbitmq 启动异常"></a>rabbitmq 启动异常</h3><p>错误信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BOOT FAILED</span><br><span class="line">2024-12-08 23:37:59.182161+08:00 [error] &lt;0.215.0&gt;</span><br><span class="line">2024-12-08 23:37:59.182161+08:00 [error] &lt;0.215.0&gt; BOOT FAILED</span><br><span class="line">2024-12-08 23:37:59.182161+08:00 [error] &lt;0.215.0&gt; ===========</span><br><span class="line">2024-12-08 23:37:59.182161+08:00 [error] &lt;0.215.0&gt; Error during startup: &#123;error,failed_to_initialize_feature_flags_registry&#125;</span><br><span class="line">2024-12-08 23:37:59.182161+08:00 [error] &lt;0.215.0&gt;</span><br><span class="line">===========</span><br><span class="line">Error during startup: &#123;error,failed_to_initialize_feature_flags_registry&#125;</span><br><span class="line"></span><br><span class="line">2024-12-08 23:38:00.183638+08:00 [notice] &lt;0.45.0&gt; Application rabbit exited with reason: &#123;failed_to_initialize_feature_flags_registry,&#123;rabbit,start,[normal,[]]&#125;&#125;</span><br><span class="line">&#123;<span class="built_in">exit</span>,terminating,[&#123;application_controller,call,2,[&#123;file,<span class="string">&quot;application_controller.erl&quot;</span>&#125;,&#123;line,511&#125;]&#125;,&#123;application,<span class="string">&#x27;-ensure_all_started/3-lc$^0/1-0-&#x27;</span>,1,[&#123;file,<span class="string">&quot;application.erl&quot;</span>&#125;,&#123;line,367&#125;]&#125;,&#123;application,ensure_all_started,3,[&#123;file,<span class="string">&quot;application.erl&quot;</span>&#125;,&#123;line,367&#125;]&#125;,&#123;rabbit,<span class="string">&#x27;-start_it/1-fun-0-&#x27;</span>,1,[&#123;file,<span class="string">&quot;rabbit.erl&quot;</span>&#125;,&#123;line,430&#125;]&#125;,&#123;timer,tc,2,[&#123;file,<span class="string">&quot;timer.erl&quot;</span>&#125;,&#123;line,590&#125;]&#125;,&#123;rabbit,start_it,1,[&#123;file,<span class="string">&quot;rabbit.erl&quot;</span>&#125;,&#123;line,426&#125;]&#125;,&#123;init,start_it,1,[]&#125;,&#123;init,start_em,1,[]&#125;]&#125;</span><br><span class="line">Runtime terminating during boot (terminating)</span><br></pre></td></tr></table></figure><p>错误原因：RabbitMQ 的数据目录可能已经损坏或者不一致</p><p>解决方式：删除 RabbitMQ 的数据目录并重启服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf /usr/local/var/lib/rabbitmq/mnesia</span><br><span class="line">brew services start rabbitmq</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>代码库</title>
      <link href="/post/5cb37524.html"/>
      <url>/post/5cb37524.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="获取请求路径上的参数"><a href="#获取请求路径上的参数" class="headerlink" title="获取请求路径上的参数"></a>获取请求路径上的参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserContextInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, String&gt; pathVariables = (Map&lt;String, String&gt;) request.getAttribute(</span><br><span class="line">                HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE);</span><br><span class="line">        <span class="type">var</span> <span class="variable">projectId</span> <span class="operator">=</span> pathVariables.get(<span class="string">&quot;project_id&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="无servlet情况下获取请求头"><a href="#无servlet情况下获取请求头" class="headerlink" title="无servlet情况下获取请求头"></a>无servlet情况下获取请求头</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();</span><br><span class="line">request.getHeader(<span class="string">&quot;project_id&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="stream操作"><a href="#stream操作" class="headerlink" title="stream操作"></a><code>stream</code>操作</h2><ul><li><code>List&lt;String&gt;</code>转<code>Map&lt;String, List&lt;String&gt;&gt;</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">list2Map</span><span class="params">(List&lt;String&gt; locations)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> locations.stream()</span><br><span class="line">        .map(s -&gt; s.split(<span class="string">&quot;:&quot;</span>))</span><br><span class="line">        .collect(Collectors.groupingBy(a -&gt; a[<span class="number">0</span>],</span><br><span class="line">            Collectors.mapping(a -&gt; a[<span class="number">1</span>], Collectors.toList())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分割字符串并取其中某个子字符串</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如要获取packageType（如：codearts.xxx.free）中的服务名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">service</span> <span class="operator">=</span> Optional.ofNullable(packageType)</span><br><span class="line">                .filter(StringUtils::isNoneBlank)</span><br><span class="line">                .map(it -&gt; it.split(<span class="string">&quot;\\.&quot;</span>))</span><br><span class="line">                .filter(it -&gt; it.length &gt; <span class="number">1</span>)</span><br><span class="line">                .map(it -&gt; it[<span class="number">1</span>])</span><br><span class="line">                .orElse(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="日期操作"><a href="#日期操作" class="headerlink" title="日期操作"></a>日期操作</h2><ul><li><code>Date</code>转<code>LocalDateTime</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> LocalDateTime <span class="title function_">asLocalDateTime</span><span class="params">(Date date)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> date.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="卫语句"><a href="#卫语句" class="headerlink" title="卫语句"></a>卫语句</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 卫语句用于检查某些前置条件，如果条件不满足，直接返回或抛出异常，避免继续执行后续的代码块。</span></span><br><span class="line"><span class="comment"> * 通过使用卫语句，可以减少代码的嵌套程度，提高代码的可读性和可维护性。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查订单是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 使用卫语句直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查订单状态</span></span><br><span class="line">    <span class="keyword">if</span> (str.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 使用卫语句直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行订单处理逻辑</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="统一返回结构"><a href="#统一返回结构" class="headerlink" title="统一返回结构"></a>统一返回结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IResult</span> &#123;</span><br><span class="line"></span><br><span class="line">    Integer <span class="title function_">getCode</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getMessage</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ResultEnum</span> <span class="keyword">implements</span> <span class="title class_">IResult</span> &#123;</span><br><span class="line"></span><br><span class="line">    SUCCESS(<span class="number">2001</span>, <span class="string">&quot;接口调用成功&quot;</span>),</span><br><span class="line"></span><br><span class="line">    FAILED(<span class="number">2002</span>, <span class="string">&quot;接口调用失败&quot;</span>),</span><br><span class="line"></span><br><span class="line">    VALIDATE_FAILED(<span class="number">2003</span>, <span class="string">&quot;参数校验失败&quot;</span>),</span><br><span class="line"></span><br><span class="line">    FORBIDDEN(<span class="number">2004</span>, <span class="string">&quot;禁止访问&quot;</span>)</span><br><span class="line"></span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line"></span><br><span class="line">    ResultEnum(Integer code, String message) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">success</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;(ResultEnum.SUCCESS.getCode(), ResultEnum.SUCCESS.getMessage(), data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">success</span><span class="params">(String message, T data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;(ResultEnum.SUCCESS.getCode(), message, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result&lt;?&gt; failed() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;(ResultEnum.FAILED.getCode(), ResultEnum.FAILED.getMessage(), <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result&lt;?&gt; failed(String message) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;(ResultEnum.FAILED.getCode(), message, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result&lt;?&gt; failed(IResult result) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;(result.getCode(), result.getMessage(), <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;world&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">helloWorld</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;java&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">helloJava</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="string">&quot;Hello, Java!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在所有接口的返回结构都统一了，但每个接口都要写上封装的逻辑也是一项很重复的工作，可以通过实现<code>ResponseBodyAdvice</code>对结果统一包装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice(basePackages = &quot;com.tw.codesnippet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseAdvice</span> <span class="keyword">implements</span> <span class="title class_">ResponseBodyAdvice</span>&lt;Object&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">beforeBodyWrite</span><span class="params">(Object body, MethodParameter returnType, MediaType selectedContentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (body <span class="keyword">instanceof</span> Result) &#123;</span><br><span class="line">            <span class="keyword">return</span> body;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.success(body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时Controller层的代码就可以简化如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;world&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">helloWorld</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;java&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">helloJava</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, Python!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但如果调用上面的接口会抛出如下异常<code>Result cannot be cast to class java.lang.String</code>，debug可以发现，如果接口的返回值是String类型，<code>beforeBodyWrite</code>的<code>selectedConverterType</code>使用的是<code>StringHttpMessageConverter</code>，而接口是其他类型返回值时<code>selectedConverterType</code>使用的则是<code>MappingJackson2HttpMessageConverter</code>。</p><p>为了解决这个问题，网上的解决办法是添加一个<code>MappingJackson2HttpMessageConverter</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">        converters.add(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但实际运行会发现，<code>selectedConverterType</code>的类型依然是<code>StringHttpMessageConverter</code>，具体原因是：当接口返回String时，Spring默认会优先使用<code>StringHttpMessageConverter</code>来处理，即使在<code>WebConfig</code>里添加了<code>MappingJackson2HttpMessageConverter</code>。</p><p>要让Spring使用<code>MappingJackson2HttpMessageConverter</code>来处理String返回值并生成JSON，可以通过以下几种方法：</p><ol><li>删除<code>StringHttpMessageConverter</code>，确保Spring使用<code>MappingJackson2HttpMessageConverter</code>作为转换器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">        converters.removeIf(converter -&gt; converter <span class="keyword">instanceof</span> StringHttpMessageConverter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>显示指定 <code>Content-Type</code> 和 <code>Accept</code> 头</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H <span class="string">&quot;Accept: application/json&quot;</span> http://localhost:8080/hello/world</span><br></pre></td></tr></table></figure><p>在客户端的请求中明确指定 <code>Accept: application/json</code>，这样 Spring 会根据 <code>Accept</code> 头使用 <code>MappingJackson2HttpMessageConverter</code> 来生成 JSON 响应。</p><ol start="3"><li>对于String类型，让接口返回<code>Result&lt;String&gt;</code></li></ol><h2 id="字段校验"><a href="#字段校验" class="headerlink" title="字段校验"></a>字段校验</h2><p>JSR303 定义了 Bean 校验的标准 validation-api，hibernate validation 是对这个标准的实现，Spring Validation 则是对 hibernate validation 的二次封装。</p><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于 web 服务来说，大部分情况下，请求参数分为如下两种形式：</p><ul><li>GET 请求，使用 <code>@RequestParam</code> 和 <code>@PathVariable</code> 传递参数</li><li>POST 和 PUT 请求，使用 <code>@RequestBody</code> 传递参数</li></ul><h4 id="GET-请求参数校验"><a href="#GET-请求参数校验" class="headerlink" title="GET 请求参数校验"></a>GET 请求参数校验</h4><p>GET 请求一般用 <code>@RequestParam</code> 或 <code>@PathVariable</code>  传参，需在 Controller 上加 <code>@Validated</code> 注解，并在接口参数加约束注解，自动参数校验才能生效。校验失败会抛出 <code>javax.validation.ConstraintViolationException</code> 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> UserDTO <span class="title function_">getUser</span><span class="params">(<span class="meta">@RequestParam(&quot;userId&quot;)</span> <span class="meta">@NotBlank</span> String userId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDTO</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="POST-PUT-请求参数校验"><a href="#POST-PUT-请求参数校验" class="headerlink" title="POST&#x2F;PUT 请求参数校验"></a>POST&#x2F;PUT 请求参数校验</h4><p>POST 或 PUT 请求一般用 <code>@RequestBody</code> 传参，后端使用 DTO 对象接收参数，只需要在 DTO 对象前加上 <code>@Valid</code> 或 <code>@Validated</code> 注解就可以实现自动参数校验，校验失败会抛出 <code>org.springframework.web.bind.MethodArgumentNotValidException</code> 异常。</p><p>比如有一个保存 <code>User</code> 的接口，要求 <code>username</code> 长度是 2-10 个字符，<code>password</code> 长度不小于 6 个字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDTO</span> &#123;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Length(min = 2, max = 10)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Length(min = 6, max = 10)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;save&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserDTO <span class="title function_">saveUser</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated</span> UserDTO userDTO)</span> &#123; <span class="comment">// 也可以使用 @Valid</span></span><br><span class="line">        <span class="keyword">return</span> userDTO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice(&quot;com.tw.codesnippet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonExceptionAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.OK)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">handleMethodArgumentNotValidException</span><span class="params">(MethodArgumentNotValidException ex)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">BindingResult</span> <span class="variable">bindingResult</span> <span class="operator">=</span> ex.getBindingResult();</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> bindingResult.getFieldError().getField() + <span class="string">&quot;:&quot;</span> + bindingResult.getFieldError().getDefaultMessage();</span><br><span class="line">        <span class="keyword">return</span> Result.failed(ResultEnum.VALIDATE_FAILED.getCode(), msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(ConstraintViolationException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.OK)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">handleConstraintViolationException</span><span class="params">(ConstraintViolationException ex)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.failed(ResultEnum.VALIDATE_FAILED.getCode(), ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><h4 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h4><p>在实际开发中，存在多个接口使用同一个DTO来接口参数的情况，而不同的接口需要校验的字段以及规则可能不一样，这时在DTO的字段上笼统地加上约束注解无法达到这个目的。为此，Spring Validation提供了分组校验功能。</p><p>还是上面这个例子，保存<code>User</code>时，<code>userId</code>可以为空，但是更新时，<code>userId</code>不允许为空。</p><ul><li>DTO字段上的约束注解指定分组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDTO</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(groups = Update.class)</span></span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">    <span class="meta">@Length(min = 2, max = 10, groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">    <span class="meta">@Length(min = 6, max = 10, groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Save</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Update</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接口参数的<code>@Validated</code>注解指定分组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;save&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserDTO <span class="title function_">saveUser</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated(UserDTO.Save.class)</span> UserDTO userDTO)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userDTO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;update&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserDTO <span class="title function_">updateUser</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated(UserDTO.Update.class)</span> UserDTO userDTO)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userDTO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：此时不能使用<code>@Valid</code>注解，因为<code>@Valid</code>不具有分组校验功能</p><h4 id="嵌套校验"><a href="#嵌套校验" class="headerlink" title="嵌套校验"></a>嵌套校验</h4><p>如果DTO的某个字段是一个对象，要自动校验这个对象的属性，就得用到嵌套校验。</p><ul><li>在DTO对象字段加上<code>@Valid</code>注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDTO</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(groups = Update.class)</span></span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">    <span class="meta">@Length(min = 2, max = 10, groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">    <span class="meta">@Length(min = 6, max = 10, groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NotBlank(groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">        <span class="keyword">private</span> String country;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NotBlank(groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">        <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NotBlank(groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">        <span class="keyword">private</span> String city;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NotBlank(groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">        <span class="keyword">private</span> String street;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Save</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Update</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义校验"><a href="#自定义校验" class="headerlink" title="自定义校验"></a>自定义校验</h4><p>有时框架提供的校验无法满足业务复杂的校验需求，此时可以自定义校验注解。</p><ul><li>自定义注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = PhoneValidator.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Phone &#123;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;无效的手机号&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现自定义校验器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhoneValidator</span> <span class="keyword">implements</span> <span class="title class_">ConstraintValidator</span>&lt;Phone, String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Pattern</span> <span class="variable">PHONE_PATTERN</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;^1[3-9]\\d&#123;9&#125;$&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String value, ConstraintValidatorContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> PHONE_PATTERN.matcher(value).matches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="批量更新时间"><a href="#批量更新时间" class="headerlink" title="批量更新时间"></a>批量更新时间</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE user_operate_record</span><br><span class="line">SET create_time = DATE_ADD(&#x27;2023-04-01 00:00:00&#x27;, INTERVAL FLOOR(RAND() * 31536000) SECOND);</span><br></pre></td></tr></table></figure><h2 id="批量插入数据"><a href="#批量插入数据" class="headerlink" title="批量插入数据"></a>批量插入数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DROP PROCEDURE IF EXISTS BatchInsert;</span><br><span class="line">delimiter $$</span><br><span class="line">CREATE PROCEDURE BatchInsert(IN loop_counts INT)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE Var LONG;</span><br><span class="line">SET Var = 0;</span><br><span class="line">SET autocommit = 0;</span><br><span class="line">WHILE Var &lt; loop_counts DO</span><br><span class="line">INSERT INTO `user_operate_record` (`iam_id`, `tenant_id`, `region`, `operate_type`, `operate_module`, `module_id`, `input_param`, `output_param`, `create_time`, `is_system`)</span><br><span class="line">VALUES (&#x27;4b98e1d72c214f72af1fa55cfcb5ecf8&#x27;, &#x27;afc4784e64d146549764787876c60856&#x27;, &#x27;cn-north-7&#x27;, &#x27;read&#x27;, &#x27;template&#x27;, &#x27;cb1069e0278144d8f49976285e1efe68&#x27;, null, null, &#x27;2023-05-30 00:00:00&#x27;, 1);</span><br><span class="line">SET Var = Var + 1;</span><br><span class="line">END WHILE;</span><br><span class="line">COMMIT;</span><br><span class="line">END$$;</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br><span class="line">CALL BatchInsert(200000);</span><br></pre></td></tr></table></figure><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="RedisTemplate序列化"><a href="#RedisTemplate序列化" class="headerlink" title="RedisTemplate序列化"></a>RedisTemplate序列化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">    RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">    redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">StringRedisSerializer</span> <span class="variable">stringRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">    redisTemplate.setKeySerializer(stringRedisSerializer);</span><br><span class="line">    redisTemplate.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>&lt;&gt;(Object.class);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">    objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">    objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);</span><br><span class="line">    jackson2JsonRedisSerializer.setObjectMapper(objectMapper);</span><br><span class="line"></span><br><span class="line">    redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">    redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">    redisTemplate.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> redisTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Reids集群搭建</title>
      <link href="/post/75b7478e.html"/>
      <url>/post/75b7478e.html</url>
      
        <content type="html"><![CDATA[<h2 id="主从集群"><a href="#主从集群" class="headerlink" title="主从集群"></a>主从集群</h2><h3 id="主从同步原理"><a href="#主从同步原理" class="headerlink" title="主从同步原理"></a>主从同步原理</h3><p>主从同步流程如图：</p><img src="/post/75b7478e/image-20250219200529477.png" class="" title="image-20250219200529477"><p>主从同步优化：</p><ul><li>在master中配置<code>repl-diskless-sync yes</code>启用无磁盘复制，避免全量复制时的磁盘IO</li><li>单节点上Redis占用内存不要太大，减少RDB文件的大小</li><li>适当提高<code>repl_log</code>的大小，发现slave宕机时尽快实现故障恢复，避免全量复制</li></ul><h3 id="集群搭建测试"><a href="#集群搭建测试" class="headerlink" title="集群搭建测试"></a>集群搭建测试</h3><p>下图就是一个简单的主从集群，如图所示，集群包含一个主节点，两个从节点。主节点负责写操作，从节点负责读操作</p><img src="/post/75b7478e/image-20250217231959576.png" class="" title="image-20250217231959576"><p>下面在虚拟机中利用docker容器搭建这样一个主从集群，首先确保容器中有redis镜像，如果没有，可以通过 <code>docker pull</code> 命令拉取。</p><p>接着通过<code>docker-compose.yaml</code>文件构建集群，文件内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">r1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">r1</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;7001&quot;</span>]</span><br><span class="line">  <span class="attr">r2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">r2</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;7002&quot;</span>]</span><br><span class="line">  <span class="attr">r3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">r3</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;7003&quot;</span>]</span><br></pre></td></tr></table></figure><p>在<code>docker-compose.yaml</code>文件所在目录执行<code>docker compose up -d</code>命令启动容器：</p><img src="/post/75b7478e/image-20250217233502378.png" class="" title="image-20250217233502378"><p>通过<code>docker compse</code>命令启动了3个redis实例，但这3个实例还未组成集群，因为它们之间没有主从关系。主从关系可以通过如下命令进行配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis5.0以前</span></span><br><span class="line">$ slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"><span class="comment"># redis5.0以后</span></span><br><span class="line">$ replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure><p>主从关系的配置有两种生效方式：</p><ul><li>永久生效：在<code>redis.conf</code>文件中利用<code>slaveof</code>制定<code>master</code>节点</li><li>临时生效：通过<code>redis-cli</code>连接到redis实例，并执行<code>slaveof</code>命令指定<code>master</code>节点</li></ul><p>下面演示临时生效方式配置主从关系：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接r2</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it r2 redis-cli -p 7002</span><br><span class="line">127.0.0.1:7002&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:758df4b32faf526a279240093645cc45984d0502</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line">127.0.0.1:7002&gt; slaveof 192.168.33.11 7001</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7002&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:192.168.33.11</span><br><span class="line">master_port:7001</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:3</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_read_repl_offset:14</span><br><span class="line">slave_repl_offset:14</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">replica_announced:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:5519e1a0e085620420c0a7afa2ccc5bf71826a52</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:14</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:14</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接r3，并执行相同操作</span></span><br></pre></td></tr></table></figure><p>接着连接r1并通过<code>info replication</code>查看节点的从节点信息，可以发现r1是<code>master</code>节点，并且有两个从节点</p><img src="/post/75b7478e/image-20250217235009950.png" class="" title="image-20250217235009950"><p>测试写操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># r1</span></span><br><span class="line">127.0.0.1:7001&gt; <span class="built_in">set</span> num 123</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7001&gt; get num</span><br><span class="line"><span class="string">&quot;123&quot;</span></span><br><span class="line">127.0.0.1:7001&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># r2或r3</span></span><br><span class="line">127.0.0.1:7003&gt; <span class="built_in">set</span> num 456</span><br><span class="line">(error) READONLY You can<span class="string">&#x27;t write against a read only replica.</span></span><br><span class="line"><span class="string">127.0.0.1:7003&gt; get num</span></span><br><span class="line"><span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="string">127.0.0.1:7003&gt;</span></span><br></pre></td></tr></table></figure><p>可以发现，从节点只能执行读操作。</p><h2 id="哨兵集群"><a href="#哨兵集群" class="headerlink" title="哨兵集群"></a>哨兵集群</h2><p>主从集群降低了节点的读写压力，但是存在单点故障的风险。master节点如果宕机，就会导致整个集群不可用。Redis的哨兵机制可以通过哨兵节点来监控集群状态，当某个节点出现故障，能及时地进行故障转移，从而保证集群的高可用性。</p><h3 id="哨兵工作原理"><a href="#哨兵工作原理" class="headerlink" title="哨兵工作原理"></a>哨兵工作原理</h3><p>哨兵集群的示意图如下：</p><img src="/post/75b7478e/image-20250219214812553.png" class="" title="image-20250219214812553"><p>哨兵的作用包括：</p><ul><li>监控集群中redis节点的状态</li><li>故障恢复(failover)：如果master故障，哨兵会将其中一个slave提升为新的master，旧master恢复后会变为新master的slave</li><li>状态通知：当集群发生failover后，哨兵会将最新的集群信息推送给客户端</li></ul><h4 id="状态监控"><a href="#状态监控" class="headerlink" title="状态监控"></a>状态监控</h4><h4 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h4><h2 id="分片集群"><a href="#分片集群" class="headerlink" title="分片集群"></a>分片集群</h2><h2 id="源码环境搭建"><a href="#源码环境搭建" class="headerlink" title="源码环境搭建"></a>源码环境搭建</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># clone 源码</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/redis/redis.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入redis目录</span></span><br><span class="line">$ <span class="built_in">cd</span> redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从制定tag创建分支</span></span><br><span class="line">$ git checkout tags/7.0.5 -b 7.0.5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看是否安装了gcc编译器</span></span><br><span class="line">$ gcc -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有制定以下命令安装</span></span><br><span class="line">$ xcode-select --install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在redis目录执行如下命令编译源码</span></span><br><span class="line"><span class="comment"># -O0 表示不要优化代码，防止在Debug的时候， IDE里面的Redis源码与实际运行的代码对应不上</span></span><br><span class="line">$ make CFLAGS=<span class="string">&quot;-g -O0&quot;</span> MALLOC=jemalloc</span><br></pre></td></tr></table></figure><p><code>CLion</code> 导入redis源码并进行如下配置：</p><img src="/post/75b7478e/image-20250217230303910.png" class="" title="image-20250217230303910"><p>直接debug启动，相当于执行命令 <code>/Users/tw/CLionProjects/redis/src/redis-server redis.conf</code>，接下来在<code>server.c</code>的<code>main()</code>中打断点，就可以debug调试源码了。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell编程</title>
      <link href="/post/6e95fc76.html"/>
      <url>/post/6e95fc76.html</url>
      
        <content type="html"><![CDATA[<h1 id="shell基本命令"><a href="#shell基本命令" class="headerlink" title="shell基本命令"></a>shell基本命令</h1><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>#!/bin/bash</code></td><td>脚本固定开头</td></tr><tr><td><code>$PATH</code></td><td>在脚本中引用环境变量</td></tr><tr><td>today&#x3D;`date`</td><td>替换命令，将 <code>date</code> 的输出赋给 <code>today</code></td></tr><tr><td><code>today=$(date)</code></td><td>同上</td></tr><tr><td><code>date +%y%m%d</code></td><td>将日期显示为两位数的年月日的组合 ，如250108</td></tr><tr><td><code>$[3 * 5]</code></td><td>数学运算</td></tr><tr><td><code>(( expression ))</code></td><td>用于数学表达式</td></tr><tr><td><code>[[ expression ]]</code></td><td>用于高级字符串处理</td></tr><tr><td><code>IFS=$&#39;\n&#39;</code></td><td>修改内部字段分隔符</td></tr><tr><td><code>for file in /etc/*</code></td><td>遍历目录</td></tr></tbody></table><p>条件测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"> commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><ul><li>数值比较</li></ul><table><thead><tr><th>比较</th><th>描述</th></tr></thead><tbody><tr><td><code>n1 -eq n2</code></td><td>检查n1是否与n2相等</td></tr><tr><td><code>n1 -ge n2</code></td><td>检查n1是否大于或等于n2</td></tr><tr><td><code>n1 -gt n2</code></td><td>检查n1是否大于n2</td></tr><tr><td><code>n1 -le n2</code></td><td>检查n1是否小于或等于n2</td></tr><tr><td><code>n1 -lt n2</code></td><td>检查n1是否小于n2</td></tr><tr><td><code>n1 -ne n2</code></td><td>检查n1是否不等于n2</td></tr></tbody></table><ul><li>字符串比较</li></ul><table><thead><tr><th>比较</th><th>说明</th></tr></thead><tbody><tr><td><code>str1 = str2</code></td><td>检查str1是否和str2相同</td></tr><tr><td><code>str1 != str2</code></td><td>检查str1是否和str2不同</td></tr><tr><td><code>str1 &lt; str2</code></td><td>检查str1是否比str2小</td></tr><tr><td><code>str1 &gt; str2</code></td><td>检查str1是否比str2大</td></tr><tr><td><code>-n str1</code></td><td>检查str1的长度是否非0</td></tr><tr><td><code>-z str1</code></td><td>检查str1的长度是否为0</td></tr></tbody></table><ul><li>文件比较</li></ul><table><thead><tr><th>比较</th><th>说明</th></tr></thead><tbody><tr><td><code>-d file</code></td><td>检查file是否存在并是一个目录</td></tr><tr><td><code>-e file</code></td><td>检查file是否存在</td></tr><tr><td><code>-f file</code></td><td>检查file是否存在并是一个文件</td></tr><tr><td><code>-r file</code></td><td>检查file是否存在并可读</td></tr><tr><td><code>-s file</code></td><td>检查file是否存在并非空</td></tr><tr><td><code>-w file</code></td><td>检查file是否存在并可写</td></tr><tr><td><code>-x file</code></td><td>检查file是否存在并可执行</td></tr><tr><td><code>-O file</code></td><td>检查file是否存在并属当前用户所有</td></tr><tr><td><code>-G file</code></td><td>检查file是否存在并且默认组与当前用户相同</td></tr><tr><td><code>file1 -nt file2</code></td><td>检查file1是否比file2新</td></tr><tr><td><code>file1 -ot file2</code></td><td>检查file1是否比file2旧</td></tr></tbody></table><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><h1 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h1><p><code>sed</code> 编辑器可以根据命令来处理数据流中的数据，这些命令要么从命令行中输入，要么存储在一个文本文件中。<code>sed</code> 编辑器会执行下列操作：</p><ol><li>一次从输入中读取一行数据。</li><li>根据所提供的编辑器命令匹配数据。</li><li>按照命令修改流中的数据。</li><li>将新的数据输出到 <code>STDOUT</code> 或文件中。</li></ol><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="模式空间和保持空间"><a href="#模式空间和保持空间" class="headerlink" title="模式空间和保持空间"></a>模式空间和保持空间</h3><p>模式空间（Pattern Space）是当前工作的空间，sed编辑器会将数据流中文本行读入到模式空间进行处理。保持空间（Hold Space）可以看作是模式空间的备份空间，可以将模式空间的某些行临时存储在保持空间，之后再将这些行从保持空间移回模式空间。</p><p>模式空间和保持空间的交互命令如下：</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>h</code></td><td>将模式空间复制到保持空间</td></tr><tr><td><code>H</code></td><td>将模式空间附加到保持空间</td></tr><tr><td><code>g</code></td><td>将保持空间复制到模式空间</td></tr><tr><td><code>G</code></td><td>将保持空间附加到模式空间</td></tr><tr><td><code>X</code></td><td>交付两个空间的内容</td></tr></tbody></table><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p>默认情况下，在sed编辑器中使用的命令会作用于文本数据的所有行。如果只想将命令作用于特定行或某些行，则必须用行寻址（line addressing）。在sed编辑器中有两种形式的行寻址：</p><ul><li>以数字形式表示行区间</li><li>用文本模式来过滤出行</li></ul><h4 id="数字形式行寻址"><a href="#数字形式行寻址" class="headerlink" title="数字形式行寻址"></a>数字形式行寻址</h4><ul><li>指定某行：<code>sed &#39;2command&#39; file</code></li><li>指定行区间：<code>sed &#39;2,3command&#39; file</code></li><li>从某行开始到结尾：<code>sed &#39;2,$command&#39; file</code></li></ul><h4 id="文本模式行寻址"><a href="#文本模式行寻址" class="headerlink" title="文本模式行寻址"></a>文本模式行寻址</h4><ul><li>匹配某行：<code>sed &#39;/pattern/command&#39; file</code></li><li>匹配行区间：<code>sed &#39;/start/[,/end/]command&#39; file</code></li></ul><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h3 id="替换：s"><a href="#替换：s" class="headerlink" title="替换：s"></a>替换：s</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># data1.txt</span></span><br><span class="line">$ <span class="built_in">cat</span> data1.txt</span><br><span class="line">The quick brown fox jumps over the lazy dog.</span><br><span class="line">The quick brown fox jumps over the lazy dog.</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单个编辑器命令，将dog替换成cat</span></span><br><span class="line">$ sed <span class="string">&quot;s/dog/cat/&quot;</span> data1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多个编辑器命令，将brown替换成green，同时将dog替换成cat</span></span><br><span class="line">$ sed <span class="string">&#x27;s/brown/green/; s/dog/cat/&#x27;</span> data1.txt</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> script1.sed</span><br><span class="line">s/brown/green/</span><br><span class="line">s/dog/cat/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 -f 选项从文件中读取编辑器命令</span></span><br><span class="line">$ sed -f script1.sed data1.txt</span><br></pre></td></tr></table></figure><p>替换命令默认只替换第一处匹配的文本，要想替换其他位置匹配文本必须使用<strong>替换标记</strong>，使用方式：<code>s/pattern/replacement/flags</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># data2.txt</span></span><br><span class="line">$ <span class="built_in">cat</span> data2.txt</span><br><span class="line">This is a <span class="built_in">test</span> of the <span class="built_in">test</span> script.</span><br><span class="line">This is the second <span class="built_in">test</span> of the <span class="built_in">test</span> script.</span><br></pre></td></tr></table></figure><p>数字：指定替换第几个匹配的文本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定替换第几个匹配的文本</span></span><br><span class="line">$ sed <span class="string">&#x27;s/test/trial/2&#x27;</span> data2.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换所有匹配的文本</span></span><br><span class="line">$ sed <span class="string">&#x27;s/test/trial/g&#x27;</span> data2.txt</span><br></pre></td></tr></table></figure><h3 id="删除：d"><a href="#删除：d" class="headerlink" title="删除：d"></a>删除：d</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># data3.txt</span></span><br><span class="line">$ <span class="built_in">cat</span> data3.txt</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is line number 4.</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除第3行</span></span><br><span class="line">$ sed <span class="string">&#x27;3d&#x27;</span> data3.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除第2～3行</span></span><br><span class="line">$ sed <span class="string">&#x27;2,3d&#x27;</span> data3.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除从第2行开始的所有行</span></span><br><span class="line">$ sed <span class="string">&#x27;2,$d&#x27;</span> data3.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除匹配到文本的行</span></span><br><span class="line">$ sed <span class="string">&#x27;/number 1/d&#x27;</span> data3.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除文本中的空行</span></span><br><span class="line">$ sed <span class="string">&#x27;/^$/d&#x27;</span> data4.txt</span><br></pre></td></tr></table></figure><h3 id="插入：i"><a href="#插入：i" class="headerlink" title="插入：i"></a>插入：i</h3><ul><li>插入一行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Test Line 2&quot;</span> | sed <span class="string">&#x27;i Test Line 1&#x27;</span></span><br><span class="line">Test Line 1</span><br><span class="line">Test Line 2</span><br></pre></td></tr></table></figure><ul><li>插入多行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Test Line 2&quot;</span> | sed <span class="string">&#x27;i Test Line 1\</span></span><br><span class="line"><span class="string">&gt; Test Line 3&#x27;</span></span><br><span class="line">Test Line 1</span><br><span class="line">Test Line 3</span><br><span class="line">Test Line 2</span><br></pre></td></tr></table></figure><ul><li>在文件开头插入</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">&#x27;1i This is one line of new Text.&#x27;</span> data3.txt</span><br><span class="line">This is one line of new Text.</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is line number 4.</span><br></pre></td></tr></table></figure><h3 id="追加：a"><a href="#追加：a" class="headerlink" title="追加：a"></a>追加：a</h3><ul><li>追加一行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Test Line 2&quot;</span> | sed <span class="string">&#x27;a Test Line 1&#x27;</span></span><br><span class="line">Test Line 2</span><br><span class="line">Test Line 1</span><br></pre></td></tr></table></figure><ul><li>追加多行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Test Line 2&quot;</span> | sed <span class="string">&#x27;a Test Line 1\</span></span><br><span class="line"><span class="string">&gt; Test Line 3&#x27;</span></span><br><span class="line">Test Line 2</span><br><span class="line">Test Line 1</span><br><span class="line">Test Line 3</span><br></pre></td></tr></table></figure><ul><li>在文件末尾追加</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">&#x27;$a This is one line of new text.&#x27;</span> data3.txt</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is line number 4.</span><br><span class="line">This is one line of new text.</span><br></pre></td></tr></table></figure><h3 id="修改行：c"><a href="#修改行：c" class="headerlink" title="修改行：c"></a>修改行：c</h3><ul><li>修改指定行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">&#x27;3c This is a changed line of text.&#x27;</span> data3.txt</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is a changed line of text.</span><br><span class="line">This is line number 4.</span><br></pre></td></tr></table></figure><ul><li>修改匹配到模式的行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">&#x27;/number 3/c This is a changed line of text.&#x27;</span> data3.txt</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is a changed line of text.</span><br><span class="line">This is line number 4.</span><br></pre></td></tr></table></figure><h3 id="转换：y"><a href="#转换：y" class="headerlink" title="转换：y"></a>转换：y</h3><p><code>sed &#39;[address]y/inchars/outchars/ file&#39;</code>：对 <code>inchars</code> 和 <code>outchars</code> 的值进行一对一映射</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">&#x27;y/23/ab/&#x27;</span> data3.txt</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number a.</span><br><span class="line">This is line number b.</span><br><span class="line">This is line number 4.</span><br></pre></td></tr></table></figure><h3 id="打印：p"><a href="#打印：p" class="headerlink" title="打印：p"></a>打印：p</h3><ul><li>打印第2行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sed -n <span class="string">&#x27;2p&#x27;</span> data3.txt</span><br><span class="line">This is line number 2.</span><br></pre></td></tr></table></figure><ul><li>打印第2～3行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sed -n <span class="string">&#x27;2,3p&#x27;</span> data3.txt</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br></pre></td></tr></table></figure><ul><li>打印匹配到的行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sed -n <span class="string">&#x27;/number 3/p&#x27;</span> data3.txt</span><br><span class="line">This is line number 3.</span><br></pre></td></tr></table></figure><ul><li>同时打印原来的行和修改后的行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sed -n <span class="string">&#x27;/3/&#123;</span></span><br><span class="line"><span class="string">&gt; p</span></span><br><span class="line"><span class="string">&gt; s/line/test/p</span></span><br><span class="line"><span class="string">&gt; &#125;&#x27;</span> data3.txt</span><br><span class="line">This is line number 3.</span><br><span class="line">This is <span class="built_in">test</span> number 3.</span><br></pre></td></tr></table></figure><ul><li>双模式匹配，可以用来过滤出某个时间段内的日志</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sed -n <span class="string">&#x27;/2/,/3/p&#x27;</span> data3.txt</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br></pre></td></tr></table></figure><h3 id="写文件：w"><a href="#写文件：w" class="headerlink" title="写文件：w"></a>写文件：w</h3><ul><li>将数据文件的第1行写入新文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">&#x27;1w data3_1.txt&#x27;</span> data3.txt</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> data3_1.txt</span><br><span class="line">This is line number 1.</span><br></pre></td></tr></table></figure><ul><li>将数据文件的第2～3行写入新文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">&#x27;2,3w data3_23.txt&#x27;</span> data3.txt</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> data3_23.txt</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br></pre></td></tr></table></figure><ul><li>写入匹配到的行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">&#x27;/4/w data3_4.txt&#x27;</span> data3.txt</span><br><span class="line"> </span><br><span class="line">$ <span class="built_in">cat</span> data3_4.txt</span><br><span class="line">This is line number 4.</span><br></pre></td></tr></table></figure><p>PS：除了可以通过w命令写文件，还可以通过 <code>-i</code> 选项直接编辑原文件。</p><h3 id="移动到下一行：n"><a href="#移动到下一行：n" class="headerlink" title="移动到下一行：n"></a>移动到下一行：n</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># data5.txt</span></span><br><span class="line">$ <span class="built_in">cat</span> data5.txt</span><br><span class="line">This is the header line.</span><br><span class="line"></span><br><span class="line">This is a data line.</span><br><span class="line"></span><br><span class="line">This is the last line.</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意：有些系统需在d后面加一个分号;</span></span><br><span class="line">$ sed <span class="string">&#x27;/header/&#123;n; d&#125;&#x27;</span> data5.txt</span><br><span class="line">This is the header line.</span><br><span class="line">This is a data line.</span><br><span class="line"></span><br><span class="line">This is the last line.</span><br></pre></td></tr></table></figure><p>命令解释：要删除第1行和第3行之间的空白行，需先根据<code>/header/</code>匹配到第1行，再用n命令让sed编辑器移动到下一行，最后用d命令删除空白行。</p><h3 id="追加下一行：N"><a href="#追加下一行：N" class="headerlink" title="追加下一行：N"></a>追加下一行：N</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># data6.txt</span></span><br><span class="line">$ <span class="built_in">cat</span> data6.txt</span><br><span class="line">This is the header line.</span><br><span class="line">This is the first data line.</span><br><span class="line">This is the second data line.</span><br><span class="line">This is the last line.</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">&#x27;/first/&#123;N ; s/\n/ /&#125;&#x27;</span> data6.txt</span><br><span class="line">This is the header line.</span><br><span class="line">This is the first data line. This is the second data line.</span><br><span class="line">This is the last line.</span><br></pre></td></tr></table></figure><p>命令解释：小写的n命令让sed编辑器移动到下一行，大写的N命令则是让编辑器将下一行追加到模式空间。因此当匹配到<code>/first/</code>所在的行时，N命令让sed编辑器继续读入下一行，此时模式空间的文本内容是 <code>This is the first data line.\nThis is the second data line.</code>，最后通过<code>s/\n/ /</code>命令将换行符替换成空格。该命令呈现出来的效果就是合并两行。</p><p>N命令的一种使用场景是查找并编辑可能分散在多行的短语。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># data7.txt</span></span><br><span class="line">$ <span class="built_in">cat</span> data7.txt</span><br><span class="line">On Tuesday, the Linux System</span><br><span class="line">Administrator<span class="string">&#x27;s group meeting will be held.</span></span><br><span class="line"><span class="string">All System Administrator should attend.</span></span><br><span class="line"><span class="string">Thank you for your attendance.</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ SED <span class="string">&#x27;N ; s/System.Administrator/Desktop user/&#x27;</span> data7.txt</span><br><span class="line">On Tuesday, the Linux Desktop user<span class="string">&#x27;s group meeting will be held.</span></span><br><span class="line"><span class="string">All Desktop users should attend.</span></span><br><span class="line"><span class="string">Thank you for your attendance.</span></span><br></pre></td></tr></table></figure><p>N命令会把上下两行读入模式空间，并通过换行符<code>\n</code>合并成单行文本，所以模式<code>/System.Administrator/</code>就可以匹配到 <code>System\nAdministrator</code>，最后通过s命令替换成 <code>Desktop user</code>。</p><p>由输出结果可以看到，上面这条命令虽然匹配到了跨行的短语，但是在替换之后会合并两行，有时这可能不符合预期。要解决这个问题，需要多条替换命令，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">&#x27;N</span></span><br><span class="line"><span class="string">&gt; s/System\nAdministrator/Desktop\nUser/</span></span><br><span class="line"><span class="string">&gt; s/System Administrator/Desktop User/</span></span><br><span class="line"><span class="string">&gt; &#x27;</span> data7.txt</span><br><span class="line">On Tuesday, the Linux Desktop</span><br><span class="line">User<span class="string">&#x27;s group meeting will be held.</span></span><br><span class="line"><span class="string">All Desktop Users should attend.</span></span><br><span class="line"><span class="string">Thank you for your attendance.</span></span><br></pre></td></tr></table></figure><p>上面这条命令既完成了跨行短语的替换，又不会合并两行，但是这条命令仍然有点问题，假设数据文件如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># data8.txt</span></span><br><span class="line">$ <span class="built_in">cat</span> data8.txt</span><br><span class="line">On Tuesday, the Linux System</span><br><span class="line">Administrator<span class="string">&#x27;s group meeting will be held.</span></span><br><span class="line"><span class="string">All System Administrator should attend.</span></span><br></pre></td></tr></table></figure><p>此时执行上面这条命令会发现，最后一行的的<code>System Administrators</code>没有替换成功。这是因为虽然匹配到该行，但是没有下一行了，N命令会终止后续命令的执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">&#x27;N</span></span><br><span class="line"><span class="string">&gt; s/System\nAdministrator/Desktop\nUser/</span></span><br><span class="line"><span class="string">&gt; s/System Administrator/Desktop User/</span></span><br><span class="line"><span class="string">&gt; &#x27;</span> data8.txt</span><br><span class="line">On Tuesday, the Linux Desktop</span><br><span class="line">User<span class="string">&#x27;s group meeting will be held.</span></span><br><span class="line"><span class="string">All System Administrators should attend.</span></span><br></pre></td></tr></table></figure><p>要解决这个命令，需要用到排除命令<code>!</code>，当遇到文件最后一行，禁止N命令执行即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">&#x27;$!N;</span></span><br><span class="line"><span class="string">&gt; s/System\nAdministrator/Desktop\nUser/</span></span><br><span class="line"><span class="string">&gt; s/System Administrator/Desktop User/</span></span><br><span class="line"><span class="string">&gt; &#x27;</span> data8.txt</span><br><span class="line">On Tuesday, the Linux Desktop</span><br><span class="line">User<span class="string">&#x27;s group meeting will be held.</span></span><br><span class="line"><span class="string">All Desktop Users should attend.</span></span><br></pre></td></tr></table></figure><h3 id="多行删除：D"><a href="#多行删除：D" class="headerlink" title="多行删除：D"></a>多行删除：D</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">&#x27;N; /System\nAdministrator/d&#x27;</span> data8.txt</span><br><span class="line">All System Administrators should attend.</span><br></pre></td></tr></table></figure><p>当N命令和d命令一起使用时，会把当前模式空间中的内容全部删除，这未必符合预期。sed提供了只大写的D命令，只删除模式空间中的第一行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">&#x27;N; /System\nAdministrator/D&#x27;</span> data8.txt</span><br><span class="line">Administrator<span class="string">&#x27;s group meeting will be held.</span></span><br><span class="line"><span class="string">All System Administrators should attend.</span></span><br></pre></td></tr></table></figure><h3 id="排除命令："><a href="#排除命令：" class="headerlink" title="排除命令：!"></a>排除命令：!</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一行不打印</span></span><br><span class="line">$ sed -n <span class="string">&#x27;/header/!p&#x27;</span> data6.txt</span><br><span class="line">This is the first data line.</span><br><span class="line">This is the second data line.</span><br><span class="line">This is the last line.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第2、3行不打印</span></span><br><span class="line">$ sed -n <span class="string">&#x27;2,3!p&#x27;</span> data6.txt</span><br><span class="line">This is the header line.</span><br><span class="line">This is the last line.</span><br></pre></td></tr></table></figure><h3 id="分支命令：b"><a href="#分支命令：b" class="headerlink" title="分支命令：b"></a>分支命令：b</h3><p>分支命令格式：<code>[address]b [label]</code></p><p><code>address</code> 参数决定了哪些行的数据会触发分支命令。<code>label</code> 参数定义了要跳转到的位置。如果没有加 <code>label</code> 参数，跳转命令会跳转到脚本的结尾。</p><ul><li>不带 <code>label</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 跳过第2～3行，不执行后续命令</span></span><br><span class="line">$ sed <span class="string">&#x27;2,3b</span></span><br><span class="line"><span class="string">&gt; s/This is/Is this/</span></span><br><span class="line"><span class="string">&gt; s/line./test?/</span></span><br><span class="line"><span class="string">&gt; &#x27;</span> data6.txt</span><br><span class="line">Is this the header <span class="built_in">test</span>?</span><br><span class="line">This is the first data line.</span><br><span class="line">This is the second data line.</span><br><span class="line">Is this the last <span class="built_in">test</span>?</span><br></pre></td></tr></table></figure><ul><li>带 <code>label</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 跳转命令指定如果文本行中出现了first，程序应该跳到标签为jump1的脚本行。</span></span><br><span class="line"><span class="comment"># 如果分支命令的模式没有匹配，sed编辑器会继续执行脚本中的命令，包括分支标签后的命令</span></span><br><span class="line">$ sed <span class="string">&#x27;/first/b jump1</span></span><br><span class="line"><span class="string">&gt; s/This is the/No jump on/</span></span><br><span class="line"><span class="string">&gt; :jump1</span></span><br><span class="line"><span class="string">&gt; s/This is the/Jump here on/</span></span><br><span class="line"><span class="string">&gt; &#x27;</span> data6.txt</span><br><span class="line">No jump on header line.</span><br><span class="line">Jump here on first data line.</span><br><span class="line">No jump on second data line.</span><br><span class="line">No jump on last line.</span><br></pre></td></tr></table></figure><p>循环删除文本中的逗号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;This, is, a, test, to, remove, commas.&quot;</span> | sed -n <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">:start</span></span><br><span class="line"><span class="string">s/,//1p</span></span><br><span class="line"><span class="string">/,/b start</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br><span class="line">This is, a, <span class="built_in">test</span>, to, remove, commas.</span><br><span class="line">This is a, <span class="built_in">test</span>, to, remove, commas.</span><br><span class="line">This is a <span class="built_in">test</span>, to, remove, commas.</span><br><span class="line">This is a <span class="built_in">test</span> to, remove, commas.</span><br><span class="line">This is a <span class="built_in">test</span> to remove, commas.</span><br><span class="line">This is a <span class="built_in">test</span> to remove commas.</span><br></pre></td></tr></table></figure><p>为了防止无限循环，<code>b start</code> 前需加行模式 <code>/,/</code>，只有文本中还存在逗号时才跳转。</p><h3 id="测试命令：t"><a href="#测试命令：t" class="headerlink" title="测试命令：t"></a>测试命令：t</h3><p>测试命令格式：<code>[address]t [label]</code></p><p>如果替换命令成功匹配并替换了一个模式，测试命令就会跳转到指定的标签。如果替换命令未能匹配指定的模式，测试命令就不会跳转。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;This, is, a, test, to, remove, commas. &quot;</span> | sed -n <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">:start</span></span><br><span class="line"><span class="string">s/,//1p</span></span><br><span class="line"><span class="string">t start</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br><span class="line">This is, a, <span class="built_in">test</span>, to, remove, commas.</span><br><span class="line">This is a, <span class="built_in">test</span>, to, remove, commas.</span><br><span class="line">This is a <span class="built_in">test</span>, to, remove, commas.</span><br><span class="line">This is a <span class="built_in">test</span> to, remove, commas.</span><br><span class="line">This is a <span class="built_in">test</span> to remove, commas.</span><br><span class="line">This is a <span class="built_in">test</span> to remove commas.</span><br></pre></td></tr></table></figure><p><code>t start</code> 只有在前一个替换命令执行成功才执行，同样避免了无限循环。</p><h1 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h1><p>gawk程序是Unix中的原始awk程序的GNU版本，其报告生成能力通常用来从大文本文件文件中提取元素，并将它们格式化成可读的格式，如格式化日志文件。</p><p>gawk的命令格式为：<code>gawk options program file</code>。</p><p>常用的选项如下：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-F fs</code></td><td>指定行中划分数据字段的字段分隔符</td></tr><tr><td><code>-f file</code></td><td>从指定的文件中读取程序</td></tr><tr><td><code>-v var=value</code></td><td>定义gawk程序中的一个变量及其默认值</td></tr><tr><td><code>-mf N</code></td><td>指定要处理的数据文件中的最大字段数</td></tr><tr><td><code>-mr N</code></td><td>指定数据文件中的最大数据行数</td></tr><tr><td><code>-W keyword</code></td><td>指定gawk的兼容模式或警告等级</td></tr></tbody></table><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>所有编程语言都可以使用变量来存取值，gawk编程语言支持两种类型变量：</p><ul><li>内建变量</li><li>自定义变量</li></ul><h3 id="内建变量"><a href="#内建变量" class="headerlink" title="内建变量"></a>内建变量</h3><h4 id="数据字段变量"><a href="#数据字段变量" class="headerlink" title="数据字段变量"></a>数据字段变量</h4><p>在处理文本时，gawk会给一行中的每个数据元素分配一个变量：</p><ul><li><code>$0</code>：表示整个文本行</li><li><code>$1</code>：表示第1个数据字段</li><li><code>$n</code>：表示第n个数据字段</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> data1.txt</span><br><span class="line">One line of <span class="built_in">test</span> text.</span><br><span class="line">Two lines of <span class="built_in">test</span> text.</span><br><span class="line">Three lines of <span class="built_in">test</span> text.</span><br><span class="line"></span><br><span class="line">$ gawk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> data1.txt</span><br><span class="line">One</span><br><span class="line">Two</span><br><span class="line">Three</span><br></pre></td></tr></table></figure><h4 id="分隔符变量"><a href="#分隔符变量" class="headerlink" title="分隔符变量"></a>分隔符变量</h4><p>gawk默认采用空白字符作为输入和输出字段分隔符。</p><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td><code>FIELDWIDTHS</code></td><td>由空格分隔的一列数字，定义了每个数据字段确切宽度</td></tr><tr><td><code>FS</code></td><td>输入字段分隔符</td></tr><tr><td><code>RS</code></td><td>输入记录分隔符</td></tr><tr><td><code>OFS </code></td><td>输出字段分隔符</td></tr><tr><td><code>ORS</code></td><td>输出记录分隔符</td></tr></tbody></table><ul><li>通过 <code>FS</code> 指定输入字段分隔符</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># data2.txt</span></span><br><span class="line">$ <span class="built_in">cat</span> data2.txt</span><br><span class="line">data11,data12,data13,data14,data15</span><br><span class="line">data21,data22,data23,data24,data25</span><br><span class="line">data31,data32,data33,data34,data35</span><br><span class="line"></span><br><span class="line">$ gawk <span class="string">&#x27;BEGIN&#123;FS=&quot;,&quot;&#125; &#123;print $1, $2, $3&#125;&#x27;</span> data2.txt</span><br><span class="line">data11 data12 data13</span><br><span class="line">data21 data22 data23</span><br><span class="line">data31 data32 data33</span><br></pre></td></tr></table></figure><ul><li>通过 <code>OFS</code> 指定输出字段分隔符</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gawk <span class="string">&#x27;BEGIN&#123;FS=&quot;,&quot;; OFS=&quot;-&quot;&#125; &#123;print $1, $2, $3&#125;&#x27;</span> data2.txt</span><br><span class="line">data11-data12-data13</span><br><span class="line">data21-data22-data23</span><br><span class="line">data31-data32-data33</span><br></pre></td></tr></table></figure><ul><li>通过 <code>FIELDWIDTHS</code> 变量来匹配数据在记录中的位置</li></ul><p>在一些应用程序中，数据并没有使用字段分隔符，而是被放置在了记录中的特定列。这种情况下，必须设定 <code>FIELDWIDTHS</code> 变量来匹配数据在记录中的位置。一旦设置了 <code>FIELDWIDTH</code> 变量，gawk就会忽略 <code>FS</code> 变量，并根据提供的字段宽度来计算字段。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># data3.txt</span></span><br><span class="line">$ <span class="built_in">cat</span> data3.txt</span><br><span class="line">1005.3247596.37</span><br><span class="line">115-2.349194.00</span><br><span class="line">05810.1298100.1</span><br><span class="line"></span><br><span class="line">$ gawk <span class="string">&#x27;BEGIN&#123;FIELDWIDTHS=&quot;3 5 2 5&quot;&#125; &#123;print $1, $2, $3, $4&#125;&#x27;</span> data3.txt</span><br><span class="line">100 5.324 75 96.37</span><br><span class="line">115 -2.34 91 94.00</span><br><span class="line">058 10.12 98 100.1</span><br></pre></td></tr></table></figure><ul><li>通过 <code>RS</code> 指定输入记录分隔符</li></ul><p>gawk默认把换行符作为记录分隔符。当遇到记录跨行存储，不同记录以空白行分隔的文本，就需要通过 <code>RS</code> 指定记录分隔符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> data4.txt</span><br><span class="line">Riley Mullen</span><br><span class="line">123 Main Street</span><br><span class="line">Chicago, IL 60601</span><br><span class="line">(312)555-1234</span><br><span class="line"></span><br><span class="line">Frank Williams</span><br><span class="line">456 Oak Street</span><br><span class="line">Indianapolis, IN 46201</span><br><span class="line">(317)555-9876</span><br><span class="line"></span><br><span class="line">Haley Snell</span><br><span class="line">4231 Elm Street</span><br><span class="line">Detroit, MI 48201</span><br><span class="line">(313)555-4938</span><br><span class="line"></span><br><span class="line"><span class="comment"># FS：指定字段分隔符为\n</span></span><br><span class="line"><span class="comment"># RS：指定记录分隔符为空字符</span></span><br><span class="line">$ gawk <span class="string">&#x27;BEGIN&#123;FS=&quot;\n&quot;; RS=&quot;&quot;&#125; &#123;print $1, $4&#125;&#x27;</span> data4.txt</span><br><span class="line">Riley Mullen (312)555-1234</span><br><span class="line">Frank Williams (317)555-9876</span><br><span class="line">Haley Snell (313)555-4938</span><br></pre></td></tr></table></figure><h4 id="其他内建变量"><a href="#其他内建变量" class="headerlink" title="其他内建变量"></a>其他内建变量</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>ARGC</code></td><td>当前命令行参数个数</td></tr><tr><td><code>ARGIND</code></td><td>当前文件在<code>ARGV</code>中的位置</td></tr><tr><td><code>ARGV</code></td><td>包含命令行参数的数组</td></tr><tr><td><code>CONVFMT</code></td><td>数字的转换格式（参见<code>printf</code>语句），默认值为<code>%.6 g</code></td></tr><tr><td><code>ENVIRON</code></td><td>当前shell环境变量及其值组成的关联数组</td></tr><tr><td><code>ERRNO</code></td><td>当读取或关闭输入文件发生错误时的系统错误号</td></tr><tr><td><code>FILENAME</code></td><td>用作gawk输入数据的数据文件的文件名</td></tr><tr><td><code>IGNORECASE</code></td><td>设成非零值时，忽略gawk命令中出现的字符串的字符大小写</td></tr><tr><td><code>NF</code></td><td>数据文件中的字段总数</td></tr><tr><td><code>NR</code></td><td>已处理的输入记录数</td></tr><tr><td><code>FNR</code></td><td>当前数据文件中的数据行数</td></tr><tr><td><code>OFMT</code></td><td>数字的输出格式，默认值为<code>%.6 g</code></td></tr><tr><td><code>RLENGTH</code></td><td>由<code>match</code>函数所匹配的子字符串的长度</td></tr><tr><td><code>RSTART</code></td><td>由<code>match</code>函数所匹配的子字符串的起始位置</td></tr></tbody></table><ul><li><code>ARGC</code> 和 <code>ARGV</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gawk不把脚本程序当作命令行参数的一部分</span></span><br><span class="line">$ gawk <span class="string">&#x27;BEGIN&#123;print ARGC, ARGV[0], ARGV[1]&#125;&#x27;</span> data1.txt</span><br><span class="line">2 gawk data1.txt</span><br></pre></td></tr></table></figure><ul><li><code>ENVIRON</code></li></ul><p>可以通过 <code>ENVIRON</code> 来获取 shell 中任何环境变量的值，以供 gawk 程序使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ gawk <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&gt; BEGIN&#123;</span></span><br><span class="line"><span class="string">&gt; print ENVIRON[&quot;HOME&quot;]</span></span><br><span class="line"><span class="string">&gt; print ENVIRON[&quot;PATH&quot;]</span></span><br><span class="line"><span class="string">&gt; &#125;&#x27;</span></span><br><span class="line">/home/rich</span><br><span class="line">/usr/local/bin:/bin:/usr/bin:</span><br></pre></td></tr></table></figure><ul><li><code>NF</code></li></ul><p>当不知记录有多少个字段，<code>NF</code> 变量可以用来指定最后一个数据字段。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gawk <span class="string">&#x27;BEGIN&#123;FS=&quot;:&quot;; OFS=&quot;:&quot;&#125; &#123;print $1, $NF&#125;&#x27;</span> /etc/passwd</span><br><span class="line">nobody:/usr/bin/false</span><br><span class="line">root:/bin/sh</span><br><span class="line">daemon:/usr/bin/false</span><br></pre></td></tr></table></figure><ul><li><code>FNR</code> 和 <code>NR</code></li></ul><p><code>FNR</code> 变量的值在 gawk 处理第二个数据文件时被重置了，而 <code>NR</code> 变量则在处理第二个数据文件时继续计数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ gawk <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&gt; BEGIN &#123;FS=&quot;,&quot;&#125;</span></span><br><span class="line"><span class="string">&gt; &#123;print $1, &quot;FNR=&quot;FNR, &quot;NR=&quot;NR&#125;</span></span><br><span class="line"><span class="string">&gt; END &#123;print &quot;There were&quot;,NR,&quot;records processed&quot;&#125;&#x27;</span> data2.txt data2.txt</span><br><span class="line">data11 FNR=1 NR=1</span><br><span class="line">data21 FNR=2 NR=2</span><br><span class="line">data31 FNR=3 NR=3</span><br><span class="line">data11 FNR=1 NR=4</span><br><span class="line">data21 FNR=2 NR=5</span><br><span class="line">data31 FNR=3 NR=6</span><br><span class="line">There were 6 records processed</span><br></pre></td></tr></table></figure><h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gawk <span class="string">&#x27;BEGIN &#123;</span></span><br><span class="line"><span class="string">&gt; text=&quot;hello world&quot;</span></span><br><span class="line"><span class="string">&gt; print text</span></span><br><span class="line"><span class="string">&gt; &#125;&#x27;</span></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><ul><li>在命令行上给脚本中的变量赋值</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># script4.gawk</span></span><br><span class="line">$ <span class="built_in">cat</span> script4.gawk</span><br><span class="line">BEGIN &#123;FS=<span class="string">&quot;,&quot;</span>&#125;</span><br><span class="line">&#123;<span class="built_in">print</span> <span class="variable">$n</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在命令行设置n</span></span><br><span class="line">$ gawk -f script4.gawk n=2 data2.txt</span><br><span class="line">data12</span><br><span class="line">data22</span><br><span class="line">data32</span><br></pre></td></tr></table></figure><p>一般情况下 <code>BEGIN</code> 命令获取不到命令行设置的变量的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> script5.gawk</span><br><span class="line">BEGIN&#123;<span class="built_in">print</span> <span class="string">&quot;The&quot;</span>, n<span class="string">&quot;th field is&quot;</span>; FS=<span class="string">&quot;,&quot;</span>&#125;</span><br><span class="line">&#123;<span class="built_in">print</span> <span class="variable">$n</span>&#125;</span><br><span class="line"></span><br><span class="line">$ gawk -f script5.gawk n=2 data2.txt</span><br><span class="line">The th field is</span><br><span class="line">data12</span><br><span class="line">data22</span><br><span class="line">data32</span><br></pre></td></tr></table></figure><p>要解决这个问题，需要加上 <code>-v</code> 命令行参数，且 <code>-v n=2</code> 必须要放在 <code>-f</code> 参数前：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gawk -v n=2 -f script5.gawk data2.txt</span><br><span class="line">The 2th field is</span><br><span class="line">data12</span><br><span class="line">data22</span><br><span class="line">data32</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>gawk使用关联数组提供数组功能。关联数组跟普通数组不同之处在于它的索引值可以是任意文本字符串，类似于字典。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ gawk <span class="string">&#x27;BEGIN&#123;</span></span><br><span class="line"><span class="string">&gt; capital[&quot;China&quot;] = &quot;Beijing&quot;</span></span><br><span class="line"><span class="string">&gt; print capital[&quot;China&quot;]</span></span><br><span class="line"><span class="string">&gt; &#125;&#x27;</span></span><br><span class="line">Beijing</span><br><span class="line"></span><br><span class="line">$ gawk <span class="string">&#x27;BEGIN&#123;</span></span><br><span class="line"><span class="string">&gt; var[1] = 34</span></span><br><span class="line"><span class="string">&gt; var[2] = 3</span></span><br><span class="line"><span class="string">&gt; total = var[1] + var[2]</span></span><br><span class="line"><span class="string">&gt; print total</span></span><br><span class="line"><span class="string">&gt; &#125;&#x27;</span></span><br><span class="line">37</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历&amp;删除数组</span></span><br><span class="line">$ gawk <span class="string">&#x27;BEGIN&#123;</span></span><br><span class="line"><span class="string">&gt; var[&quot;a&quot;] = 1</span></span><br><span class="line"><span class="string">&gt; var[&quot;g&quot;] = 2</span></span><br><span class="line"><span class="string">&gt; for (test in var)</span></span><br><span class="line"><span class="string">&gt; &#123;</span></span><br><span class="line"><span class="string">&gt; print &quot;Index:&quot;,test,&quot;- Value:&quot;,var[test]</span></span><br><span class="line"><span class="string">&gt; &#125;</span></span><br><span class="line"><span class="string">&gt; delete var[&quot;g&quot;]</span></span><br><span class="line"><span class="string">&gt; print &quot;-----&quot;</span></span><br><span class="line"><span class="string">&gt; for (test in var)</span></span><br><span class="line"><span class="string">&gt; &#123;</span></span><br><span class="line"><span class="string">&gt; print &quot;Index:&quot;,test,&quot;- Value:&quot;,var[test]</span></span><br><span class="line"><span class="string">&gt; &#125;</span></span><br><span class="line"><span class="string">&gt; &#125;&#x27;</span></span><br><span class="line">Index: a - Value: 1</span><br><span class="line">Index: g - Value: 2</span><br><span class="line">-----</span><br><span class="line">Index: a - Value: 1</span><br></pre></td></tr></table></figure><h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> data1</span><br><span class="line">data11,data12,data13,data14,data15</span><br><span class="line">data21,data22,data23,data24,data25</span><br><span class="line">data31,data32,data33,data34,data35</span><br></pre></td></tr></table></figure><ul><li>正则表达式</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /11/匹配了数据字段中含有字符串11的记录</span></span><br><span class="line">$ gawk <span class="string">&#x27;BEGIN&#123;FS=&quot;,&quot;&#125; /11/&#123;print $0&#125;&#x27;</span> data1</span><br><span class="line">data11,data12,data13,data14,data15</span><br></pre></td></tr></table></figure><ul><li>匹配操作符</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $1 ~ /^data2/匹配第一个字段以data2开头的记录</span></span><br><span class="line">$ gawk <span class="string">&#x27;BEGIN&#123;FS=&quot;,&quot;&#125; $1 ~ /^data2/&#123;print $0&#125;&#x27;</span> data1</span><br><span class="line">data21,data22,data23,data24,data25</span><br><span class="line"></span><br><span class="line"><span class="comment"># $1 !~ /^data2/匹配第一个字段不以data2开头的记录</span></span><br><span class="line">$ gawk <span class="string">&#x27;BEGIN&#123;FS=&quot;,&quot;&#125; $1 !~ /^data2/&#123;print $0&#125;&#x27;</span> data1</span><br><span class="line">data11,data12,data13,data14,data15</span><br><span class="line">data31,data32,data33,data34,data35</span><br></pre></td></tr></table></figure><ul><li>数学表达式</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $1 == &quot;data11&quot;匹配第一个字段等于data11的记录</span></span><br><span class="line">$ gawk <span class="string">&#x27;BEGIN&#123;FS=&quot;,&quot;&#125; $1 == &quot;data11&quot;&#123;print $1&#125;&#x27;</span> data1</span><br><span class="line">data11,data12,data13,data14,data15</span><br></pre></td></tr></table></figure><h2 id="结构化"><a href="#结构化" class="headerlink" title="结构化"></a>结构化</h2><ul><li><code>if</code> 语句</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> data2</span><br><span class="line">10</span><br><span class="line">5</span><br><span class="line">13</span><br><span class="line">50</span><br><span class="line">34</span><br><span class="line"></span><br><span class="line">$ gawk <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">&gt; if ($1 &gt; 20) &#123;</span></span><br><span class="line"><span class="string">&gt; x = $1 / 2</span></span><br><span class="line"><span class="string">&gt; print x</span></span><br><span class="line"><span class="string">&gt; &#125; else &#123;</span></span><br><span class="line"><span class="string">&gt; x = $1 * 2</span></span><br><span class="line"><span class="string">&gt; print x</span></span><br><span class="line"><span class="string">&gt; &#125;</span></span><br><span class="line"><span class="string">&gt; &#125;&#x27;</span> data2</span><br><span class="line">20</span><br><span class="line">10</span><br><span class="line">26</span><br><span class="line">25</span><br><span class="line">17</span><br></pre></td></tr></table></figure><ul><li><code>while</code> 语句</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> data3</span><br><span class="line">130 120 135</span><br><span class="line">160 113 140</span><br><span class="line">145 170 215</span><br><span class="line"></span><br><span class="line">$ gawk <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">total = 0</span></span><br><span class="line"><span class="string">i = 1</span></span><br><span class="line"><span class="string">while (i &lt; 4) &#123;</span></span><br><span class="line"><span class="string">  total += $i</span></span><br><span class="line"><span class="string">  if (i == 2)</span></span><br><span class="line"><span class="string">    break</span></span><br><span class="line"><span class="string">  i++</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">avg = total / 2</span></span><br><span class="line"><span class="string">print &quot;Average:&quot;,avg</span></span><br><span class="line"><span class="string">&#125;&#x27;</span> data3</span><br><span class="line">Average: 125</span><br><span class="line">Average: 136.5</span><br><span class="line">Average: 157.5</span><br></pre></td></tr></table></figure><ul><li><code>do-while</code> 语句</li><li><code>for</code> 语句</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ gawk <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">&gt; total = 0</span></span><br><span class="line"><span class="string">&gt; i = 1</span></span><br><span class="line"><span class="string">&gt; for (i = 1; i &lt; 4; i++) &#123;</span></span><br><span class="line"><span class="string">&gt; total += $i</span></span><br><span class="line"><span class="string">&gt; &#125;</span></span><br><span class="line"><span class="string">&gt; avg = total / 3</span></span><br><span class="line"><span class="string">&gt; print &quot;Average:&quot;,avg</span></span><br><span class="line"><span class="string">&gt; &#125;&#x27;</span> data3</span><br><span class="line">Average: 128.333</span><br><span class="line">Average: 137.667</span><br><span class="line">Average: 176.667</span><br></pre></td></tr></table></figure><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p>gawk使用 <code>printf</code> 命令实现格式化，命令格式：<code>printf &quot;%[modifier]control-letter ...&quot;, var1, var2 ...</code></p><table><thead><tr><th>控制字母</th><th>说明</th></tr></thead><tbody><tr><td><code>c</code></td><td>将一个数作为ASCII字符显示</td></tr><tr><td><code>d</code></td><td>显示一个整数值</td></tr><tr><td><code>i</code></td><td>显示一个整数值（跟d一样）</td></tr><tr><td><code>e</code></td><td>用科学计数法显示一个数</td></tr><tr><td><code>f</code></td><td>显示一个浮点值</td></tr><tr><td><code>g</code></td><td>用科学计数法或浮点数显示（选择较短的格式）</td></tr><tr><td><code>o</code></td><td>显示一个八进制值</td></tr><tr><td><code>s</code></td><td>显示一个文本字符串</td></tr><tr><td><code>x</code></td><td>显示一个十六进制值</td></tr><tr><td><code>X</code></td><td>显示一个十六进制值，但用大写字母A~F</td></tr></tbody></table><p>除了控制字母外，还有3种修饰符可以用来进一步控制输出。</p><ul><li><p>width：指定了输出字段最小宽度的数字值。如果输出短于这个值，printf会将文本右对齐，并用空格进行填充。如果输出比指定的宽度还要长，则按照实际的长度输出。</p></li><li><p>prec：指定了浮点数中小数点后面位数，或者文本字符串中显示的最大字符数。</p></li><li><p>-（减号）：采用左对齐（默认右对齐）。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> data4</span><br><span class="line">Riley Mullen</span><br><span class="line">123 Main Street</span><br><span class="line">Chicago, IL 60601</span><br><span class="line">(312)555-1234</span><br><span class="line"></span><br><span class="line">Frank Williams</span><br><span class="line">456 Oak Street</span><br><span class="line">Indianapolis, IN 46201</span><br><span class="line">(317)555-9876</span><br><span class="line"></span><br><span class="line">Haley Snell</span><br><span class="line">4231 Elm Street</span><br><span class="line">Detroit, MI 48201</span><br><span class="line">(313)555-4938</span><br><span class="line"></span><br><span class="line">$ gawk <span class="string">&#x27;BEGIN&#123;FS=&quot;\n&quot;; RS=&quot;&quot;&#125; &#123;printf &quot;%-14s  %s\n&quot;, $1, $4&#125;&#x27;</span> data4</span><br><span class="line">Riley Mullen    (312)555-1234</span><br><span class="line">Frank Williams  (317)555-9876</span><br><span class="line">Haley Snell     (313)555-4938</span><br><span class="line"></span><br><span class="line">$ gawk <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">&gt; total = 0</span></span><br><span class="line"><span class="string">&gt; for (i = 1; i &lt; 4; i++) &#123;</span></span><br><span class="line"><span class="string">&gt; total += $i</span></span><br><span class="line"><span class="string">&gt; &#125;</span></span><br><span class="line"><span class="string">&gt; avg = total / 3</span></span><br><span class="line"><span class="string">&gt; printf &quot;Average: %5.1f\n&quot;,avg</span></span><br><span class="line"><span class="string">&gt; &#125;&#x27;</span> data3</span><br><span class="line">Average: 128.3</span><br><span class="line">Average: 137.7</span><br><span class="line">Average: 176.7</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim基础</title>
      <link href="/post/d16c64e7.html"/>
      <url>/post/d16c64e7.html</url>
      
        <content type="html"><![CDATA[<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h3 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>i</code></td><td>在光标前插入</td></tr><tr><td><code>a</code></td><td>在光标后插入</td></tr><tr><td><code>o</code></td><td>在当前行后插入一行</td></tr><tr><td><code>O</code></td><td>在当前行前插入一行</td></tr><tr><td><code>esc</code></td><td>返回Normal模式（退出编辑）</td></tr><tr><td><code>:q</code></td><td>退出</td></tr><tr><td><code>:q!</code></td><td>强制退出</td></tr><tr><td><code>:wq</code></td><td>保存并退出</td></tr><tr><td><code>hjkl</code></td><td>←↓↑→</td></tr><tr><td><code>u</code></td><td>撤销上一步操作</td></tr><tr><td><code>ctrl+r</code></td><td>重放上一步操作</td></tr><tr><td><code>:set number</code></td><td>设置行号</td></tr><tr><td><code>:set nonumber</code></td><td>取消行号</td></tr><tr><td><code>G</code></td><td>跳转到最后一行开头</td></tr><tr><td><code>gg</code></td><td>跳转到第一行开头</td></tr><tr><td><code>:n + enter</code></td><td>跳转到指定行</td></tr><tr><td><code>n + G</code></td><td>跳转到指定行</td></tr></tbody></table><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>0</code></td><td>移动光标到行头</td></tr><tr><td><code>$</code></td><td>移动光标到行尾</td></tr><tr><td><code>^</code></td><td>移动光标到第一个非空字符</td></tr><tr><td><code>g_</code></td><td>移动光标到最后一个非空字符</td></tr><tr><td><code>w</code></td><td>移动光标到下一个单词</td></tr><tr><td><code>W</code></td><td>移动光标到下一个单词，跳过标点符号</td></tr><tr><td><code>b</code></td><td>移动光标到单词开头</td></tr><tr><td><code>B</code></td><td>移动光标到单词开头，跳过标点符号</td></tr><tr><td><code>e</code></td><td>移动光标到单词结尾</td></tr><tr><td><code>E</code></td><td>移动光标到单词结尾，跳过标点符号</td></tr></tbody></table><h3 id="选择、剪切、拷贝"><a href="#选择、剪切、拷贝" class="headerlink" title="选择、剪切、拷贝"></a>选择、剪切、拷贝</h3><table><thead><tr><th>光标命令</th><th>删除命令</th><th>选择命令</th><th>剪切命令</th><th>拷贝命令</th></tr></thead><tbody><tr><td></td><td></td><td></td><td><code>dd</code></td><td><code>yy</code></td></tr><tr><td><code>0</code></td><td><code>c0</code></td><td><code>v0</code></td><td><code>d0</code></td><td><code>y0</code></td></tr><tr><td><code>$</code></td><td><code>c$</code></td><td><code>v$</code></td><td><code>d$</code></td><td><code>y$</code></td></tr><tr><td><code>w</code></td><td><code>cw</code></td><td><code>vw</code></td><td><code>dw</code></td><td><code>yw</code></td></tr><tr><td><code>W</code></td><td><code>cW</code></td><td><code>vW</code></td><td><code>dW</code></td><td><code>yW</code></td></tr><tr><td><code>b</code></td><td><code>cb</code></td><td><code>vb</code></td><td><code>de</code></td><td><code>ye</code></td></tr><tr><td><code>B</code></td><td><code>cB</code></td><td><code>vB</code></td><td><code>dE</code></td><td><code>yE</code></td></tr><tr><td><code>e</code></td><td><code>ce</code></td><td><code>ve</code></td><td><code>db</code></td><td><code>yb</code></td></tr><tr><td><code>E</code></td><td><code>cE</code></td><td><code>vE</code></td><td><code>dB</code></td><td><code>yB</code></td></tr><tr><td><code>G</code></td><td><code>cG</code></td><td><code>vG</code></td><td><code>dG</code></td><td><code>yG</code></td></tr><tr><td><code>gg</code></td><td><code>cgg</code></td><td><code>vgg</code></td><td><code>dgg</code></td><td><code>ygg</code></td></tr></tbody></table><h3 id="删除字符"><a href="#删除字符" class="headerlink" title="删除字符"></a>删除字符</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>x</code></td><td>删除当前字符</td></tr><tr><td><code>X</code></td><td>删除前一个字符</td></tr></tbody></table><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><table><thead><tr><th>命令</th><th>组合命令</th><th>说明</th></tr></thead><tbody><tr><td><code>p</code></td><td><code>x/X</code> + <code>p</code></td><td>小写p，将剪切版内容复制到当前光标的后面</td></tr><tr><td></td><td><code>d./y.</code> + <code>p</code></td><td>小写p，将剪切版内容复制到当前光标的下一行</td></tr><tr><td><code>P</code></td><td><code>x/X</code> + <code>P</code></td><td>大写P，将剪切版内容复制到当前光标的前面</td></tr><tr><td></td><td><code>d./y.</code> + <code>P</code></td><td>大写P，将剪切版内容复制到当前光标的上一行</td></tr></tbody></table><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>/keyword</code> + <code>enter</code></td><td>向下搜索</td></tr><tr><td><code>?keyword</code> + <code>enter</code></td><td>向上搜索</td></tr><tr><td><code>n</code></td><td>下一个匹配项</td></tr><tr><td><code>N</code></td><td>上一个匹配项</td></tr></tbody></table><h2 id="进阶命令"><a href="#进阶命令" class="headerlink" title="进阶命令"></a>进阶命令</h2><h3 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>.</code></td><td>重复上一次命令</td></tr><tr><td><code>n&lt;command&gt;</code></td><td>重复某个命令n次</td></tr></tbody></table><h3 id="光标移动-1"><a href="#光标移动-1" class="headerlink" title="光标移动"></a>光标移动</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>)</code></td><td>移动光标到下一个句子开头</td></tr><tr><td><code>(</code></td><td>移动光标到上一个句子开头</td></tr><tr><td><code>&#125;</code></td><td>移动光标到下一段落开头</td></tr><tr><td><code>&#123;</code></td><td>移动光标到上一段落开头</td></tr><tr><td><code>*</code></td><td>移动光标到下一个匹配单词</td></tr><tr><td><code>#</code></td><td>移动光标到上一个匹配单词</td></tr><tr><td><code>f&lt;char&gt;</code></td><td>移动光标到下一个<code>&lt;char&gt;</code></td></tr><tr><td><code>t&lt;char&gt;</code></td><td>移动光标到下一个<code>&lt;char&gt;</code>的前一个字符</td></tr></tbody></table><h3 id="搜索-1"><a href="#搜索-1" class="headerlink" title="搜索"></a>搜索</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>:set hlsearch</code></td><td>开启高亮显示</td></tr><tr><td><code>:nohlsearch</code></td><td>关闭高亮显示</td></tr><tr><td><code>/\&lt;keyword\&gt;</code></td><td>全词匹配搜索</td></tr><tr><td><code>:set noignorecae</code></td><td>大小写敏感（默认）</td></tr><tr><td><code>:set ignorecase</code></td><td>忽略大小写</td></tr><tr><td><code>/\d</code></td><td>搜索包含数字的行</td></tr><tr><td><code>/^keyword</code></td><td>搜索以<code>keyword</code>开头的行</td></tr></tbody></table><h3 id="搜索并替换"><a href="#搜索并替换" class="headerlink" title="搜索并替换"></a>搜索并替换</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>:%s/foo/bar/g</code></td><td>全文替换</td></tr><tr><td><code>:%s/foo/bar/gc</code></td><td>替换前确认</td></tr><tr><td><code>:%s/foo/bar/gi</code></td><td>忽略大小写</td></tr><tr><td><code>:10,20s/foo/bar/g</code></td><td>指定范围替换</td></tr><tr><td><code>:.,$s/foo/bar/g</code></td><td>从当前行到文件末尾替换</td></tr><tr><td><code>:%s/foo//g</code></td><td>删除匹配文本</td></tr></tbody></table><h3 id="大小写切换"><a href="#大小写切换" class="headerlink" title="大小写切换"></a>大小写切换</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>gu</code>+<code>l(→)</code></td><td>当前字符变小写</td></tr><tr><td><code>gu</code>+<code>enter</code></td><td>当前行变小写</td></tr><tr><td><code>gU</code>+<code>l(→)</code></td><td>当前字符变大写</td></tr><tr><td><code>gU</code>+<code>enter</code></td><td>当前行变大写</td></tr></tbody></table><h2 id="实用命令"><a href="#实用命令" class="headerlink" title="实用命令"></a>实用命令</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>:%</code></td><td>选中全文</td></tr><tr><td><code>:%d</code></td><td>删除全文</td></tr><tr><td><code>:%y</code></td><td>拷贝全文到寄存器</td></tr><tr><td><code>:%y+</code></td><td>拷贝全文到系统剪切板</td></tr><tr><td><code>ggVGy</code></td><td>拷贝全文到寄存器</td></tr><tr><td><code>dt&quot;</code></td><td>删除所有的内容，直到遇到双引号</td></tr><tr><td><code>y2/foo</code></td><td>拷贝两个 <code>foo</code> 之间的内容</td></tr></tbody></table><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础</title>
      <link href="/post/82734d8.html"/>
      <url>/post/82734d8.html</url>
      
        <content type="html"><![CDATA[<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>Linux文件系统目录结构通常如下：</p><img src="/post/82734d8/image-20240917223411860.png" class="" title="image-20240917223411860"><span id="more"></span><p>目录说明：</p><ul><li>&#x2F;bin：存放基本的用户命令文件，如ls、cp等</li><li>&#x2F;boot：存放启动系统所需文件</li><li>&#x2F;dev：设备文件</li><li><strong>&#x2F;etc：存放系统和应用程序的配置文件</strong></li><li>&#x2F;home：存放用户的主目录</li><li>&#x2F;lib：存放系统程序和内核所需的共享库文件</li><li>&#x2F;opt：存放可选的第三方软件包</li><li>&#x2F;proc：虚拟文件系统，提供关于内核和进程的信息</li><li>&#x2F;root：超级用户（root）的主目录</li><li>&#x2F;sbin：存放系统管理命令和工具</li><li>&#x2F;tmp：存放临时文件</li><li><strong>&#x2F;usr：存放应用程序和库，包括大多数系统工具和应用程序</strong></li><li>&#x2F;var：存放动态数据，如日志、缓存、邮件等</li><li><strong>&#x2F;usr&#x2F;local：存放通过源码安装的软件</strong></li></ul><h3 id="文件基本属性"><a href="#文件基本属性" class="headerlink" title="文件基本属性"></a>文件基本属性</h3><img src="/post/82734d8/image-20240916235314084.png" class="" title="image-20240916235314084"><ul><li>[d] 目录</li><li>[-] 文件</li><li>[l] 链接</li><li>[b] 存储设备</li><li>[c] 串行端口设备，如鼠标、键盘</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="文件和目录操作"><a href="#文件和目录操作" class="headerlink" title="文件和目录操作"></a>文件和目录操作</h3><h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a><code>cd</code></h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>cd -</code></td><td>返回上次所在的目录</td></tr></tbody></table><h4 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a><code>pwd</code></h4><p>打印当前工作目录</p><h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a><code>mkdir</code></h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>mkdir -P dir1/dir2/dir3</code></td><td>递归创建目录</td></tr></tbody></table><h4 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a><code>rmdir</code></h4><h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a><code>ls</code></h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>ls -al</code></td><td>显示所有文件（包括隐藏文件）的详细信息</td></tr><tr><td><code>ls -F1R</code></td><td>递归列出所有文件和目录，每行显示一个，并在文件名后附加一个指示符来标识文件类型</td></tr><tr><td><code>ls -tr</code></td><td>按修改时间正序显示</td></tr></tbody></table><h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a><code>cp</code></h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>cp -r dir1 dir2</code></td><td>递归复制（保留基本结构）</td></tr><tr><td><code>cp -a dir1 dir2</code></td><td>归档复制（保留元数据）</td></tr><tr><td><code>cp -u file1 file2</code></td><td>有更新才复制</td></tr></tbody></table><h4 id="mv"><a href="#mv" class="headerlink" title="mv"></a><code>mv</code></h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>mv -i</code></td><td>移动前提示用户确认</td></tr></tbody></table><h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a><code>rm</code></h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>rm -i</code></td><td>删除前提示用户确认</td></tr><tr><td><code>rm -rf</code></td><td>不提示，递归强制删除（高危命令）</td></tr></tbody></table><h4 id="touch"><a href="#touch" class="headerlink" title="touch"></a><code>touch</code></h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>touch file</code></td><td>创建空文件</td></tr><tr><td><code>touch existed_file</code></td><td>更新文件的修改时间</td></tr><tr><td><code>touch -a existed_file</code></td><td>更新文件的访问时间</td></tr></tbody></table><h4 id="ln"><a href="#ln" class="headerlink" title="ln"></a><code>ln</code></h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>ln file hard_link</code></td><td>创建硬链接</td></tr><tr><td><code>ln -s file soft_link</code></td><td>创建软链接</td></tr></tbody></table><h3 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h3><h4 id="find"><a href="#find" class="headerlink" title="find"></a><code>find</code></h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>find /path -name filename</code></td><td>搜索当前目录及其子目录</td></tr><tr><td><code>find /path -maxdepth 1 -name filename</code></td><td>仅搜索当前目录</td></tr><tr><td><code>find /path -mindepth 2 -name filename</code></td><td>从指定深度开始搜索</td></tr><tr><td><code>find /path -type f </code></td><td>搜索文件</td></tr><tr><td><code>find /path -iname filename</code></td><td>忽略大小写</td></tr></tbody></table><h4 id="locate"><a href="#locate" class="headerlink" title="locate"></a><code>locate</code></h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>locate -i filename</code></td><td>忽略大小写</td></tr><tr><td><code>locate -r pattern</code></td><td>正则匹配查找</td></tr></tbody></table><h4 id="which"><a href="#which" class="headerlink" title="which"></a><code>which</code></h4><p><code>which</code> 用于显示某个命令或程序的绝对路径。它会查找系统的 <code>$PATH</code> 环境变量中列出的目录，并返回第一个匹配的命令或程序的路径。</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>which python</code></td><td>显示一个二进制文件或可执行文件的完整路径</td></tr></tbody></table><h4 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a><code>whereis</code></h4><p><code>whereis</code> 是一个类似于 <code>which</code> 的命令，用于查找命令、二进制文件、源代码和手册页的所在位置。与 <code>which</code> 只查找 <code>$PATH</code> 环境变量中的可执行文件不同，<code>whereis</code> 会搜索系统中更多的路径，包括标准二进制文件路径、源代码目录和手册页目录。</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>whereis python </code></td><td>输出会包括多个路径，显示命令、源代码和手册页的路径</td></tr><tr><td><code>whereis -b python</code></td><td>查找 <code>python</code> 的二进制文件</td></tr><tr><td><code>whereis -m python</code></td><td>查找 <code>python</code> 的手册页</td></tr></tbody></table><h3 id="文件内容查看和编辑"><a href="#文件内容查看和编辑" class="headerlink" title="文件内容查看和编辑"></a>文件内容查看和编辑</h3><h4 id="wc"><a href="#wc" class="headerlink" title="wc"></a><code>wc</code></h4><p>统计文本，输出3个值：文本行数、文本词数、文本字节数</p><h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a><code>cat</code></h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>cat -n file</code></td><td>显示时添加行号</td></tr><tr><td><code>cat -b file</code></td><td>空行不添加行号</td></tr><tr><td><code>cat /dev/null &gt; file</code></td><td>清空文件</td></tr></tbody></table><h4 id="more"><a href="#more" class="headerlink" title="more"></a><code>more</code></h4><h4 id="less"><a href="#less" class="headerlink" title="less"></a><code>less</code></h4><h4 id="head"><a href="#head" class="headerlink" title="head"></a><code>head</code></h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>head -n 5 file</code> &#x2F; <code>head -5 file</code></td><td>显示开头5行</td></tr></tbody></table><h4 id="tail"><a href="#tail" class="headerlink" title="tail"></a><code>tail</code></h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>tail -n 5 file</code> &#x2F; <code>tail -5 file</code></td><td>显示最后5行</td></tr><tr><td><code>tail -f file</code></td><td>实时监控文件更新</td></tr></tbody></table><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a><code>sort</code></h4><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a><code>grep</code></h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>grep &quot;keyword&quot; file</code></td><td>查找包含 <code>keyword</code> 的行</td></tr><tr><td><code>grep -i &quot;keyword&quot; file</code></td><td>忽略大小写</td></tr><tr><td><code>grep -n &quot;keyword&quot; file</code></td><td>查找包含 <code>keyword</code> 的行并显示行号</td></tr><tr><td><code>grep &quot;^keyword&quot; file</code></td><td>查找以 <code>keyword</code> 开头的行</td></tr><tr><td><code>grep &quot;keyword$&quot; file</code></td><td>查找以 <code>keyword</code> 结尾的行</td></tr><tr><td><code>grep &quot;[0-9]&quot; file</code></td><td>查找包含数字的行</td></tr><tr><td><code>grep -E</code></td><td>支持更强大的扩展正则表达式</td></tr><tr><td><code>grep -r &quot;keyword&quot; .</code></td><td>在当前目录及其子目录查找</td></tr><tr><td><code>grep -A 10 &quot;keyword&quot; file</code></td><td>显示匹配行后面 <code>n</code> 行</td></tr><tr><td><code>grep -B 10 &quot;keyword&quot; file</code></td><td>显示匹配行前面 <code>n</code> 行</td></tr><tr><td><code>grep -C 10 &quot;keyword&quot; file</code></td><td>显示匹配行前后各 <code>n</code> 行</td></tr></tbody></table><h3 id="文件权限和所有权"><a href="#文件权限和所有权" class="headerlink" title="文件权限和所有权"></a>文件权限和所有权</h3><h4 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a><code>chmod</code></h4><h4 id="chown"><a href="#chown" class="headerlink" title="chown"></a><code>chown</code></h4><h4 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a><code>chgrp</code></h4><h3 id="系统监控和管理"><a href="#系统监控和管理" class="headerlink" title="系统监控和管理"></a>系统监控和管理</h3><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a><code>ps</code></h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>ps -aux</code></td><td><code>-a</code>：显示所有用户的进程</td></tr><tr><td></td><td><code>-u</code>：显示进程的详细信息，特别是进程所属的用户（USER），CPU 和内存占用情况（%CPU、%MEM）</td></tr><tr><td></td><td><code>-x</code>：包括后台进程</td></tr><tr><td><code>ps -ef</code></td><td><code>-e</code>：显示所有进程，等同于 <code>-A</code></td></tr><tr><td></td><td><code>-f</code>：以树状结构显示进程，显示进程的父子关系，并且包括更多的详细信息，如父进程 ID（PPID）、终端（TTY）等</td></tr></tbody></table><img src="/post/82734d8/image-20240917103223950.png" class="" title="image-20240917103223950"><img src="/post/82734d8/image-20240917103250778.png" class="" title="image-20240917103250778"><p>小结：</p><ul><li><p><code>ps -aux</code> 显示详细的进程信息（包括资源占用），没有父子进程关系。</p></li><li><p><code>ps -ef</code> 显示进程树，重点展示进程间的层次结构</p></li></ul><h4 id="top"><a href="#top" class="headerlink" title="top"></a><code>top</code></h4><p><code>top</code> 用于实时显示系统的资源使用情况，包括 CPU、内存、进程等信息。</p><h4 id="df"><a href="#df" class="headerlink" title="df"></a><code>df</code></h4><p><code>df</code> 用于显示文件系统磁盘空间使用情况，包括已用空间、可用空间和文件系统总容量等信息。</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>df -h</code></td><td>显示可读性更好的输出</td></tr></tbody></table><h4 id="du"><a href="#du" class="headerlink" title="du"></a><code>du</code></h4><p><code>du</code> 用于显示文件和目录的磁盘使用情况，可以帮助查看文件或目录占用的磁盘空间，以便有效地管理磁盘空间。</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>du -h /path</code></td><td>查看 <code>/path</code> 目录的磁盘使用情况</td></tr><tr><td><code>du -sh /path</code></td><td>显示目录的总磁盘使用情况</td></tr></tbody></table><h4 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a><code>uptime</code></h4><p>显示系统的运行时间和负载。</p><h3 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h3><h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a><code>ping</code></h4><p><code>ping</code> 是一个网络诊断工具，用于测试主机之间的网络连通性，以及通信的延迟情况。</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>ping -c 3 baidu.com</code></td><td>发送指定数量的请求</td></tr></tbody></table><h4 id="ifconfig-ip"><a href="#ifconfig-ip" class="headerlink" title="ifconfig/ip"></a><code>ifconfig/ip</code></h4><p><code>ifconfig</code>（Interface Configuration）用于配置和显示网络接口信息。在现代Linux系统中，<code>ifconfig</code> 逐渐被 <code>ip</code> 命令所取代，但仍然广泛使用。</p><h4 id="netstat-ss"><a href="#netstat-ss" class="headerlink" title="netstat/ss"></a><code>netstat/ss</code></h4><p><code>netstat</code>（network statistics）用于显示网络连接、路由表、接口统计、伪装连接和多播成员的信息。它提供了一个概述当前系统网络状态的方式，帮助用户了解哪些端口正在被使用、连接的状态以及网络接口的统计数据。</p><p>常用选项：</p><ul><li><code>-t</code>： 仅显示 TCP 连接</li><li><code>-u</code>： 仅显示 UDP 连接</li><li><code>-l</code>： 仅显示<strong>监听（LISTEN）</strong> 状态的套接字（即服务的端口）</li><li><code>-n</code>： 以数字形式显示地址和端口号（<strong>非常重要</strong>，避免耗时且可能失败的反向域名解析，让输出更清晰快速）</li><li><code>-p</code> (Linux): 显示进程ID和程序名称（需要sudo权限才能查看所有进程信息）</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>netstat -tuln</code></td><td>显示所有TCP和UDP的监听端口</td></tr></tbody></table><h4 id="curl"><a href="#curl" class="headerlink" title="curl"></a><code>curl</code></h4><p><strong>常用选项：</strong></p><ul><li><code>-o</code> (小写o)：将输出保存到指定文件（而非屏幕）</li><li><code>-O</code> (大写O)：使用远程文件的文件名保存到本地</li><li><code>-s</code> (Silent)：静默模式。不显示进度条和错误信息，只输出纯数据。常与其他选项组合用于脚本中。</li><li><code>-v</code> (Verbose)：详细模式。显示整个通信过程的详细信息，包括请求头和响应头，用于调试。</li><li><code>-X</code> &#x2F; <code>--request</code>：指定自定义的 HTTP 方法</li><li><code>-d</code> &#x2F; <code>--data</code>：发送 POST 请求的表单数据（默认 <code>Content-Type: application/x-www-form-urlencoded</code>）</li><li><code>-H</code> &#x2F; <code>--header</code>：自定义请求头。发送 JSON 数据或设置认证时必须。</li><li><code>-L</code> &#x2F; <code>--location</code>：自动跟随重定向。如果服务器返回 3xx 状态码，curl 会自动请求新的 URL。</li><li><code>-u</code> &#x2F; <code>--user</code>：提供用户名和密码进行基础认证 (Basic Auth)</li><li><code>-i</code> &#x2F; <code>--include</code>：在输出中包含 HTTP 响应头</li></ul><p><strong>常用场景和命令速查表</strong></p><table><thead><tr><th align="left">场景</th><th align="left">命令示例</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>下载文件</strong></td><td align="left"><code>curl -O http://example.com/file.zip</code></td><td align="left">保留原文件名下载</td></tr><tr><td align="left"><strong>测试API (GET)</strong></td><td align="left"><code>curl https://api.example.com/users</code></td><td align="left">最简单的 GET 请求</td></tr><tr><td align="left"><strong>测试API (POST JSON)</strong></td><td align="left"><code>curl -X POST -H &quot;Content-Type: application/json&quot; -d &#39;&#123;&quot;key&quot;:&quot;val&quot;&#125;&#39; https://api.example.com</code></td><td align="left"><strong>API 调试核心用法</strong></td></tr><tr><td align="left"><strong>提交表单&#x2F;登录</strong></td><td align="left"><code>curl -X POST -d &quot;user=alice&amp;pass=123&quot; https://login.com</code></td><td align="left">模拟表单提交</td></tr><tr><td align="left"><strong>文件上传</strong></td><td align="left"><code>curl -F &quot;file=@localfile.jpg&quot; https://upload.com</code></td><td align="left">模拟表单文件上传</td></tr><tr><td align="left"><strong>带认证的请求</strong></td><td align="left"><code>curl -u user:pass https://api.com</code></td><td align="left">Basic 认证</td></tr><tr><td align="left"><strong>查看响应头</strong></td><td align="left"><code>curl -I https://example.com</code></td><td align="left">检查状态码和头部信息</td></tr><tr><td align="left"><strong>自动跟随跳转</strong></td><td align="left"><code>curl -L http://example.com</code></td><td align="left">处理 301&#x2F;302 重定向</td></tr><tr><td align="left"><strong>静默下载</strong></td><td align="left"><code>curl -s -o file.txt https://example.com</code></td><td align="left">适合脚本中使用</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个非常常见的调试命令：静默模式、显示响应头、自动跳转、发送 JSON、带上认证</span></span><br><span class="line">$ curl -s -i -L -X POST \</span><br><span class="line">     -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">     -H <span class="string">&quot;Authorization: Bearer tok123&quot;</span> \</span><br><span class="line">     -d <span class="string">&#x27;&#123;&quot;param&quot;: &quot;value&quot;&#125;&#x27;</span> \</span><br><span class="line">     https://api.example.com/endpoint</span><br></pre></td></tr></table></figure><h4 id="wget"><a href="#wget" class="headerlink" title="wget"></a><code>wget</code></h4><p>常用场景和命令速查表</p><table><thead><tr><th align="left">场景</th><th align="left">命令示例</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>简单下载文件</strong></td><td align="left"><code>wget https://example.com/file.zip</code></td><td align="left">最基础的下载</td></tr><tr><td align="left"><strong>下载并重命名</strong></td><td align="left"><code>wget -O backup.zip https://ex.com/file.zip</code></td><td align="left">指定输出文件名</td></tr><tr><td align="left"><strong>断点续传</strong></td><td align="left"><code>wget -c https://ex.com/big.iso</code></td><td align="left"><strong>下载大文件必备</strong></td></tr><tr><td align="left"><strong>限速下载</strong></td><td align="left"><code>wget --limit-rate=1m https://ex.com/big.iso</code></td><td align="left">避免带宽占满</td></tr><tr><td align="left"><strong>后台下载</strong></td><td align="left"><code>wget -b https://ex.com/big.iso</code></td><td align="left">退出终端也不中断</td></tr><tr><td align="left"><strong>下载整个网站</strong></td><td align="left"><code>wget -r -l 5 -k -p -np https://ex.com/docs/</code></td><td align="left"><strong>镜像&#x2F;备份网站</strong></td></tr><tr><td align="left"><strong>只下载特定文件</strong></td><td align="left"><code>wget -r -A &quot;*.pdf&quot; https://ex.com/docs/</code></td><td align="left">只抓取PDF文件</td></tr><tr><td align="left"><strong>带认证的下载</strong></td><td align="left"><code>wget --user=me --password=pass https://ex.com/private</code></td><td align="left">访问需要登录的资源</td></tr></tbody></table><h3 id="压缩和解压缩"><a href="#压缩和解压缩" class="headerlink" title="压缩和解压缩"></a>压缩和解压缩</h3><h4 id="tar"><a href="#tar" class="headerlink" title="tar"></a><code>tar</code></h4><p>常用选项：</p><ul><li><p><code>-c</code>：创建一个新的归档文件。</p></li><li><p><code>-x</code>：解压归档文件。</p></li><li><p><code>-t</code>：查看归档文件的内容。</p></li><li><p><code>-v</code>：显示详细信息</p></li><li><p><code>-f</code>：指定归档文件名。</p></li><li><p><code>-z</code>：使用 gzip 压缩。</p></li><li><p><code>-C</code>：解压到指定目录。</p></li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>tar -czvf archive.tar file1 file2 dir1</code></td><td>创建压缩归档文件</td></tr><tr><td><code>tar -xzvf arvhive.tar</code></td><td>解压压缩归档文件</td></tr></tbody></table><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><h4 id="history"><a href="#history" class="headerlink" title="history"></a><code>history</code></h4><p>命令历史通常保存在 <code>~/.bash_history</code> 文件中。</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>history -5</code></td><td>显示最近5条命令</td></tr><tr><td><code>!10057</code></td><td>执行编号为10057的命令</td></tr><tr><td><code>!man</code></td><td>调出最近一条 <code>man</code> 命令</td></tr><tr><td><code>!!</code></td><td>调出最近一条命令</td></tr></tbody></table><p><code>history | grep man</code>：查找包含 <code>man</code> 的历史命令</p><h4 id="un-alias"><a href="#un-alias" class="headerlink" title="(un)alias"></a><code>(un)alias</code></h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>alias</code></td><td>查看所有别名</td></tr><tr><td><code>unalias ll</code></td><td>删除别名</td></tr><tr><td><code>alias ll=&#39;ls -l&#39;</code></td><td>设置别名</td></tr></tbody></table><p>在命令行通过 <code>alias</code> 设置的别名只在当前 shell 有效，要让别名永久生效，需要在配置文件中设置，用户的 shell 配置文件通常是<code>~/.bashrc</code> 或 <code>~/.bash_profile</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ vim ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在文件末尾添改行</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -l&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载配置文件使别名生效</span></span><br><span class="line">$ <span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h4 id="echo"><a href="#echo" class="headerlink" title="echo"></a><code>echo</code></h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>echo -n &gt; file</code></td><td>清空文件</td></tr><tr><td><code>echo $?</code></td><td>查看shell执行的最后一条命令的退出状态码</td></tr></tbody></table><h4 id="set"><a href="#set" class="headerlink" title="set"></a><code>set</code></h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>set</code></td><td>显示当前的完整环境变量列表</td></tr></tbody></table><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令</title>
      <link href="/post/e8c9512e.html"/>
      <url>/post/e8c9512e.html</url>
      
        <content type="html"><![CDATA[<p>Git 常用命令：<a href="https://git-scm.com/docs">Reference</a></p><span id="more"></span><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a><code>git add</code></h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>git add &lt;file&gt;...</code></td><td>跟踪&#x2F;暂存文件</td></tr></tbody></table><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a><code>git branch</code></h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>git branch dev</code></td><td>创建分支</td></tr><tr><td><code>git checkout dev</code></td><td>切换分支</td></tr><tr><td><code>git checkout -b dev</code></td><td>创建并切换分支</td></tr><tr><td><code>git checkout -b dev origin/dev</code></td><td>从远程分支创建分支</td></tr><tr><td><code>git checkout --track origin/dev</code></td><td>从远程分支创建分支</td></tr><tr><td><code>git branch -u origin/dev</code></td><td>设置本地分支跟踪远程分支</td></tr><tr><td><code>git branch -v</code></td><td>查看每一个分支的最后一次提交</td></tr><tr><td><code>git branch -vv</code></td><td>查看设置的所有跟踪分支</td></tr><tr><td><code>git branch --merged</code></td><td>查看已合并分支</td></tr><tr><td><code>git branch --no-merged</code></td><td>查看未合并分支</td></tr><tr><td><code>git branch -d dev</code></td><td>删除分支</td></tr><tr><td><code>git branch -D dev</code></td><td>强制删除分支</td></tr><tr><td><code>git push origin --delete dev</code></td><td>删除远程分支</td></tr><tr><td><code>git branch --unset-upstream 分值名</code></td><td>取消本地分支与远程分支的关联</td></tr></tbody></table><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a><code>git status</code></h3><p><code>git status</code>的作用是查看文件的状态，但该命令的输出较为繁琐，可以加上<code>-s</code>选项简化输出。</p><p><code>git status -s</code>的输出中有两栏表示状态，左侧是暂存区状态，右侧是工作区状态：</p><ul><li><code>[?][?]</code>：新文件，未跟踪</li><li><code>[A][ ] </code>：新文件，已跟踪</li><li><code> [ ][M]</code>：旧文件，已修改未暂存</li><li><code>[M][ ] </code>：旧文件，已修改已暂存</li><li><code>MM</code>：旧文件，修改并暂存后再次修改</li></ul><p>ps：真实输出中没有<code>[]</code></p><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a><code>git log</code></h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>git log -n</code></td><td>查看最近n次提交历史</td></tr><tr><td><code>git log -p</code></td><td>查看每次提交引入的差异</td></tr><tr><td><code>git log --stat</code></td><td>查看提交的简略统计信息</td></tr><tr><td><code>git log --graph</code></td><td>图形显示分支合并历史</td></tr><tr><td><code>git log --since=&quot;2020-10-10&quot; --until=&quot;2024-10-10&quot;</code></td><td>显示指定时间范围内的提交</td></tr><tr><td><code>git log --grep=&#39;commit&#39;</code></td><td>根据关键字搜索提交</td></tr><tr><td><code>git log --name-only</code></td><td>查看已修改的文件清单</td></tr><tr><td><code>git log --author=&#39;zhang3&#39;</code></td><td>查看指定用户的提交</td></tr><tr><td><code>git log --pretty=formt:&quot;%h - %an, %cd: %s&quot; --date=short</code></td><td>自定义输出格式</td></tr><tr><td><code>git log --oneline --decorate</code></td><td>查看当前各分支所指的提交对象</td></tr><tr><td><code>git log --oneline --decorate --graph</code></td><td>查看提交历史、各个分支的指向以及分支分叉情况</td></tr><tr><td><code>git log master..dev</code></td><td>查看在dev分支但不在master分支的提交</td></tr><tr><td><code>git log ^master dev test</code></td><td>查看在dev和test分支但不在master分支的提交</td></tr><tr><td><code>git log dev test --not master</code></td><td>查看在dev和test分支但不在master分支的提交</td></tr><tr><td><code>git log origin/master..HEAD</code></td><td>查看即将推送到远端的提交</td></tr><tr><td><code>git log master...dev</code></td><td>查看只在其中一个分支上的提交</td></tr></tbody></table><h3 id="git-show"><a href="#git-show" class="headerlink" title="git show"></a><code>git show</code></h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>git show HEAD^</code></td><td>查看<code>HEAD</code>的第1个父提交</td></tr><tr><td><code>git show HEAD~</code></td><td>查看<code>HEAD</code>的第1个父提交</td></tr><tr><td><code>git show HEAD^2</code></td><td>查看<code>HEAD</code>的第2个父提交</td></tr><tr><td><code>git show HEAD~2</code></td><td>查看<code>HEAD</code>的第1个父提交的父提交</td></tr><tr><td><code>git show HEAD^2~</code></td><td>查看<code>HEAD</code>的第2个父提交的父提交</td></tr></tbody></table><h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a><code>git merge</code></h3><p><code>fast-forward</code>：当前所在分支指向的提交是被合并分支所指向的提交的直接上游，合并操作只简单的将让当前分支指向被合并分支所指向的提交，这种合并就叫做 <code>fast-forward</code></p><h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a><code>git rebase</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git co dev</span><br><span class="line">git rebase master</span><br><span class="line">git co master</span><br><span class="line">git merge dev</span><br><span class="line"></span><br><span class="line">git rebase master dev（如果当前分支不是dev，此命令会切到dev分支）</span><br><span class="line">git co master</span><br><span class="line">git merge dev</span><br><span class="line"></span><br><span class="line">git rebase --onto master server client：选中在client分支但不在server分支的修改，将它们在master分支重放</span><br></pre></td></tr></table></figure><p>最佳实践：只把变基命令用于推送前整理提交历史，并且只在从未推送至公共仓的提交上执行变基命令。</p><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a><code>git reset</code></h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>git reset --soft HEAD~</code></td><td>回退到上一个提交，暂存区和工作目录不变</td></tr><tr><td><code>git reset [--mixed] HEAD~</code></td><td>默认模式，回退到上一个提交，取消暂存，保留工作目录的修改</td></tr><tr><td><code>git reset --hard HEAD~</code></td><td>回退到上一个提交，撤销工作目录的所有修改</td></tr></tbody></table><p><code>git reset</code> 会同时移动 <code>HEAD</code> 和分支的指向，<code>git checkout</code> 只移动 <code>HEAD</code></p><h3 id="git-restore"><a href="#git-restore" class="headerlink" title="git restore"></a><code>git restore</code></h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>git restore --staged &lt;file&gt;...</code></td><td>取消暂存</td></tr><tr><td><code>git restore &lt;file&gt;...</code></td><td>撤销修改</td></tr></tbody></table><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a><code>git diff</code></h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>git diff &lt;file&gt;...</code></td><td>查看已修改未暂存的改动</td></tr><tr><td><code>git diff --staged &lt;file&gt;...</code></td><td>查看已暂存未提交的改动</td></tr></tbody></table><h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a><code>git remote</code></h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>git remote -v</code></td><td>查看远程仓库</td></tr><tr><td><code>git remote add &lt;remote-name&gt; &lt;url&gt;</code></td><td>关联远程仓库</td></tr><tr><td><code>git remote rename &lt;remote-name&gt; &lt;another-name&gt;</code></td><td>重命名远程仓库名</td></tr><tr><td><code>git remote rm &lt;remote-name&gt;</code></td><td>删除关联</td></tr></tbody></table><h3 id="git-lfs"><a href="#git-lfs" class="headerlink" title="git lfs"></a><code>git lfs</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git lfs install (需确保本地git lfs已安装)</span><br><span class="line">git lfs track &#123;file_path&#125;  （直接track目录下所有文件）</span><br><span class="line">git add .</span><br><span class="line">git commit -m</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h3 id="git-help"><a href="#git-help" class="headerlink" title="git help"></a><code>git help</code></h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>git &lt;verb&gt; --help</code></td><td>查看帮助文档</td></tr><tr><td><code>git &lt;verb&gt; -h</code></td><td>查看快速参考</td></tr></tbody></table><h3 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a><code>git config</code></h3><p>根据作用范围，git有如下三种配置文件：</p><table><thead><tr><th>配置文件</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>/etc/gitconfig</code></td><td><code>git config --system</code></td><td>包含系统上所有用户的配置</td></tr><tr><td><code>~/.gitconfig</code></td><td><code>git config --global</code></td><td>只包含当前用户的配置</td></tr><tr><td><code>.git/config</code></td><td><code>git config --local</code></td><td>只包含当前仓库的配置</td></tr></tbody></table><p>和配置有关的常用命令：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>git config user.name</code></td><td>查看单个配置</td></tr><tr><td><code>git config --list </code></td><td>列出所有配置</td></tr><tr><td><code>git config --list --show-origin</code></td><td>列出所有配置及配置所在的文件</td></tr><tr><td><code>git config --global use.name &quot;zhang3&quot;</code></td><td>配置用户名</td></tr><tr><td><code>git config --global use.email &quot;xxx@xxx.com&quot;</code></td><td>配置邮箱</td></tr><tr><td><code>git config --global alias.co checkout</code></td><td>配置别名</td></tr></tbody></table><h2 id="几个命令的原理"><a href="#几个命令的原理" class="headerlink" title="几个命令的原理"></a>几个命令的原理</h2><h3 id="git-目录"><a href="#git-目录" class="headerlink" title=".git 目录"></a><code>.git</code> 目录</h3><p>准备一个空目录 <code>repo</code>，<code>cd</code> 到这个目录执行 <code>git init</code> 命令。当在一个目录执行 <code>git init</code> 命令时，Git 会创建一个 <code>.git</code> 目录，这个目录包含了几乎所有 Git 存储和操作的对象。该目录的结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -F1 .git <span class="comment"># -F1 标识文件类型并一行显示一个</span></span><br><span class="line">HEAD <span class="comment">#存储目前检出的分支的文件路径</span></span><br><span class="line">config</span><br><span class="line">description</span><br><span class="line">hooks/</span><br><span class="line">info/</span><br><span class="line">objects/ <span class="comment">#存储对象文件，包括blob对象、tree对象、commit对象</span></span><br><span class="line">refs/ <span class="comment">#refs/heads目录存储分支文件，文件内容是分支当前指向的提交的校验和</span></span><br></pre></td></tr></table></figure><p>最初，<code>.git/objects</code> 目录和 <code>.git/refs/heads</code> 目录都是空的，执行完相应命令后才会在这两个目录下生成文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ll .git/objects</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x  2 tw  staff    64B 12 29 18:49 info</span><br><span class="line">drwxr-xr-x  2 tw  staff    64B 12 29 18:49 pack</span><br><span class="line"></span><br><span class="line">$ ll .git/refs/heads</span><br><span class="line">total 0</span><br></pre></td></tr></table></figure><p><code>.git/HEAD</code> 存储当前分支的文件路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> .git/HEAD</span><br><span class="line">ref: refs/heads/main</span><br></pre></td></tr></table></figure><p>ps：当前 <code>.git/refs/heads</code> 目录下并没有 <code>main</code> 这个分支文件，这是因为仓库当前没有任何提交，只有产生提交才会生成这个文件。</p><h3 id="git-add-1"><a href="#git-add-1" class="headerlink" title="git add"></a><code>git add</code></h3><p>在 <code>repo</code> 目录中准备三个文件，<code>file1</code>、<code>file2</code>、<code>dir/file3</code>。</p><p>查看仓库的状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch main</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line"><span class="built_in">dir</span>/</span><br><span class="line">file1</span><br><span class="line">file2</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">&quot;git add&quot;</span> to track)</span><br></pre></td></tr></table></figure><p>跟踪文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add file1 file2 <span class="built_in">dir</span>/file3 <span class="comment"># 也可以使用 git add . 跟踪所有文件</span></span><br></pre></td></tr></table></figure><p>当执行 <code>git add</code> 命令时，Git 会为每一个文件生成长度为40位的校验和，并以校验和的前2位为目录名，后38位为文件名来存储文件快照，文件快照以 <code>blob</code> 对象存储，存储位置就是 <code>.git/objects</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -F1R .git/objects</span><br><span class="line">25/</span><br><span class="line">7d/</span><br><span class="line">b8/</span><br><span class="line"></span><br><span class="line">.git/objects/25:</span><br><span class="line">a8f74b822fb9b0efd64d7443c1c35f361bb7cc <span class="comment">#blob</span></span><br><span class="line"></span><br><span class="line">.git/objects/7d:</span><br><span class="line">2832ce3bae5b3b3f54731b4886947f977e2ac2 <span class="comment">#blob</span></span><br><span class="line"></span><br><span class="line">.git/objects/b8:</span><br><span class="line">914fa8629794ecb72cfc7fcdadbececeea0b4f <span class="comment">#blob</span></span><br></pre></td></tr></table></figure><img src="/post/e8c9512e/image-20241229115204753.png" class="" title="image-20241229115204753"><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a><code>git commit</code></h3><p>通过 <code>git add</code> 命令跟踪文件后再次查看仓库状态，此时文件已被暂存，等待提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch main</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">new file:   <span class="built_in">dir</span>/file3.txt</span><br><span class="line">new file:   file1.txt</span><br><span class="line">new file:   file2.txt</span><br></pre></td></tr></table></figure><p>提交文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">&#x27;the initial commit of repo&#x27;</span></span><br></pre></td></tr></table></figure><p>执行 <code>git commit</code> 命令，Git 会生成执行如下操作：</p><ul><li><p>为每一个有文件变更的目录生成一个 <code>tree</code> 对象</p></li><li><p>生成一个 <code>commit</code> 对象，保存根目录 <code>tree</code> 对象的校验和，如果有父提交，还会保存父提交对象的校验和</p></li><li><p>在 <code>.git/refs/heads</code> 目录中创建分支文件，文件内容就是当前分支最新提交的校验和</p></li></ul><p>与 <code>blob</code> 对象类似，Git 会为每一个 <code>tree</code> 对象和 <code>commit</code> 对象计算校验和，同样以校验和的前2位为目录名，后38位为文件名来存储这两种对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -F1R .git/objects</span><br><span class="line">25/</span><br><span class="line">54/</span><br><span class="line">7d/</span><br><span class="line">9f/</span><br><span class="line">b8/</span><br><span class="line"><span class="built_in">fc</span>/</span><br><span class="line"></span><br><span class="line">.git/objects/25:</span><br><span class="line">a8f74b822fb9b0efd64d7443c1c35f361bb7cc <span class="comment">#blob</span></span><br><span class="line"></span><br><span class="line">.git/objects/54:</span><br><span class="line">8f32fb2ee149dee0637bea72ef60963eca6b51 <span class="comment">#commit</span></span><br><span class="line"></span><br><span class="line">.git/objects/7d:</span><br><span class="line">2832ce3bae5b3b3f54731b4886947f977e2ac2 <span class="comment">#blob</span></span><br><span class="line"></span><br><span class="line">.git/objects/9f:</span><br><span class="line">a6bc0f50083bf5f7ec4bc14c4ea6f48cfe35eb <span class="comment">#tree</span></span><br><span class="line"></span><br><span class="line">.git/objects/b8:</span><br><span class="line">914fa8629794ecb72cfc7fcdadbececeea0b4f <span class="comment">#blob</span></span><br><span class="line"></span><br><span class="line">.git/objects/fc:</span><br><span class="line">41d977852fce6e0c8cce1632884b7efaca4a98 <span class="comment">#tree</span></span><br></pre></td></tr></table></figure><img src="/post/e8c9512e/image-20241229120752341.png" class="" title="image-20241229120752341"><p>因为有了提交，此时 <code>.git/refs/heads</code> 目录中就会生成 <code>main</code> 分支文件，文件存储当前分支的最新提交</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ll .git/refs/heads</span><br><span class="line">total 8</span><br><span class="line">-rw-r--r--  1 tw  staff    41B 12 29 19:13 main</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> .git/refs/heads/main</span><br><span class="line">548f32fb2ee149dee0637bea72ef60963eca6b51</span><br></pre></td></tr></table></figure><p>修改 <code>file1</code> 和 <code>dir/file3</code>，并使用 <code>git add</code> 命令暂存文件，Git 会为 <code>file1</code> 和 <code>dir/file3</code> 重新计算校验和，也就是说 <code>.git/objects</code> 目录会新生成两个 <code>blob</code> 对象</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ ll .git/objects</span><br><span class="line">drwxr-xr-x  3 tw  staff    96B 12 29 11:14 25</span><br><span class="line">drwxr-xr-x  3 tw  staff    96B 12 29 11:25 54</span><br><span class="line">drwxr-xr-x  3 tw  staff    96B 12 29 11:14 7d</span><br><span class="line">drwxr-xr-x  3 tw  staff    96B 12 29 11:25 9f</span><br><span class="line">drwxr-xr-x  3 tw  staff    96B 12 29 11:14 b8</span><br><span class="line">drwxr-xr-x  3 tw  staff    96B 12 29 11:25 <span class="built_in">fc</span></span><br><span class="line"></span><br><span class="line">$ git add file1 <span class="built_in">dir</span>/file3</span><br><span class="line"></span><br><span class="line">$ ll .git/objects</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x  3 tw  staff    96B 12 29 11:14 25</span><br><span class="line">drwxr-xr-x  3 tw  staff    96B 12 29 11:25 54</span><br><span class="line">drwxr-xr-x  3 tw  staff    96B 12 29 11:14 7d</span><br><span class="line">drwxr-xr-x  3 tw  staff    96B 12 29 11:25 9f</span><br><span class="line">drwxr-xr-x  3 tw  staff    96B 12 29 11:14 b8</span><br><span class="line">drwxr-xr-x  3 tw  staff    96B 12 29 12:22 c0 <span class="comment">#new blob</span></span><br><span class="line">drwxr-xr-x  3 tw  staff    96B 12 29 12:22 c9 <span class="comment">#new blob</span></span><br><span class="line">drwxr-xr-x  3 tw  staff    96B 12 29 11:25 <span class="built_in">fc</span></span><br></pre></td></tr></table></figure><p>使用 <code>git commit</code> 命令提交，因为 <code>dir</code> 和仓库根目录下都有文件变更，因此会新生成两个 <code>tree</code> 对象，其中一个 <code>tree</code> 对象的校验和的前两位和之前的对象重了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ ll .git/objects</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x  4 tw  staff   128B 12 29 12:26 25 </span><br><span class="line">drwxr-xr-x  3 tw  staff    96B 12 29 12:26 47 <span class="comment">#new tree</span></span><br><span class="line">drwxr-xr-x  3 tw  staff    96B 12 29 11:25 54</span><br><span class="line">drwxr-xr-x  3 tw  staff    96B 12 29 11:14 7d</span><br><span class="line">drwxr-xr-x  3 tw  staff    96B 12 29 12:26 81 <span class="comment">#new commit</span></span><br><span class="line">drwxr-xr-x  3 tw  staff    96B 12 29 11:25 9f</span><br><span class="line">drwxr-xr-x  3 tw  staff    96B 12 29 11:14 b8</span><br><span class="line">drwxr-xr-x  3 tw  staff    96B 12 29 12:22 c0</span><br><span class="line">drwxr-xr-x  3 tw  staff    96B 12 29 12:22 c9</span><br><span class="line">drwxr-xr-x  3 tw  staff    96B 12 29 11:25 <span class="built_in">fc</span></span><br><span class="line"></span><br><span class="line">$ ll .git/objects/25</span><br><span class="line">total 16</span><br><span class="line">-r--r--r--  1 tw  staff    33B 12 29 11:14 a8f74b822fb9b0efd64d7443c1c35f361bb7cc</span><br><span class="line">-r--r--r--  1 tw  staff    50B 12 29 12:26 b034b431c310c762aa9d7272ac847bf8b32dfa <span class="comment">#new tree</span></span><br></pre></td></tr></table></figure><img src="/post/e8c9512e/image-20241229124958332.png" class="" title="image-20241229124958332"><p>ps：要查看 <code>.git/objects</code> 目录下这些文件的内容，可以用以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看对象类型</span></span><br><span class="line">$ git cat-file -t &lt;object-hash&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看对象内容</span></span><br><span class="line">$ git cat-file -p &lt;object-hash&gt;</span><br></pre></td></tr></table></figure><h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a><code>git checkout</code></h3><p>Git 分支，本质上就是指向提交对象的可变指针。在 <code>.git/refs/heads</code> 目录下，每个分支都有一个对应文件，存储着当前分支所指向的最新提交的校验和。</p><p>创建分支，就是新建一个分支文件，写入提交对象的校验和；删除分支，就是删除对应的分支文件。因此 Git 分支的创建和销毁都非常高效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* main</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> .git/HEAD</span><br><span class="line">ref: refs/heads/main</span><br><span class="line"></span><br><span class="line">$ ll .git/refs/heads</span><br><span class="line">total 8</span><br><span class="line">-rw-r--r--  1 tw  staff    41B 12 29 12:26 main</span><br></pre></td></tr></table></figure><p>通过以上几个命令可以看出，当前只有一个分支 <code>main</code>，并且当前检出分支就是 <code>main</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> .git/HEAD</span><br><span class="line">ref: refs/heads/main</span><br><span class="line"></span><br><span class="line">$ ll .git/refs/heads</span><br><span class="line">total 24</span><br><span class="line">-rw-r--r--  1 tw  staff    41B 12 29 20:07 dev</span><br><span class="line">-rw-r--r--  1 tw  staff    41B 12 29 12:26 main</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> .git/refs/heads/dev</span><br><span class="line">81306fe754dae188929a1e98c3a894a5641a3728</span><br></pre></td></tr></table></figure><p>使用 <code>git branch</code> 创建新的分支后，可以看出，当前检出分支依然是 <code>main</code>，但 <code>.git/refs/heads</code> 目录下多一个 <code>dev</code> 分支文件，分支内容是 <code>main</code> 分支最新提交的校验和。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> .git/HEAD</span><br><span class="line">ref: refs/heads/dev</span><br></pre></td></tr></table></figure><p>使用 <code>git checkout</code> 命令检出到 <code>dev</code> 分支后，可以看到 <code>HEAD</code> 文件现在保存的是 <code>dev</code> 分支的文件路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout main</span><br><span class="line"></span><br><span class="line">$ git branch -d dev</span><br><span class="line"></span><br><span class="line">$ ll .git/refs/heads</span><br><span class="line">total 8</span><br><span class="line">-rw-r--r--  1 tw  staff    41B 12 29 12:26 main</span><br></pre></td></tr></table></figure><p>使用 <code>git branch -d</code> 删除分支后，Git 会删除 <code>.git/refs/heads</code> 目录下对应的分支文件。</p><h3 id="git-merge-1"><a href="#git-merge-1" class="headerlink" title="git merge"></a><code>git merge</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b iss37</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;file2: version 2&quot;</span> &gt; file2</span><br><span class="line"></span><br><span class="line">$ git add file2</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&#x27;iss37: made a achange to file2&#x27;</span></span><br><span class="line"></span><br><span class="line">$ git checkout main</span><br><span class="line"></span><br><span class="line">$ git checkout -b hotfix</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;file1: version 3&quot;</span> &gt; file1</span><br><span class="line"></span><br><span class="line">$ git add file1</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&#x27;hotfix: made a change to file1&#x27;</span></span><br><span class="line"></span><br><span class="line">$ git checkout main</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> --oneline --decorate --graph --all</span><br><span class="line">* 9ba0744 (hotfix) hotfix: made a change to file1</span><br><span class="line">| * d222cd6 (iss37) iss37: made a achange to file2</span><br><span class="line">|/</span><br><span class="line">* 81306fe (HEAD -&gt; main) made changes to file1 and file3</span><br><span class="line">* 548f32f the initial commit of repo</span><br></pre></td></tr></table></figure><p>依次执行如上命令后，当前检出分支，以及各个分支的指向如下如所示：</p><img src="/post/e8c9512e/image-20241229221518223.png" class="" title="image-20241229221518223"><p>将 <code>hotfix</code> 分支合入 <code>main</code> 分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git merge hotfix</span><br><span class="line">Updating 81306fe..9ba0744</span><br><span class="line">Fast-forward</span><br><span class="line"> file1 | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line"> </span><br><span class="line">$ git <span class="built_in">log</span> --oneline --decorate --graph --all</span><br><span class="line">* 9ba0744 (HEAD -&gt; main, hotfix) hotfix: made a change to file1</span><br><span class="line">| * d222cd6 (iss37) iss37: made a achange to file2</span><br><span class="line">|/</span><br><span class="line">* 81306fe made changes to file1 and file3</span><br><span class="line">* 548f32f the initial commit of repo</span><br></pre></td></tr></table></figure><img src="/post/e8c9512e/image-20241229222153973.png" class="" title="image-20241229222153973"><p>注意上述的 <code>Fast-forward</code> ： <code>main</code> 分支指向的提交是 <code>hotfix</code> 分支指向的提交的直接上游，<code>git merge</code> 只是简单的让 <code>main</code> 分支指向 <code>hotfix</code> 分支所指向的提交，这种合并就叫做 <code>fast-forward</code>。</p><p>与之相对应的，合并完 <code>hotfix</code> 分支后，<code>main</code> 分支当前指向的提交不是 <code>iss37</code> 指向的提交的直接上游，此时如果要合并 <code>iss37</code> 分支，就无法通过 <code>Fast-forward</code> 方式简单地改变 <code>main</code> 分支的指向来完成了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout main</span><br><span class="line"></span><br><span class="line">$ git merge iss37</span><br><span class="line">Merge made by the <span class="string">&#x27;ort&#x27;</span> strategy.</span><br><span class="line"> file2 | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line"> </span><br><span class="line">$ git <span class="built_in">log</span> --oneline --decorate --graph --all</span><br><span class="line">*   6d58973 (HEAD -&gt; main) Merge branch <span class="string">&#x27;iss37&#x27;</span></span><br><span class="line">|\</span><br><span class="line">| * d222cd6 (iss37) iss37: made a achange to file2</span><br><span class="line">* | 9ba0744 (hotfix) hotfix: made a change to file1</span><br><span class="line">|/</span><br><span class="line">* 81306fe made changes to file1 and file3</span><br><span class="line">* 548f32f the initial commit of repo</span><br></pre></td></tr></table></figure><img src="/post/e8c9512e/image-20241229224617129.png" class="" title="image-20241229224617129"><p>可以看到，合并 <code>iss37</code> 分支会生成一个新的提交，新的提交有两个父提交。</p><h3 id="git-rebase-1"><a href="#git-rebase-1" class="headerlink" title="git rebase"></a><code>git rebase</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b feature_a</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;file_a: version 1&quot;</span> &gt; file_a</span><br><span class="line"></span><br><span class="line">$ git add file_a</span><br><span class="line"></span><br><span class="line">$ git cm <span class="string">&#x27;feature_a: add a new file&#x27;</span></span><br><span class="line"></span><br><span class="line">$ git checkout main</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;file2: version 3&quot;</span> &gt; file2</span><br><span class="line"></span><br><span class="line">$ git add file2</span><br><span class="line"></span><br><span class="line">$ git cm <span class="string">&#x27;main: made a change to file2&#x27;</span></span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> --oneline --decorate --graph --all</span><br><span class="line">* 594eabd (HEAD -&gt; main) main: made a change to file2</span><br><span class="line">| * 05cfcab (feature_a) feature_a: add a new file</span><br><span class="line">|/</span><br><span class="line">*   6d58973 Merge branch <span class="string">&#x27;iss37&#x27;</span></span><br><span class="line">|\</span><br><span class="line">| * d222cd6 (iss37) iss37: made a achange to file2</span><br><span class="line">* | 9ba0744 (hotfix) hotfix: made a change to file1</span><br><span class="line">|/</span><br><span class="line">* 81306fe made changes to file1 and file3</span><br><span class="line">* 548f32f the initial commit of repo</span><br></pre></td></tr></table></figure><img src="/post/e8c9512e/image-20241229225433535.png" class="" title="image-20241229225433535"><p>通过 <code>git rebase</code> 合并 <code>feature_a</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase main feature_a</span><br><span class="line">Successfully rebased and updated refs/heads/feature_a.</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> --oneline --decorate --graph --all</span><br><span class="line">* ac7d58d (HEAD -&gt; feature_a) feature_a: add a new file</span><br><span class="line">* 594eabd (main) main: made a change to file2</span><br><span class="line">*   6d58973 Merge branch <span class="string">&#x27;iss37&#x27;</span></span><br><span class="line">|\</span><br><span class="line">| * d222cd6 (iss37) iss37: made a achange to file2</span><br><span class="line">* | 9ba0744 (hotfix) hotfix: made a change to file1</span><br><span class="line">|/</span><br><span class="line">* 81306fe made changes to file1 and file3</span><br><span class="line">* 548f32f the initial commit of repo</span><br></pre></td></tr></table></figure><img src="/post/e8c9512e/image-20241229225758134.png" class="" title="image-20241229225758134"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout main</span><br><span class="line"></span><br><span class="line">$ git merge feature_a</span><br><span class="line">Updating 594eabd..ac7d58d</span><br><span class="line">Fast-forward</span><br><span class="line"> file_a | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 file_a</span><br><span class="line"> </span><br><span class="line">$ git <span class="built_in">log</span> --oneline --decorate --graph --all</span><br><span class="line">* ac7d58d (HEAD -&gt; main, feature_a) feature_a: add a new file</span><br><span class="line">* 594eabd main: made a change to file2</span><br><span class="line">*   6d58973 Merge branch <span class="string">&#x27;iss37&#x27;</span></span><br><span class="line">|\</span><br><span class="line">| * d222cd6 (iss37) iss37: made a achange to file2</span><br><span class="line">* | 9ba0744 (hotfix) hotfix: made a change to file1</span><br><span class="line">|/</span><br><span class="line">* 81306fe made changes to file1 and file3</span><br><span class="line">* 548f32f the initial commit of repo</span><br></pre></td></tr></table></figure><img src="/post/e8c9512e/image-20241229230127060.png" class="" title="image-20241229230127060"><p>从结果上来看，就好将 <code>feature_a</code> 分支上的提交在 <code>main</code> 分支上重放了一遍，然后通过 <code>Fast-forward</code> 方式进行快速合并。</p><p><strong>总结</strong>：<code>git rebase</code> 整理了提交历史，使提交历史更加线性，但是丢失了原本的提交记录。假设某个分支已经推送到远程仓库，并且有其他人已经拉取了该分支，并在该分支上提交了变更，如果对这种分支的提交记录执行 <code>git rebase</code>，会使用情况变更的复杂。因此最佳实践就是，只把 <code>git rebase</code> 命令用于推送前整理提交历史，并且只在从未推送至公共仓的提交上执行变基命令。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA常用快捷键</title>
      <link href="/post/566321e7.html"/>
      <url>/post/566321e7.html</url>
      
        <content type="html"><![CDATA[<h2 id="通用操作"><a href="#通用操作" class="headerlink" title="通用操作"></a>通用操作</h2><table><thead><tr><th>操作</th><th>Windows</th><th>Mac</th></tr></thead><tbody><tr><td>重命名</td><td>Shift+F6</td><td>⇧+Fn+F6</td></tr><tr><td>跳转到某行</td><td>Ctrl+G</td><td>⌘+L</td></tr><tr><td>新建</td><td></td><td>⌘+N</td></tr><tr><td>全局搜索&#x2F;替换</td><td>Ctrl+Shift+F&#x2F;R</td><td>⇧+⌘+F&#x2F;R</td></tr><tr><td>格式化</td><td>Ctrl+Alt+L</td><td>⌘+⌥+L</td></tr><tr><td>import优化</td><td>Ctrl+Alt+O</td><td>⌃+⌥+O</td></tr><tr><td>复制行</td><td>Ctrl+D</td><td>⌘+D</td></tr></tbody></table><span id="more"></span><h2 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h2><table><thead><tr><th>操作</th><th>Windows</th><th>Mac</th></tr></thead><tbody><tr><td>移动光标到代码块开始位置</td><td>Ctrl+[</td><td>⌘+⌥+[</td></tr><tr><td>移动光标到代码块结束位置</td><td>Ctrl+]</td><td>⌘+⌥+]</td></tr><tr><td>移动光标到当前行的开始位置</td><td>Home</td><td>⌘+←</td></tr><tr><td>移动光标到当前行的结束位置</td><td>End</td><td>⌘+→</td></tr><tr><td>移动光标到上一个单词</td><td>Ctrl+←</td><td>⌥+←</td></tr><tr><td>移动光标到下一个单词</td><td>Ctrl+→</td><td>⌥+→</td></tr></tbody></table><h2 id="代码块操作"><a href="#代码块操作" class="headerlink" title="代码块操作"></a>代码块操作</h2><table><thead><tr><th>操作</th><th>Windows</th><th>Mac</th></tr></thead><tbody><tr><td>块注释</td><td>Ctrl+Shift+&#x2F;</td><td>⌘+⇧+&#x2F;</td></tr><tr><td>展开&#x2F;折叠代码块</td><td>Ctrl+加号&#x2F;减号</td><td>⌘+加号&#x2F;减号</td></tr><tr><td>展开&#x2F;折叠全部代码块</td><td>Ctrl+Shift+加号&#x2F;减号</td><td>⌘+⇧+加号&#x2F;减号</td></tr></tbody></table><h2 id="代码编辑"><a href="#代码编辑" class="headerlink" title="代码编辑"></a>代码编辑</h2><table><thead><tr><th>操作</th><th>Windows</th><th>Mac</th></tr></thead><tbody><tr><td>字面量切换大小写</td><td>Ctrl+Shift+U</td><td>⌘+⇧+U</td></tr><tr><td>删除光标后面的单词</td><td>Ctrl+Delete</td><td>⌥+Fn+⌫</td></tr><tr><td>删除光标前面的单词</td><td>Ctrl+BackSpace</td><td>⌥+⌦</td></tr><tr><td>包围代码</td><td>Ctrl+Alt+T</td><td>⌘+⌥+T</td></tr><tr><td>生成代码</td><td>Alt+Insert</td><td>⌃+Enter</td></tr><tr><td>覆盖方法</td><td>Ctrl+O</td><td>⌘+O</td></tr><tr><td>实现方法</td><td>Ctrl+I</td><td>⌘+I</td></tr><tr><td>更改签名</td><td>Ctrl+F6</td><td>⌘+Fn+F6</td></tr><tr><td>提取方法</td><td>Ctrl+Alt+M</td><td>⌘+⌥+M</td></tr><tr><td>提取变量</td><td>Ctrl+Alt+V</td><td>⌘+⌥+V</td></tr><tr><td>提取字段</td><td>Ctrl+Alt+F</td><td>⌘+⌥+F</td></tr><tr><td>提取参数</td><td>Ctrl+Alt+P</td><td>⌘+⌥+P</td></tr><tr><td>向上插入一行</td><td>Ctrl+Alt+Enter</td><td>⌘+Enter</td></tr><tr><td>向下插入一行</td><td>Shift+Enter</td><td>⇧+Enter</td></tr></tbody></table><h2 id="类和方法"><a href="#类和方法" class="headerlink" title="类和方法"></a>类和方法</h2><table><thead><tr><th>操作</th><th>Windows</th><th>Mac</th></tr></thead><tbody><tr><td>弹窗显示当前类结构</td><td>Ctrl+F12</td><td>⌘+Fn+F12</td></tr><tr><td>查看继承树结构</td><td>Ctrl+H</td><td>⌃+H</td></tr><tr><td>类的UML关系图</td><td>Ctrl+Alt+U</td><td>⌥+⌘+U</td></tr><tr><td>弹窗显示或跳转到父类（接口）</td><td>Ctrl+U</td><td>⌘+U</td></tr><tr><td>弹窗显示或跳转到子类</td><td>Ctrl+Alt+B</td><td>⌥+⌘+B</td></tr><tr><td>跳转到选择目标的定义处或使用处</td><td>Ctrl+B</td><td>⌘+B</td></tr><tr><td>查看方法调用链</td><td>Ctrl+Alt+H</td><td>⌃+⌘+H</td></tr><tr><td>形参提示</td><td>Ctrl+P</td><td>⌘+P</td></tr><tr><td>查看文档</td><td>Ctrl+Q</td><td>⌃+J</td></tr></tbody></table><h2 id="代码调试"><a href="#代码调试" class="headerlink" title="代码调试"></a>代码调试</h2><table><thead><tr><th>操作</th><th><strong>Windows</strong></th><th><strong>Mac</strong></th></tr></thead><tbody><tr><td>Run启动</td><td>Shift+F10</td><td>⌃+R</td></tr><tr><td>Debug启动</td><td>Shift+F9</td><td>⌃+D</td></tr><tr><td>停止</td><td>Ctrl+F2</td><td>⌘+Fn+F2</td></tr><tr><td>下一步（Step Over）</td><td>F8</td><td>Fn+F8</td></tr><tr><td>下一步（Step In）</td><td>F7</td><td>Fn+F7</td></tr><tr><td>选择进入哪个方法</td><td>Shift+F7</td><td>⇧+Fn+F7</td></tr><tr><td>跳出（Step Out）</td><td>Shift+F8</td><td>⇧+Fn+F8</td></tr><tr><td>恢复运行</td><td>F9</td><td>⌥+⌘+R</td></tr><tr><td>运行到光标处</td><td>Alt+F9</td><td>⌥+Fn+F9</td></tr><tr><td>加上&#x2F;取消断点</td><td>Ctrl+F8</td><td>⌘+Fn+F8</td></tr><tr><td>查看所有断点</td><td>Ctrl+Shift+F8</td><td>⌘+⇧+Fn+F8</td></tr><tr><td>计算表达式</td><td>Alt+F8</td><td>⌥+Fn+F8</td></tr></tbody></table><h2 id="Git操作"><a href="#Git操作" class="headerlink" title="Git操作"></a>Git操作</h2><table><thead><tr><th>操作</th><th>Windows</th><th>Mac</th></tr></thead><tbody><tr><td>提交代码</td><td>Ctrl+K</td><td>⌘+K</td></tr><tr><td>推送代码</td><td>Ctrl+Shift+K</td><td>⇧+⌘+K</td></tr><tr><td>拉取代码</td><td>Ctrl+T</td><td>⌘+T</td></tr><tr><td>弹出git操作</td><td>Alt+&#96;</td><td>⌃+V</td></tr></tbody></table><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis Plus基础</title>
      <link href="/post/e9be66b7.html"/>
      <url>/post/e9be66b7.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus</a> 是一个 <a href="https://www.mybatis.org/mybatis-3/">MyBatis</a> 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p><p>这篇笔记主要记录MyBatis-Plus的入门使用，主要包含如下内容：</p><ul><li>使用MyBatis-Plus实现基本的CRUD</li><li>使用条件构造器构建查询和更新语句</li><li>使用MyBatis-Plus的基本注解</li><li>使用MyBatis-Plus的扩展功能</li></ul><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>创建表并插入一些数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `mp`;</span><br><span class="line">USE `mp`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">`id` <span class="type">BIGINT</span>(<span class="number">19</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">`username` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户名&#x27;</span> <span class="keyword">COLLATE</span> <span class="string">&#x27;utf8_general_ci&#x27;</span>,</span><br><span class="line">`password` <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;密码&#x27;</span> <span class="keyword">COLLATE</span> <span class="string">&#x27;utf8_general_ci&#x27;</span>,</span><br><span class="line">`phone` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;注册手机号&#x27;</span> <span class="keyword">COLLATE</span> <span class="string">&#x27;utf8_general_ci&#x27;</span>,</span><br><span class="line">`info` JSON <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;详细信息&#x27;</span>,</span><br><span class="line">`status` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;1&#x27;</span> COMMENT <span class="string">&#x27;使用状态（1正常 2冻结）&#x27;</span>,</span><br><span class="line">`balance` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;账户余额&#x27;</span>,</span><br><span class="line">`create_time` DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">`update_time` DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE,</span><br><span class="line"><span class="keyword">UNIQUE</span> INDEX `username` (`username`) <span class="keyword">USING</span> BTREE</span><br><span class="line">)</span><br><span class="line">COMMENT<span class="operator">=</span><span class="string">&#x27;用户表&#x27;</span></span><br><span class="line"><span class="keyword">COLLATE</span><span class="operator">=</span><span class="string">&#x27;utf8_general_ci&#x27;</span></span><br><span class="line">ENGINE<span class="operator">=</span>InnoDB</span><br><span class="line">ROW_FORMAT<span class="operator">=</span>COMPACT</span><br><span class="line">AUTO_INCREMENT<span class="operator">=</span><span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` (`id`, `username`, `password`, `phone`, `info`, `status`, `balance`, `create_time`, `update_time`) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;13900112224&#x27;</span>, <span class="string">&#x27;&#123;&quot;age&quot;: 20, &quot;gender&quot;: &quot;male&quot;&#125;&#x27;</span>, <span class="number">1</span>, <span class="number">1600</span>, <span class="string">&#x27;2023-05-19 20:50:21&#x27;</span>, <span class="string">&#x27;2023-06-19 20:50:21&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;Rose&#x27;</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;13900112223&#x27;</span>, <span class="string">&#x27;&#123;&quot;age&quot;: 19, &quot;gender&quot;: &quot;female&quot;&#125;&#x27;</span>, <span class="number">1</span>, <span class="number">600</span>, <span class="string">&#x27;2023-05-19 21:00:23&#x27;</span>, <span class="string">&#x27;2023-06-19 21:00:23&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;Hope&#x27;</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;13900112222&#x27;</span>, <span class="string">&#x27;&#123;&quot;age&quot;: 25, &quot;gender&quot;: &quot;male&quot;&#125;&#x27;</span>, <span class="number">1</span>, <span class="number">100000</span>, <span class="string">&#x27;2023-06-19 22:37:44&#x27;</span>, <span class="string">&#x27;2023-06-19 22:37:44&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;Thomas&#x27;</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;17701265258&#x27;</span>, <span class="string">&#x27;&#123;&quot;age&quot;: 29, &quot;gender&quot;: &quot;male&quot;&#125;&#x27;</span>, <span class="number">1</span>, <span class="number">800</span>, <span class="string">&#x27;2023-06-19 23:44:45&#x27;</span>, <span class="string">&#x27;2023-06-19 23:44:45&#x27;</span>);</span><br></pre></td></tr></table></figure><p>创建工程、新建<code>User</code>、<code>UserMapper</code></p><img src="/post/e9be66b7/image-20241102093153288.png" class="" title="image-20241102093153288"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> String info;</span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line">    <span class="keyword">private</span> Integer balance;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis-plus.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>基本配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.itheima:</span> <span class="string">debug</span></span><br><span class="line">  <span class="attr">pattern:</span></span><br><span class="line">    <span class="attr">dateformat:</span> <span class="string">HH:mm:ss</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath*:/mapper/**/*.xml</span></span><br></pre></td></tr></table></figure><h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><h3 id="单表CRUD"><a href="#单表CRUD" class="headerlink" title="单表CRUD"></a>单表CRUD</h3><p>MyBatis Plus提供了一个基础的<code>BaseMapper</code>接口，实现了单表的CRUD，自定义Mapper只要继承了<code>BaseMapper</code>，就无需实现单表的CRUD了。</p><img src="/post/e9be66b7/image-20241102144540554.png" class="" title="image-20241102144540554"><p>创建一个测试类，测试基本的CRUD功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserMapperTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(<span class="number">5L</span>);</span><br><span class="line">        user.setUsername(<span class="string">&quot;Lucy&quot;</span>);</span><br><span class="line">        user.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        user.setPhone(<span class="string">&quot;18688990011&quot;</span>);</span><br><span class="line">        user.setBalance(<span class="number">200</span>);</span><br><span class="line">        user.setInfo(<span class="string">&quot;&#123;\&quot;age\&quot;: 24, \&quot;intro\&quot;: \&quot;英文老师\&quot;, \&quot;gender\&quot;: \&quot;female\&quot;&#125;&quot;</span>);</span><br><span class="line">        user.setCreateTime(LocalDateTime.now());</span><br><span class="line">        user.setUpdateTime(LocalDateTime.now());</span><br><span class="line">        userMapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSelectById</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(<span class="number">5L</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testQueryByIds</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">3L</span>));</span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testUpdateById</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(<span class="number">5L</span>);</span><br><span class="line">        user.setBalance(<span class="number">20000</span>);</span><br><span class="line">        userMapper.updateById(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testDeleteUser</span><span class="params">()</span> &#123;</span><br><span class="line">        userMapper.deleteById(<span class="number">5L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><p>MyBatis Plus通过扫描实体类，基于反射将实体类映射到数据库中的表。默认情况下，实体类的类名和字段名与表中的列名应该一一对应，如果出现不一致，就需要通过注解进行指定。</p><p>常用注解</p><ul><li><code>@TableName</code>：指定表名</li><li><code>@TableId</code>：指定主键</li><li><code>@TableFiled</code>：指定普通字段</li></ul><p>其中 <code>@TableField</code> 的常见使用场景如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;tb_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// 如果id是自增长类型，需明确指定IdType为AUTO</span></span><br><span class="line">    <span class="meta">@TableId(type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="comment">// 成员变量名与表字段名不一致</span></span><br><span class="line">    <span class="meta">@TableFiled(&quot;username&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 以is开头的布尔类型成员变量，序列化时会将is去除，导致无法与表中is_married匹配，需手动指定</span></span><br><span class="line">    <span class="meta">@TableField(&quot;is_married&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Boolean isMarried;</span><br><span class="line">    <span class="comment">// 表字段是数据库关键字</span></span><br><span class="line">    <span class="meta">@TableField(&quot;`order`&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer order;</span><br><span class="line">    <span class="comment">// 成员变量不是数据库字段</span></span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h2><p>MyBatis-Plus除了支持以<code>id</code>作为基本的查询条件之外，还支持通过<code>Wrapper</code>构造复杂的查询条件。<code>Wrapper</code>的继承关系图如下：</p><img src="/post/e9be66b7/image-20241102143801416.png" class="" title="image-20241102143801416"><p>其中子类<code>AbstractWrapper</code>提供了<code>where</code>子句中会用到的所有条件构造方法：</p><img src="/post/e9be66b7/image-20241102144423632.png" class="" title="image-20241102144423632"><h3 id="QueryWrapper"><a href="#QueryWrapper" class="headerlink" title="QueryWrapper"></a><code>QueryWrapper</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;()</span><br><span class="line">        .select(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;balance&quot;</span>) <span class="comment">// 硬编码</span></span><br><span class="line">        .like(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;ho&quot;</span>)</span><br><span class="line">        .ge(<span class="string">&quot;balance&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">final</span> List&lt;User&gt; users = userMapper.selectList(queryWrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UpdateWrapper"><a href="#UpdateWrapper" class="headerlink" title="UpdateWrapper"></a><code>UpdateWrapper</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdateWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> UpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;User&gt;()</span><br><span class="line">        .setSql(<span class="string">&quot;balance = balance + 1000&quot;</span>) </span><br><span class="line">        .in(<span class="string">&quot;id&quot;</span>, <span class="number">1L</span>, <span class="number">2L</span>); <span class="comment">// 硬编码</span></span><br><span class="line">    userMapper.update(updateWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LambdaQueryWrapper"><a href="#LambdaQueryWrapper" class="headerlink" title="LambdaQueryWrapper"></a><code>LambdaQueryWrapper</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLambdaQueryWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> LambdaQueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;()</span><br><span class="line">        .select(User::getId, User::getUsername, User::getBalance)</span><br><span class="line">        .like(User::getUsername, <span class="string">&quot;ho&quot;</span>)</span><br><span class="line">        .ge(User::getBalance, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">final</span> List&lt;User&gt; users = userMapper.selectList(queryWrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LambdaUpdateWrapper"><a href="#LambdaUpdateWrapper" class="headerlink" title="LambdaUpdateWrapper"></a><code>LambdaUpdateWrapper</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLambdaUpdateWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> LambdaUpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;User&gt;()</span><br><span class="line">        .setSql(<span class="string">&quot;balance = balance - 500&quot;</span>)</span><br><span class="line">        .in(User::getId, <span class="number">1L</span>, <span class="number">2L</span>);</span><br><span class="line">    userMapper.update(updateWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IService接口"><a href="#IService接口" class="headerlink" title="IService接口"></a>IService接口</h2><p><code>BaseMapper</code>接口提供了基本的增删改查接口，但是这些接口只能操作单个对象。因此MyBatis-Plus另外提供了一个<code>IService</code>接口，接口包含了一堆批处理接口，实现类<code>ServiceImpl</code>提供了基本的实现。</p><img src="/post/e9be66b7/image-20241102164213193.png" class="" title="image-20241102164213193"><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-openapi2-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>swagger配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">knife4j:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">openapi:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">接口文档</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">&quot;接口文档&quot;</span></span><br><span class="line">    <span class="attr">group:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">group-name:</span> <span class="string">default</span></span><br><span class="line">        <span class="attr">api-rule:</span> <span class="string">package</span></span><br><span class="line">        <span class="attr">api-rule-resources:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">com.tw.mbp.controller</span></span><br></pre></td></tr></table></figure><p>mapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateBalanceByIds</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> LambdaQueryWrapper&lt;User&gt; queryWrapper, <span class="meta">@Param(&quot;amount&quot;)</span> <span class="type">int</span> amount)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;update user set balance = balance - #&#123;amount&#125; where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deductBalance</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id, <span class="meta">@Param(&quot;amount&quot;)</span> Integer amount)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductBalance</span><span class="params">(Long id, Integer amount)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 简单CURD直接使用IService中定义好的方法，如getById()方法</span></span><br><span class="line"><span class="comment">         * 业务处理在自定义service中实现，如用户状态校验、余额校验</span></span><br><span class="line"><span class="comment">         * 需要编写额外SQL在自定义Mapper中实现，如deductBalance()方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 查询用户</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getById(id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用户状态校验</span></span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span> || user.getStatus() == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户不存在或已被冻结&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 余额校验</span></span><br><span class="line">        <span class="keyword">if</span> (user.getBalance() &lt; amount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户余额不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新余额</span></span><br><span class="line">        <span class="built_in">this</span>.baseMapper.deductBalance(id, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Api(tags = &quot;用户管理接口&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spring推荐使用构造函数注入，因此这里不使用@Autowired注解；</span></span><br><span class="line">    <span class="comment">// 但是如果类的字段过多，构造函数会显得臃肿，可以用final修饰符加@RequiredArgsConstructor注解实现字段注入</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;扣减余额&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/&#123;id&#125;/deduct/&#123;amount&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductBalance</span><span class="params">(<span class="meta">@PathVariable</span> Long id, <span class="meta">@PathVariable</span> Integer amount)</span> &#123;</span><br><span class="line">        userService.deductBalance(id, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lambda方法"><a href="#lambda方法" class="headerlink" title="lambda方法"></a>lambda方法</h3><p><code>lambdaQuery()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">queryUsers</span><span class="params">(UserQuery query)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lambdaQuery()</span><br><span class="line">        .like(StrUtil.isNotBlank(query.getName()), User::getUsername, query.getName())</span><br><span class="line">        .eq(query.getStatus() != <span class="literal">null</span>, User::getStatus, query.getStatus())</span><br><span class="line">        .ge(query.getMinBalance() != <span class="literal">null</span>, User::getBalance, query.getMinBalance())</span><br><span class="line">        .le(query.getMaxBalance() != <span class="literal">null</span>, User::getBalance, query.getMaxBalance())</span><br><span class="line">        .list();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lambdaUpdate</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductBalance</span><span class="params">(Long id, Integer amount)</span> &#123;</span><br><span class="line">    <span class="comment">// 查询用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getById(id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验用户状态</span></span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span> || user.getStatus() == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户不存在或已被冻结&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验余额</span></span><br><span class="line">    <span class="keyword">if</span> (user.getBalance() &lt; amount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户余额不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新余额</span></span><br><span class="line">    <span class="comment">// this.baseMapper.deductBalance(id, amount);</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">newBalance</span> <span class="operator">=</span> user.getBalance() - amount;</span><br><span class="line">    lambdaUpdate()</span><br><span class="line">        .set(User::getBalance, newBalance)</span><br><span class="line">        .set(newBalance &lt;= <span class="number">0</span>, User::getStatus, <span class="number">2</span>)</span><br><span class="line">        .eq(User::getId, id)</span><br><span class="line">        .update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h3><p>当要插入多条数据时，如果逐条插入（调用<code>save()</code>方法），效率较低，因为每次插入都会请求网络，数据库层面的sql也是逐条执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveOneByOne</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5_0000</span>; i++) &#123;</span><br><span class="line">        userService.save(buildUser(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;耗费时间&quot;</span> + (endTime - startTime));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/post/e9be66b7/image-20241102213505591.png" class="" title="image-20241102213505591"><p>为了提高效率，可以改用批量插入（调用<code>saveBatch()</code>方法），<code>saveBatch()</code>基于预编译处理，只需发起少量网络请求，但数据库层面的sql依然是逐条执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveBatch</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    List&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5_0000</span>; i++) &#123;</span><br><span class="line">        users.add(buildUser(i));</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            userService.saveBatch(users);</span><br><span class="line">            users.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;耗费时间&quot;</span> + (endTime - startTime));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/post/e9be66b7/image-20241102213654618.png" class="" title="image-20241102213654618"><p>为了是批量插入的效率最大化，需开启<code>rewriteBatchedStatements=true</code>，开启后数据库会重写sql，多条插入语句会合并成一条来执行</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true</span></span><br></pre></td></tr></table></figure><img src="/post/e9be66b7/image-20241102213940690.png" class="" title="image-20241102213940690"><h2 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h2><h3 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h3><p>添加配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">logic-delete-field:</span> <span class="string">deleted</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testLogicDelete</span><span class="params">()</span> &#123;</span><br><span class="line">    userService.removeById(<span class="number">1L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><img src="/post/e9be66b7/image-20241102231813017.png" class="" title="image-20241102231813017"><p>开启逻辑删除功能后，查询操作的过滤条件默认都会带上 <code>deleted = 0</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testQueryWithLogicDelete</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(<span class="number">1L</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/post/e9be66b7/image-20241102232415756.png" class="" title="image-20241102232415756"><p>PS：逻辑删除会导致表中数据越来越多，随着数据的堆积会影响查询效率。</p><h3 id="枚举映射"><a href="#枚举映射" class="headerlink" title="枚举映射"></a>枚举映射</h3><p>枚举</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">UserStatus</span> &#123;</span><br><span class="line"></span><br><span class="line">    NORMAL(<span class="number">1</span>, <span class="string">&quot;正常&quot;</span>),</span><br><span class="line">    FREEZE(<span class="number">2</span>, <span class="string">&quot;冻结&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EnumValue</span> <span class="comment">// 指定与表中字段映射的枚举字段</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonValue</span> <span class="comment">// 指定序列化返回给前端的枚举字段</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">default-enum-type-handler:</span> <span class="string">com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span></span><br></pre></td></tr></table></figure><h3 id="JSON映射"><a href="#JSON映射" class="headerlink" title="JSON映射"></a>JSON映射</h3><p>将表中<code>json</code>类型字段转换成实体类中对象成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(value = &quot;user&quot;, autoResultMap = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 详细信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(typeHandler = JacksonTypeHandler.class)</span></span><br><span class="line">    <span class="keyword">private</span> ExtraInfo info;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor(staticName = &quot;of&quot;)</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtraInfo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动填充字段"><a href="#自动填充字段" class="headerlink" title="自动填充字段"></a>自动填充字段</h3><img src="/post/e9be66b7/image-20241103020436064.png" class="" title="image-20241103020436064"><p><code>user</code>表的时间字段定义了默认值，因此在插入数据时无需手动填充这两个字段的值。但是如果定义表时未指定字段的默认值，可以使用MyBatis-Plus提供的自动填充字段功能在插入数据时自动填充数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strictInsertFill(metaObject, <span class="string">&quot;createTime&quot;</span>, LocalDateTime::now, LocalDateTime.class);</span><br><span class="line">        <span class="built_in">this</span>.strictInsertFill(metaObject, <span class="string">&quot;updateTime&quot;</span>, LocalDateTime::now, LocalDateTime.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strictUpdateFill(metaObject, <span class="string">&quot;updateTime&quot;</span>, LocalDateTime::now, LocalDateTime.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableField(value = &quot;create_time&quot;, fill = FieldFill.INSERT)</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@TableField(value = &quot;update_time&quot;, fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime updateTime;</span><br></pre></td></tr></table></figure><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">MybatisPlusInterceptor</span> <span class="variable">mybatisPlusInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分页插件</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">PaginationInnerInterceptor</span> <span class="variable">paginationInnerInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL);</span><br><span class="line">        paginationInnerInterceptor.setMaxLimit(<span class="number">100L</span>);</span><br><span class="line">        mybatisPlusInterceptor.addInnerInterceptor(paginationInnerInterceptor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mybatisPlusInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPaginationInnerInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">    Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    page.setOrders(OrderItem.ascs(<span class="string">&quot;balance&quot;</span>));</span><br><span class="line">    page = userService.page(page);</span><br><span class="line">    page.getRecords().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><img src="/post/e9be66b7/image-20241103005233009.png" class="" title="image-20241103005233009"><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>更新时会增加一个version条件，如果version和之前查出来的不一致，就停止更新。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">MybatisPlusInterceptor</span> <span class="variable">mybatisPlusInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 乐观锁插件</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">OptimisticLockerInnerInterceptor</span> <span class="variable">optimisticLockerInnerInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>();</span><br><span class="line">        mybatisPlusInterceptor.addInnerInterceptor(optimisticLockerInnerInterceptor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mybatisPlusInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testOptimisticLockerInnerInterceptor</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(<span class="number">2L</span>);</span><br><span class="line">    user.setBalance(<span class="number">999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> userService.getById(<span class="number">2L</span>);</span><br><span class="line">        user1.setBalance(<span class="number">888</span>);</span><br><span class="line">        userService.updateById(user1);</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">updated</span> <span class="operator">=</span> userService.updateById(user);</span><br><span class="line">    Assertions.assertFalse(updated);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><img src="/post/e9be66b7/image-20241103015855684.png" class="" title="image-20241103015855684"><img src="/post/e9be66b7/image-20241103020004869.png" class="" title="image-20241103020004869"><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> ORM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis-Plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis基础</title>
      <link href="/post/4658a061.html"/>
      <url>/post/4658a061.html</url>
      
        <content type="html"><![CDATA[<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>创建<code>user</code>表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `pwd` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">6</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_0900_ai_ci;</span><br></pre></td></tr></table></figure><span id="more"></span><p>创建maven工程，并定义<code>User</code>实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><p>定义 <code>UserMapper</code>，并定义一个查询所有用户的方法<code>listUsers</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">listUsers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在resources&#x2F;mapper目录下创建<code>UserMapper.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.tw.mybatis.dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.tw.mybatis.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from User</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在resources目录下创建<code>mybatis-config.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Time_Wait7&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>定义<code>MyBatisUtil</code>，用于获取<code>SqlSession</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title function_">getSqlSession</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title function_">getSqlSession</span><span class="params">(<span class="type">boolean</span> autoCommit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession(autoCommit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserMapperTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testListUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtil.getSqlSession()) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> sqlSession.getMapper(UserDao.class);</span><br><span class="line">            userDao.listUsers().forEach(System.out::println);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单CRUD"><a href="#简单CRUD" class="headerlink" title="简单CRUD"></a>简单CRUD</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; <span class="title function_">listUsers</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">addUser</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateUser</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteUser</span><span class="params">(Long id)</span>;</span><br><span class="line">    </span><br><span class="line">    User <span class="title function_">getUserById</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="xml配置"><a href="#xml配置" class="headerlink" title="xml配置"></a>xml配置</h4><p>在<code>UserMapper.xml</code>编写对应的sql</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.tw.mybatis.dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser&quot;</span>&gt;</span></span><br><span class="line">        insert into User(name,pwd) values(#&#123;name&#125;,#&#123;pwd&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span>&gt;</span></span><br><span class="line">        update User set name = #&#123;name&#125;,pwd = #&#123;pwd&#125; where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span>&gt;</span></span><br><span class="line">        delete from User where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.tw.mybatis.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from User</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.tw.mybatis.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from User where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tw.mybatis.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.tw.mybatis.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Delete;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Insert;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Update;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">listUsers</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解方式，根据id查询用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">getUserById</span><span class="params">(Long id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解方式，添加用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into user(name, pwd) values(#&#123;name&#125;, #&#123;password&#125;) &quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">addUser</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解方式，更新用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Update(&quot;update user set pwd = #&#123;password&#125; where name = #&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateUser</span><span class="params">(User user)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解方式，删除用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Delete(&quot;delete from user where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteUser</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>方式一：自定义sql</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">listUsersByPage</span><span class="params">(<span class="meta">@Param(&quot;offset&quot;)</span> Integer offset, <span class="meta">@Param(&quot;limit&quot;)</span> Integer limit)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.tw.mybatis.dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;pwd&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listUsersByPage&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserMap&quot;</span>&gt;</span></span><br><span class="line">        select * from User limit #&#123;offset&#125;,#&#123;limit&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>方式二：<code>RowBounds</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">listUsersByRowBounds</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.tw.mybatis.dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;pwd&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listUsersByPage&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserMap&quot;</span>&gt;</span></span><br><span class="line">        select * from User</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testListUsersByRowBounds</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtil.getSqlSession()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> sqlSession.getMapper(UserDao.class);</span><br><span class="line">        <span class="keyword">final</span> List&lt;User&gt; users = sqlSession.selectList(<span class="string">&quot;com.tw.mybatis.dao.UserDao.listUsersByRowBounds&quot;</span>, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">RowBounds</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>直接将数据库连接信息硬编码在<code>mybatis-config.xml</code>文件中不够优雅，数据库连接属性可以在外部进行配置，并可以进行动态替换。</p><p>创建<code>db.properties</code>文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">xxx</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置数据库连接信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;db.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>在上述例子中可以看到，<code>resultType</code>属性需要写类的全路径，有点繁琐，可以配置别名简化书写。配置别名有以下两种方式：</p><p>方式一：为指定类配置别名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置别名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;com.tw.mybatis.pojo.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;user&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>方式二：指定包下的实体类默认以类名小写作为别名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置别名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.tw.mybatis.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置别名之后，<code>resultType</code>就可以简写如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.tw.mybatis.dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        select * from User</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        select * from User where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><h3 id="简单映射"><a href="#简单映射" class="headerlink" title="简单映射"></a>简单映射</h3><p>如果实体类属性和表字段不一致，就需要手动指定映射。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表字段是pwd</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.tw.mybatis.dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定实体类属性与表字段的映射关系 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;pwd&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listUsers&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserMap&quot;</span>&gt;</span></span><br><span class="line">        select * from User</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="复杂映射"><a href="#复杂映射" class="headerlink" title="复杂映射"></a>复杂映射</h3><h4 id="环境准备-1"><a href="#环境准备-1" class="headerlink" title="环境准备"></a>环境准备</h4><p>创建<code>student</code>和<code>teacher</code>表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tid` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `fk_tid` (`tid`),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `fk_tid` <span class="keyword">FOREIGN</span> KEY (`tid`) <span class="keyword">REFERENCES</span> `teacher` (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">6</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `teacher` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3;</span><br></pre></td></tr></table></figure><p>定义<code>Student</code>和<code>Teacher</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Teacher teacher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义<code>Mapper</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentMapper</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TeacherMapper</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建<code>Mapper.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.tw.mybatis.dao.StudentMapper&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.tw.mybatis.dao.TeacherMapper&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置映射文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper/TeacherMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper/StudentMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="association"><a href="#association" class="headerlink" title="association"></a><code>association</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询学生信息，同时包含老师信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Student&gt; <span class="title function_">listStudentsWithTeacher</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="子查询方式"><a href="#子查询方式" class="headerlink" title="子查询方式"></a>子查询方式</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.tw.mybatis.dao.StudentMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;StudentWithTeacher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Teacher&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span> <span class="attr">select</span>=<span class="string">&quot;getTeacher&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listStudentsWithTeacher&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;StudentWithTeacher&quot;</span>&gt;</span></span><br><span class="line">        select * from student</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacher&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">        select * from teacher where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="连表查询方式"><a href="#连表查询方式" class="headerlink" title="连表查询方式"></a>连表查询方式</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.tw.mybatis.dao.StudentMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;StudentWithTeacher2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sid&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sname&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tname&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listStudentsWithTeacher2&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;StudentWithTeacher2&quot;</span>&gt;</span></span><br><span class="line">        select s.id sid, s.name sname, t.id tid, t.name tname</span><br><span class="line">        from student s left join teacher t</span><br><span class="line">        on s.tid = t.id</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="collection"><a href="#collection" class="headerlink" title="collection"></a><code>collection</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long tid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; students;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TeacherMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Teacher&gt; <span class="title function_">selectList</span><span class="params">(Object o)</span>;</span><br><span class="line"></span><br><span class="line">    Teacher <span class="title function_">getTeacherWithStudents</span><span class="params">(<span class="meta">@Param(&quot;tid&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="子查询方式-1"><a href="#子查询方式-1" class="headerlink" title="子查询方式"></a>子查询方式</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.tw.mybatis.dao.TeacherMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;TeacherWithStudents&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;students&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;ArrayList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Student&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">select</span>=<span class="string">&quot;listStudentByTid&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacherWithStudents&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;TeacherWithStudents&quot;</span>&gt;</span></span><br><span class="line">        select * from teacher where id = #&#123;tid&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listStudentByTid&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">        select * from student where tid = #&#123;tid&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="连表查询方式-1"><a href="#连表查询方式-1" class="headerlink" title="连表查询方式"></a>连表查询方式</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.tw.mybatis.dao.TeacherMapper&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;TeacherWithStudents&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tname&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;students&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sid&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sname&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;tid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacherWithStudents&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;TeacherWithStudents&quot;</span>&gt;</span></span><br><span class="line">        select t.id tid, t.name tname, s.id sid, s.name sname</span><br><span class="line">        from teacher t left join student s</span><br><span class="line">        on t.id = s.tid</span><br><span class="line">        where t.id = #&#123;tid&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>创建<code>blog</code>表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `blog` (</span><br><span class="line">  `id` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;博客id&#x27;</span>,</span><br><span class="line">  `title` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;博客标题&#x27;</span>,</span><br><span class="line">  `author` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;作者&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `views` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;浏览量&#x27;</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3;</span><br></pre></td></tr></table></figure><p>定义<code>Blog</code>实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Blog</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer views;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义<code>BlogMapper</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BlogMapper</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建<code>BlogMapper.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.tw.mybatis.dao.BlogMapper&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>mybatis-config.xml</code>添加映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper/BlogMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="if"><a href="#if" class="headerlink" title="if"></a><code>if</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BlogMapper</span> &#123;</span><br><span class="line">List&lt;Blog&gt; <span class="title function_">listBlogs</span><span class="params">(Map&lt;String, Object&gt; params)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listBlogs&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.tw.mybatis.pojo.Blog&quot;</span>&gt;</span></span><br><span class="line">    select * from Blog</span><br><span class="line">    where  1 = 1</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null&quot;</span>&gt;</span></span><br><span class="line">        and author like concat(&#x27;%&#x27;, #&#123;author&#125;, &#x27;%&#x27;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">        and title like concat(&#x27;%&#x27;, #&#123;title&#125;, &#x27;%&#x27;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;createTime != null&quot;</span>&gt;</span></span><br><span class="line">        and create_time &gt; #&#123;createTime&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;views != null&quot;</span>&gt;</span></span><br><span class="line">        and views &gt; #&#123;views&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testListBlogs</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtil.getSqlSession()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">BlogMapper</span> <span class="variable">blogMapper</span> <span class="operator">=</span> sqlSession.getMapper(BlogMapper.class);</span><br><span class="line">        Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        params.put(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;learning&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> List&lt;Blog&gt; blogs = blogMapper.listBlogs(params);</span><br><span class="line">        blogs.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="where"><a href="#where" class="headerlink" title="where"></a><code>where</code></h3><p>前面的例子中为了避免拼接出如下错误sql，手动加了条件<code>1 = 1</code>，这样虽然能解决问题，但显得不够优雅，为此MyBatis提供了<code>&lt;where&gt;</code>标签，可以更好地解决这个问题。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> Blog</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> Blog</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line"><span class="keyword">and</span> title <span class="keyword">like</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listBlogs&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.tw.mybatis.pojo.Blog&quot;</span>&gt;</span></span><br><span class="line">    select * from Blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null&quot;</span>&gt;</span></span><br><span class="line">            and author like concat(&#x27;%&#x27;, #&#123;author&#125;, &#x27;%&#x27;)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">            and title like concat(&#x27;%&#x27;, #&#123;title&#125;, &#x27;%&#x27;)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;createTime != null&quot;</span>&gt;</span></span><br><span class="line">            and create_time &gt; #&#123;createTime&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;views != null&quot;</span>&gt;</span></span><br><span class="line">            and views &gt; #&#123;views&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set"></a><code>set</code></h3><p>与<code>where</code>标签类似，<code>set</code>标签可以去除可能多余的字符，保证sql拼接正确</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BlogMapper</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateBlog</span><span class="params">(Map&lt;String, Object&gt; params)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateBlog&quot;</span>&gt;</span></span><br><span class="line">    update Blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">            title = #&#123;title&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null&quot;</span>&gt;</span></span><br><span class="line">            author = #&#123;author&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;createTime != null&quot;</span>&gt;</span></span><br><span class="line">            create_time = #&#123;createTime&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;views != null&quot;</span>&gt;</span></span><br><span class="line">            views = #&#123;views&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>choose-when-otherwise</code></p><p>有点类似<code>switch</code>语句，传入哪个条件就用哪个条件查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BlogMapper</span> &#123;</span><br><span class="line">    List&lt;Blog&gt; <span class="title function_">listBlogsByChoose</span><span class="params">(Map&lt;String, Object&gt; params)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listBlogsByChoose&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.tw.mybatis.pojo.Blog&quot;</span>&gt;</span></span><br><span class="line">    select * from Blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">                and title like concat(&#x27;%&#x27;, #&#123;title&#125;, &#x27;%&#x27;)</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;author != null&quot;</span>&gt;</span></span><br><span class="line">                and author like concat(&#x27;%&#x27;, #&#123;author&#125;, &#x27;%&#x27;)</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">                and 1 = 1</span><br><span class="line">            <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a><code>foreach</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BlogMapper</span> &#123;</span><br><span class="line">List&lt;Blog&gt; <span class="title function_">listBlogsByForEach</span><span class="params">(<span class="meta">@Param(&quot;ids&quot;)</span> List&lt;String&gt; ids)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;listBlogsByForEach&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.tw.mybatis.pojo.Blog&quot;</span>&gt;</span></span><br><span class="line">    select * from Blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">open</span>=<span class="string">&quot;id in (&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="sql片段"><a href="#sql片段" class="headerlink" title="sql片段"></a>sql片段</h3><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> ORM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx基础</title>
      <link href="/post/33a007fa.html"/>
      <url>/post/33a007fa.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h2><ul><li>安装</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install nginx</span><br></pre></td></tr></table></figure><ul><li>检查是否装成功</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -v</span><br><span class="line"><span class="comment"># nginx version: nginx/1.21.2</span></span><br></pre></td></tr></table></figure><ul><li>安装成功后的相关目录</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 安装文件目录</span><br><span class="line">/usr/local/Cellar/nginx/1.21.2</span><br><span class="line"># 配置文件目录</span><br><span class="line">/usr/local/etc/nginx</span><br><span class="line"># html目录</span><br><span class="line">/usr/local/var/www</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="Nginx基本命令"><a href="#Nginx基本命令" class="headerlink" title="Nginx基本命令"></a>Nginx基本命令</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>brew list nginx</code></td><td>查看nginx的安装信息</td></tr><tr><td><code>nginx</code></td><td>启动</td></tr><tr><td><code>nginx -s stop</code></td><td>停止</td></tr><tr><td><code>nginx -s reload</code></td><td>重启</td></tr><tr><td><code>nginx -t</code></td><td>查看配置文件位置</td></tr></tbody></table><h2 id="反向代理与负载均衡"><a href="#反向代理与负载均衡" class="headerlink" title="反向代理与负载均衡"></a>反向代理与负载均衡</h2><p>创建一个demo项目，并打包，通过<code>java -jar</code>方式启动两个实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -jar demo-0.0.1-SNAPSHOT.jar --server.port=8080</span><br><span class="line"></span><br><span class="line">java -jar demo-0.0.1-SNAPSHOT.jar --server.port=8081</span><br></pre></td></tr></table></figure><p>修改nginx.conf，配置反向代理与负载均衡</p><img src="/post/33a007fa/image-20240916203606556.png" class="" title="image-20240916203606556"><p>访问测试：<a href="http://localhost/hello%EF%BC%8C%E5%A4%9A%E6%AC%A1%E8%AE%BF%E9%97%AE%E8%BF%99%E4%B8%AA%E8%BF%9E%E6%8E%A5%EF%BC%8C%E8%AF%B7%E6%B1%82%E9%9A%8F%E6%9C%BA%E6%89%93%E5%88%B0%E4%B8%8D%E5%90%8C%E5%AE%9E%E4%BE%8B">http://localhost/hello，多次访问这个连接，请求随机打到不同实例</a></p><img src="/post/33a007fa/image-20240916203807897.png" class="" title="image-20240916203807897"><img src="/post/33a007fa/image-20240916203832170.png" class="" title="image-20240916203832170"><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker基础</title>
      <link href="/post/89826705.html"/>
      <url>/post/89826705.html</url>
      
        <content type="html"><![CDATA[<h2 id="Docker架构图"><a href="#Docker架构图" class="headerlink" title="Docker架构图"></a>Docker架构图</h2><img src="/post/89826705/Docker%E6%9E%B6%E6%9E%84%E5%9B%BE.png" class=""><span id="more"></span><h2 id="Docker与虚拟机"><a href="#Docker与虚拟机" class="headerlink" title="Docker与虚拟机"></a>Docker与虚拟机</h2><img src="/post/89826705/Docker%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8A%BD%E8%B1%A1%E5%9B%BE.png" class=""><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><img src="/post/89826705/image-20241027223956215.png" class="" title="image-20241027223956215"><h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>docker build</code></td><td>构建镜像</td></tr><tr><td><code>docker images</code></td><td>查看本地镜像</td></tr><tr><td><code>docker images -q</code></td><td>只显示镜像ID</td></tr><tr><td><code>docker search mysql</code></td><td>查找镜像</td></tr><tr><td><code>docker pull mysql</code></td><td>拉取最新版本镜像</td></tr><tr><td><code>docker pull mysql:5.7</code></td><td>拉取指定版本镜像</td></tr><tr><td><code>docker rmi 镜像名/镜像ID ...</code></td><td>删除镜像</td></tr><tr><td><code>docker rmi $(docker images -q)</code></td><td>批量删除镜像</td></tr></tbody></table><h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>docker ps</code></td><td>查看容器</td></tr><tr><td><code>docker ps -a</code></td><td>查看所有容器</td></tr><tr><td><code>docker ps -a -n=1</code></td><td>查看最新创建的容器</td></tr><tr><td><code>docker run -d --name nginx -p 80:80 nginx</code></td><td>运行容器</td></tr><tr><td><code>docker stop</code></td><td>停止容器</td></tr><tr><td><code>docker start</code></td><td>启动容器</td></tr><tr><td><code>docker restart</code></td><td>重启容器</td></tr><tr><td><code>docker rm -f 容器</code></td><td>删除容器</td></tr><tr><td><code>docker logs</code></td><td>查看容器运行日志</td></tr><tr><td><code>docker exec -it 容器 /bin/bash</code></td><td>进入容器</td></tr><tr><td><code>docker inspect 容器</code></td><td>查看容器详细信息</td></tr><tr><td><code>docker update --restart=always 容器</code></td><td>设置容器开机自启</td></tr><tr><td><code>docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</code></td><td>格式化输出</td></tr><tr><td><code>docker save</code></td><td>保存镜像</td></tr><tr><td><code>docker load</code></td><td>加载镜像</td></tr></tbody></table><p>ps：上面这些命令中的容器即可以是容器名也可以是容器ID</p><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>docker COMMAND --help</code></td><td>查看帮助文档</td></tr><tr><td><code>systemctl enable docker</code></td><td>设置docker开机自启动</td></tr></tbody></table><h3 id="命令别名"><a href="#命令别名" class="headerlink" title="命令别名"></a>命令别名</h3><p>修改 <code>/root/.bashrc</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .bashrc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># User specific aliases and functions</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">rm</span>=<span class="string">&#x27;rm -i&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">cp</span>=<span class="string">&#x27;cp -i&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">mv</span>=<span class="string">&#x27;mv -i&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> psf=<span class="string">&#x27;ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Source global definitions</span></span><br><span class="line"><span class="keyword">if</span> [ -f /etc/bashrc ]; <span class="keyword">then</span></span><br><span class="line">        . /etc/bashrc</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>执行命令让别名生效：<code>source /root/.bashrc</code></p><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p>数据卷（Volume）是容器技术（如 Docker）中一种用于<strong>持久化数据</strong>和<strong>共享数据</strong>的机制。它允许容器之间、或者容器和宿主机之间共享数据，同时实现数据的持久存储，即使容器被删除，数据也不会丢失。</p><img src="/post/89826705/image-20241028233002568.png" class="" title="image-20241028233002568"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>docker volume create</code></td><td>创建数据卷</td></tr><tr><td><code>docker volume ls</code></td><td>查看数据卷</td></tr><tr><td><code>docker volume rm</code></td><td>删除数据卷</td></tr><tr><td><code>docker volume prune</code></td><td>清除数据卷</td></tr><tr><td><code>docker volume inspect</code></td><td>查看数据卷详情</td></tr></tbody></table><p>数据卷挂载：在创建容器时用 <code>-v 卷名:容器目录</code> 进行挂载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nginx -p 80:80 -v html:/usr/share/nginx/html nginx</span><br></pre></td></tr></table></figure><p>查看是否挂载成功：</p><img src="/post/89826705/image-20241029000212988.png" class="" title="image-20241029000212988"><p>查看具体的挂载路径：</p><img src="/post/89826705/image-20241028234315885.png" class="" title="image-20241028234315885"><p>这样就完成了宿主机目录 <code>/var/lib/docker/volumes/html/_data</code> 和容器目录 <code>/usr/share/nginx/html</code> 的双向映射。</p><p>PS：如果创建容器时未通过 <code>-v html:/usr/share/nginx/html</code> 选项挂载，虚拟机会创建一个匿名卷，并将 <code>/usr/share/nginx/html</code> 挂载到这个匿名卷上，匿名卷的名称是一串随机字符串，具体的挂载路径就是 <code>/var/lib/docker/volumes/xxx/_data</code>。</p><p>通过数据卷进行挂载，宿主机中的挂载目录默认是：<code>/var/lib/docker/volumes/卷名/_data</code>，挂载路径有点太深，所以 docker 也支持直接指定宿主机目录进行挂载，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name mysql \</span><br><span class="line">-p 3306:3306 \</span><br><span class="line">-e TZ=Asia/Shanghai \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">-v /root/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /root/mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">-v /root/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">mysql</span><br></pre></td></tr></table></figure><p>ps：本地目录或文件必须以 <code>/</code> 或 <code>./</code>开头，如果直接以名字开头，会被识别为数据卷名。</p><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><h3 id="镜像结构"><a href="#镜像结构" class="headerlink" title="镜像结构"></a>镜像结构</h3><p>联合文件系统</p><p>镜像分层</p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a><code>Dockerfile</code></h3><p><code>Dockerfile</code> 就是一个文本文件，包含一系列指令，用来说明如何构建镜像。常见指令如下：</p><table><thead><tr><th>指令</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>FROM</code></td><td>指定基础镜像</td><td><code>FROM centos:7</code></td></tr><tr><td><code>ENV</code></td><td>配置环境变量，用于后续指令</td><td><code>ENV key=value</code></td></tr><tr><td><code>COPY</code></td><td>拷贝本地文件到镜像的指定目录</td><td><code>COPY ./jre11.tar.gz /tmp</code></td></tr><tr><td><code>RUN</code></td><td>执行Linux的shell命令</td><td><code>RUN tar -zxvf /tmp/jre11.tar.gz &amp;&amp; EXPORTS path=/tmp/jre11:$path</code></td></tr><tr><td><code>EXPOSE</code></td><td>指定容器运行时监听的端口</td><td><code>EXPOSE 8080</code></td></tr><tr><td><code>ENTRYPOINT</code></td><td>镜像中应用的启动命令，容器运行时调用</td><td><code>ENTRYPOINT java -jar xxx.jar</code></td></tr><tr><td><code>VOLUME</code></td><td>创建一个数据卷挂载点</td><td></td></tr><tr><td><code>WORKDIR</code></td><td>配置工作目录</td><td></td></tr></tbody></table><p><code>Dockerfile</code> 示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置环境变量：jdk安装目录</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_DIR=/usr/local</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./jdk8.tar.gz <span class="variable">$JAVA_DIR</span>/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./docker-demo.jar /app.jar</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装jdk</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> <span class="variable">$JAVA_DIR</span> &amp;&amp; tar -xf ./jdk8.tar.gz &amp;&amp; <span class="built_in">mv</span> ./jdk1.8.0_144 ./jdk8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME=$JAVA_DIR/jdk8</span><br><span class="line"><span class="keyword">ENV</span> PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 入口，java项目的启动命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>上面这个 <code>Dockerfile</code> 等同于：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11.0</span>-jre-buster</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./docker-demo.jar /app.jar</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 入口</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>构建镜像</p><p>有了 <code>Dockerfile</code> 之后，就可以通过如下命令构建镜像了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># . 表示Dockerfile所在目录</span></span><br><span class="line">docker build -t 镜像名称 .</span><br></pre></td></tr></table></figure><p>PS：如果构建镜像所用文件名称不是 <code>Dockerfile</code>，需通过 <code>-f dockerfileName</code> 选项指定构建镜像所用文件</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>在 Linux 系统中，网络配置文件目录是<code>/etc/sysconfig/network-scripts</code>。虚拟机和主机宿主机的网络连接方式主要分为如下三种：</p><ul><li>桥接模式 (Bridged)</li></ul><blockquote><p>桥接模式下，虚拟机与宿主机位于同一个物理网络中。虚拟机通过宿主机的物理网卡直接连接到网络，并获得与宿主机相同网段的IP地址。这使得虚拟机与其他网络设备可以直接进行通信，类似于它自己是一台物理机。</p><p>常用于需要虚拟机像物理机一样直接访问外部网络的情况，如文件服务器、Web服务器等。</p></blockquote><ul><li>网络地址转换 (NAT)</li></ul><blockquote><p>NAT模式下，虚拟机通过宿主机的网络连接访问外部网络。宿主机为虚拟机提供一个虚拟网卡，并将虚拟机的网络请求转换为宿主机的网络请求。这种方式类似于路由器工作原理，虚拟机自己不能被外部网络直接访问，但可以访问外部资源。</p><p>常用于需要虚拟机访问外部网络但无需被外部设备访问的场景，比如开发和测试环境。</p></blockquote><ul><li>仅主机模式 (Host-only)</li></ul><blockquote><p>仅主机模式下，虚拟机只能与宿主机进行网络通信，无法访问外部网络。这种模式创建了一个虚拟的网络环境，虚拟机只能和宿主机或其他配置为Host-only模式的虚拟机通信。</p><p>适用于需要完全封闭的网络环境，如局域网测试或调试等。</p></blockquote><p>默认情况下，所有容器都是以 <code>bridge</code> 方式连接到 Docker 的一个虚拟网桥上，如下图：</p><img src="/post/89826705/image-20241030004706881.png" class="" title="image-20241030004706881"><p>通过默认网桥连接的容器之间只能通过ip互相访问，但是如果容器重启，ip地址变了，相关的ip配置未同步修改，就会导致容器之间不通。解决办法是创建自定义网络，并将需要互相访问的容器加入该网络，这样容器之间就可以通过容器名互相访问，不会受ip地址变化的影响。</p><p>Docker常用网络命令：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>docker network ls</code></td><td>查看所有网络</td></tr><tr><td><code>docker network create</code></td><td>创建网络</td></tr><tr><td><code>docker network rm</code></td><td>删除指定网络</td></tr><tr><td><code>docker network prune</code></td><td>清除未使用网络</td></tr><tr><td><code>docker network connect</code></td><td>使指定容器加入网络</td></tr><tr><td><code>docker network disconnect</code></td><td>使指定容器离开网络</td></tr><tr><td><code>docker network inspect</code></td><td>查看网络详细信息</td></tr></tbody></table><p>PS：容器可以先启动再通过命令 <code>docker network connect</code> 加入指定网络，也可以在启动容器时通过选项 <code>--network 网络名</code> 直接加入指定网络。两者的区别在于：方式一会同时加入默认网络docker0和指定网络，方式二只会加入指定网络。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="制作Tomcat镜像"><a href="#制作Tomcat镜像" class="headerlink" title="制作Tomcat镜像"></a>制作<code>Tomcat</code>镜像</h3><ul><li>编写 <code>Dockerfile</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">MAINTAINER timewait7&lt;1029776125@qq.com&gt;</span><br><span class="line"></span><br><span class="line">ADD jdk-8u202-linux-x64.tar.gz /usr/local</span><br><span class="line">ADD apache-tomcat-9.0.94.tar.gz /usr/local</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">ENV JAVA_HOME /usr/local/jdk1.8.0_202</span><br><span class="line">ENV CLASSPATH $JAVA_HOME/lib/dt/jar $JAVA_HOME/lib/tools.jar</span><br><span class="line">ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.94</span><br><span class="line">ENV CATALINA_BASE /usr/local/apache-tomcat-9.0.94</span><br><span class="line">ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line">CMD /usr/local/apache-tomcat-9.0.94/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.94/bin/logs/catalina.out</span><br></pre></td></tr></table></figure><ul><li>构建镜像</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以Dockerfile作为文件名，构建时不需要通过 -f 参数指定文件</span></span><br><span class="line">docker build -t diytomcat .</span><br></pre></td></tr></table></figure><img src="/post/89826705/%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F%E8%BF%87%E7%A8%8B.png" class=""><ul><li>启动镜像</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:8080 --name diytomcat -v /home/mount/tomcat/test:/usr/local/apache-tomcat-9.0.94/webapps/test -v /home/mount/tomcat/logs:/usr/local/apache-tomcat-9.0.94/logs diytomcat</span><br></pre></td></tr></table></figure><ul><li>测试tomcat</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 依次执行以下步骤</span></span><br><span class="line"><span class="built_in">cd</span> /home/mount/tomcat/test</span><br><span class="line"><span class="built_in">mkdir</span> WEB-INF</span><br><span class="line"><span class="built_in">cd</span> WEB-INF</span><br><span class="line">vi web.xml</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">vi index.jsp</span><br></pre></td></tr></table></figure><p><code>web.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">version</span>=<span class="string">&quot;2.4&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/j2ee&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/j2ee</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>index.jsp</code></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Hello World JSP&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello, World!&lt;/h1&gt;</span><br><span class="line">&lt;% System.out.println(<span class="string">&quot;----------logs----------&quot;</span>); %&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><img src="/post/89826705/image-20240915230103023.png" class="" title="image-20240915230103023"><img src="/post/89826705/image-20240915230216263.png" class="" title="image-20240915230216263"><h3 id="部署前后端项目"><a href="#部署前后端项目" class="headerlink" title="部署前后端项目"></a>部署前后端项目</h3><h4 id="创建网络"><a href="#创建网络" class="headerlink" title="创建网络"></a>创建网络</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个名为test的网络</span></span><br><span class="line">docker network create <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h4 id="创建数据库容器"><a href="#创建数据库容器" class="headerlink" title="创建数据库容器"></a>创建数据库容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name mysql \</span><br><span class="line">-p 3306:3306 \</span><br><span class="line">-e TZ=Asia/Shanghai \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">-v /root/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /root/mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">-v /root/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">--network <span class="built_in">test</span> \</span><br><span class="line">mysql</span><br></pre></td></tr></table></figure><h4 id="部署后端应用"><a href="#部署后端应用" class="headerlink" title="部署后端应用"></a>部署后端应用</h4><ol><li><p>准备 jar 包和 <code>Dockerfile</code> 文件，假设放在虚拟机的 &#x2F;root 目录下</p></li><li><p>构建镜像</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root</span><br><span class="line">docker built -t appname .</span><br></pre></td></tr></table></figure><ol start="3"><li>创建容器并运行</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行容器并连接网络test</span></span><br><span class="line">docker run -d --name imagename -p 8080:8080 --network <span class="built_in">test</span> appname</span><br></pre></td></tr></table></figure><h4 id="部署前端应用"><a href="#部署前端应用" class="headerlink" title="部署前端应用"></a>部署前端应用</h4><ol><li>将前端项目和 nginx 配置文件放在 &#x2F;root&#x2F;nginx 目录下</li><li>创建容器并运行</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name nginx \</span><br><span class="line">-p 18080:18080 \</span><br><span class="line">-p 18081:18081 \</span><br><span class="line">-v /root/nginx/html:/usr/share/nginx/html \</span><br><span class="line">-v /root/nginx/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">--network <span class="built_in">test</span> \</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure><h3 id="部署Redis集群"><a href="#部署Redis集群" class="headerlink" title="部署Redis集群"></a>部署Redis集群</h3><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><ul><li>创建redis网络</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create --driver bridge --subnet 172.38.0.0/16 --gateway 172.38.0.1 redis-net</span><br></pre></td></tr></table></figure><ul><li>集群配置文件脚本</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">for port in $(seq 1 6); \</span><br><span class="line">do \</span><br><span class="line">mkdir -p /mydata/redis/node-$&#123;port&#125;/conf</span><br><span class="line">touch /mydata/redis/node-$&#123;port&#125;/conf/redis.conf</span><br><span class="line">cat &lt;&lt; EOF &gt; /mydata/redis/node-$&#123;port&#125;/conf/redis.conf</span><br><span class="line">port 6379</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">cluster-announce-ip 172.38.0.1$&#123;port&#125;</span><br><span class="line">cluster-announce-port 6379</span><br><span class="line">cluster-announce-bus-port 16379</span><br><span class="line">appendonly yes</span><br><span class="line">EOF</span><br><span class="line">done</span><br></pre></td></tr></table></figure><ul><li>启动容器，创建集群节点</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># node-01</span></span><br><span class="line">docker run -d -p 6371:6379 -p 16371:16379 --name redis-01 \</span><br><span class="line">-v /mydata/redis/node-1/data:/data \</span><br><span class="line">-v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">--net redis-net --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># node-02</span></span><br><span class="line">docker run -d -p 6372:6379 -p 16372:16379 --name redis-02 \</span><br><span class="line">-v /mydata/redis/node-2/data:/data \</span><br><span class="line">-v /mydata/redis/node-2/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">--net redis-net --ip 172.38.0.12 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他节点类推</span></span><br></pre></td></tr></table></figure><ul><li>创建集群</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1</span><br></pre></td></tr></table></figure><img src="/post/89826705/image-20240916133527083.png" class="" title="image-20240916133527083"><ul><li>以集群方式创建redis客户端</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -c</span><br></pre></td></tr></table></figure><ul><li>查看集群信息</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster info</span><br></pre></td></tr></table></figure><img src="/post/89826705/image-20240916133836873.png" class="" title="image-20240916133836873"><ul><li>查看集群节点</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster nodes</span><br></pre></td></tr></table></figure><img src="/post/89826705/image-20240916133936635.png" class="" title="image-20240916133936635"><ul><li>测试集群高可用</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置一个键值对</span></span><br><span class="line"><span class="built_in">set</span> hello world</span><br></pre></td></tr></table></figure><img src="/post/89826705/image-20240916134512178.png" class="" title="image-20240916134512178"><p>停掉redis-01节点，redis-05自动升级为master</p><img src="/post/89826705/image-20240916134700142.png" class="" title="image-20240916134700142"><p>此时依然可以<code>get hello</code>依然可以成功返回值</p><img src="/post/89826705/image-20240916135154195.png" class="" title="image-20240916135154195"><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><ul><li>编写<code>docker-compose.yaml</code>文件</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">r1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">r1</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;7001&quot;</span>]</span><br><span class="line">  <span class="attr">r2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">r2</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;7002&quot;</span>]</span><br><span class="line">  <span class="attr">r3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">r3</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;7003&quot;</span>]</span><br></pre></td></tr></table></figure><ul><li>启动容器</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker compose up -d</span><br></pre></td></tr></table></figure><ul><li>配置主从关系</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it r2 redis-cli -p 7002</span><br><span class="line">$ slaveof 虚拟机ip 7001</span><br><span class="line"></span><br><span class="line">$ docker <span class="built_in">exec</span> -it r2 redis-cli -p 7003</span><br><span class="line">$ slaveof 虚拟机ip 7001</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it r1 redis-cli -p 7001</span><br><span class="line">$ info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=192.168.33.11,port=7002,state=online,offset=2165,lag=1</span><br><span class="line">slave1:ip=192.168.33.11,port=7003,state=online,offset=2165,lag=1</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:f7b8c1f916ecc6e3ab6fcba7d73c1f115a880cb6</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:2165</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:2165</span><br><span class="line">$ <span class="built_in">set</span> num 123</span><br><span class="line">$ get num</span><br><span class="line"><span class="string">&quot;123&quot;</span></span><br><span class="line"></span><br><span class="line">$ docker <span class="built_in">exec</span> -it r2 redis-cli -p 7002</span><br><span class="line">$ info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:192.168.33.11</span><br><span class="line">master_port:7001</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:6</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_read_repl_offset:2249</span><br><span class="line">slave_repl_offset:2249</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">replica_announced:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:f7b8c1f916ecc6e3ab6fcba7d73c1f115a880cb6</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:2249</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:15</span><br><span class="line">repl_backlog_histlen:2235</span><br><span class="line">$ <span class="built_in">set</span> num 456</span><br><span class="line">(error) READONLY You can<span class="string">&#x27;t write against a read only replica.</span></span><br><span class="line"><span class="string">$ get num</span></span><br><span class="line"><span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$ docker exec -it r3 redis-cli -p 7003</span></span><br><span class="line"><span class="string"># Replication</span></span><br><span class="line"><span class="string">role:slave</span></span><br><span class="line"><span class="string">master_host:192.168.33.11</span></span><br><span class="line"><span class="string">master_port:7001</span></span><br><span class="line"><span class="string">master_link_status:up</span></span><br><span class="line"><span class="string">master_last_io_seconds_ago:1</span></span><br><span class="line"><span class="string">master_sync_in_progress:0</span></span><br><span class="line"><span class="string">slave_read_repl_offset:2417</span></span><br><span class="line"><span class="string">slave_repl_offset:2417</span></span><br><span class="line"><span class="string">slave_priority:100</span></span><br><span class="line"><span class="string">slave_read_only:1</span></span><br><span class="line"><span class="string">replica_announced:1</span></span><br><span class="line"><span class="string">connected_slaves:0</span></span><br><span class="line"><span class="string">master_failover_state:no-failover</span></span><br><span class="line"><span class="string">master_replid:f7b8c1f916ecc6e3ab6fcba7d73c1f115a880cb6</span></span><br><span class="line"><span class="string">master_replid2:0000000000000000000000000000000000000000</span></span><br><span class="line"><span class="string">master_repl_offset:2417</span></span><br><span class="line"><span class="string">second_repl_offset:-1</span></span><br><span class="line"><span class="string">repl_backlog_active:1</span></span><br><span class="line"><span class="string">repl_backlog_size:1048576</span></span><br><span class="line"><span class="string">repl_backlog_first_byte_offset:113</span></span><br><span class="line"><span class="string">repl_backlog_histlen:2305</span></span><br><span class="line"><span class="string">$ set num 789</span></span><br><span class="line"><span class="string">(error) READONLY You can&#x27;</span>t write against a <span class="built_in">read</span> only replica.</span><br><span class="line">$ get num</span><br><span class="line"><span class="string">&quot;123&quot;</span></span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vagrant使用入门</title>
      <link href="/post/f8d4142b.html"/>
      <url>/post/f8d4142b.html</url>
      
        <content type="html"><![CDATA[<h2 id="创建虚拟机"><a href="#创建虚拟机" class="headerlink" title="创建虚拟机"></a>创建虚拟机</h2><ul><li>安装Vagrant</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew tap hashicorp/tap</span><br><span class="line">brew install hashicorp/tap/hashicorp-vagrant</span><br></pre></td></tr></table></figure><ul><li>初始化虚拟机</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 仅创建一个Vagrantfile</span></span><br><span class="line"><span class="built_in">mkdir</span> vm</span><br><span class="line"><span class="built_in">cd</span> vm</span><br><span class="line">vagrant init centos/7</span><br></pre></td></tr></table></figure><ul><li>启动虚拟机</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这一步才是拉取并启动镜像</span></span><br><span class="line">vagrant up</span><br></pre></td></tr></table></figure><ul><li>连接虚拟机</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant ssh</span><br></pre></td></tr></table></figure><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><ul><li>卸载旧版docker</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure><ul><li>安装yum-utils并设置docker仓库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><ul><li><p>安装docker</p><ul><li><p>安装最新版</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure></li><li><p>安装指定版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看docker版本</span></span><br><span class="line">yum list docker-ce --showduplicates | <span class="built_in">sort</span> -r</span><br><span class="line"></span><br><span class="line">docker-ce.x86_64    3:27.1.1-1.el9    docker-ce-stable</span><br><span class="line">docker-ce.x86_64    3:27.1.0-1.el9    docker-ce-stable</span><br><span class="line">&lt;...&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装指定版本</span></span><br><span class="line">sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure></li></ul></li><li><p>启动docker</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置开机默认启动</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置容器自动启动</span></span><br><span class="line">docker run -d --restart=always --name 容器名称 镜像</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改容器自动启动</span></span><br><span class="line">docker update --restart=always 容器ID</span><br></pre></td></tr></table></figure><h2 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h2><p>假设在虚拟机中启动了一个tomcat镜像，要想在宿主机中的访问该tomcat，需配置端口转发。打开Vagrantfile，按如下修改配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.network &quot;forwarded_port&quot;, guest: 8080, host: 8080</span><br></pre></td></tr></table></figure><p>修改完Vagrantfile后，需重启虚拟机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant reload</span><br></pre></td></tr></table></figure><h2 id="Tabby连接虚拟机"><a href="#Tabby连接虚拟机" class="headerlink" title="Tabby连接虚拟机"></a>Tabby连接虚拟机</h2><p>Tabby是一个类终端的ssh客户端，使用Tabby连接到虚拟机后，可以向虚拟机上传文件。操作步骤如下：</p><ol><li>获取虚拟机的SSH信息</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入Vagrantfile所在目录</span></span><br><span class="line">vagrant ssh-config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行上述命令，将得到连接虚拟机所需的ssh信息：</span></span><br><span class="line">Host default</span><br><span class="line">  HostName 127.0.0.1</span><br><span class="line">  User vagrant</span><br><span class="line">  Port 2222</span><br><span class="line">  IdentityFile /path/to/private_key</span><br></pre></td></tr></table></figure><ol start="2"><li>配置Tabby连接</li></ol><blockquote><p>在 Tabby 中，点击 <code>Profiles</code> -&gt; <code>New Profile</code>。</p><p>在 <code>Connection</code> 选项卡中设置以下信息：</p><ul><li><strong>Host:</strong> <code>127.0.0.1</code> （从 <code>vagrant ssh-config</code> 中获取的 <code>HostName</code>）</li><li><strong>Port:</strong> <code>2222</code> （从 <code>vagrant ssh-config</code> 中获取的 <code>Port</code>）</li><li><strong>User:</strong> <code>vagrant</code> （从 <code>vagrant ssh-config</code> 中获取的 <code>User</code>）</li><li><strong>Private Key</strong>: 选择 <code>IdentityFile</code> 的路径（从 <code>vagrant ssh-config</code> 中获取的 <code>/path/to/private_key</code>）。</li></ul></blockquote><img src="/post/f8d4142b/Tabby%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA.png" class=""><ol start="3"><li><p>上传文件</p><p>如果以下两种方式上传失败，请注意vagrant对虚拟机中的目的路径是否有写权限，如果没有，需要用chmod和chown命令修改文件的属性以获得写权限。</p><ul><li><p>图形界面化方式</p><img src="/post/f8d4142b/Tabby%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0%E8%99%9A%E6%8B%9F%E6%9C%BA.png" class=""></li><li><p>命令行方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /path/to/private_key 连接虚拟机的ssh信息中的IdentityFile</span></span><br><span class="line"><span class="comment"># /Users/yourname/Documents/example.txt 宿主机文件路径</span></span><br><span class="line">scp -i /path/to/private_key -P 2222 /Users/yourname/Documents/example.txt vagrant@127.0.0.1:/home/vagrant/</span><br></pre></td></tr></table></figure><p>PS：该命令在宿主机命令行终端中执行</p></li></ul></li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><img src="/post/f8d4142b/image-20241027114900897.png" class="" title="image-20241027114900897"><p>解决方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">su root</span><br><span class="line">sed -i <span class="string">&#x27;s/mirrorlist/#mirrorlist/g&#x27;</span> /etc/yum.repos.d/CentOS-*</span><br><span class="line">sed -i <span class="string">&#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27;</span> /etc/yum.repos.d/CentOS-*</span><br></pre></td></tr></table></figure><h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><img src="/post/f8d4142b/image-20241027115202371.png" class="" title="image-20241027115202371"><p>解决方法：使用阿里云镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><h3 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h3><img src="/post/f8d4142b/image-20241027135816837.png" class="" title="image-20241027135816837"><p>解决方法：添加镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;https://xxx.mirror.aliyuncs.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://docker.m.daocloud.io&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://dockerproxy.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://docker.nju.edu.cn&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://hammal.staronearth.win/&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://hub.staronearth.win/&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vagrant </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>build you own X</title>
      <link href="/post/eb09633c.html"/>
      <url>/post/eb09633c.html</url>
      
        <content type="html"><![CDATA[<h2 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h2><h2 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait/notify"></a><code>wait/notify</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> data;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> empty;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Buffer</span><span class="params">()</span> &#123;</span><br><span class="line">      empty = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生产数据</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">(<span class="type">int</span> newData)</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (!empty) &#123; <span class="comment">// 如果缓冲区不为空，则等待</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              wait();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      data = newData; <span class="comment">// 放入数据</span></span><br><span class="line">      empty = <span class="literal">false</span>; <span class="comment">// 标记缓冲区不为空</span></span><br><span class="line">      notify(); <span class="comment">// 通知消费者可以消费数据</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 消费数据</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">consume</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (empty) &#123; <span class="comment">// 如果缓冲区为空，则等待</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              wait();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> <span class="variable">consumedData</span> <span class="operator">=</span> data; <span class="comment">// 取出数据</span></span><br><span class="line">      empty = <span class="literal">true</span>; <span class="comment">// 标记缓冲区为空</span></span><br><span class="line">      notify(); <span class="comment">// 通知生产者可以生产数据</span></span><br><span class="line">      <span class="keyword">return</span> consumedData;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Buffer buffer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Buffer buffer)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.buffer = buffer;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">          buffer.produce(i);</span><br><span class="line">          System.out.println(<span class="string">&quot;生产者生产了数据: &quot;</span> + i);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟生产者生产数据的耗时操作</span></span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Buffer buffer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Buffer buffer)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.buffer = buffer;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">consumedData</span> <span class="operator">=</span> buffer.consume();</span><br><span class="line">          System.out.println(<span class="string">&quot;消费者消费了数据: &quot;</span> + consumedData);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              Thread.sleep(<span class="number">1500</span>); <span class="comment">// 模拟消费者消费数据的耗时操作</span></span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Buffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Buffer</span>();</span><br><span class="line">      <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(buffer);</span><br><span class="line">      <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(buffer);</span><br><span class="line"></span><br><span class="line">      <span class="type">Thread</span> <span class="variable">producerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(producer);</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">consumerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(consumer);</span><br><span class="line"></span><br><span class="line">      producerThread.start();</span><br><span class="line">      consumerThread.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="await-signal"><a href="#await-signal" class="headerlink" title="await/signal"></a><code>await/signal</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxSize</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">while</span> (queue.size() == maxSize) &#123;</span><br><span class="line">              <span class="comment">// 缓冲区已满，生产者等待</span></span><br><span class="line">              notFull.await();</span><br><span class="line">          &#125;</span><br><span class="line">          queue.add(num);</span><br><span class="line">          System.out.println(<span class="string">&quot;Produced: &quot;</span> + num);</span><br><span class="line">          notEmpty.signal(); <span class="comment">// 通知消费者缓冲区不为空</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">consume</span><span class="params">()</span> &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">              <span class="comment">// 缓冲区为空，消费者等待</span></span><br><span class="line">              notEmpty.await();</span><br><span class="line">          &#125;</span><br><span class="line">          num = queue.poll();</span><br><span class="line">          System.out.println(<span class="string">&quot;Consumed: &quot;</span> + num);</span><br><span class="line">          notFull.signal(); <span class="comment">// 通知生产者缓冲区不满</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> num;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PipedOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumerExample</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">PipedInputStream</span> <span class="variable">pipedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipedInputStream</span>();</span><br><span class="line">      <span class="type">PipedOutputStream</span> <span class="variable">pipedOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipedOutputStream</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将管道输入流和管道输出流关联起来</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          pipedInputStream.connect(pipedOutputStream);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建生产者线程和消费者线程</span></span><br><span class="line">      <span class="type">Thread</span> <span class="variable">producerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(pipedOutputStream));</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">consumerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(pipedInputStream));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 启动生产者线程和消费者线程</span></span><br><span class="line">      producerThread.start();</span><br><span class="line">      consumerThread.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> PipedOutputStream pipedOutputStream;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(PipedOutputStream pipedOutputStream)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.pipedOutputStream = pipedOutputStream;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 生产者向管道写入数据</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                  <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;Data &quot;</span> + i;</span><br><span class="line">                  pipedOutputStream.write(data.getBytes());</span><br><span class="line">                  System.out.println(<span class="string">&quot;Produced: &quot;</span> + data);</span><br><span class="line">              &#125;</span><br><span class="line">              pipedOutputStream.close();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> PipedInputStream pipedInputStream;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(PipedInputStream pipedInputStream)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.pipedInputStream = pipedInputStream;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 消费者从管道读取数据</span></span><br><span class="line">              <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">              <span class="type">int</span> bytesRead;</span><br><span class="line">              <span class="keyword">while</span> ((bytesRead = pipedInputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                  <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">                  System.out.println(<span class="string">&quot;Consumed: &quot;</span> + data);</span><br><span class="line">              &#125;</span><br><span class="line">              pipedInputStream.close();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumerExample</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="comment">// 创建一个容量为10的阻塞队列</span></span><br><span class="line">      BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建生产者线程和消费者线程</span></span><br><span class="line">      <span class="type">Thread</span> <span class="variable">producerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(blockingQueue));</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">consumerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(blockingQueue));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 启动生产者线程和消费者线程</span></span><br><span class="line">      producerThread.start();</span><br><span class="line">      consumerThread.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> BlockingQueue&lt;String&gt; blockingQueue;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 生产者向阻塞队列添加数据</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                  <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;Data &quot;</span> + i;</span><br><span class="line">                  blockingQueue.put(data);</span><br><span class="line">                  System.out.println(<span class="string">&quot;Produced: &quot;</span> + data);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> BlockingQueue&lt;String&gt; blockingQueue;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 消费者从阻塞队列取出数据</span></span><br><span class="line">              <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                  <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> blockingQueue.take();</span><br><span class="line">                  System.out.println(<span class="string">&quot;Consumed: &quot;</span> + data);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="semaphore"><a href="#semaphore" class="headerlink" title="semaphore"></a><code>semaphore</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumerExample</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="comment">// 创建一个初始计数为0的 Semaphore，用于控制生产者线程的访问</span></span><br><span class="line">      <span class="type">Semaphore</span> <span class="variable">producerSemaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="comment">// 创建一个初始计数为1的 Semaphore，用于控制消费者线程的访问</span></span><br><span class="line">      <span class="type">Semaphore</span> <span class="variable">consumerSemaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建生产者线程和消费者线程</span></span><br><span class="line">      <span class="type">Thread</span> <span class="variable">producerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(producerSemaphore, consumerSemaphore));</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">consumerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(producerSemaphore, consumerSemaphore));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 启动生产者线程和消费者线程</span></span><br><span class="line">      producerThread.start();</span><br><span class="line">      consumerThread.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> Semaphore producerSemaphore;</span><br><span class="line">      <span class="keyword">private</span> Semaphore consumerSemaphore;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Semaphore producerSemaphore, Semaphore consumerSemaphore)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.producerSemaphore = producerSemaphore;</span><br><span class="line">          <span class="built_in">this</span>.consumerSemaphore = consumerSemaphore;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 生产者线程生产数据</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                  Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟生产耗时</span></span><br><span class="line">                  System.out.println(<span class="string">&quot;Produced: Data &quot;</span> + i);</span><br><span class="line">                  producerSemaphore.release(); <span class="comment">// 增加 producerSemaphore 的计数</span></span><br><span class="line">                  consumerSemaphore.acquire(); <span class="comment">// 获取 consumerSemaphore 的许可</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> Semaphore producerSemaphore;</span><br><span class="line">      <span class="keyword">private</span> Semaphore consumerSemaphore;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Semaphore producerSemaphore, Semaphore consumerSemaphore)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.producerSemaphore = producerSemaphore;</span><br><span class="line">          <span class="built_in">this</span>.consumerSemaphore = consumerSemaphore;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 消费者线程消费数据</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                  consumerSemaphore.acquire(); <span class="comment">// 获取 consumerSemaphore 的许可</span></span><br><span class="line">                  Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟消费耗时</span></span><br><span class="line">                  System.out.println(<span class="string">&quot;Consumed: Data &quot;</span> + i);</span><br><span class="line">                  producerSemaphore.release(); <span class="comment">// 增加 producerSemaphore 的计数</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
